<?xml version="1.0" standalone="yes"?>
<RECORDS>
<RECORD>
<snippet_key>480426</snippet_key>
<tag>android 安卓 播放器 音乐 界面设计</tag>
<comment>来自CSDN博客：android音乐播放器开发 SweetMusicPlayer  智能加载在线歌词 http://blog.csdn.net/huweigoodboy/article/details/39878063#</comment>
<code>package com.huwei.sweetmusicplayer.util;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.util.Random;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import android.os.Environment;
import android.util.Log;

public class OnlineLrcUtil {
private static String TAG = &quot;OnlineLrcUtil&quot;;
private static OnlineLrcUtil instance;
public static final String lrcRootPath = Environment
.getExternalStorageDirectory().toString()
+ &quot;/SweetMusicPlayer/Lyrics/&quot;;

public static final String queryLrcURLRoot = &quot;http://geci.me/api/lyric/&quot;;

public static OnlineLrcUtil getInstance() {
if (null == instance) {
instance = new OnlineLrcUtil();
}

return instance;
}

public String getQueryLrcURL(String title, String artist) {
return queryLrcURLRoot + Encode(title) + &quot;/&quot; + Encode(artist);
}

public String getLrcURL(String title, String artist) {
String queryLrcURLStr = getQueryLrcURL(title, artist);
try {
URL url = new URL(queryLrcURLStr);
URLConnection urlConnection = url.openConnection();
urlConnection.connect();

BufferedReader in = new BufferedReader(new InputStreamReader(
urlConnection.getInputStream()));

StringBuffer sb = new StringBuffer();

String temp;
while ((temp = in.readLine()) != null) {
sb.append(temp);
}

JSONObject jObject = new JSONObject(sb.toString());
int count = jObject.getInt(&quot;count&quot;);
int index = count == 0 ? 0 : new Random().nextInt() % count;
JSONArray jArray = jObject.getJSONArray(&quot;result&quot;);
JSONObject obj = jArray.getJSONObject(index);
return obj.getString(&quot;lrc&quot;);

} catch (MalformedURLException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} catch (IOException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} catch (JSONException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}

return null;
}

// 歌手，歌曲名中的空格进行转码
public String Encode(String str) {

try {
return URLEncoder.encode(str.trim(), &quot;utf-8&quot;);
} catch (UnsupportedEncodingException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}

return str;

}

// 歌词文件网络地址，歌词文件本地缓冲地址
public boolean wrtieContentFromUrl(String urlPath, String lrcPath) {
Log.i(TAG, &quot;lrcURL&quot; + urlPath);

try {
URL url = new URL(urlPath);

URLConnection urlConnection = url.openConnection();
urlConnection.connect();

HttpURLConnection httpConn = (HttpURLConnection) urlConnection;
if (httpConn.getResponseCode() == HttpURLConnection.HTTP_OK) {
File file = new File(lrcRootPath);
if (!file.exists()) {
file.mkdirs();
}

BufferedReader bf = new BufferedReader(new InputStreamReader(
urlConnection.getInputStream(), &quot;utf-8&quot;));
PrintWriter out = new PrintWriter(new BufferedWriter(
new OutputStreamWriter(new FileOutputStream(lrcPath),
&quot;utf-8&quot;)));

char c[] = new char[256];
int temp = -1;
while ((temp = bf.read()) != -1) {
bf.read(c);
out.write(c);
}

bf.close();
out.close();

return true;
}

// System.out.println(&quot;getFile:&quot;+str);
} catch (MalformedURLException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} catch (IOException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}

return false;
}

public String getLrcPath(String title, String artist) {
return lrcRootPath + title + &quot; - &quot; + artist + &quot;.lrc&quot;;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>480505</snippet_key>
<tag>http服务器 OSGI BundleException</tag>
<comment>来自CSDN博客：OSGi嵌入 http 服务器 时遇到的问题  缺少 org.apache.felix.service.command 包 http://blog.csdn.net/heyu158/article/details/39890703#</comment>
<code>The bundle &quot;org.eclipse.equinox.console_1.0.100.v20130429-0953 [14]&quot; could not be resolved. Reason: Missing Constraint: Import-Package: org.apache.felix.service.command; version=&quot;0.8.0&quot;
</code>
</RECORD>
<RECORD>
<snippet_key>480499</snippet_key>
<tag>201</tag>
<comment>来自CSDN博客：Android通过反射和注解简化代码编写（一） http://blog.csdn.net/jwzhangjie/article/details/19006557# 派生自jwzhangjie/blog_20140213_1_2473595</comment>
<code>&lt;span style=&quot;font-size:14px;&quot;&gt;package com.jwzhangjie.reflection;

import java.lang.reflect.Method;

public class DumpMethods {

public static void main(String args[]) throws Exception{
//加载 并初始化命令行参数指定的类
Class classType = Class.forName(args[0]);
//获取类的所有方法
Method method[] = classType.getDeclaredMethods();
for (int i = 0; i &lt; method.length; i++) {
System.out.println(method[i].toString());
}
}
}
&lt;/span&gt;
&lt;span style=&quot;font-size:14px;&quot;&gt;package com.jwzhangjie.reflection;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class ReflectTester {

public Object copy(Object object) throws Exception{
//获取对象类型
Class classType = object.getClass();
//获得类的完整名字
System.out.println(&quot;Class:&quot;+classType.getName());
//通过默认构造方法创建一个新的对象
Object objectCopy = classType.getConstructor().newInstance();
//获取对象的所有属性
Field fields[] = classType.getDeclaredFields();
for (int i = 0; i &lt; fields.length; i++) {
Field field = fields[i];
String fieldName = field.getName();
String firstLetter = fieldName.substring(0, 1).toUpperCase();
//获得和属性对应的getXXX()方法的名字
String getMethodName = &quot;get&quot;+firstLetter+fieldName.substring(1);
//获得和属性对应的setXXX()方法的名字
String setMethodName = &quot;set&quot;+firstLetter+fieldName.substring(1);
//获得和属性对应的getXXX()方法
Method getMethod = classType.getMethod(getMethodName, new Class[]{});
//获得和属性对应的setXXX()方法
Method setMethod = classType.getMethod(setMethodName, new Class[]{field.getType()});

//调用原对象的getXXX()方法
Object value = getMethod.invoke(object, new Object[]{});
System.out.println(fieldName+&quot;: &quot;+value);
//调用复制对象的setXXX()方法
setMethod.invoke(objectCopy, new Object[]{value});
}
return objectCopy;
}

public static void main(String[] args) throws Exception{
ReflectTester test = new ReflectTester();
Customer customer = new Customer(&quot;Tom&quot;, 21);
customer.setId(new Long(1));

Customer customerCopy = (Customer)test.copy(customer);
System.out.println(&quot;Copy infomation:&quot;+customerCopy.getName()+&quot; : &quot;+customerCopy.getAge());
}

public static class Customer{
private Long id;
private String name;
private int age;

public Customer(){}
public Customer(String name, int age){
this.name = name;
this.age = age;
}
public Long getId(){return id;}
public void setId(Long id){this.id = id;}

public String getName(){return name;}
public void setName(String name){this.name = name;}

public int getAge(){return age;}
public void setAge(int age){this.age = age;}
}
}&lt;/span&gt;
&lt;span style=&quot;font-size:14px;&quot;&gt; Class classType = object.getClass();
System.out.println(&quot;Class:&quot;+classType.getName());&lt;/span&gt;
&lt;span style=&quot;font-size:14px;&quot;&gt;Object objectCopy = classType.getConstructor().newInstance();&lt;/span&gt;
&lt;span style=&quot;font-size:14px;&quot;&gt;Field fields[] = classType.getDeclaredFields();&lt;/span&gt;
&lt;span style=&quot;font-size:14px;&quot;&gt; for (int i = 0; i &lt; fields.length; i++) {
Field field = fields[i];
String fieldName = field.getName();
String firstLetter = fieldName.substring(0, 1).toUpperCase();
//获得和属性对应的getXXX()方法的名字
String getMethodName = &quot;get&quot;+firstLetter+fieldName.substring(1);
//获得和属性对应的setXXX()方法的名字
String setMethodName = &quot;set&quot;+firstLetter+fieldName.substring(1);
//获得和属性对应的getXXX()方法
Method getMethod = classType.getMethod(getMethodName, new Class[]{});
//获得和属性对应的setXXX()方法
Method setMethod = classType.getMethod(setMethodName, new Class[]{field.getType()});

//调用原对象的getXXX()方法
Object value = getMethod.invoke(object, new Object[]{});
System.out.println(fieldName+&quot;: &quot;+value);
//调用复制对象的setXXX()方法
setMethod.invoke(objectCopy, new Object[]{value});
}&lt;/span&gt;
package com.jwzhangjie.reflection;

import java.lang.reflect.Method;

public class InvokeTester {

public int add(int param1, int param2){
return param1+param2;
}

public String echo(String msg){
return &quot;echo:&quot;+msg;
}

public static void main(String[] args) throws Exception{
Class classType = InvokeTester.class;
Object invokeTester = classType.newInstance();

//调用InvokeTester对象的add()方法
Method addMethod = classType.getMethod(&quot;add&quot;, int.class, int.class);
Object result = addMethod.invoke(invokeTester, 100, 200);
System.out.println((Integer)result);

//调用InvokeTester对象的echo()方法
Method echoMethod = classType.getMethod(&quot;echo&quot;, String.class);
result = echoMethod.invoke(invokeTester, &quot;Hello&quot;);
System.out.println((String)result);
}
}
Method addMethod = classType.getMethod(&quot;add&quot;, int.class, int.class);
package com.jwzhangjie.reflection;

import java.lang.reflect.Array;

public class ArrayTester1 {
public static void main(String args[]) throws Exception{
Class classType = Class.forName(&quot;java.lang.String&quot;);
//创建一个长度为10的字符串数组
Object array = Array.newInstance(classType, 10);
//把索引位置为5的元素设为&quot;hello&quot;
Array.set(array, 5, &quot;hello&quot;);
//读取索引位置为5的元素的值
String s = (String)Array.get(array, 5);
System.out.println(s);
}
}
package com.jwzhangjie.reflection;

import java.lang.reflect.Array;

public class ArrayTester2 {
public static void main(String[] args) throws Exception{
int dims[] = new int[]{5, 10, 15};
Object array = Array.newInstance(Integer.TYPE, dims);
//使用arrayObj引用array[3]
Object arrayObj = Array.get(array, 3);
Class cls = arrayObj.getClass().getComponentType();
System.out.println(cls);
//使用arrayObj引用array[3][5]
arrayObj = Array.get(arrayObj, 5);
//把元素array[3][5][10]设为37
Array.setInt(arrayObj, 10, 37);
int arrayCast[][][] = (int[][][])array;
System.out.println(arrayCast[3][5][10]);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>480498</snippet_key>
<tag>201</tag>
<comment>来自CSDN博客：Android通过反射和注解简化代码编写（一） http://blog.csdn.net/jwzhangjie/article/details/19006557# 派生自jwzhangjie/blog_20140213_1_2473595</comment>
<code>&lt;span style=&quot;font-size:14px;&quot;&gt;package com.jwzhangjie.reflection;

import java.lang.reflect.Method;

public class DumpMethods {

public static void main(String args[]) throws Exception{
//加载 并初始化命令行参数指定的类
Class classType = Class.forName(args[0]);
//获取类的所有方法
Method method[] = classType.getDeclaredMethods();
for (int i = 0; i &lt; method.length; i++) {
System.out.println(method[i].toString());
}
}
}
&lt;/span&gt;
&lt;span style=&quot;font-size:14px;&quot;&gt;package com.jwzhangjie.reflection;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class ReflectTester {

public Object copy(Object object) throws Exception{
//获取对象类型
Class classType = object.getClass();
//获得类的完整名字
System.out.println(&quot;Class:&quot;+classType.getName());
//通过默认构造方法创建一个新的对象
Object objectCopy = classType.getConstructor().newInstance();
//获取对象的所有属性
Field fields[] = classType.getDeclaredFields();
for (int i = 0; i &lt; fields.length; i++) {
Field field = fields[i];
String fieldName = field.getName();
String firstLetter = fieldName.substring(0, 1).toUpperCase();
//获得和属性对应的getXXX()方法的名字
String getMethodName = &quot;get&quot;+firstLetter+fieldName.substring(1);
//获得和属性对应的setXXX()方法的名字
String setMethodName = &quot;set&quot;+firstLetter+fieldName.substring(1);
//获得和属性对应的getXXX()方法
Method getMethod = classType.getMethod(getMethodName, new Class[]{});
//获得和属性对应的setXXX()方法
Method setMethod = classType.getMethod(setMethodName, new Class[]{field.getType()});

//调用原对象的getXXX()方法
Object value = getMethod.invoke(object, new Object[]{});
System.out.println(fieldName+&quot;: &quot;+value);
//调用复制对象的setXXX()方法
setMethod.invoke(objectCopy, new Object[]{value});
}
return objectCopy;
}

public static void main(String[] args) throws Exception{
ReflectTester test = new ReflectTester();
Customer customer = new Customer(&quot;Tom&quot;, 21);
customer.setId(new Long(1));

Customer customerCopy = (Customer)test.copy(customer);
System.out.println(&quot;Copy infomation:&quot;+customerCopy.getName()+&quot; : &quot;+customerCopy.getAge());
}

public static class Customer{
private Long id;
private String name;
private int age;

public Customer(){}
public Customer(String name, int age){
this.name = name;
this.age = age;
}
public Long getId(){return id;}
public void setId(Long id){this.id = id;}

public String getName(){return name;}
public void setName(String name){this.name = name;}

public int getAge(){return age;}
public void setAge(int age){this.age = age;}
}
}&lt;/span&gt;
&lt;span style=&quot;font-size:14px;&quot;&gt; Class classType = object.getClass();
System.out.println(&quot;Class:&quot;+classType.getName());&lt;/span&gt;
&lt;span style=&quot;font-size:14px;&quot;&gt;Object objectCopy = classType.getConstructor().newInstance();&lt;/span&gt;
&lt;span style=&quot;font-size:14px;&quot;&gt;Field fields[] = classType.getDeclaredFields();&lt;/span&gt;
&lt;span style=&quot;font-size:14px;&quot;&gt; for (int i = 0; i &lt; fields.length; i++) {
Field field = fields[i];
String fieldName = field.getName();
String firstLetter = fieldName.substring(0, 1).toUpperCase();
//获得和属性对应的getXXX()方法的名字
String getMethodName = &quot;get&quot;+firstLetter+fieldName.substring(1);
//获得和属性对应的setXXX()方法的名字
String setMethodName = &quot;set&quot;+firstLetter+fieldName.substring(1);
//获得和属性对应的getXXX()方法
Method getMethod = classType.getMethod(getMethodName, new Class[]{});
//获得和属性对应的setXXX()方法
Method setMethod = classType.getMethod(setMethodName, new Class[]{field.getType()});

//调用原对象的getXXX()方法
Object value = getMethod.invoke(object, new Object[]{});
System.out.println(fieldName+&quot;: &quot;+value);
//调用复制对象的setXXX()方法
setMethod.invoke(objectCopy, new Object[]{value});
}&lt;/span&gt;
package com.jwzhangjie.reflection;

import java.lang.reflect.Method;

public class InvokeTester {

public int add(int param1, int param2){
return param1+param2;
}

public String echo(String msg){
return &quot;echo:&quot;+msg;
}

public static void main(String[] args) throws Exception{
Class classType = InvokeTester.class;
Object invokeTester = classType.newInstance();

//调用InvokeTester对象的add()方法
Method addMethod = classType.getMethod(&quot;add&quot;, int.class, int.class);
Object result = addMethod.invoke(invokeTester, 100, 200);
System.out.println((Integer)result);

//调用InvokeTester对象的echo()方法
Method echoMethod = classType.getMethod(&quot;echo&quot;, String.class);
result = echoMethod.invoke(invokeTester, &quot;Hello&quot;);
System.out.println((String)result);
}
}
Method addMethod = classType.getMethod(&quot;add&quot;, int.class, int.class);
package com.jwzhangjie.reflection;

import java.lang.reflect.Array;

public class ArrayTester1 {
public static void main(String args[]) throws Exception{
Class classType = Class.forName(&quot;java.lang.String&quot;);
//创建一个长度为10的字符串数组
Object array = Array.newInstance(classType, 10);
//把索引位置为5的元素设为&quot;hello&quot;
Array.set(array, 5, &quot;hello&quot;);
//读取索引位置为5的元素的值
String s = (String)Array.get(array, 5);
System.out.println(s);
}
}
package com.jwzhangjie.reflection;

import java.lang.reflect.Array;

public class ArrayTester2 {
public static void main(String[] args) throws Exception{
int dims[] = new int[]{5, 10, 15};
Object array = Array.newInstance(Integer.TYPE, dims);
//使用arrayObj引用array[3]
Object arrayObj = Array.get(array, 3);
Class cls = arrayObj.getClass().getComponentType();
System.out.println(cls);
//使用arrayObj引用array[3][5]
arrayObj = Array.get(arrayObj, 5);
//把元素array[3][5][10]设为37
Array.setInt(arrayObj, 10, 37);
int arrayCast[][][] = (int[][][])array;
System.out.println(arrayCast[3][5][10]);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>480495</snippet_key>
<tag>112</tag>
<comment>来自CSDN博客：cxf WebService整理  http://blog.csdn.net/zjw10wei321/article/details/39889823#</comment>
<code>package com.cxfdemo.ws.service;

import java.util.List;

import javax.jws.WebParam;
import javax.jws.WebResult;
import javax.jws.WebService;

import com.cxfdemo.ws.service.model.Resume;
import com.cxfdemo.ws.service.model.User;

@WebService
public interface HelloWorld {

@WebResult(name = &quot;String&quot;)
public String sayHi(@WebParam(name=&quot;text&quot;)String text);

@WebResult(name = &quot;user&quot;)
public User getUser(@WebParam(name=&quot;id&quot;)String id);

public List&lt;User&gt; getAllUsers();

public void saveUser(@WebParam(name=&quot;id&quot;)String id,
@WebParam(name=&quot;name&quot;)String name,
@WebParam(name=&quot;sex&quot;)int sex);

/**
* 客户端的ObjectFactory的createUser方法的参数必须和User的构造函数的参数一致
* &lt;p&gt;
* 如客户端中需要用到new User(&quot;id&quot;,&quot;name&quot;,1)构造User对象时
*
* 需要在ObjectFactory中加入
* public User createUser(String id,String name,int sex) {
* return new User(id,name,sex);
* }
* &lt;/p&gt;
* @param user
*/
public void saveUsers(@WebParam(name=&quot;user&quot;)User user);

@WebResult(name = &quot;String&quot;)
public String saveResumes(@WebParam(name=&quot;resume&quot;)Resume resume);

}
package com.cxfdemo.ws.service;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.List;

import javax.activation.DataHandler;
import javax.jws.WebService;
import javax.xml.bind.annotation.XmlMimeType;

import com.cxfdemo.ws.service.model.Resume;
import com.cxfdemo.ws.service.model.User;

@WebService(endpointInterface=&quot;com.cxfdemo.ws.service.HelloWorld&quot;,
serviceName=&quot;HelloWorldServiceService&quot;,portName=&quot;HelloWorldServicePort&quot;,
name=&quot;HelloWorldService&quot;,targetNamespace=&quot;http://service.ws.cxfdemo.com/&quot;)
public class HelloWorldService implements HelloWorld{

public String sayHi(String text) {
return &quot;Hello &quot; + text;
}

public User getUser(String id) {
return new User(&quot;大王&quot;, id, 1);
}

public List&lt;User&gt; getAllUsers() {
List&lt;User&gt; list = new ArrayList&lt;User&gt;();
for (int i=0;i&lt;4;i++) {
list.add(new User(&quot;小明&quot;+i,&quot;&quot;+i,i));
}
return list;
}

public void saveUser(String id, String name, int sex) {
System.out.println(new User(id, name, sex));
}

public void saveUsers(User user) {
System.out.println(user);
}

public String saveResumes(@XmlMimeType(&quot;application/octet-stream&quot;)Resume resume) {
if (resume == null) {
throw new NullPointerException(&quot;参数非法.&quot;);
}

DataHandler handler = resume.getDataHandler();
if (handler == null) {
throw new NullPointerException(&quot;参数非法.&quot;);
}
OutputStream os = null;
InputStream is = null;
try {
is = handler.getInputStream();
os = new FileOutputStream(new File(&quot;D:\\&quot;
+ resume.getCandidateName() + &quot;.&quot;
+ resume.getResumeFileType()));
byte[] b = new byte[100000];
int bytesRead = 0;
while ((bytesRead = is.read(b)) != -1) {
os.write(b, 0, bytesRead);
}
os.flush();
} catch (IOException e) {
e.printStackTrace();
} finally {
try {
if (os != null) {
os.close();
}
} catch (IOException e) {
e.printStackTrace();
}
try {
if (is != null) {
is.close();
}
} catch (IOException e) {
e.printStackTrace();
}
}
return &quot;ok&quot;;
}
}
&lt;import resource=&quot;classpath:META-INF/cxf/cxf.xml&quot; /&gt;
&lt;import resource=&quot;classpath:META-INF/cxf/cxf-extension-soap.xml&quot; /&gt;
&lt;import resource=&quot;classpath:META-INF/cxf/cxf-servlet.xml&quot; /&gt;

&lt;!-- 设置密码bean --&gt;
&lt;bean id=&quot;serverPasswordCallback&quot; class=&quot;com.cxfdemo.ws.service.ServerPasswordCallback&quot;&gt;&lt;/bean&gt;

&lt;!-- WSS4J密码校验 --&gt;
&lt;bean id=&quot;wss4jInInterceptor&quot; class=&quot;org.apache.cxf.ws.security.wss4j.WSS4JInInterceptor&quot;&gt;
&lt;constructor-arg&gt;
&lt;map&gt;
&lt;!-- 用户认证（明文密码） --&gt;
&lt;entry key=&quot;action&quot; value=&quot;UsernameToken&quot; /&gt;
&lt;entry key=&quot;passwordType&quot; value=&quot;PasswordText&quot; /&gt;&lt;!-- 明文 密文采用PasswordDigest--&gt;
&lt;entry key=&quot;passwordCallbackRef&quot; value-ref=&quot;serverPasswordCallback&quot; /&gt;
&lt;/map&gt;
&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;!-- 发布服务 --&gt;
&lt;jaxws:endpoint id=&quot;helloWorld&quot; address=&quot;/helloWorld&quot;
implementor=&quot;com.cxfdemo.ws.service.HelloWorldService&quot;&gt;
&lt;!-- 文件传送必须协议 --&gt;
&lt;jaxws:properties&gt;
&lt;entry key=&quot;mtom-enabled&quot; value=&quot;true&quot;/&gt;
&lt;/jaxws:properties&gt;
&lt;!-- 输入拦截器 --&gt;
&lt;jaxws:inInterceptors&gt;
&lt;ref bean=&quot;wss4jInInterceptor&quot; /&gt;
&lt;!-- 日志打印 --&gt;
&lt;bean class=&quot;org.apache.cxf.interceptor.LoggingInInterceptor&quot; /&gt;
&lt;/jaxws:inInterceptors&gt;
&lt;!-- 正常输出拦截器 --&gt;
&lt;jaxws:outInterceptors&gt;
&lt;bean class=&quot;com.cxfdemo.ws.service.interceptor.ErrorHandlerInterceptor&quot;&gt;&lt;/bean&gt;
&lt;/jaxws:outInterceptors&gt;
&lt;!-- 错误输出拦截器 --&gt;
&lt;jaxws:outFaultInterceptors&gt;
&lt;bean class=&quot;com.cxfdemo.ws.service.interceptor.ErrorHandlerInterceptor&quot;&gt;&lt;/bean&gt;
&lt;/jaxws:outFaultInterceptors&gt;
&lt;/jaxws:endpoint&gt;

&lt;jaxws:endpoint id=&quot;updateFile&quot; address=&quot;/updateFile&quot;
implementor=&quot;com.cxfdemo.ws.service.UpdateFileService&quot;&gt;
&lt;jaxws:properties&gt;
&lt;entry key=&quot;mtom-enabled&quot; value=&quot;true&quot; /&gt;
&lt;/jaxws:properties&gt;
&lt;/jaxws:endpoint&gt;

&lt;!-- 全局配置 --&gt;
&lt;!-- &lt;cxf:bus&gt;
&lt;cxf:features&gt;
&lt;cxf:logging /&gt;
&lt;/cxf:features&gt;
&lt;/cxf:bus&gt; --&gt;
public class ServerPasswordCallback implements CallbackHandler {

private static final Map&lt;String, String&gt; userMap = new HashMap&lt;String, String&gt;();

static {
userMap.put(&quot;client&quot;, &quot;clientpass&quot;);
userMap.put(&quot;server&quot;, &quot;serverpass&quot;);
}

public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {
WSPasswordCallback callback = (WSPasswordCallback) callbacks[0];
//实际上 callback.getPassword()是为null
String clientUsername = callback.getIdentifier();
//其实这一步是应该从数据库中取密码在设置到callback中
String serverPassword = userMap.get(clientUsername);
if (serverPassword != null) {
callback.setPassword(serverPassword);
}

try {
System.out.println(new Date());
Thread.sleep(1000L);
} catch (InterruptedException e) {
//nothing.
}
}
}
/**
* Verify a UsernameToken containing a password digest. It does this by querying a
* CallbackHandler instance to obtain a password for the given username, and then comparing
* it against the received password.
* @param usernameToken The UsernameToken instance to verify
* @throws WSSecurityException on a failed authentication.
*/
protected void verifyDigestPassword(UsernameToken usernameToken,
RequestData data) throws WSSecurityException {
if (data.getCallbackHandler() == null) {
throw new WSSecurityException(WSSecurityException.FAILURE, &quot;noCallback&quot;);
}

String user = usernameToken.getName();
String password = usernameToken.getPassword();
String nonce = usernameToken.getNonce();
String createdTime = usernameToken.getCreated();
String pwType = usernameToken.getPasswordType();
boolean passwordsAreEncoded = usernameToken.getPasswordsAreEncoded();

WSPasswordCallback pwCb =
new WSPasswordCallback(user, null, pwType, WSPasswordCallback.USERNAME_TOKEN, data);
try {
data.getCallbackHandler().handle(new Callback[]{pwCb});
} catch (IOException e) {
if (log.isDebugEnabled()) {
log.debug(e);
}
throw new WSSecurityException(
WSSecurityException.FAILED_AUTHENTICATION, null, null, e
);
} catch (UnsupportedCallbackException e) {
if (log.isDebugEnabled()) {
log.debug(e);
}
throw new WSSecurityException(
WSSecurityException.FAILED_AUTHENTICATION, null, null, e
);
}
String origPassword = pwCb.getPassword();
if (origPassword == null) {
if (log.isDebugEnabled()) {
log.debug(&quot;Callback supplied no password for: &quot; + user);
}
throw new WSSecurityException(WSSecurityException.FAILED_AUTHENTICATION);
}
if (usernameToken.isHashed()) {
String passDigest;
if (passwordsAreEncoded) {
passDigest = UsernameToken.doPasswordDigest(nonce, createdTime, Base64.decode(origPassword));
} else {
passDigest = UsernameToken.doPasswordDigest(nonce, createdTime, origPassword);
}
if (!passDigest.equals(password)) {
throw new WSSecurityException(WSSecurityException.FAILED_AUTHENTICATION);
}
} else {
if (!origPassword.equals(password)) {
throw new WSSecurityException(WSSecurityException.FAILED_AUTHENTICATION);
}
}
}
public class ErrorHandlerInterceptor extends AbstractSoapInterceptor {

public ErrorHandlerInterceptor() {
super(Phase.MARSHAL);
}

public void handleMessage(SoapMessage message) throws Fault {
// 错误原因
Fault fault = (Fault) message.getContent(Exception.class);
// 错误信息
String errorMessage = null;
Throwable cause = null;
if (fault != null) {
errorMessage = fault.getMessage();
cause = fault.getCause();
}

Exchange exchange = message.getExchange();
// wsdl描述
String servicePath = null;
// url与uri
String url = null;
String uri = null;
// 客户端ip
String clientIp = null;
// 用户名
String username = null;
// 密码
String psw = null;
// 服务中的方法
String methodName = null;
// 参数名
Object[] paramNames = null;
// 参数值
Object[] paramValues = null;

if (exchange != null) {
Object object = exchange.get(&quot;javax.xml.ws.wsdl.description&quot;);
if (object != null) {
servicePath = object.toString();
}

Message inMessage = exchange.getInMessage();
if (inMessage != null) {
HttpServletRequest req = (HttpServletRequest) inMessage
.get(&quot;HTTP.REQUEST&quot;);
clientIp = getIpAddr(req);
url = (String) inMessage.get(&quot;org.apache.cxf.request.url&quot;);
uri = (String) inMessage.get(&quot;org.apache.cxf.request.uri&quot;);
}

W3CDOMStreamWriter w3CDOMStreamWriter = (W3CDOMStreamWriter) inMessage
.get(W3CDOMStreamWriter.class.getName());
if (w3CDOMStreamWriter != null) {
Document document = w3CDOMStreamWriter.getDocument();
if (document != null) {
NodeList usernames = document
.getElementsByTagName(&quot;wsse:Username&quot;);
NodeList psws = document
.getElementsByTagName(&quot;wsse:Password&quot;);

if (usernames != null &amp;&amp; usernames.getLength() == 1) {
username = usernames.item(0).getTextContent();
}
if (psws != null &amp;&amp; psws.getLength() == 1) {
psw = psws.item(0).getTextContent();
}

NodeList body = document.getElementsByTagName(&quot;soap:Body&quot;);
Node method = body.item(0).getFirstChild();
if (method != null) {
methodName = method.getNodeName();
String[] methods = methodName.split(&quot;:&quot;);
if (methods != null &amp;&amp; methods.length == 2) {
methodName = methods[1];
}

NodeList args = method.getChildNodes();
paramNames = getParam(args, true);
paramValues = getParam(args, false);
}
}
}
}
System.out.println(cause);
System.out.println(errorMessage);
System.out.println(servicePath);
System.out.println(url);
System.out.println(uri);
System.out.println(clientIp);
System.out.println(username);
System.out.println(psw);
System.out.println(methodName);
System.out.println(&quot;---names--&quot;);
System.out.print(getParam(paramNames) + &quot;\t&quot;);
System.out.println(&quot;\n---values--&quot;);
System.out.print(getParam(paramValues) + &quot;\t&quot;);
}
public class ClientPasswordCallback implements CallbackHandler {

public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {
WSPasswordCallback callback = (WSPasswordCallback) callbacks[0];
System.out.println(new Date());
try {
Thread.sleep(1000L);
} catch (InterruptedException e) {
e.printStackTrace();
}
callback.setPassword(&quot;clientpass&quot;);
}
}
&lt;import resource=&quot;classpath:META-INF/cxf/cxf.xml&quot; /&gt;
&lt;import resource=&quot;classpath:META-INF/cxf/cxf-extension-soap.xml&quot; /&gt;
&lt;import resource=&quot;classpath:META-INF/cxf/cxf-servlet.xml&quot; /&gt;

&lt;bean id=&quot;clientPasswordCallback&quot; class=&quot;com.cxfdemo.ws.client.ClientPasswordCallback&quot;&gt;&lt;/bean&gt;

&lt;bean id=&quot;wss4jOutInterceptor&quot; class=&quot;org.apache.cxf.ws.security.wss4j.WSS4JOutInterceptor&quot;&gt;
&lt;constructor-arg&gt;
&lt;map&gt;
&lt;!-- 用户认证（明文密码） --&gt;
&lt;entry key=&quot;action&quot; value=&quot;UsernameToken&quot;/&gt;
&lt;entry key=&quot;user&quot; value=&quot;client&quot;/&gt;
&lt;entry key=&quot;passwordType&quot; value=&quot;PasswordText&quot;/&gt;
&lt;entry key=&quot;passwordCallbackRef&quot; value-ref=&quot;clientPasswordCallback&quot;/&gt;
&lt;/map&gt;
&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;jaxws:client id=&quot;client&quot; address=&quot;http://localhost:8888/CXFDemo/webservice/helloWorld&quot;
serviceClass=&quot;com.cxfdemo.ws.service.HelloWorld&quot;&gt;
&lt;jaxws:inInterceptors&gt;
&lt;bean class=&quot;org.apache.cxf.interceptor.LoggingInInterceptor&quot; /&gt;
&lt;/jaxws:inInterceptors&gt;
&lt;jaxws:outInterceptors&gt;
&lt;bean class=&quot;org.apache.cxf.interceptor.LoggingOutInterceptor&quot; /&gt;
&lt;ref bean=&quot;wss4jOutInterceptor&quot;/&gt;
&lt;/jaxws:outInterceptors&gt;
&lt;/jaxws:client&gt;

&lt;jaxws:client id=&quot;updateFile&quot; address=&quot;http://localhost:8888/CXFDemo/webservice/updateFile&quot;
serviceClass=&quot;com.cxfdemo.ws.service.HelloWorld&quot;&gt;
&lt;/jaxws:client&gt;

&lt;!-- 对所有的服务配置超时机制 只对服务名为{http://service.ws.cxfdemo.com/}HelloWorldService的服务生效. --&gt;
&lt;http-conf:conduit name=&quot;*.http-conduit&quot;&gt;
&lt;!-- ConnectionTimeout获取连接超时 ReceiveTimeout获取结果超时--&gt;
&lt;http-conf:client ConnectionTimeout=&quot;15000&quot; ReceiveTimeout=&quot;30000&quot;/&gt;
&lt;/http-conf:conduit&gt;
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;client_Spring.xml&quot;);
HelloWorld helloService = context.getBean(&quot;client&quot;,HelloWorld.class);
String response = helloService.sayHi(&quot;Peter&quot;);
System.out.println(response);
private static final QName SERVICE_NAME = new QName(&quot;http://service.ws.cxfdemo.com/&quot;, &quot;HelloWorldServiceService&quot;);
URL wsdlURL = HelloWorldServiceService.WSDL_LOCATION;
if (args.length &gt; 0 &amp;&amp; args[0] != null &amp;&amp; !&quot;&quot;.equals(args[0])) {
File wsdlFile = new File(args[0]);
try {
if (wsdlFile.exists()) {
wsdlURL = wsdlFile.toURI().toURL();
} else {
wsdlURL = new URL(args[0]);
}
} catch (MalformedURLException e) {
e.printStackTrace();
}
}

HelloWorldServiceService ss = new HelloWorldServiceService(wsdlURL, SERVICE_NAME);
HelloWorld port = ss.getHelloWorldServicePort();
org.apache.cxf.endpoint.Client client = ClientProxy.getClient(port);
org.apache.cxf.endpoint.Endpoint cxfEndpoint = client.getEndpoint();
Map&lt;String, Object&gt; outProps = new HashMap&lt;String, Object&gt;();
outProps.put(WSHandlerConstants.ACTION, WSHandlerConstants.USERNAME_TOKEN);
outProps.put(WSHandlerConstants.USER, &quot;client&quot;);
outProps.put(WSHandlerConstants.PASSWORD_TYPE, WSConstants.PW_TEXT);
outProps.put(WSHandlerConstants.PW_CALLBACK_CLASS, ClientPasswordCallback.class.getName());
WSS4JOutInterceptor wssOut = new WSS4JOutInterceptor(outProps);
cxfEndpoint.getOutInterceptors().add(wssOut);

System.out.println(&quot;Invoking sayHi...&quot;);
java.lang.String _sayHi_text = &quot;tttttt&quot;;
java.lang.String _sayHi__return = port.sayHi(_sayHi_text);
System.out.println(&quot;sayHi.result=&quot; + _sayHi__return);
</code>
</RECORD>
<RECORD>
<snippet_key>480481</snippet_key>
<tag>来自CSDN博客：java中单例模式 http://blog.csdn.net/ruanjian11110/article/details/38641615#</tag>
<comment>派生自炸死特/blog_20140416_1_3007966</comment>
<code>public class Singleton {
private static Singleton uniqueInstance = null;

private Singleton() {
// Exists only to defeat instantiation.
}

public static Singleton getInstance() {
if (uniqueInstance == null) {
uniqueInstance = new Singleton();
}
return uniqueInstance;
}
// Other methods...
}
package jason.single;

public class TestStream {
String name = null;

public String getName() {
return name;
}

public void setName(String name) {
this.name = name;
}

private TestStream() {
}

private static TestStream ts1 = null;

public static TestStream getTest() {
if (ts1 == null) {
ts1 = new TestStream();
}
return ts1;
}

public void printInfo() {
System.out.println(&quot;the name is &quot; + name);
}

}
package jason.single;

public class TMain {
public static void main(String[] args){
TestStream ts1 = TestStream.getTest();
ts1.setName(&quot;jason&quot;);
TestStream ts2 = TestStream.getTest();
ts2.setName(&quot;0539&quot;);

ts1.printInfo();
ts2.printInfo();

if(ts1 == ts2){
System.out.println(&quot;创建的是同一个实例&quot;);
}else{
System.out.println(&quot;创建的不是同一个实例&quot;);
}
}
}
//饿汉式单例类.在类初始化时，已经自行实例化
public class Singleton1 {
//私有的默认构造子
private Singleton1() {}
//已经自行实例化
private static final Singleton1 single = new Singleton1();
//静态工厂方法
public static Singleton1 getInstance() {
return single;
}
}
//懒汉式单例类.在第一次调用的时候实例化
public class Singleton2 {
//私有的默认构造子
private Singleton2() {}
//注意，这里没有final
private static Singleton2 single=null;
//静态工厂方法
public synchronized static Singleton2 getInstance() {
if (single == null) {
single = new Singleton2();
}
return single;
}
}
import java.util.HashMap;
import java.util.Map;
//登记式单例类.
//类似Spring里面的方法，将类名注册，下次从里面直接获取。
public class Singleton3 {
private static Map&lt;String,Singleton3&gt; map = new HashMap&lt;String,Singleton3&gt;();
static{
Singleton3 single = new Singleton3();
map.put(single.getClass().getName(), single);
}
//保护的默认构造子
protected Singleton3(){}
//静态工厂方法,返还此类惟一的实例
public static Singleton3 getInstance(String name) {
if(name == null) {
name = Singleton3.class.getName();
System.out.println(&quot;name == null&quot;+&quot;---&gt;name=&quot;+name);
}
if(map.get(name) == null) {
try {
map.put(name, (Singleton3) Class.forName(name).newInstance());
} catch (InstantiationException e) {
e.printStackTrace();
} catch (IllegalAccessException e) {
e.printStackTrace();
} catch (ClassNotFoundException e) {
e.printStackTrace();
}
}
return map.get(name);
}
//一个示意性的商业方法
public String about() {
return &quot;Hello, I am RegSingleton.&quot;;
}
public static void main(String[] args) {
Singleton3 single3 = Singleton3.getInstance(null);
System.out.println(single3.about());
}
}
&lt;pre class=&quot;java&quot; name=&quot;code&quot;&gt;Java Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例在。 使用Singleton的好处还在于可以节省内存，因为它限制了实例的个数，有利于Java垃圾回（garbage collection）。
&lt;pre class=&quot;java&quot; name=&quot;code&quot;&gt;01.public class Singleton {
02. private static Singleton uniqueInstance = null;
03.
04. private Singleton() {
05. // Exists only to defeat instantiation.
06. }
07.
08. public static Singleton getInstance() {
09. if (uniqueInstance == null) {
10. uniqueInstance = new Singleton();
11. }
12. return uniqueInstance;
13. }
14. // Other methods...
15.}
</code>
</RECORD>
<RECORD>
<snippet_key>230157</snippet_key>
<tag>273</tag>
<comment>android canvas 图形 Run onDraw 来自CSDN博客：Android Draw01 http://blog.csdn.net/u014030821/article/details/21031877#</comment>
<code>package com.example.draw01;

import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.app.Activity;
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.util.AttributeSet;
import android.view.View;

public class MainActivity extends Activity {
RefreshHandler handler=null;
MyView v=null;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
handler=new RefreshHandler();
v=new MyView(this,null);
setContentView(v);
}

//////////////////////////////////////////////内部类(1)
class MyView extends View implements Runnable{
//图形当前坐标
private int x=20,y=20;
public MyView(Context context, AttributeSet attrs) {
super(context, attrs);
// TODO Auto-generated constructor stub
//获得焦点
setFocusable(true);
//启动线程
new Thread(this).start();
}
@Override
public void run() {
// TODO Auto-generated method stub
Looper.prepare();
//RefreshHandler handler=new RefreshHandler();
while (!Thread.currentThread().isInterrupted()) {
//通过发送消息更新页面
Message m=new Message();
m.what=0x101;
handler.sendMessage(m);
try {
Thread.sleep(100);
} catch (InterruptedException e) {
// TODO: handle exception
e.printStackTrace();
}
}
Looper.loop();
}
@Override
protected void onDraw(Canvas canvas) {
// TODO Auto-generated method stub
super.onDraw(canvas);
//实例化画笔
Paint p=new Paint();
//设置画笔颜色
p.setColor(Color.GREEN);
//画圆
canvas.drawCircle(x, y, 10, p);
}
//更新坐标
private void update() {
// TODO Auto-generated method stub
int h=getHeight();//获取总高
y+=5;
if(y&gt;=h) y=20;//落到底部则回到x=20，y=20的起始位置
}
}//MyView内部类

////////////////////////////更新界面处理器(内部类2)
class RefreshHandler extends Handler{
@Override
public void handleMessage(Message msg) {
// TODO Auto-generated method stub
if (msg.what==0x101) {
v.update();
v.invalidate();
}
super.handleMessage(msg);
}
}//RefreshHandler内部类
}//MainActivity
</code>
</RECORD>
<RECORD>
<snippet_key>480562</snippet_key>
<tag>298</tag>
<comment>来自CSDN博客：Android开发系列（十四）：ListView用法、对ListView监听的三种方法以及ListView中Adapter的使用方法  http://blog.csdn.net/u010800530/article/details/39892387#</comment>
<code>public class FriendActivity extends Activity {

private ListView listView;

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);

//我们设置一个List集合，然后向里边添加几条数据
List&lt;String&gt; ls = new ArrayList&lt;String&gt;();
ls.add(&quot;张三&quot;);
ls.add(&quot;李四&quot;);
ls.add(&quot;王五&quot;);

//获取xml文件中listView控件
listView = (ListView)findViewById(R.id.ayyay_list_list);
//然后为listView控件调用setAdapter方法，让数据显示在界面上。
listView.setAdapter(new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_1,ls));
}
public class FriendActivity extends Activity {

private ListView listView;

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);

//我们设置一个List集合，然后向里边添加几条数据
List&lt;String&gt; ls = new ArrayList&lt;String&gt;();
ls.add(&quot;张三&quot;);
ls.add(&quot;李四&quot;);
ls.add(&quot;王五&quot;);

//获取xml文件中listView控件
listView = (ListView)findViewById(R.id.ayyay_list_list);
//然后为listView控件调用setAdapter方法，让数据显示在界面上。
listView.setAdapter(new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_1,ls));

//为listView对象进行监听：当点击子项目的时候触发
listView.setOnItemClickListener(new ItemClickEvent());
}

//继承OnItemClickListener，当子项目被点击的时候触发
private final class ItemClickEvent implements OnItemClickListener{
@Override
//这里需要注意的是第三个参数arg2，这是代表单击第几个选项
public void onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int arg2,
long arg3) {
//通过单击事件，获得单击选项的内容
String text = listView.getItemAtPosition(arg2)+&quot;&quot;;
//通过吐丝对象显示出来。
Toast.makeText(getApplicationContext(), text, 1).show();
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>480559</snippet_key>
<tag>466</tag>
<comment>java 算法 最大公约数 辗转相除法 来自CSDN博客：辗转相除法求最大公约数Java实现 http://blog.csdn.net/zhuifengshenku/article/details/39892347#</comment>
<code>/*
* 最大公约数
*/
public static int GCD(int a,int b){
int c=a%b;
if (c==0) {
return b;
}else{
return GCD(b,c);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>480555</snippet_key>
<tag>j478</tag>
<comment>来自CSDN博客：交换排序之冒泡排序Java实现 http://blog.csdn.net/zhuifengshenku/article/details/39892311#</comment>
<code>package com.mike.sort;

import java.util.Arrays;

public class BubleSort {
/*
* 冒泡排序
*/
public static void bubbleSort(DataWrap[] data){
boolean change=true;
for (int i = 0; i &lt; data.length-1 &amp;&amp;change; i++) {
change=false;
for (int j = 0; j &lt; data.length-1-i; j++) {
if(data[j].compareTo(data[j+1])&gt;0){
change=true;
DataWrap tempDataWrap=data[j];
data[j]=data[j+1];
data[j+1]=tempDataWrap;
}
}
}
}
public static void main(String[] args) {
DataWrap[] dataWraps={
new DataWrap(21,&quot;&quot;),
new DataWrap(31,&quot;&quot;),
new DataWrap(2,&quot;&quot;),
new DataWrap(2338,&quot;*&quot;),
new DataWrap(2122,&quot;&quot;),
new DataWrap(22,&quot;&quot;),
new DataWrap(55,&quot;&quot;),
new DataWrap(134,&quot;&quot;),
new DataWrap(24000,&quot;&quot;)
};
System.out.println(&quot;排序之前：&quot;+Arrays.toString(dataWraps));
bubbleSort(dataWraps);
System.out.println(&quot;排序之后：&quot;+Arrays.toString(dataWraps));
}
}
/*
*定义一个数据包装类
*/
class DataWrap implements Comparable&lt;DataWrap&gt;{
int data;
String flag;
public DataWrap() {
// TODO Auto-generated constructor stub
}
public DataWrap(int data,String flag) {
this.data=data;
this.flag=flag;
}
@Override
public String toString(){
return data+flag;
}
@Override
public int compareTo(DataWrap o) {
// TODO Auto-generated method stub
return this.data&gt;o.data?1:(this.data==o.data?0:-1);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>480547</snippet_key>
<tag>ListView scrollView 嵌套 滑动冲突</tag>
<comment>来自CSDN博客：解决ScrollView中嵌套Listview，Listview中嵌套Listview显示不完整和滑动冲突的问题  http://blog.csdn.net/bz419927089/article/details/38585547#</comment>
<code>public class ListViewForScrollView extends ListView {

public ListViewForScrollView(Context context) {
super(context);
}

public ListViewForScrollView(Context context, AttributeSet attrs) {
super(context, attrs);
}

public ListViewForScrollView(Context context, AttributeSet attrs,
int defStyle) {
super(context, attrs, defStyle);

}

/**
* 只需要重写这个方法即可
*/
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2,
MeasureSpec.AT_MOST);
super.onMeasure(widthMeasureSpec, expandSpec);
}

}
/**
* scrollview嵌套listview显示不全解决
*
* @param listView
*/
public static void setListViewHeightBasedOnChildren(ListView listView) {
ListAdapter listAdapter = listView.getAdapter();
if (listAdapter == null) {
return;
}

int totalHeight = 0;
for (int i = 0; i &lt; listAdapter.getCount(); i++) {
View listItem = listAdapter.getView(i, null, listView);
listItem.measure(0, 0);
totalHeight += listItem.getMeasuredHeight();
}

ViewGroup.LayoutParams params = listView.getLayoutParams();
params.height = totalHeight
+ (listView.getDividerHeight() * (listAdapter.getCount() - 1));
listView.setLayoutParams(params);
}
/**
*
* @ClassName: com.example.listdemo.InnerListview
* @Description: 可以放在Listview中的Listview
* @author zhaokaiqiang
* @date 2014-8-15 下午2:43:34
*
*/
public class InnerListview extends ListView {
public InnerListview(Context context) {
super(context);
}

public InnerListview(Context context, AttributeSet attrs) {
super(context, attrs);
}

public InnerListview(Context context, AttributeSet attrs, int defStyle) {
super(context, attrs, defStyle);

}

@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {
switch (ev.getAction()) {
// 当手指触摸listview时，让父控件交出ontouch权限,不能滚动
case MotionEvent.ACTION_DOWN:
setParentScrollAble(false);
case MotionEvent.ACTION_MOVE:
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
// 当手指松开时，让父控件重新获取onTouch权限
setParentScrollAble(true);
break;

}
return super.onInterceptTouchEvent(ev);

}

// 设置父控件是否可以获取到触摸处理权限
private void setParentScrollAble(boolean flag) {
getParent().requestDisallowInterceptTouchEvent(!flag);
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>480539</snippet_key>
<tag>473</tag>
<comment>来自CSDN博客：基于桶式排序的基数排序Java实现 http://blog.csdn.net/zhuifengshenku/article/details/39889607#</comment>
<code>package com.mike.sort;

import java.util.Arrays;

public class RadixSort {
/*
* 基于桶式的基数排序
* @param radix进制数
* @param digit 最高位数
*/
public static void radixSort(DataWrap[] data,int radix,int digit){
int length=data.length;
DataWrap[] temp=new DataWrap[length];
int[] buckets=new int[radix];
for (int i = 0,rate=1; i &lt; digit; i++) {
Arrays.fill(buckets, 0);
System.arraycopy(data, 0, temp, 0, length);
for (int j = 0; j &lt; length; j++) {
int subKey=((temp[j].data/rate)%radix);
buckets[subKey]++;
}
System.out.println(Arrays.toString(buckets));
for (int j = 1; j &lt; buckets.length; j++) {
buckets[j]=buckets[j]+buckets[j-1];
}
System.out.println(Arrays.toString(buckets));
for (int j = length-1; j &gt;=0; j--) {
int subKey=(temp[j].data/rate%radix);
data[--buckets[subKey]]=temp[j];
}
rate*=radix;
}
}
/*
* 交换数组元素
*/
public static void swap(DataWrap[] data,int i,int j){
DataWrap temp=data[i];
data[i]=data[j];
data[j]=temp;
}
public static void main(String[] args) {
DataWrap[] dataWraps={
new DataWrap(21,&quot;&quot;),
new DataWrap(31,&quot;&quot;),
new DataWrap(2,&quot;&quot;),
new DataWrap(2338,&quot;*&quot;),
new DataWrap(2122,&quot;&quot;),
new DataWrap(22,&quot;&quot;),
new DataWrap(55,&quot;&quot;),
new DataWrap(134,&quot;&quot;),
new DataWrap(24000,&quot;&quot;)
};
System.out.println(&quot;排序之前：&quot;+Arrays.toString(dataWraps));
radixSort(dataWraps,10,5);
System.out.println(&quot;排序之后：&quot;+Arrays.toString(dataWraps));
}
}
/*
*定义一个数据包装类
*/
class DataWrap implements Comparable&lt;DataWrap&gt;{
int data;
String flag;
public DataWrap() {
// TODO Auto-generated constructor stub
}
public DataWrap(int data,String flag) {
this.data=data;
this.flag=flag;
}
@Override
public String toString(){
return data+flag;
}
@Override
public int compareTo(DataWrap o) {
// TODO Auto-generated method stub
return this.data&gt;o.data?1:(this.data==o.data?0:-1);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>480533</snippet_key>
<tag>shiro</tag>
<comment>来自CSDN博客：shiro 授权介绍  http://blog.csdn.net/wangliqiang1014/article/details/39891755#</comment>
<code>Subject currentUser = SecurityUtils.getSubject();
if (currentUser.hasRole(&quot;administrator&quot;)) {
//show the admin button
} else {
//don&apos;t show the button? Grey it out?
}
Subject currentUser = SecurityUtils.getSubject();
//guarantee that the current user is a bank teller and
//therefore allowed to open the account:
currentUser.checkRole(&quot;bankTeller&quot;);
openBankAccount();
Permission printPermission = new PrinterPermission(&quot;laserjet4400n&quot;, &quot;print&quot;);
Subject currentUser = SecurityUtils.getSubject();
if (currentUser.isPermitted(printPermission)) {
//show the Print button
} else {
//don&apos;t show the button? Grey it out?
}
Permission printPermission = new PrinterPermission(&quot;laserjet4400n&quot;, &quot;print&quot;);
Subject currentUser = SecurityUtils.getSubject();
if (currentUser.isPermitted(printPermission)) {
//show the Print button
} else {
//don&apos;t show the button? Grey it out?
}
Subject currentUser = SecurityUtils.getSubject();
if (currentUser.isPermitted(&quot;printer:print:laserjet4400n&quot;)) {
//show the Print button
} else {
//don&apos;t show the button? Grey it out?
}
Subject currentUser = SecurityUtils.getSubject();
//guarantee that the current user is permitted
//to open a bank account:
Permission p = new AccountPermission(&quot;open&quot;);
currentUser.checkPermission(p);
openBankAccount();
Subject currentUser = SecurityUtils.getSubject();
//guarantee that the current user is permitted
//to open a bank account:
currentUser.checkPermission(&quot;account:open&quot;);
openBankAccount();
@RequiresAuthentication
public void updateAccount(Account userAccount) {
//this method will only be invoked by a
//Subject that is guaranteed authenticated
...
}
@RequiresPermissions(&quot;account:create&quot;)
public void createAccount(Account account) {
//this method will only be invoked by a Subject
//that is permitted to create an account
...
}
&lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;
&lt;shiro:guest&gt;
Hi there! Please &lt;a href=&quot;login.jsp&quot;&gt;Login&lt;/a&gt; or &lt;a href=&quot;signup.jsp&quot;&gt;Signup&lt;/a&gt; today!
&lt;/shiro:guest&gt;
&lt;shiro:user&gt;
Welcome back John! Not John? Click &lt;a href=&quot;login.jsp&quot;&gt;here&lt;a&gt; to login.
&lt;/shiro:user&gt;
&lt;shiro:authenticated&gt;
&lt;a href=&quot;updateAccount.jsp&quot;&gt;Update your contact information&lt;/a&gt;.
&lt;/shiro:authenticated&gt;
&lt;shiro:notAuthenticated&gt;
Please &lt;a href=&quot;login.jsp&quot;&gt;login&lt;/a&gt; in order to update your credit card information.
&lt;/shiro:notAuthenticated&gt;
Xml代码
Hello, &lt;shiro:principal/&gt;, how are you today?
&lt;shiro:hasRole name=&quot;administrator&quot;&gt;
&lt;a href=&quot;admin.jsp&quot;&gt;Administer the system&lt;/a&gt;
&lt;/shiro:hasRole&gt;
&lt;shiro:lacksRole name=&quot;administrator&quot;&gt;
Sorry, you are not allowed to administer the system.
&lt;/shiro:lacksRole&gt;
&lt;shiro:hasAnyRoles name=&quot;developer, project manager, administrator&quot;&gt;
You are either a developer, project manager, or administrator.
&lt;/shiro:lacksRole&gt;
&lt;shiro:hasPermission name=&quot;user:create&quot;&gt;
&lt;a href=&quot;createUser.jsp&quot;&gt;Create a new User&lt;/a&gt;
&lt;/shiro:hasPermission&gt;
&lt;shiro:hasPermission name=&quot;user:create&quot;&gt;
&lt;a href=&quot;createUser.jsp&quot;&gt;Create a new User&lt;/a&gt;
&lt;/shiro:hasPermission&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>361997</snippet_key>
<tag>Security 加密 解密 md5 base64</tag>
<comment>来自CSDN博客：TokenBasedRememberMeServices  加密解密 http://blog.csdn.net/fendou4533/article/details/26888287#</comment>
<code>TokenBasedRememberMeServices.java : » Security » acegi-security » org » acegisecurity » ui » rememberme » Java Open Source
Java Open Source » Security » acegi security
acegi security » org » acegisecurity » ui » rememberme » TokenBasedRememberMeServices.java

/* Copyright 2004, 2005, 2006 Acegi Technology Pty Limited
*
* Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package org.acegisecurity.ui.rememberme;

import java.util.Date;
import java.util.Map;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.acegisecurity.Authentication;
import org.acegisecurity.providers.rememberme.RememberMeAuthenticationToken;
import org.acegisecurity.ui.AccessDeniedHandler;
import org.acegisecurity.ui.AuthenticationDetailsSource;
import org.acegisecurity.ui.AuthenticationDetailsSourceImpl;
import org.acegisecurity.ui.logout.LogoutHandler;
import org.acegisecurity.userdetails.UserDetails;
import org.acegisecurity.userdetails.UserDetailsService;
import org.acegisecurity.userdetails.UsernameNotFoundException;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.ApplicationContext;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.RequestUtils;

/**
* Identifies previously remembered users by a Base-64 encoded cookie.
*
* &lt;p&gt;
* This implementation does not rely on an external database, so is attractive
* for simple applications. The cookie will be valid for a specific period from
* the date of the last
* {@link #loginSuccess(HttpServletRequest, HttpServletResponse, Authentication)}.
* As per the interface contract, this method will only be called when the
* principal completes a successful interactive authentication. As such the time
* period commences from the last authentication attempt where they furnished
* credentials - not the time period they last logged in via remember-me. The
* implementation will only send a remember-me token if the parameter defined by
* {@link #setParameter(String)} is present.
* &lt;/p&gt;
*
* &lt;p&gt;
* An {@link org.acegisecurity.userdetails.UserDetailsService} is required by
* this implementation, so that it can construct a valid
* &lt;code&gt;Authentication&lt;/code&gt; from the returned {@link
* org.acegisecurity.userdetails.UserDetails}. This is also necessary so that
* the user&apos;s password is available and can be checked as part of the encoded
* cookie.
* &lt;/p&gt;
*
* &lt;p&gt;
* The cookie encoded by this implementation adopts the following form:
*
* &lt;pre&gt;
* username + &quot;:&quot; + expiryTime + &quot;:&quot; + Md5Hex(username + &quot;:&quot; + expiryTime + &quot;:&quot; + password + &quot;:&quot; + key)
* &lt;/pre&gt;
*
* &lt;/p&gt;
* &lt;p&gt;
* As such, if the user changes their password any remember-me token will be
* invalidated. Equally, the system administrator may invalidate every
* remember-me token on issue by changing the key. This provides some reasonable
* approaches to recovering from a remember-me token being left on a public
* machine (eg kiosk system, Internet cafe etc). Most importantly, at no time is
* the user&apos;s password ever sent to the user agent, providing an important
* security safeguard. Unfortunately the username is necessary in this
* implementation (as we do not want to rely on a database for remember-me
* services) and as such high security applications should be aware of this
* occasionally undesired disclosure of a valid username.
* &lt;/p&gt;
* &lt;p&gt;
* This is a basic remember-me implementation which is suitable for many
* applications. However, we recommend a database-based implementation if you
* require a more secure remember-me approach.
* &lt;/p&gt;
* &lt;p&gt;
* By default the tokens will be valid for 14 days from the last successful
* authentication attempt. This can be changed using
* {@link #setTokenValiditySeconds(long)}.
* &lt;/p&gt;
*
* @author Ben Alex
* @version $Id: TokenBasedRememberMeServices.java 1871 2007-05-25 03:12:49Z
* benalex $
*/
public class TokenBasedRememberMeServices implements RememberMeServices, InitializingBean, LogoutHandler {
// ~ Static fields/initializers
// =====================================================================================

public static final String ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY = &quot;ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE&quot;;

public static final String DEFAULT_PARAMETER = &quot;_acegi_security_remember_me&quot;;

protected static final Log logger = LogFactory.getLog(TokenBasedRememberMeServices.class);

// ~ Instance fields
// ================================================================================================

protected AuthenticationDetailsSource authenticationDetailsSource = new AuthenticationDetailsSourceImpl();

private String key;

private String parameter = DEFAULT_PARAMETER;

private UserDetailsService userDetailsService;

protected long tokenValiditySeconds = 1209600; // 14 days

private boolean alwaysRemember = false;

private static final int DEFAULT_ORDER = Integer.MAX_VALUE; // ~ default

private String cookieName = ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY;

// ~ Methods
// ========================================================================================================

public void afterPropertiesSet() throws Exception {
Assert.hasLength(key);
Assert.hasLength(parameter);
Assert.hasLength(cookieName);
Assert.notNull(userDetailsService);
}

/**
* Introspects the &lt;code&gt;Applicationcontext&lt;/code&gt; for the single instance
* of {@link AccessDeniedHandler}. If found invoke
* setAccessDeniedHandler(AccessDeniedHandler accessDeniedHandler) method by
* providing the found instance of accessDeniedHandler as a method
* parameter. If more than one instance of &lt;code&gt;AccessDeniedHandler&lt;/code&gt;
* is found, the method throws &lt;code&gt;IllegalStateException&lt;/code&gt;.
*
* @param applicationContext to locate the instance
*/
private void autoDetectAndUseAnyUserDetailsService(ApplicationContext applicationContext) {
Map map = applicationContext.getBeansOfType(UserDetailsService.class);
if (map.size() &gt; 1) {
throw new IllegalArgumentException(
&quot;More than one UserDetailsService beans detected please refer to the one using &quot;
+ &quot; [ principalRepositoryBeanRef ] &quot; + &quot;attribute&quot;);
}
else if (map.size() == 1) {
setUserDetailsService((UserDetailsService) map.values().iterator().next());
}
}

public Authentication autoLogin(HttpServletRequest request, HttpServletResponse response) {
Cookie[] cookies = request.getCookies();

if ((cookies == null) || (cookies.length == 0)) {
return null;
}

for (int i = 0; i &lt; cookies.length; i++) {
if (cookieName.equals(cookies[i].getName())) {
String cookieValue = cookies[i].getValue();

for (int j = 0; j &lt; cookieValue.length() % 4; j++) {
cookieValue = cookieValue + &quot;=&quot;;
}

if (Base64.isArrayByteBase64(cookieValue.getBytes())) {
if (logger.isDebugEnabled()) {
logger.debug(&quot;Remember-me cookie detected&quot;);
}

// Decode token from Base64
// format of token is:
// username + &quot;:&quot; + expiryTime + &quot;:&quot; +
// Md5Hex(username + &quot;:&quot; + expiryTime + &quot;:&quot; + password + &quot;:&quot;
// + key)
String cookieAsPlainText = new String(Base64.decodeBase64(cookieValue.getBytes()));
String[] cookieTokens = StringUtils.delimitedListToStringArray(cookieAsPlainText, &quot;:&quot;);

if (cookieTokens.length == 3) {

long tokenExpiryTime;

try {
tokenExpiryTime = new Long(cookieTokens[1]).longValue();
}
catch (NumberFormatException nfe) {
cancelCookie(request, response,
&quot;Cookie token[1] did not contain a valid number (contained &apos;&quot; + cookieTokens[1]
+ &quot;&apos;)&quot;);

return null;
}

if (isTokenExpired(tokenExpiryTime)) {
cancelCookie(request, response, &quot;Cookie token[1] has expired (expired on &apos;&quot;
+ new Date(tokenExpiryTime) + &quot;&apos;; current time is &apos;&quot; + new Date() + &quot;&apos;)&quot;);

return null;
}

// Check the user exists
// Defer lookup until after expiry time checked, to
// possibly avoid expensive lookup
UserDetails userDetails = loadUserDetails(request, response, cookieTokens);

if (userDetails == null) {
cancelCookie(request, response, &quot;Cookie token[0] contained username &apos;&quot; + cookieTokens[0]
+ &quot;&apos; but was not found&quot;);
return null;
}

if (!isValidUserDetails(request, response, userDetails, cookieTokens)) {
return null;
}

// Check signature of token matches remaining details
// Must do this after user lookup, as we need the
// DAO-derived password
// If efficiency was a major issue, just add in a
// UserCache implementation,
// but recall this method is usually only called one per
// HttpSession
// (as if the token is valid, it will cause
// SecurityContextHolder population, whilst
// if invalid, will cause the cookie to be cancelled)
String expectedTokenSignature = makeTokenSignature(tokenExpiryTime, userDetails);

if (!expectedTokenSignature.equals(cookieTokens[2])) {
cancelCookie(request, response, &quot;Cookie token[2] contained signature &apos;&quot; + cookieTokens[2]
+ &quot;&apos; but expected &apos;&quot; + expectedTokenSignature + &quot;&apos;&quot;);

return null;
}

// By this stage we have a valid token
if (logger.isDebugEnabled()) {
logger.debug(&quot;Remember-me cookie accepted&quot;);
}

RememberMeAuthenticationToken auth = new RememberMeAuthenticationToken(this.key, userDetails,
userDetails.getAuthorities());
auth.setDetails(authenticationDetailsSource.buildDetails((HttpServletRequest) request));

return auth;
}
else {
cancelCookie(request, response, &quot;Cookie token did not contain 3 tokens; decoded value was &apos;&quot;
+ cookieAsPlainText + &quot;&apos;&quot;);

return null;
}
}
else {
cancelCookie(request, response, &quot;Cookie token was not Base64 encoded; value was &apos;&quot; + cookieValue
+ &quot;&apos;&quot;);

return null;
}
}
}

return null;
}

/**
* @param tokenExpiryTime
* @param userDetails
* @return
*/
protected String makeTokenSignature(long tokenExpiryTime, UserDetails userDetails) {
String expectedTokenSignature = DigestUtils.md5Hex(userDetails.getUsername() + &quot;:&quot; + tokenExpiryTime + &quot;:&quot;
+ userDetails.getPassword() + &quot;:&quot; + this.key);
return expectedTokenSignature;
}

protected boolean isValidUserDetails(HttpServletRequest request, HttpServletResponse response,
UserDetails userDetails, String[] cookieTokens) {
// Immediately reject if the user is not allowed to
// login
if (!userDetails.isAccountNonExpired() || !userDetails.isCredentialsNonExpired() || !userDetails.isEnabled()) {
cancelCookie(request, response, &quot;Cookie token[0] contained username &apos;&quot; + cookieTokens[0]
+ &quot;&apos; but account has expired, credentials have expired, or user is disabled&quot;);

return false;
}
return true;
}

protected UserDetails loadUserDetails(HttpServletRequest request, HttpServletResponse response,
String[] cookieTokens) {
UserDetails userDetails = null;

try {
userDetails = this.userDetailsService.loadUserByUsername(cookieTokens[0]);
}
catch (UsernameNotFoundException notFound) {
cancelCookie(request, response, &quot;Cookie token[0] contained username &apos;&quot; + cookieTokens[0]
+ &quot;&apos; but was not found&quot;);

return null;
}
return userDetails;
}

protected boolean isTokenExpired(long tokenExpiryTime) {
// Check it has not expired
if (tokenExpiryTime &lt; System.currentTimeMillis()) {
return true;
}
return false;
}

protected void cancelCookie(HttpServletRequest request, HttpServletResponse response, String reasonForLog) {
if ((reasonForLog != null) &amp;&amp; logger.isDebugEnabled()) {
logger.debug(&quot;Cancelling cookie for reason: &quot; + reasonForLog);
}

response.addCookie(makeCancelCookie(request));
}

public String getKey() {
return key;
}

public String getParameter() {
return parameter;
}

public long getTokenValiditySeconds() {
return tokenValiditySeconds;
}

public UserDetailsService getUserDetailsService() {
return userDetailsService;
}

public void loginFail(HttpServletRequest request, HttpServletResponse response) {
cancelCookie(request, response, &quot;Interactive authentication attempt was unsuccessful&quot;);
}

protected boolean rememberMeRequested(HttpServletRequest request, String parameter) {
if (alwaysRemember) {
return true;
}

return RequestUtils.getBooleanParameter(request, parameter, false);
}

public void loginSuccess(HttpServletRequest request, HttpServletResponse response,
Authentication successfulAuthentication) {
// Exit if the principal hasn&apos;t asked to be remembered
if (!rememberMeRequested(request, parameter)) {
if (logger.isDebugEnabled()) {
logger.debug(&quot;Did not send remember-me cookie (principal did not set parameter &apos;&quot; + this.parameter
+ &quot;&apos;)&quot;);
}

return;
}

// Determine username and password, ensuring empty strings
Assert.notNull(successfulAuthentication.getPrincipal());
Assert.notNull(successfulAuthentication.getCredentials());

String username = retrieveUserName(successfulAuthentication);
String password = retrievePassword(successfulAuthentication);

// If unable to find a username and password, just abort as
// TokenBasedRememberMeServices unable to construct a valid token in
// this case
if (!StringUtils.hasLength(username) || !StringUtils.hasLength(password)) {
return;
}

long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000);

// construct token to put in cookie; format is:
// username + &quot;:&quot; + expiryTime + &quot;:&quot; + Md5Hex(username + &quot;:&quot; +
// expiryTime + &quot;:&quot; + password + &quot;:&quot; + key)
String signatureValue = DigestUtils.md5Hex(username + &quot;:&quot; + expiryTime + &quot;:&quot; + password + &quot;:&quot; + key);
String tokenValue = username + &quot;:&quot; + expiryTime + &quot;:&quot; + signatureValue;
String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes()));
response.addCookie(makeValidCookie(tokenValueBase64, request, tokenValiditySeconds));

if (logger.isDebugEnabled()) {
logger
.debug(&quot;Added remember-me cookie for user &apos;&quot; + username + &quot;&apos;, expiry: &apos;&quot; + new Date(expiryTime)
+ &quot;&apos;&quot;);
}
}

public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {
cancelCookie(request, response, &quot;Logout of user &quot;
+ (authentication == null ? &quot;Unknown&quot; : authentication.getName()));
}

protected String retrieveUserName(Authentication successfulAuthentication) {
if (isInstanceOfUserDetails(successfulAuthentication)) {
return ((UserDetails) successfulAuthentication.getPrincipal()).getUsername();
}
else {
return successfulAuthentication.getPrincipal().toString();
}
}

protected String retrievePassword(Authentication successfulAuthentication) {
if (isInstanceOfUserDetails(successfulAuthentication)) {
return ((UserDetails) successfulAuthentication.getPrincipal()).getPassword();
}
else {
return successfulAuthentication.getCredentials().toString();
}
}

private boolean isInstanceOfUserDetails(Authentication authentication) {
return authentication.getPrincipal() instanceof UserDetails;
}

protected Cookie makeCancelCookie(HttpServletRequest request) {
Cookie cookie = new Cookie(cookieName, null);
cookie.setMaxAge(0);
cookie.setPath(StringUtils.hasLength(request.getContextPath()) ? request.getContextPath() : &quot;/&quot;);

return cookie;
}

protected Cookie makeValidCookie(String tokenValueBase64, HttpServletRequest request, long maxAge) {
Cookie cookie = new Cookie(cookieName, tokenValueBase64);
cookie.setMaxAge(new Long(maxAge).intValue());
cookie.setPath(StringUtils.hasLength(request.getContextPath()) ? request.getContextPath() : &quot;/&quot;);

return cookie;
}

public void setAuthenticationDetailsSource(AuthenticationDetailsSource authenticationDetailsSource) {
Assert.notNull(authenticationDetailsSource, &quot;AuthenticationDetailsSource required&quot;);
this.authenticationDetailsSource = authenticationDetailsSource;
}

public void setKey(String key) {
this.key = key;
}

public void setParameter(String parameter) {
this.parameter = parameter;
}

public void setCookieName(String cookieName) {
this.cookieName = cookieName;
}

public void setTokenValiditySeconds(long tokenValiditySeconds) {
this.tokenValiditySeconds = tokenValiditySeconds;
}

public void setUserDetailsService(UserDetailsService userDetailsService) {
this.userDetailsService = userDetailsService;
}

public boolean isAlwaysRemember() {
return alwaysRemember;
}

public void setAlwaysRemember(boolean alwaysRemember) {
this.alwaysRemember = alwaysRemember;
}

public String getCookieName() {
return cookieName;
}

}


</code>
</RECORD>
<RECORD>
<snippet_key>165645</snippet_key>
<tag>45</tag>
<comment>AES算法工具类</comment>
<code>package AES;

import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class AESUtil {

/**
* 加密
*
* @param content
* 需要加密的内容
* @param password
* 加密密钥
* @return
*/
public static byte[] encrypt(String content, String password) {
try {
KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;);
kgen.init(128, new SecureRandom(password.getBytes()));
SecretKey secretKey = kgen.generateKey();
byte[] enCodeFormat = secretKey.getEncoded();
SecretKeySpec key = new SecretKeySpec(enCodeFormat, &quot;AES&quot;);
Cipher cipher = Cipher.getInstance(&quot;AES&quot;);// 创建密码器
byte[] byteContent = content.getBytes(&quot;utf-8&quot;);
cipher.init(Cipher.ENCRYPT_MODE, key);// 初始化
byte[] result = cipher.doFinal(byteContent);
return result; // 加密
} catch (NoSuchAlgorithmException e) {
e.printStackTrace();
} catch (NoSuchPaddingException e) {
e.printStackTrace();
} catch (InvalidKeyException e) {
e.printStackTrace();
} catch (UnsupportedEncodingException e) {
e.printStackTrace();
} catch (IllegalBlockSizeException e) {
e.printStackTrace();
} catch (BadPaddingException e) {
e.printStackTrace();
}
return null;
}

/**
* 解密
*
* @param content
* 待解密内容
* @param password
* 解密密钥
* @return
*/
public static byte[] decrypt(byte[] content, String password) {
try {
KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;);
kgen.init(128, new SecureRandom(password.getBytes()));
SecretKey secretKey = kgen.generateKey();
byte[] enCodeFormat = secretKey.getEncoded();
SecretKeySpec key = new SecretKeySpec(enCodeFormat, &quot;AES&quot;);
Cipher cipher = Cipher.getInstance(&quot;AES&quot;);// 创建密码器
cipher.init(Cipher.DECRYPT_MODE, key);// 初始化
byte[] result = cipher.doFinal(content);
return result; // 加密
} catch (NoSuchAlgorithmException e) {
e.printStackTrace();
} catch (NoSuchPaddingException e) {
e.printStackTrace();
} catch (InvalidKeyException e) {
e.printStackTrace();
} catch (IllegalBlockSizeException e) {
e.printStackTrace();
} catch (BadPaddingException e) {
e.printStackTrace();
}
return null;
}

/**
* 将二进制转换成16进制
*
* @param buf
* @return
*/
public static String parseByte2HexStr(byte buf[]) {
StringBuffer sb = new StringBuffer();
for (int i = 0; i &lt; buf.length; i++) {
String hex = Integer.toHexString(buf[i] &amp; 0xFF);
if (hex.length() == 1) {
hex = &apos;0&apos; + hex;
}
sb.append(hex.toUpperCase());
}
return sb.toString();
}

/**
* 将16进制转换为二进制
*
* @param hexStr
* @return
*/
public static byte[] parseHexStr2Byte(String hexStr) {
if (hexStr.length() &lt; 1)
return null;
byte[] result = new byte[hexStr.length() / 2];
for (int i = 0; i &lt; hexStr.length() / 2; i++) {
int high = Integer.parseInt(hexStr.substring(i * 2, i * 2 + 1), 16);
int low = Integer.parseInt(hexStr.substring(i * 2 + 1, i * 2 + 2),
16);
result[i] = (byte) (high * 16 + low);
}
return result;
}

public static void main(String[] args) {
String content = &quot;mintz1chen&quot;;
String password = &quot;Mintz1chen&quot;;
// 加密
System.out.println(&quot;加密前：&quot; + content+&quot; 密钥：&quot;+password);
byte[] encryptResult = encrypt(content, password);
String encryptResultStr = parseByte2HexStr(encryptResult);
System.out.println(&quot;加密后：&quot; + encryptResultStr);
// 解密
byte[] decryptFrom = parseHexStr2Byte(encryptResultStr);
byte[] decryptResult = decrypt(decryptFrom, password);
System.out.println(&quot;解密后：&quot; + new String(decryptResult));
}
}
package AES;


import java.security.MessageDigest;

/**
* 对密码进行加密和验证的类
*/
public class CipherUtil{

//十六进制下数字到字符的映射数组
private final static String[] hexDigits = {&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;,
&quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;};

/** * 把inputString加密 */
public static String generatePassword(String inputString){
return encodeByMD5(inputString);
}

/**
* 验证输入的密码是否正确
* @param password 加密后的密码
* @param inputString 输入的字符串
* @return 验证结果，TRUE:正确 FALSE:错误
*/
public static boolean validatePassword(String password, String inputString){
if(password.equals(encodeByMD5(inputString))){
return true;
} else{
return false;
}
}
/** 对字符串进行MD5加密 */
private static String encodeByMD5(String originString){
if (originString != null){
try{
//创建具有指定算法名称的信息摘要
MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
//使用指定的字节数组对摘要进行最后更新，然后完成摘要计算
byte[] results = md.digest(originString.getBytes());
//将得到的字节数组变成字符串返回
String resultString = byteArrayToHexString(results);
return resultString.toUpperCase();
} catch(Exception ex){
ex.printStackTrace();
}
}
return null;
}

/**
* 转换字节数组为十六进制字符串
* @param 字节数组
* @return 十六进制字符串
*/
private static String byteArrayToHexString(byte[] b){
StringBuffer resultSb = new StringBuffer();
for (int i = 0; i &lt; b.length; i++){
resultSb.append(byteToHexString(b[i]));
}
return resultSb.toString();
}

/** 将一个字节转化成十六进制形式的字符串 */
private static String byteToHexString(byte b){
int n = b;
if (n &lt; 0)
n = 256 + n;
int d1 = n / 16;
int d2 = n % 16;
return hexDigits[d1] + hexDigits[d2];
}
public static void main(String[] args) {
String pwd1=&quot;123456&quot;;
String pwd2=&quot;&quot;;
CipherUtil cipher = new CipherUtil();
System.out.println(&quot;未加密的密码:&quot;+pwd1);
//将123加密
pwd2 = cipher.generatePassword(pwd1);
System.out.println(&quot;加密后的密码:&quot;+pwd2);

System.out.print(&quot;验证密码是否正确:&quot;);
if(cipher.validatePassword(pwd2, pwd1)) {
System.out.println(&quot;正确&quot;);
}
else {
System.out.println(&quot;错误&quot;);
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>480527</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：Java(Android)线程池详解  http://blog.csdn.net/u012827205/article/details/39891581#</comment>
<code>new Thread(new Runnable() {

@Override
public void run() {
// TODO Auto-generated method stub
}
}).start();
ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
for (int i = 0; i &lt; 10; i++) {
final int index = i;
try {
Thread.sleep(index * 1000);
} catch (InterruptedException e) {
e.printStackTrace();
}

cachedThreadPool.execute(new Runnable() {

@Override
public void run() {
System.out.println(index);
}
});
}
ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
for (int i = 0; i &lt; 10; i++) {
final int index = i;
fixedThreadPool.execute(new Runnable() {

@Override
public void run() {
try {
System.out.println(index);
Thread.sleep(2000);
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}
});
}
ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
scheduledThreadPool.schedule(new Runnable() {

@Override
public void run() {
System.out.println(&quot;delay 3 seconds&quot;);
}
}, 3, TimeUnit.SECONDS);
scheduledThreadPool.scheduleAtFixedRate(new Runnable() {

@Override
public void run() {
System.out.println(&quot;delay 1 seconds, and excute every 3 seconds&quot;);
}
}, 1, 3, TimeUnit.SECONDS);
ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
for (int i = 0; i &lt; 10; i++) {
final int index = i;
singleThreadExecutor.execute(new Runnable() {

@Override
public void run() {
try {
System.out.println(index);
Thread.sleep(2000);
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}
});
}
</code>
</RECORD>
<RECORD>
<snippet_key>480609</snippet_key>
<tag>android应用 dialog</tag>
<comment>来自CSDN博客：Alertialog警告对话框的用法  http://blog.csdn.net/u013985004/article/details/25601833#</comment>
<code>private void dialog() {
Dialog dialog = new AlertDialog.Builder(this)
.setTitle(&quot;对话框的标题&quot;)
.setMessage(&quot;对话框的内容&quot;)
.setIcon(R.drawable.ic_launcher)
// 自定义图标
.setCancelable(false)
// 设置焦点，false时点击屏幕其他地方和返回键都不操作
.setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() {
@Override
public void onClick(DialogInterface dialog, int which) {
Toast.makeText(getApplicationContext(), &quot;点击确定按钮&quot;,
Toast.LENGTH_SHORT).show();
}
})
.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() {
@Override
public void onClick(DialogInterface dialog, int which) {
Toast.makeText(getApplicationContext(), &quot;点击取消按钮&quot;,
Toast.LENGTH_SHORT).show();
}
})
.setNeutralButton(&quot;中立&quot;, new DialogInterface.OnClickListener() {
@Override
public void onClick(DialogInterface dialog, int which) {
Toast.makeText(getApplicationContext(), &quot;点击中立按钮&quot;,
Toast.LENGTH_SHORT).show();
}
}).create();
dialog.show();
}
protected void dialog() {
AlertDialog.Builder builder = new Builder(this);
builder.setTitle(&quot;对话框的标题&quot;);
builder.setMessage(&quot;对话框的内容&quot;);
builder.setCancelable(false);
builder.setPositiveButton(&quot;确认&quot;, new DialogInterface.OnClickListener() {
@Override
public void onClick(DialogInterface dialog, int which) {
Toast.makeText(getApplicationContext(), &quot;点击确定按钮&quot;,
Toast.LENGTH_SHORT).show();
}
});
builder.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() {
@Override
public void onClick(DialogInterface dialog, int which) {
Toast.makeText(getApplicationContext(), &quot;点击取消按钮&quot;,
Toast.LENGTH_SHORT).show();
}
});
builder.create().show();
}
private void dialog() {
final String[] arrayFruit = new String[] { &quot;苹果&quot;, &quot;橘子&quot;, &quot;草莓&quot;, &quot;香蕉&quot; };
Dialog alertDialog = new AlertDialog.Builder(this)
.setTitle(&quot;你喜欢吃哪种水果？&quot;)
.setIcon(R.drawable.ic_launcher)
.setItems(arrayFruit, new DialogInterface.OnClickListener() {
@Override
public void onClick(DialogInterface dialog, int which) {
Toast.makeText(getApplicationContext(),
arrayFruit[which], Toast.LENGTH_SHORT).show();
}
})
.setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() {
@Override
public void onClick(DialogInterface dialog, int which) {
Toast.makeText(getApplicationContext(), &quot;点击确定按钮&quot;,
Toast.LENGTH_SHORT).show();
}
}).create();
alertDialog.show();
}
String fruit = &quot;选择水果&quot;;
private void dialog() {
final String[] arrayFruit = new String[] { &quot;苹果&quot;, &quot;橘子&quot;, &quot;草莓&quot;, &quot;香蕉&quot; };
Dialog alertDialog = new AlertDialog.Builder(this)
.setTitle(&quot;你喜欢吃哪种水果？&quot;)
.setIcon(R.drawable.ic_launcher)
.setSingleChoiceItems(arrayFruit, 0,
new DialogInterface.OnClickListener() {
@Override
public void onClick(DialogInterface dialog,
int which) {
fruit = arrayFruit[which];
Toast.makeText(getApplicationContext(),
arrayFruit[which], Toast.LENGTH_SHORT)
.show();
}
})
.setPositiveButton(&quot;确认&quot;, new DialogInterface.OnClickListener() {
@Override
public void onClick(DialogInterface dialog, int which) {
Toast.makeText(getApplicationContext(), &quot;选择了&quot; + fruit,
Toast.LENGTH_SHORT).show();
}
})
.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() {
@Override
public void onClick(DialogInterface dialog, int which) {
Toast.makeText(getApplicationContext(), &quot;点击取消按钮&quot;,
Toast.LENGTH_SHORT).show();
}
}).create();
alertDialog.show();
}
private void dialog() {
final String[] arrayFruit = new String[] { &quot;苹果&quot;, &quot;橘子&quot;, &quot;草莓&quot;, &quot;香蕉&quot; };
final boolean[] arrayFruitSelected = new boolean[] { true, true, false,
false };
Dialog alertDialog = new AlertDialog.Builder(this)
.setTitle(&quot;你喜欢吃哪种水果？&quot;)
.setIcon(R.drawable.ic_launcher)
.setMultiChoiceItems(arrayFruit, arrayFruitSelected,
new DialogInterface.OnMultiChoiceClickListener() {
@Override
public void onClick(DialogInterface dialog,
int which, boolean isChecked) {
arrayFruitSelected[which] = isChecked;
}
})
.setPositiveButton(&quot;确认&quot;, new DialogInterface.OnClickListener() {
@Override
public void onClick(DialogInterface dialog, int which) {
StringBuilder stringBuilder = new StringBuilder();
for (int i = 0; i &lt; arrayFruitSelected.length; i++) {
if (arrayFruitSelected[i] == true) {
stringBuilder.append(arrayFruit[i] + &quot;、&quot;);
}
}
Toast.makeText(getApplicationContext(),
stringBuilder.toString(), Toast.LENGTH_SHORT)
.show();
}
})
.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() {
@Override
public void onClick(DialogInterface dialog, int which) {
Toast.makeText(getApplicationContext(), &quot;点击取消按钮&quot;,
Toast.LENGTH_SHORT).show();
}
}).create();
alertDialog.show();
}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:orientation=&quot;vertical&quot; &gt;
&lt;TextView
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;我的自定义:&quot; /&gt;
&lt;EditText
android:id=&quot;@+id/et_content&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:hint=&quot;请输入内容&quot; /&gt;
&lt;/LinearLayout&gt;
private void dialog() {
LayoutInflater layoutInflater = LayoutInflater.from(this);
View myDialog = layoutInflater.inflate(R.layout.dialog, null);
final EditText editText = (EditText) myDialog
.findViewById(R.id.et_content);
Dialog alertDialog = new AlertDialog.Builder(this)
.setTitle(&quot;自定义布局&quot;)
.setIcon(R.drawable.ic_launcher)
.setView(myDialog)
.setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() {
@Override
public void onClick(DialogInterface dialog, int which) {
String msg = editText.getText().toString();
Toast.makeText(getApplicationContext(), msg,
Toast.LENGTH_SHORT).show();
}
})
.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() {
@Override
public void onClick(DialogInterface dialog, int which) {
Toast.makeText(getApplicationContext(), &quot;点击取消按钮&quot;,
Toast.LENGTH_SHORT).show();
}
}).create();
alertDialog.show();
}
</code>
</RECORD>
<RECORD>
<snippet_key>165901</snippet_key>
<tag></tag>
<comment>来自CSDN博客：关于两个值的交换  http://blog.csdn.net/u013400779/article/details/18621225#</comment>
<code>关于两个值的交换还有一种方法，但是本人能力有限不能解释！我会在最下面给出代码，谁会的话可以解释一下原理！
public class Dome04{
public static void main(String[] agrs){

int a=3;//经典的a b值交换
int c;
int b=4;
System.out.println(&quot; a = &quot; + a + &quot;,b = &quot; + b);
c = a;
a = b;
b = c;
System.out.println(&quot; a = &quot; + a + &quot;,b = &quot; + b);
System.out.println(&quot;-------------------------------&quot;);
a = 3; //因为上面已经定义过了a和b，现在再定义运行时就会报错了！
b = 4;
System.out.println(&quot; a = &quot; + a + &quot;,b = &quot; + b);
a = a + b;
b = a - b; //简单的数学技巧
a = a - b;
System.out.println(&quot; a = &quot;+ a + &quot;,b = &quot; + b);}}
&lt;img src=&quot;http://img.blog.csdn.net/20140121203303890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzQwMDc3OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;&quot; /&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>362509</snippet_key>
<tag>java 邮件 邮件服务器</tag>
<comment>来自CSDN博客：Java发邮件：Java Mail与Apache Mail  http://blog.csdn.net/jorbiee/article/details/26964909#</comment>
<code>public static void main(String[] args) throws Exception {
final String user = &quot;779554589&quot;;
final String password = &quot;&quot;;

String fromAddress = &quot;779554589@qq.com&quot;;
String toAddress = &quot;loadfate@163.com&quot;;
String subject = &quot;邮件测试主题&quot;;
String content = &quot;这是一个测试邮件&lt;b&gt;哈哈&lt;/b&gt;&quot;;

//配置参数
Properties props = new Properties();
props.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;);
props.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;);
props.setProperty(&quot;mail.host&quot;, &quot;smtp.qq.com&quot;);
// 方法一：使用transport对象发送邮件
{
//通过参数生成会话
Session session = Session.getInstance(props);
//启用调试模式
session.setDebug(true);
//创建一封邮件，并设置信息
Message message = new MimeMessage(session);
message.setFrom(new InternetAddress(fromAddress));
message.setSubject(subject);
message.setText(content);
//创建传输
Transport transport = session.getTransport();
//连接smtp服务器
transport.connect(user, password);
//发送
transport.sendMessage(message, new InternetAddress[] { new InternetAddress(toAddress) });
transport.close();
}


// 方法二：使用Transport类静态方法发送邮件
{
//生成Session时以获取授权连接
Session session = Session.getInstance(props, new Authenticator() {
@Override
protected PasswordAuthentication getPasswordAuthentication() {
return new PasswordAuthentication(user, password);
}
});
session.setDebug(true);
//创建一封邮件，并设置信息
Message message = new MimeMessage(session);
message.setSubject(subject);
message.setFrom(new InternetAddress(fromAddress));
message.setRecipient(RecipientType.TO, new InternetAddress(toAddress));
message.setContent(content, &quot;text/html;charset=utf-8&quot;);

//直接发送，message通过已经授权的Session生成
Transport.send(message);
}
}
public class ApacheMailTest {
// smtp服务器
private String hostName = &quot;smtp.qq.com&quot;;
// 帐号与密码
private String userName = &quot;779554589&quot;;
private String password = &quot;这是个秘密&quot;;
// 发件人
private String fromAddress = &quot;779554589@qq.com&quot;;
// 发件人姓名
private String fromName = &quot;loadfate&quot;;

public static void main(String[] args) throws Exception {
// 收件人与收件人名字
String toAddress = &quot;loadfate@163.com&quot;;
String toName = &quot;loadfate&quot;;
ApacheMailTest test = new ApacheMailTest();
// 所有的异常都为处理，方便浏览

test.sendSimpleEmail(toAddress, toName);
test.sendHtmlEmail(toAddress, toName);
test.sendMultiPartEmail(toAddress, toName);
System.out.println(&quot;发送完成&quot;);
}

// 发送简单邮件，类似一条信息
public void sendSimpleEmail(String toAddress, String toName) throws Exception {
SimpleEmail email = new SimpleEmail();
email.setHostName(hostName);// 设置smtp服务器
email.setAuthentication(userName, password);// 设置授权信息
email.setCharset(&quot;utf-8&quot;);
email.setFrom(fromAddress, fromName, &quot;utf-8&quot;);// 设置发件人信息
email.addTo(toAddress, toName, &quot;utf-8&quot;);// 设置收件人信息
email.setSubject(&quot;测试主题&quot;);// 设置主题
email.setMsg(&quot;这是一个简单的测试！&quot;);// 设置邮件内容
email.send();// 发送邮件
}

// 发送Html内容的邮件
public void sendHtmlEmail(String toAddress, String toName) throws Exception {
HtmlEmail email = new HtmlEmail();
email.setHostName(hostName);
email.setAuthentication(userName, password);
email.setCharset(&quot;utf-8&quot;);
email.addTo(toAddress, toName, &quot;utf-8&quot;);
email.setFrom(fromAddress, fromName, &quot;utf-8&quot;);
email.setSubject(&quot;这是一个html邮件&quot;);
// 设置html内容，实际使用时可以从文本读入写好的html代码
email.setHtmlMsg(&quot;&lt;div style=&apos;width:100px;height:200px;&apos;&gt;a&lt;/div&gt;&quot;);
email.send();

}

// 发送复杂的邮件，包含附件等
public void sendMultiPartEmail(String toAddress, String toName) throws Exception {
MultiPartEmail email = null;
email = new MultiPartEmail();
email.setHostName(hostName);
email.setAuthentication(userName, password);
email.setCharset(&quot;utf-8&quot;);
email.addTo(toAddress, toName, &quot;utf-8&quot;);
email.setFrom(fromAddress, fromName, &quot;utf-8&quot;);
email.setSubject(&quot;这是有附件的邮件&quot;);
email.setMsg(&quot;&lt;a href=&apos;#&apos;&gt;测试内容&lt;/a&gt;&quot;);

// 为邮件添加附加内容
EmailAttachment attachment = new EmailAttachment();
attachment.setPath(&quot;D:\\邮件.txt&quot;);// 本地文件
// attachment.setURL(new URL(&quot;http://xxx/a.gif&quot;));//远程文件
attachment.setDisposition(EmailAttachment.ATTACHMENT);
attachment.setDescription(&quot;描述信息&quot;);
// 设置附件显示名字，必须要编码，不然中文会乱码
attachment.setName(MimeUtility.encodeText(&quot;邮件.txt&quot;));
// 将附件添加到邮件中
email.attach(attachment);
email.send();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>480596</snippet_key>
<tag>javascript</tag>
<comment>来自CSDN博客：javascript之博客前端之事件绑定  http://blog.csdn.net/chenchudongsg/article/details/39893277#</comment>
<code>/*
//实现累加，并且清晰的指出是专给addEvent用的
//JS一切皆为对象，所以addEvent.ID语法正确，实际上是个全局变量
alert(addEvent.ID);
addEvent.ID++;


*/


//跨浏览器添加事件绑定
function addEvent(obj, type, fn) {
if (typeof obj.addEventListener != &apos;undefined&apos;) {
obj.addEventListener(type, fn, false);
} else {
//创建一个存放事件的哈希表(散列表)
if (!obj.events) obj.events = {};
//第一次执行时执行
if (!obj.events[type]) {
//创建一个存放事件处理函数的数组
obj.events[type] = [];
//把第一次的事件处理函数先储存到第一个位置上
if (obj[&apos;on&apos; + type]) obj.events[type][0] = fn;
} else {
//同一个注册函数进行屏蔽，不添加到计数器中
if (addEvent.equal(obj.events[type], fn)) return false;
}
//从第二次开始我们用事件计数器来存储
obj.events[type][addEvent.ID++] = fn;
//执行事件处理函数
obj[&apos;on&apos; + type] = addEvent.exec;
}
}

//为每个事件分配一个计数器
addEvent.ID = 1;

//执行事件处理函数
addEvent.exec = function (event) {
var e = event || addEvent.fixEvent(window.event);
var es = this.events[e.type];
for (var i in es) {
es[i].call(this, e);
}
};

//同一个注册函数进行屏蔽
addEvent.equal = function (es, fn) {
for (var i in es) {
if (es[i] == fn) return true;
}
return false;
}

//把IE常用的Event对象配对到W3C中去
addEvent.fixEvent = function (event) {
event.preventDefault = addEvent.fixEvent.preventDefault;
event.stopPropagation = addEvent.fixEvent.stopPropagation;
return event;
};

//IE阻止默认行为
addEvent.fixEvent.preventDefault = function () {
this.returnValue = false;
};

//IE取消冒泡
addEvent.fixEvent.stopPropagation = function () {
this.cancelBubble = true;
};


//跨浏览器删除事件
function removeEvent(obj, type, fn) {
if (typeof obj.removeEventListener != &apos;undefined&apos;) {
obj.removeEventListener(type, fn, false);
} else {
for (var i in obj.events[type]) {
if (obj.events[type][i] == fn) {
delete obj.events[type][i];
}
}
}
}
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;Base.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;demo3.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=&quot;button&quot; value=&quot;按钮&quot; id=&quot;button&quot; /&gt;
&lt;a href=&quot;http://www.baidu.com&quot; id=&quot;a&quot;&gt;百度一下&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
window.onload = function () {

var oButton = document.getElementById(&apos;button&apos;);
/*
addEvent(oButton, &apos;click&apos;, fn1);
addEvent(oButton, &apos;click&apos;, fn2);
addEvent(oButton, &apos;click&apos;, fn3);
removeEvent(oButton, &apos;click&apos;, fn2);
*/

var a = document.getElementById(&apos;a&apos;);
addEvent(a, &apos;click&apos;, function (e) {
e.preventDefault();
});

addEvent(oButton, &apos;click&apos;, function (e) {
e.stopPropagation();
alert(&apos;button&apos;);
});

addEvent(document, &apos;click&apos;, function () {
alert(&apos;document&apos;);
});

};


function fn1(e) {
alert(&apos;1&apos; + this.value + e.clientX);
}

function fn2(e) {
alert(&apos;2&apos; + this.value + e.clientX);
}

function fn3(e) {
alert(&apos;3&apos; + this.value + e.clientX);
}
</code>
</RECORD>
<RECORD>
<snippet_key>428301</snippet_key>
<tag></tag>
<comment>来自CSDN博客：MD5  代码 http://blog.csdn.net/iqingfen/article/details/37885787#</comment>
<code>// 全局数组
private final static String[] strDigits = { &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;,
&quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot; };

public MD5() {
}

// 返回形式为数字跟字符串
private static String byteToArrayString(byte bByte) {
int iRet = bByte;
// System.out.println(&quot;iRet=&quot;+iRet);
if (iRet &lt; 0) {
iRet += 256;
}
int iD1 = iRet / 16;
int iD2 = iRet % 16;
return strDigits[iD1] + strDigits[iD2];
}

// 返回形式只为数字
private static String byteToNum(byte bByte) {
int iRet = bByte;
System.out.println(&quot;iRet1=&quot; + iRet);
if (iRet &lt; 0) {
iRet += 256;
}
return String.valueOf(iRet);
}

// 转换字节数组为16进制字串
private static String byteToString(byte[] bByte) {
StringBuffer sBuffer = new StringBuffer();
for (int i = 0; i &lt; bByte.length; i++) {
sBuffer.append(byteToArrayString(bByte[i]));
}
return sBuffer.toString();
}

public static String GetMD5Code(String strObj) {
String resultString = null;
try {
resultString = new String(strObj);
MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
// md.digest() 该函数返回值为存放哈希值结果的byte数组
resultString = byteToString(md.digest(strObj.getBytes()));
} catch (NoSuchAlgorithmException ex) {
ex.printStackTrace();
}
return resultString;
}

public static void main(String[] args) {
MD5 getMD5 = new MD5();
System.out.println(getMD5.GetMD5Code(&quot;000000&quot;));
}
</code>
</RECORD>
<RECORD>
<snippet_key>166413</snippet_key>
<tag>327</tag>
<comment>来自CSDN博客：Java RandomAccessFile用法  http://blog.csdn.net/Love_5209/article/details/18656177#</comment>
<code>import java.io.IOException;
import java.io.RandomAccessFile;

public class TestRandomAccessFile {
public static void main(String[] args) throws IOException {
RandomAccessFile rf = new RandomAccessFile(&quot;rtest.dat&quot;, &quot;rw&quot;);
for (int i = 0; i &lt; 10; i++) {
//写入基本类型double数据
rf.writeDouble(i * 1.414);
}
rf.close();
rf = new RandomAccessFile(&quot;rtest.dat&quot;, &quot;rw&quot;);
//直接将文件指针移到第5个double数据后面
rf.seek(5 * 8);
//覆盖第6个double数据
rf.writeDouble(47.0001);
rf.close();
rf = new RandomAccessFile(&quot;rtest.dat&quot;, &quot;r&quot;);
for (int i = 0; i &lt; 10; i++) {
System.out.println(&quot;Value &quot; + i + &quot;: &quot; + rf.readDouble());
}
rf.close();
}
} 
import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;

public class LargeMappedFiles {
static int length = 0x8000000; // 128 Mb

public static void main(String[] args) throws Exception {
// 为了以可读可写的方式打开文件，这里使用RandomAccessFile来创建文件。
FileChannel fc = new RandomAccessFile(&quot;test.dat&quot;, &quot;rw&quot;).getChannel();
//注意，文件通道的可读可写要建立在文件流本身可读写的基础之上
MappedByteBuffer out = fc.map(FileChannel.MapMode.READ_WRITE, 0, length);
//写128M的内容
for (int i = 0; i &lt; length; i++) {
out.put((byte) &apos;x&apos;);
}
System.out.println(&quot;Finished writing&quot;);
//读取文件中间6个字节内容
for (int i = length / 2; i &lt; length / 2 + 6; i++) {
System.out.print((char) out.get(i));
}
fc.close();
}
}
/*
* 程序功能：演示了RandomAccessFile类的操作，同时实现了一个文件复制操作。
*/
package com.lwj.demo;

import java.io.*;

public class RandomAccessFileDemo {
public static void main(String[] args) throws Exception {
RandomAccessFile file = new RandomAccessFile(&quot;file&quot;, &quot;rw&quot;);
// 以下向file文件中写数据
file.writeInt(20);// 占4个字节
file.writeDouble(8.236598);// 占8个字节
file.writeUTF(&quot;这是一个UTF字符串&quot;);// 这个长度写在当前文件指针的前两个字节处，可用readShort()读取
file.writeBoolean(true);// 占1个字节
file.writeShort(395);// 占2个字节
file.writeLong(2325451l);// 占8个字节
file.writeUTF(&quot;又是一个UTF字符串&quot;);
file.writeFloat(35.5f);// 占4个字节
file.writeChar(&apos;a&apos;);// 占2个字节

file.seek(0);// 把文件指针位置设置到文件起始处

// 以下从file文件中读数据，要注意文件指针的位置
System.out.println(&quot;——————从file文件指定位置读数据——————&quot;);
System.out.println(file.readInt());
System.out.println(file.readDouble());
System.out.println(file.readUTF());

file.skipBytes(3);// 将文件指针跳过3个字节，本例中即跳过了一个boolean值和short值。
System.out.println(file.readLong());

file.skipBytes(file.readShort()); // 跳过文件中“又是一个UTF字符串”所占字节，注意readShort()方法会移动文件指针，所以不用加2。
System.out.println(file.readFloat());

//以下演示文件复制操作
System.out.println(&quot;——————文件复制（从file到fileCopy）——————&quot;);
file.seek(0);
RandomAccessFile fileCopy=new RandomAccessFile(&quot;fileCopy&quot;,&quot;rw&quot;);
int len=(int)file.length();//取得文件长度（字节数）
byte[] b=new byte[len];
file.readFully(b);
fileCopy.write(b);
System.out.println(&quot;复制完成！&quot;);
}
}
/**
*
* @param skip 跳过多少过字节进行插入数据
* @param str 要插入的字符串
* @param fileName 文件路径
*/
public static void beiju(long skip, String str, String fileName){
try {
RandomAccessFile raf = new RandomAccessFile(fileName,&quot;rw&quot;);
if(skip &lt; 0 || skip &gt; raf.length()){
System.out.println(&quot;跳过字节数无效&quot;);
return;
}
byte[] b = str.getBytes();
raf.setLength(raf.length() + b.length);
for(long i = raf.length() - 1; i &gt; b.length + skip - 1; i--){
raf.seek(i - b.length);
byte temp = raf.readByte();
raf.seek(i);
raf.writeByte(temp);
}
raf.seek(skip);
raf.write(b);
raf.close();
} catch (Exception e) {
e.printStackTrace();
}
}
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;

/**
* 测试利用多线程进行文件的写操作
*/
public class Test {

public static void main(String[] args) throws Exception {
// 预分配文件所占的磁盘空间，磁盘中会创建一个指定大小的文件
RandomAccessFile raf = new RandomAccessFile(&quot;D://abc.txt&quot;, &quot;rw&quot;);
raf.setLength(1024*1024); // 预分配 1M 的文件空间
raf.close();

// 所要写入的文件内容
String s1 = &quot;第一个字符串&quot;;
String s2 = &quot;第二个字符串&quot;;
String s3 = &quot;第三个字符串&quot;;
String s4 = &quot;第四个字符串&quot;;
String s5 = &quot;第五个字符串&quot;;

// 利用多线程同时写入一个文件
new FileWriteThread(1024*1,s1.getBytes()).start(); // 从文件的1024字节之后开始写入数据
new FileWriteThread(1024*2,s2.getBytes()).start(); // 从文件的2048字节之后开始写入数据
new FileWriteThread(1024*3,s3.getBytes()).start(); // 从文件的3072字节之后开始写入数据
new FileWriteThread(1024*4,s4.getBytes()).start(); // 从文件的4096字节之后开始写入数据
new FileWriteThread(1024*5,s5.getBytes()).start(); // 从文件的5120字节之后开始写入数据
}

// 利用线程在文件的指定位置写入指定数据
static class FileWriteThread extends Thread{
private int skip;
private byte[] content;

public FileWriteThread(int skip,byte[] content){
this.skip = skip;
this.content = content;
}

public void run(){
RandomAccessFile raf = null;
try {
raf = new RandomAccessFile(&quot;D://abc.txt&quot;, &quot;rw&quot;);
raf.seek(skip);
raf.write(content);
} catch (FileNotFoundException e) {
e.printStackTrace();
} catch (IOException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} finally {
try {
raf.close();
} catch (Exception e) {
}
}
}
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>363021</snippet_key>
<tag>458</tag>
<comment>来自CSDN博客：图着色问题  http://blog.csdn.net/u010567606/article/details/26984151#</comment>
<code>//我们用1,2,3,4...表示不同的颜色，color[i]表示第i的顶点的颜色值
private static int[] color = new int[10];

// 判断顶点k的着色是否发生冲突
public static boolean ok(int k, int[][] c) {
int i, j;
for (i = 0; i &lt; k; i++)
if (c[k][i] == 1 &amp;&amp; color[i] == color[k])//如果两个顶点相连，并且颜色一样，说明冲突
return false;
return true;
}

//给图着色
public static void graphcolor(int n, int m, int[][] c) {
int i, k;
for (i = 0; i &lt; n; i++)
color[i] = 0;//首先将每个顶点的颜色值初始化为0，表示没有颜色
k = 0; //k代表顶点，从第0个顶点开始
while (k &gt;= 0) {
color[k] = color[k] + 1; //给当前顶点第一次着色，从第一种颜色开始；如果遇到回溯，就不是从第一个颜色开始了
while (color[k] &lt;= m){
if (ok(k, c))
break; //当前顶点的着色没有冲突，退出循环
else
color[k] = color[k] + 1;//如果冲突，搜索下一个颜色
}
if (color[k] &lt;= m &amp;&amp; k == n-1){ // 求解完毕，输出解
for (i = 0; i &lt; n; i++)
System.out.print(color[i]+&quot;,&quot;);//输出解决方案
System.out.println();
} else if (color[k] &lt;= m &amp;&amp; k &lt; n-1)/ //仍有顶点没有处理
k = k + 1; // 处理下一个顶点
else { //此时说明某一顶点的颜色值大于所给的颜色数m
color[k] = 0;
k = k - 1; // 回溯；直到第0个顶点再想回溯时，已经没有顶点可回溯了，则退出循环
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>232205</snippet_key>
<tag>472</tag>
<comment>来自CSDN博客：选择排序、树形排序、堆排序的java代码实现 http://blog.csdn.net/a15994269853/article/details/21114045#</comment>
<code>package com.sort;

/**
* 选择排序：
* 简单选择排序，树形选择排序与堆排序
*
*/
public class SelecSortDemo {

/**
* --------------------------------------------
* 简单选择排序
* 原理：假设列表中有n个元素，从第一个元素开始，在第一个元素
* 与最后一个元素之间选择一个最小的元素与第一个元素交换，
* 然后从第二个元素开始，在第二个元素与最后一个元素之间选择
* 最小的元素与第二个元素交换，以此类推，最后列表有序。
*/
public static void simpleSelectSort(Object[] a){
int len = a.length;
for(int i = 0,j;i&lt;len;i++){
j = selectMin(a, i);
if(i!=j) //等于就没有必要交换了
a[i] = a[j];
}
}
/**
* 简单选择排序的辅助方法
* 从指定位置i开始到最后位置选择出一个最小的元素
* 并且返回它的索引值
*/
private static int selectMin(Object[] a,int low){
int min = low; //假设第一个元素为最小值
for(int i = low+1;i&lt;a.length;i++){
if(((Comparable)a[i]).compareTo(a[min])&lt;0){
min = i;
}
}
return min;
}



/**
* ---------------------------------------
* 树形选择排序 ：
* 对于简单排序来说，主要是进行n-1趟元素的比较，每趟比较n-2次，
* 每趟比较取出一个最小值(也可以是最大值)，逐步使列表有序。
* 但是第一趟的比较是可以为后续的比较提供信息的，使后续的比较次数大大减少，
* 而后续的比较又可以为更后续的比较提供信息，这样就减少了比较的次数，减少了
* 时间复杂度。
*
* 实现原理：
* 第一步，首先对n个记录进行两两比较，得到较小的n/2个数再依次比较，依次类推
* 直到得到一个最小值,这是一个构造完全二叉树的过程，根节点即为最小元素，叶子节点为列表元素。
* 构造的此树的存储结构可以用数组表示方法，数组长度为2n-1。填充此树，比如
* 列表元素为：49 38 65 97 76 13 27 49
* 构造的树为： 13
* 38 13
* 38 65 13 27
* 19 38 65 97 76 13 27 49
* 13为根结点位最小值，列表元素为叶子节点
*
* 第二步，移走最小元素，此时可重新为数组a的第一个位置赋值为此最小值，
* 之后如果找出次小值则可以为第二个位置赋值，......
*
* 第三步，找出次小值，找出最小值在叶子节点的位置，从该节点开始，和其兄弟节点
* 进行比较，修改从叶子节点到根节点的元素值，比较完毕后，根节点为次小值。
* 第三步比较是利用了第一次比较提供的信息，因为第一步已经得到了两两比较的
* 较小值，只要拿第一次与最小值比较的元素(即最小值的兄弟节点)与它们比较即可得最小值。
* 即拿上述例子的76与27比较，然后27与38比较得到次小值27。
* 重复第二和第三步，排序完成。
*
* PS:这里把移出去的叶子节点都要重设为最大值，可对此方法进行稍微改动
* 可传一个最大值进来，这里是整型所以用了Integer.MAX_VALUE
*/
public static void treeSelectSort(Object[] a){
int len = a.length;
int treeSize = 2 * len - 1; //完全二叉树的节点数
int low = 0;
Object[] tree = new Object[treeSize]; //临时的树存储空间
//由后向前填充此树，索引从0开始
for(int i = len-1,j=0 ;i &gt;= 0; --i,j++){ //填充叶子节点
tree[treeSize-1-j] = a[i];
}

for(int i = treeSize-1;i&gt;0;i-=2){ //填充非终端节点
tree[(i-1)/2] = ((Comparable)tree[i-1]).compareTo(tree[i]) &lt; 0 ? tree[i-1]:tree[i];
}

//不断移走最小节点
int minIndex;
while(low &lt; len){
Object min = tree[0]; //最小值
a[low++] = min;
minIndex = treeSize-1;
//找到最小值的索引
while(((Comparable)tree[minIndex]).compareTo(min)!=0){
minIndex--;
}
tree[minIndex] = Integer.MAX_VALUE; //设置一个最大值标志
//找到其兄弟节点
while(minIndex &gt; 0){ //如果其还有父节点
if(minIndex % 2 == 0){ //如果是右节点
tree[(minIndex-1)/2] = ((Comparable)tree[minIndex-1]).compareTo(tree[minIndex])
&lt; 0 ? tree[minIndex-1]:tree[minIndex];
minIndex = (minIndex-1)/2;
}else{ //如果是左节点
tree[minIndex/2] = ((Comparable)tree[minIndex]).compareTo(tree[minIndex+1])
&lt; 0 ? tree[minIndex]:tree[minIndex+1];
minIndex = minIndex/2;
}
}

}
}



/**
* ----------------------------------
* 堆排序
* 堆排序是在树形选择排序的基础上进一步进行优化
* 只需要一个额外的存储空间，且不需根据标志判断是不是最大值。
* 堆的定义：在1到n/2的元素中，有k(i)&lt;=k(2i),k(i)&lt;=k(2i+1)
* 或k(i)&gt;=k(2i),k(i)&gt;=k(2i+1)
* 简单来说：就是假如将此序列看成一棵完全二叉树，要使这个无序列表
* 变成堆，则小于等于n/2(最后一个非终端节点就是n/2)的某个节点i的左右子节点均大于此节点，
* 即堆的定义k(i)&lt;=k(2i),k(i)&lt;=k(2i+1)。
*
* 实现原理：
* 首先将序列看成一个树形结构，
* 1.构建堆的过程：找到最后一个非终端节点n/2，与它的左右子节点比较，
* 比较结果使此父节点为这三个节点的最小值。再找n/2-1这个节点，
* 与其左右子节点比较，得到最小值，以此类推....，最后根节点即为最小值
* 比如：49 38 65 97 76 13 27 49
* 初始树为：
* 49
* 38 65
* 97 76 13 27
* 49
* 构造堆后的树为
* 13
* 38 27
* 49 76 65 49
* 97
* 交换数据的顺序为：97&lt;——&gt;49, 13&lt;---&gt;65,38不用换，49&lt;--&gt;13,13&lt;--&gt;27
* 2.输出堆顶元素并调整建新堆的过程
* 输出堆顶最小值后，假设以最后一个值替代之，由于其左右子树的堆结构并没有被破坏
* 只需要自上而下进行调整。比如把上图的13输出后以97替代，然后可以把97与27交换，
* 然后97又与49交换，此时最小值为根元素27，输出27后以又用最后一个值替换根元素，
* 以此类推，则最终得到有序序列
*/
public static void heapSort(Object[] a){
int len = a.length;
//构建堆
for(int i=(len-1)/2;i&gt;=0;i--){
heapAdjust(a,i,len);
}

//输出堆顶元素并调整建新堆的过程
int count = len-1;
while(count &gt; 0 ){
//交换树根与最后一个值
swap(a,0,count);
count -- ;
heapAdjust(a,0,count);
}
}

/**
* 调整某一个节点极其左右子节点的位置 ，并选择左右节点中的较大者
* 继续向下调整
*/
private static void heapAdjust(Object[] a,int i,int len){
Object parent = a[i];
for(int j = (i+1) * 2 - 1;j &lt; len; j = (j+1) * 2 - 1){ //沿着左右节点中的较小者继续往下搜索
if(j &lt; len-1 &amp;&amp; ((Comparable)a[j]).compareTo(a[j+1]) &lt; 0 ){
++j; //如果左节点较大过度到右节点
}
if(((Comparable)parent).compareTo(a[j]) &gt; 0) //左右节点均小于父节点则不必要继续向下搜索
break;
a[i] = a[j];
i = j ;
}
a[i] = parent; //parent插入到正确的位置

}

/**
* 交换数组中两元素的值
*/
private static void swap(Object[] a,int i,int j){
Object temp = null;
temp = a[i];
a[i] = a[j];
a[j] = temp;
}

//just for test
public static void main(String[] args) {
Integer[] data = {49,38,65,97,76,13,27,49};
SelecSortDemo.treeSelectSort(data);
for(Integer d:data){
System.out.println(d);
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>232461</snippet_key>
<tag>471</tag>
<comment>来自CSDN博客：分治算法—对数组排序 http://blog.csdn.net/xpzhang123/article/details/21121521#</comment>
<code>package algorithms;

public class DivideAndConquer {
public static void main(String args[]) {
int[] num = {23, 27, 56 , 78, 99, 4, 24, 38, 55, 80};
System.out.println(&quot;未排序前：&quot;);
for (int a: num)
System.out.print(a + &quot; &quot;);
System.out.println();

mergesort(num, 0, 9); // merge(数组名，第一个数组第一个元素角标，第一个数组最后一个元素角标，第二个数组最后一个元素角标)
System.out.println(&quot;未排序前：&quot;);
for (int a: num)
System.out.print(a + &quot; &quot;);
System.out.println();
}

public static void merge(int[] A, int p, int q, int r) {
int n1 = q - p + 1;
int n2 = r - q;
int []L = new int[n1];
int []R = new int[n2];

int i = 0;
int j = 0;
while (i != n1) {
L[i] = A[p + i];
++i;
}
while (j != n2) {
R[j] = A[q + j + 1];
++j;
}

i = j = 0;
int k = p;
while (i != n1 &amp;&amp; j != n2) {
if (L[i] &lt;= R[j]) {
A[k] = L[i];
++i;
}
else {
A[k] = R[j];
++j;
}
++k;
}
if (i == n1)
while (j != n2) {
A[k] = R[j];
++k;
++j;
}
if (j == n2)
while (i != n1) {
A[k] = L[i];
++k;
++i;
}
}

public static void mergesort(int[] A, int p, int r) {
if (p &lt; r) {
int q = (int)((p + r) / 2);
mergesort(A, p, q);
mergesort(A, q+1, r);
merge(A, p, q, r);
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>480651</snippet_key>
<tag>来自CSDN博客：Android 仿美团网,大众点评购买框悬浮效果之修改版 http://blog.csdn.net/xiaanming/article/details/17761431#</tag>
<comment>派生自xiaanming/blog_20140103_1_3490728</comment>
<code>package com.example.meituandemo;

import android.content.Context;
import android.util.AttributeSet;
import android.widget.ScrollView;
/**
* @blog http://blog.csdn.net/xiaanming
*
* @author xiaanming
*
*/
public class MyScrollView extends ScrollView {
private OnScrollListener onScrollListener;

public MyScrollView(Context context) {
this(context, null);
}

public MyScrollView(Context context, AttributeSet attrs) {
this(context, attrs, 0);
}

public MyScrollView(Context context, AttributeSet attrs, int defStyle) {
super(context, attrs, defStyle);
}

/**
* 设置滚动接口
* @param onScrollListener
*/
public void setOnScrollListener(OnScrollListener onScrollListener) {
this.onScrollListener = onScrollListener;
}


@Override
public int computeVerticalScrollRange() {
return super.computeVerticalScrollRange();
}


@Override
protected void onScrollChanged(int l, int t, int oldl, int oldt) {
super.onScrollChanged(l, t, oldl, oldt);
if(onScrollListener != null){
onScrollListener.onScroll(t);
}
}



/**
*
* 滚动的回调接口
*
* @author xiaanming
*
*/
public interface OnScrollListener{
/**
* 回调方法， 返回MyScrollView滑动的Y方向距离
* @param scrollY
* 、
*/
public void onScroll(int scrollY);
}



}
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:id=&quot;@+id/parent_layout&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:orientation=&quot;vertical&quot; &gt;

&lt;ImageView
android:id=&quot;@+id/imageView1&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;45dip&quot;
android:scaleType=&quot;centerCrop&quot;
android:src=&quot;@drawable/navigation_bar&quot; /&gt;

&lt;com.example.meituandemo.MyScrollView
android:id=&quot;@+id/scrollView&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;fill_parent&quot; &gt;

&lt;FrameLayout
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot; &gt;

&lt;LinearLayout
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:orientation=&quot;vertical&quot; &gt;

&lt;ImageView
android:id=&quot;@+id/iamge&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:background=&quot;@drawable/pic&quot;
android:scaleType=&quot;centerCrop&quot; /&gt;

&lt;include
android:id=&quot;@+id/buy&quot;
layout=&quot;@layout/buy_layout&quot; /&gt;

&lt;ImageView
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:background=&quot;@drawable/one&quot;
android:scaleType=&quot;centerCrop&quot; /&gt;

&lt;ImageView
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:background=&quot;@drawable/one&quot;
android:scaleType=&quot;centerCrop&quot; /&gt;

&lt;ImageView
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:background=&quot;@drawable/one&quot;
android:scaleType=&quot;centerCrop&quot; /&gt;
&lt;/LinearLayout&gt;

&lt;include
android:id=&quot;@+id/top_buy_layout&quot;
layout=&quot;@layout/buy_layout&quot; /&gt;
&lt;/FrameLayout&gt;
&lt;/com.example.meituandemo.MyScrollView&gt;

&lt;/LinearLayout&gt;
package com.example.meituandemo;

import android.app.Activity;
import android.os.Bundle;
import android.view.ViewTreeObserver.OnGlobalLayoutListener;
import android.widget.LinearLayout;

import com.example.meituandemo.MyScrollView.OnScrollListener;

/**
* @blog http://blog.csdn.net/xiaanming
*
* @author xiaanming
*
*/
public class MainActivity extends Activity implements OnScrollListener{
/**
* 自定义的MyScrollView
*/
private MyScrollView myScrollView;
/**
* 在MyScrollView里面的购买布局
*/
private LinearLayout mBuyLayout;
/**
* 位于顶部的购买布局
*/
private LinearLayout mTopBuyLayout;


@SuppressWarnings(&quot;deprecation&quot;)
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

myScrollView = (MyScrollView) findViewById(R.id.scrollView);
mBuyLayout = (LinearLayout) findViewById(R.id.buy);
mTopBuyLayout = (LinearLayout) findViewById(R.id.top_buy_layout);

myScrollView.setOnScrollListener(this);

//当布局的状态或者控件的可见性发生改变回调的接口
findViewById(R.id.parent_layout).getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {

@Override
public void onGlobalLayout() {
//这一步很重要，使得上面的购买布局和下面的购买布局重合
onScroll(myScrollView.getScrollY());

}
});
}




@Override
public void onScroll(int scrollY) {
int mBuyLayout2ParentTop = Math.max(scrollY, mBuyLayout.getTop());
mTopBuyLayout.layout(0, mBuyLayout2ParentTop, mTopBuyLayout.getWidth(), mBuyLayout2ParentTop + mTopBuyLayout.getHeight());
}



}
&lt;FrameLayout
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;100dip&quot;
android:background=&quot;#ff00ffff&quot;
android:tag=&quot;sticky&quot; &gt;

&lt;Button
android:id=&quot;@+id/button&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;Button&quot; /&gt;
&lt;/FrameLayout&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>167437</snippet_key>
<tag>67</tag>
<comment>来自CSDN博客：SAXParser线程变量化提高xml解析性能和吞吐量  http://blog.csdn.net/bestree007/article/details/18675867#</comment>
<code>package bestree.love;

import java.io.IOException;
import java.io.InputStream;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

/**
* XML解析性能优化。
*
* @author bestree007
*
*/
public class ParserThreadLocal {

// usually we parse XML in this way.
public void parseXml(InputStream input) {
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setNamespaceAware(true);
try {
DefaultHandler handler = new DefaultHandler();
SAXParser parser = factory.newSAXParser();
parser.parse(input, handler);
// next use the parser to parse the xml source.
} catch (ParserConfigurationException e) {
e.printStackTrace();
} catch (SAXException e) {
e.printStackTrace();
} catch (IOException e) {
e.printStackTrace();
}
}
}
package bestree.love;

import java.io.IOException;
import java.io.InputStream;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

/**
* XML解析性能优化。
*
* @author bestree007
*
*/
public class ParserThreadLocalCase {

/**
* 将parser作为线程变量。
*/
private ThreadLocal&lt;SAXParser&gt; parser = new ThreadLocal&lt;SAXParser&gt;() {
protected SAXParser initialValue() {
SAXParser newParser = null;
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setNamespaceAware(true);
try {
newParser = factory.newSAXParser();
} catch (ParserConfigurationException e) {
e.printStackTrace();
} catch (SAXException e) {
e.printStackTrace();
}
return newParser;
};
};

// now we parse XML in this way.
public void parseXml(InputStream input) {

try {
DefaultHandler handler = new DefaultHandler();
// next use the parser to parse the xml source.
parser.get().parse(input, handler);
} catch (SAXException e) {
e.printStackTrace();
} catch (IOException e) {
e.printStackTrace();
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>232973</snippet_key>
<tag>471</tag>
<comment>来自CSDN博客：Collections.sort给对象排序 http://blog.csdn.net/duankaishan/article/details/21159009#</comment>
<code>public class DistanceComparator implements Comparator&lt;Shop&gt; {

double xAxis; //要比较的纬度

double yAxis; //要比较的经度

public DistanceComparator(double xAxis, double yAxis) {
this.xAxis = xAxis;
this.yAxis = yAxis;
}

@Override
public int compare(Shop o1, Shop o2) {
double d1 = MapDistance.distance(yAxis, xAxis, o1.getyAxis(), o1.getxAxis());
double d2 = MapDistance.distance(yAxis, xAxis, o2.getyAxis(), o2.getxAxis());
if (d1 &gt; d2) {
return 1;
} else if (d1 &lt; d2) {
return -1;
} else {
return 0;
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>298509</snippet_key>
<tag>478,472</tag>
<comment>来自CSDN博客：java面试准备之基础排序——冒泡与选择排序  http://blog.csdn.net/suifengerbi/article/details/23959919#</comment>
<code>public void select(int[] arr){
for(int i=0;i&lt;arr.length;i++){
for(int j=i+1;j&lt;arr.length;j++){
if(arr[j]&gt;arr[i]){
int one = arr[i];
arr[i]=arr[j];
arr[j]=one;
}
}

}

}
public static int[] popo(int[] arr){
for(int i=0;i&lt;arr.length-1;i++){
for(int j=1,k=0;j&lt;arr.length-i;j++,k++){
if(arr[k]&gt;arr[j]){
int one = arr[k];
arr[k]=arr[j];
arr[j]=one;
}

}
}
for(int i=0;i&lt;arr.length;i++){

System.out.print(arr[i]+&quot; &quot;);
}
return arr;
}
</code>
</RECORD>
<RECORD>
<snippet_key>480642</snippet_key>
<tag>来自CSDN博客：spring4.0.6最新稳定版新特性学习,注解自动扫描bean,自动注入bean(二) http://blog.csdn.net/xmt1139057136/article/details/38114735#</tag>
<comment>派生自伪砖家/blog_20140731_10_474217</comment>
<code>package com.herman.ss.test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.herman.ss.action.TestAction;
import com.herman.ss.filter.Filter1;
import com.herman.ss.filter.Filter2;
import com.herman.ss.filter.test.Filter3;
import com.herman.ss.pojo.House;
import com.herman.ss.pojo.Person;
/**
* @see spring4.0.0最新稳定版新特性,自动扫描bean,自动注入bean
* @author Herman.Xiong
* @date 2014年7月18日14:49:42
*/
public class Test1 {
/**
* @see spring4.0自动扫描bean,自动注入bean
*/
public static void test0(){
//1.加载配置文件
ApplicationContext ctx=new ClassPathXmlApplicationContext(&quot;com/herman/ss/config/applicationContext1.xml&quot;);
//2.获取bean实例
Person person=(Person)ctx.getBean(&quot;person&quot;);
House house=(House)ctx.getBean(&quot;house&quot;);
//3.打印bean属性
System.out.println(person);
System.out.println(house);
}

/**
* @see spring4.0简单业务逻辑的注解
*/
public static void test1(){
//1.加载配置文件
ApplicationContext ctx=new ClassPathXmlApplicationContext(&quot;com/herman/ss/config/applicationContext1.xml&quot;);
//2.获取bean实例 获取bean
TestAction testAction=(TestAction)ctx.getBean(&quot;testAction&quot;);
//3.打印bean属性
System.out.println(testAction);
//4.调用bean对象的方法
testAction.testAction();

//@Service 用于标注业务层组件；
//@Repository 用于标注数据访问层组件；
//@Controller 用于标注控制层组件(如：Struts中的action)
//@Component 表示泛型组件，当组件不好归类的时候，我们可以使用这个组件进行注解。
}

/**
* @see spring4.0简单注解的排除过滤器配置
*/
public static void test2(){
//1.加载配置文件
ApplicationContext ctx=new ClassPathXmlApplicationContext(&quot;com/herman/ss/config/applicationContext1.xml&quot;);
//2.获取bean实例,只能根据bean的id获取bean
Filter1 filter1=(Filter1)ctx.getBean(&quot;filter1&quot;);
Filter2 filter2=(Filter2)ctx.getBean(&quot;filter2&quot;);
//3.打印bean属性
System.out.println(filter1);
System.out.println(filter2);
/**
* 运行会报错：Exception in thread &quot;main&quot; org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named &apos;filter2&apos; is defined
* 原因是：filter2被我们排除在外了，不会自动注入
* 因此会抛异常
*/
}
/**
* @see spring4.0简单注解的包含过滤器配置
*/
public static void test3(){
//1.加载配置文件
ApplicationContext ctx=new ClassPathXmlApplicationContext(&quot;com/herman/ss/config/applicationContext1.xml&quot;);
//2.获取bean实例
Filter3 filter3=(Filter3)ctx.getBean(&quot;filter3&quot;);
Filter2 filter2=(Filter2)ctx.getBean(&quot;filter2&quot;);
Filter1 filter1=(Filter1)ctx.getBean(&quot;filter1&quot;);
//3.打印bean属性
System.out.println(filter3);
System.out.println(filter2);
System.out.println(filter1);
/**
* 运行会报错：Exception in thread &quot;main&quot; org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named &apos;filter2&apos; is defined
* 原因：filter2 被我们排除在外了
* 因此：我们回去filter2 这个bean对象的时候就会报错。
* filter1 为什么不报错呢，因为我们设置了 com.herman.ss.filter包下面的use-default-filters=&quot;true&quot; 自动导入
* 因此：filter1 不会报错
*/
}

public static void main(String[] args) {
/**
* 注解需要的jar包列举：
* spring-aop-4.0.6.RELEASE.jar
* spring-beans-4.0.6.RELEASE.jar
* spring-context-4.0.6.RELEASE.jar
* spring-core-4.0.6.RELEASE.jar
* spring-expression-4.0.6.RELEASE.jar
* commons-lang-2.4.jar
*/
//test0();
//test1();
//test2();
test3();
}
}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
http://www.springframework.org/schema/mvc
http://www.springframework.org/schema/mvc/spring-mvc.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;

&lt;!-- 打开Spring组件自动扫面，并配置要扫描的基本包 --&gt;
&lt;context:component-scan base-package=&quot;com.herman.ss.pojo&quot;&gt;&lt;/context:component-scan&gt;
&lt;context:component-scan base-package=&quot;com.herman.ss.action&quot;&gt;&lt;/context:component-scan&gt;
&lt;context:component-scan base-package=&quot;com.herman.ss.biz&quot;&gt;&lt;/context:component-scan&gt;
&lt;context:component-scan base-package=&quot;com.herman.ss.dao&quot;&gt;&lt;/context:component-scan&gt;
&lt;context:component-scan base-package=&quot;com.herman.ss.filter&quot; use-default-filters=&quot;false&quot;&gt;
&lt;!-- 取消自动注入，配置只注入com.herman.ss.filter.test下面的所有类 --&gt;
&lt;context:include-filter type=&quot;regex&quot; expression=&quot;com.herman.ss.filter.test.*&quot;/&gt;
&lt;/context:component-scan&gt;
&lt;context:component-scan base-package=&quot;com.herman.ss.filter&quot; use-default-filters=&quot;true&quot;&gt;
&lt;!-- 自动注入，但是Filter2除外 --&gt;
&lt;context:exclude-filter type=&quot;regex&quot; expression=&quot;com.herman.ss.filter.Filter2&quot; /&gt;
&lt;/context:component-scan&gt;
&lt;!--
注：&lt;context:component-scan&gt;节点用于通知Spring容器扫描组件，base-package属性用于指定将要被扫描的组件所在的包名
这里将自动的配置扫描com.herman.ss.pojo下面的bean
--&gt;
&lt;/beans&gt;
package com.herman.ss.pojo;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
/**
* @see 实体类使用Component注解
* @author Herman.Xiong
* @date 2014年7月24日17:11:59
*/
@Component(&quot;person&quot;)
public class Person {
private String name;
private int age;
//这里设置自动注入
@Autowired
private House house;
public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
public int getAge() {
return age;
}
public void setAge(int age) {
this.age = age;
}
public House getHouse() {
return house;
}
public void setHouse(House house) {
this.house = house;
}
public Person() {
super();
}
public Person(String name, int age) {
super();
this.name = name;
this.age = age;
}
public Person(String name, int age, House house) {
super();
this.name = name;
this.age = age;
this.house = house;
}
@Override
public String toString() {
return &quot;Person [age=&quot; + age + &quot;, house=&quot; + house + &quot;, name=&quot; + name
+ &quot;]&quot;;
}

}
package com.herman.ss.pojo;

import org.springframework.stereotype.Component;

@Component(&quot;house&quot;)
public class House {
private String name;
private String address;
private float price;
public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
public String getAddress() {
return address;
}
public void setAddress(String address) {
this.address = address;
}
public float getPrice() {
return price;
}
public void setPrice(float price) {
this.price = price;
}
public House() {
super();
}
public House(String name, String address, float price) {
super();
this.name = name;
this.address = address;
this.price = price;
}
public String toString() {
return &quot;House [address=&quot; + address + &quot;, name=&quot; + name + &quot;, price=&quot;
+ price + &quot;]&quot;;
}

}
package com.herman.ss.action;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

import com.herman.ss.biz.TestBiz;

/**
* @see 模拟action
* @author Herman.Xiong
* @date 2014年7月24日17:17:16
* @since jdk 1.6,tomcat 6.0
*/
@Controller(&quot;testAction&quot;)
public class TestAction {

//使用自动载入
@Autowired
private TestBiz testBiz;
//必须提供set方法
public void setTestBiz(TestBiz testBiz) {
this.testBiz = testBiz;
}

public TestAction(){
System.out.println(&quot;模拟的action类&quot;);
}

public void testAction(){
testBiz.testBiz();
}
}
package com.herman.ss.biz;

/**
* @see 模拟biz层进行注解
* @author Herman.Xiong
* @date 2014年7月24日17:20:25
*/
public interface TestBiz {
void testBiz();
}
package com.herman.ss.biz.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.herman.ss.biz.TestBiz;
import com.herman.ss.dao.TestDao;
@Service(&quot;testBiz&quot;)
public class TestBizImpl implements TestBiz{
@Autowired
private TestDao testDao;

//必须提供set方法
public void setTestDao(TestDao testDao) {
this.testDao = testDao;
}

public void testBiz() {
System.out.println(&quot;模拟biz层&quot;);
testDao.testDao();
}

}
package com.herman.ss.dao;

/**
* @see 模拟dao层进行注解
* @author Herman.Xiong
* @date 2014年7月24日17:20:25
*/
public interface TestDao {
void testDao();
}
package com.herman.ss.dao.impl;

import org.springframework.stereotype.Repository;

import com.herman.ss.dao.TestDao;
@Repository(&quot;testDao&quot;)
public class TestDaoImpl implements TestDao{

public void testDao() {
System.out.println(&quot;模拟dao层&quot;);
}

}
package com.herman.ss.filter;

import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Controller;
//Scope注解设置作用域
@Controller(&quot;filter1&quot;)@Scope(&quot;prototype&quot;)
public class Filter1 {
public Filter1(){
System.out.println(&quot;我是Filter1 ...&quot;);
System.out.println(&quot;Scope注解设置作用域&quot;);
}
}
package com.herman.ss.filter.test;

import org.springframework.stereotype.Controller;

@Controller(&quot;filter3&quot;)
public class Filter3 {
public Filter3(){
System.out.println(&quot;ććŻfilter3&quot;);
}
}
package com.herman.ss.filter;

import org.springframework.stereotype.Controller;

@Controller(&quot;filter2&quot;)
public class Filter2 {
public Filter2(){
System.out.println(&quot;ććŻFilter2 ...&quot;);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>480627</snippet_key>
<tag>297</tag>
<comment>来自CSDN博客：Android 根据sql文件创建数据库并插入数据  http://blog.csdn.net/qianqianyihao/article/details/39893857#</comment>
<code>public class DBHelper extends SQLiteOpenHelper {

private Context mContext;

public DBHelper(Context context, String databaseName,
CursorFactory factory, int version) {
super(context, databaseName, factory, version);
mContext = context;
}

/**
* 数据库第一次创建时调用
* */
@Override
public void onCreate(SQLiteDatabase db) {
if (!tabIsExist(&quot;test&quot;, db)) {
executeAssetsSQL(db, &quot;test.sql&quot;);
// db.execSQL(sql);
//System.out.println(&quot;创建表&quot;);
}
}

/**
* 数据库升级时调用
* */
@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
// 数据库不升级
if (newVersion &lt;= oldVersion) {
return;
}
Configuration.oldVersion = oldVersion;

int changeCnt = newVersion - oldVersion;
for (int i = 0; i &lt; changeCnt; i++) {
// 依次执行updatei_i+1文件 由1更新到2 [1-2]，2更新到3 [2-3]
String schemaName = &quot;update&quot; + (oldVersion + i) + &quot;_&quot;
+ (oldVersion + i + 1) + &quot;.sql&quot;;
executeAssetsSQL(db, schemaName);
}
}

/**
* 读取数据库文件（.sql），并执行sql语句
* */
private void executeAssetsSQL(SQLiteDatabase db, String schemaName) {
BufferedReader in = null;
try {
in = new BufferedReader(new InputStreamReader(mContext.getAssets()
.open(Configuration.DB_PATH + &quot;/&quot; + schemaName)));

//System.out.println(&quot;路径:&quot; + Configuration.DB_PATH + &quot;/&quot; + schemaName);
String line;
String buffer = &quot;&quot;;
while ((line = in.readLine()) != null) {
buffer += line;
if (line.trim().endsWith(&quot;;&quot;)) {
db.execSQL(buffer.replace(&quot;;&quot;, &quot;&quot;));
buffer = &quot;&quot;;
}
}
} catch (IOException e) {
Log.e(&quot;db-error&quot;, e.toString());
} finally {
try {
if (in != null)
in.close();
} catch (IOException e) {
Log.e(&quot;db-error&quot;, e.toString());
}
}
}

public List&lt;Area&gt; selectAllCities(SQLiteDatabase db) {
List&lt;Area&gt; areas = new ArrayList&lt;Area&gt;();
Area area;
String sql = &quot;select * from test where area_level=?&quot;;
Cursor cursor = db.rawQuery(sql, new String[] { &quot;&quot; + 0 });

while(cursor.moveToNext()){
area = new Area();
area.setId(cursor.getInt(0));
area.setArea_name(cursor.getString(2));
areas.add(area);
area = null;
}
cursor.close();

return areas;
}

public List&lt;Area&gt; selectAllAreas(SQLiteDatabase db,int parent_id) {
List&lt;Area&gt; areas = new ArrayList&lt;Area&gt;();
Area area;
String sql = &quot;select * from test where parent_id=?&quot;;
Cursor cursor = db.rawQuery(sql, new String[] { &quot;&quot; + parent_id });

while(cursor.moveToNext()){
area = new Area();
area.setId(cursor.getInt(0));
area.setArea_name(cursor.getString(2));
areas.add(area);
area = null;
}
cursor.close();

return areas;
}

/**
* 判断是否存在某一张表
* @param tabName
* @param db
* @return
*/
public boolean tabIsExist(String tabName, SQLiteDatabase db) {
boolean result = false;
if (tabName == null) {
return false;
}
Cursor cursor = null;
try {
String sql = &quot;select count(*) as c from sqlite_master where type =&apos;table&apos; and name =&apos;&quot; + tabName.trim() + &quot;&apos; &quot;;
cursor = db.rawQuery(sql, null);
if (cursor.moveToNext()) {
int count = cursor.getInt(0);
if (count &gt; 0) {
result = true;
}
}

} catch (Exception e) {
}
return result;
}

}
public class Configuration {
public static final String DB_PATH = &quot;schema&quot;;
public static final String DB_NAME = &quot;test.db&quot;;
public static final int DB_VERSION = 1;
public static int oldVersion = -1;

}
dbHelper = new DBHelper(this, &quot;test&quot;, null, 1);

dbHelper.onCreate(dbHelper.getWritableDatabase());
</code>
</RECORD>
<RECORD>
<snippet_key>168461</snippet_key>
<tag>android service 音乐播放器</tag>
<comment>来自CSDN博客：[Android]结合MediaPlayer和Service的音乐播放器  http://blog.csdn.net/sam1437/article/details/18709541#</comment>
<code>package com.example.mediaplayer;

import java.io.File;
import java.io.FilenameFilter;

public class MusicFilter implements FilenameFilter{

@Override
public boolean accept(File dir, String filename) {
// TODO Auto-generated method stub
return (filename.endsWith(&quot;.mp3&quot;));
}

}
package com.example.mediaplayer;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import android.media.AudioManager;
import android.os.Bundle;
import android.annotation.SuppressLint;
import android.app.ListActivity;
import android.content.Intent;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ImageButton;
import android.widget.ListView;
import android.widget.SeekBar;
import android.widget.SimpleAdapter;
import android.widget.Toast;

public class MainActivity extends ListActivity {
public static ImageButton start_btn;
private ImageButton last_btn;
private ImageButton next_btn;
public static SeekBar progressBar;
private SeekBar volumeBar;

public static List&lt;Map&lt;String, Object&gt;&gt; mList= new ArrayList&lt;Map&lt;String,Object&gt;&gt;();
public static int currentListItem=0;//当前播放歌曲的索引
@SuppressLint(&quot;SdCardPath&quot;)
public static String MUSIC_PATH = new String(&quot;/mnt/sdcard/Music/&quot;);
public static AudioManager audioManager=null;
private String[] mFrom=new String[]{&quot;img&quot;,&quot;music_name&quot;};
private int[] mTo=new int[]{R.id.img, R.id.music_name};

protected void onCreate(Bundle savedInstanceState) {
// TODO Auto-generated method stub
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
musicList();
init();
}
/*初始化Button*/
private void init(){
next_btn= (ImageButton) this.findViewById(R.id.next_btn);
next_btn.setOnClickListener(btnListen);
start_btn = (ImageButton) this.findViewById(R.id.start_btn);
start_btn.setOnClickListener(btnListen);
last_btn= (ImageButton) this.findViewById(R.id.last_btn);
last_btn.setOnClickListener(btnListen);
volumeBar=(SeekBar) this.findViewById(R.id.volume_seekBar);
progressBar =(SeekBar) this.findViewById(R.id.progressBar);

/*进度条监听*/
progressBar.setOnSeekBarChangeListener(new ProgressBarChange());
/*退出后再次进去程序时，进度条保持持续更新*/
if(PlayerService.mediaPlayer!=null){
//设置进度条最大值
MainActivity.progressBar.setMax(PlayerService.mediaPlayer.getDuration());
progressBar.setProgress(PlayerService.mediaPlayer.getCurrentPosition());
}



audioManager = (AudioManager) getSystemService(AUDIO_SERVICE);
/* 把当前音量值赋给进度条 */
volumeBar.setProgress(audioManager .getStreamVolume(AudioManager.STREAM_MUSIC));
/* 监听音量 */
volumeBar.setOnSeekBarChangeListener(new VolumeBarChang());
}
/*设置按键监听*/
private OnClickListener btnListen = new OnClickListener() {
@Override
public void onClick(View v) {
switch (v.getId()) {
case R.id.start_btn:
{
if(PlayerService.mediaPlayer.isPlaying()){
playMusic(AppConstant.PlayerMag.PAUSE);
start_btn.setImageDrawable(getResources().getDrawable(R.drawable.pause_round));
}else{
playMusic(AppConstant.PlayerMag.PLAY);
start_btn.setImageDrawable(getResources().getDrawable(R.drawable.play_round));
}
}
break;
case R.id.next_btn:
nextMusic();
break;
case R.id.last_btn:
frontMusic();
break;
default:
break;
}
}
};
/*显示歌曲到listView*/
public void musicList(){
File home= new File(MUSIC_PATH);
File[] files=home.listFiles(new MusicFilter());
Map&lt;String,Object&gt; mMap = null;
mList.clear();
if(files.length &gt; 0){
for(File f:files){
mMap = new HashMap&lt;String,Object&gt;();
mMap.put(&quot;img&quot;, R.drawable.music_round);
mMap.put(&quot;music_name&quot;, f.getName());
mList.add(mMap);
}
}
SimpleAdapter mAdapter = new SimpleAdapter(this, mList, R.layout.item, mFrom, mTo);
setListAdapter(mAdapter);
}

//播放音乐
public void playMusic(int action){
Intent intent = new Intent();
intent.putExtra(&quot;CMD&quot;, action);
intent.putExtra(&quot;ITEM&quot;, currentListItem);
intent.setClass(MainActivity.this, PlayerService.class);
startService(intent);
}

//下一首
public void nextMusic(){
if (++currentListItem &gt;= mList.size()) {
Toast.makeText(MainActivity.this, &quot;已到最后一首歌曲&quot;, Toast.LENGTH_SHORT) .show();
currentListItem = mList.size() - 1;
} else {
playMusic(AppConstant.PlayerMag.PLAY);
}

}

//上一首
public void frontMusic(){
if (--currentListItem &gt; 0) {
playMusic(AppConstant.PlayerMag.PLAY);

} else {
Toast.makeText(MainActivity.this, &quot;已到第一首歌曲&quot;, Toast.LENGTH_SHORT)
.show();
currentListItem = 0;
}
}

/* 音乐选择监听
* 用户点击listview的栏目，直接播放
* */
@Override
protected void onListItemClick(ListView l, View v, int position, long id) {
currentListItem = position;
playMusic(AppConstant.PlayerMag.PLAY);

}
@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
// TODO Auto-generated method stub
if(keyCode == KeyEvent.KEYCODE_BACK){
this.finish();
}
return super.onKeyDown(keyCode, event);
}
@Override
public boolean onCreateOptionsMenu(Menu menu) {
// TODO Auto-generated method stub
getMenuInflater().inflate(R.menu.main, menu);
return true;
}
@Override
public boolean onOptionsItemSelected(MenuItem item) {
// TODO Auto-generated method stub
if(item.getItemId() == R.id.exit){
Intent intent = new Intent();
intent.setClass(MainActivity.this, PlayerService.class);
stopService(intent);//停止Service
MainActivity.this.finish();
}
return super.onOptionsItemSelected(item);
}
}
package com.example.mediaplayer;

import android.widget.SeekBar;


/*
* 播放进度监听
* */
public class ProgressBarChange implements SeekBar.OnSeekBarChangeListener{

@Override
public void onProgressChanged(SeekBar seekBar, int progress,
boolean fromUser) {
// TODO Auto-generated method stub
// 当进度条的值改变时，音乐播放器从新的位置开始播放
if(fromUser){
PlayerService.mediaPlayer.seekTo(progress);
}

}

@Override
public void onStartTrackingTouch(SeekBar seekBar) {
// TODO Auto-generated method stub
PlayerService.mediaPlayer.pause(); // 开始拖动进度条时，音乐暂停播放

}

@Override
public void onStopTrackingTouch(SeekBar seekBar) {
// TODO Auto-generated method stub
PlayerService.mediaPlayer.start();// 停止拖动进度条时，音乐开始播放
}

}
package com.example.mediaplayer;

import android.media.AudioManager;
import android.widget.SeekBar;


/*
* 音量监听
* */
public class VolumeBarChang implements SeekBar.OnSeekBarChangeListener{

@Override
public void onProgressChanged(SeekBar seekBar, int progress,
boolean fromUser) {
// TODO Auto-generated method stub
MainActivity.audioManager.setStreamVolume(AudioManager.STREAM_MUSIC, progress,
0);

}

@Override
public void onStartTrackingTouch(SeekBar seekBar) {
// TODO Auto-generated method stub

}

@Override
public void onStopTrackingTouch(SeekBar seekBar) {
// TODO Auto-generated method stub

}

}
package com.example.mediaplayer;
import java.io.IOException;
import java.util.Map;

import android.app.Service;
import android.content.Intent;
import android.media.MediaPlayer;
import android.os.IBinder;
import android.widget.Toast;


public class PlayerService extends Service implements Runnable,
MediaPlayer.OnCompletionListener{

public static MediaPlayer mediaPlayer=null;
private static boolean isLoop=false;
private String path = null;
private int CMD;


@Override
public void onCreate() {
// TODO Auto-generated method stub
super.onCreate();
if(mediaPlayer != null){
mediaPlayer.reset();
mediaPlayer.release();
mediaPlayer=null;
}
mediaPlayer=new MediaPlayer();
mediaPlayer.setOnCompletionListener(this);
}

@Override
public int onStartCommand(Intent intent, int flags, int startId) {
// TODO Auto-generated method stub
CMD=(int)intent.getIntExtra(&quot;CMD&quot;, AppConstant.PlayerMag.PLAY);

if(CMD == AppConstant.PlayerMag.PLAY){
playMusic((int)intent.getIntExtra(&quot;ITEM&quot;,MainActivity.currentListItem));
}else if(CMD == AppConstant.PlayerMag.PAUSE){
if(mediaPlayer.isPlaying()){
mediaPlayer.pause();
}else {
mediaPlayer.start();
}

}
new Thread(this).start();//进度条开始
return super.onStartCommand(intent, flags, startId);
}

public void playMusic(int item) {
try {
Map&lt;String, Object&gt; map = MainActivity.mList.get(item);
path=MainActivity.MUSIC_PATH+map.get(&quot;music_name&quot;);

mediaPlayer.reset();
mediaPlayer.setDataSource(path);
mediaPlayer.prepare();
mediaPlayer.start();
mediaPlayer.setLooping(isLoop);

MainActivity.progressBar.setMax(PlayerService.mediaPlayer.getDuration());//设置播放进度条的最大值
} catch (IllegalArgumentException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} catch (SecurityException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} catch (IllegalStateException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} catch (IOException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}
@Override
public IBinder onBind(Intent intent) {
// TODO Auto-generated method stub
return null;
}

@Override
public void onDestroy() {
// TODO Auto-generated method stub
super.onDestroy();
if(mediaPlayer != null){
mediaPlayer.stop();
mediaPlayer.release();
mediaPlayer=null;
}
}

@Override
public void run() {
int currentPosition = 0;// 设置默认进度条当前位置
int total = mediaPlayer.getDuration();//
while (mediaPlayer != null &amp;&amp; currentPosition &lt; total) {
try {
Thread.sleep(1000);
if (mediaPlayer != null) {
currentPosition = mediaPlayer.getCurrentPosition();
}
} catch (InterruptedException e) {
e.printStackTrace();
}
MainActivity.progressBar.setProgress(currentPosition);
}

}
@Override
public void onCompletion(MediaPlayer mp) {
/*当前歌曲播放完，自动播放跳到下一首*/
if (++MainActivity.currentListItem &gt;= MainActivity.mList.size()) {
Toast.makeText(PlayerService.this, &quot;已到最后一首歌曲&quot;, Toast.LENGTH_SHORT)
.show();
MainActivity.currentListItem--;
MainActivity.progressBar.setMax(0);
} else {

playMusic(MainActivity.currentListItem);

}
MainActivity.start_btn.setImageDrawable(getResources().getDrawable(R.drawable.play_round));
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>480625</snippet_key>
<tag>446</tag>
<comment>来自CSDN博客：Java堆栈算法的实现 http://blog.csdn.net/yongzhian/article/details/39894053#</comment>
<code>/**
* @Project: struts2
* @Title: Stack.java
* @Package com.yza.struct
* @author yongzhian
* @date 2014-10-8 下午2:49:10
* @Copyright: 2014 www.yineng.com.cn Inc. All rights reserved.
* @version V1.0
*/
package com.yza.struct;

/**
* @ClassName Stack
* @Description 堆栈
* @author yongzhian
* @Date 2014-10-8
*/
public class Stack {
int index = -1;
int size;
Object[] objArr;
Object o;
boolean isEmpty;

public Stack() {
this(10);
}

public Stack(int size) {
this.size = size;
if (size &lt;= 0) {
System.out.println(&quot;堆栈初始化错误!&quot;);
} else {
this.size = size;
objArr = new Object[this.size];
}
}

// 添加元素 入栈
public void push(Object o) {
if (++index != size) {
objArr[index] = o;
} else {// 如果超过了原始堆栈的大小则会将最下面的压出去
for (int i = 0; i &lt; size - 1; i++) {
objArr[i] = objArr[i + 1];
}
if (index-- == 0) {
index = 0;
}
objArr[index] = objArr;
}
}

// 得到出栈的对象
public Object pop() {
if (index != 0) {
o = objArr[index];
objArr[index--] = null;
} else {
o = objArr[0];
objArr[0] = null;
}
return o;
}

public boolean isEmpty() {
isEmpty = false;
if (objArr[0] == null)
isEmpty = true;
return isEmpty;
}

public static void main(String[] args) {
Stack stack = new Stack();
System.out.println(stack.objArr[0] + &quot; &quot; + stack.size);
stack.push(new Object());
stack.push(new Object());
stack.pop();
System.out.println(stack.objArr[0] + &quot; &quot; + stack.objArr[1] + &quot; &quot;
+ stack.size);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>480622</snippet_key>
<tag>来自CSDN博客：Android如何完全调试framework层代码 http://blog.csdn.net/I2Cbus/article/details/21739261#</tag>
<comment>派生自I2Cbus/blog_20140322_1_8860752</comment>
<code>public static List&lt;String&gt; readCommandOutput(String command) {

Runtime rt =Runtime.getRuntime();

java.lang.Processproc;

try {

proc =rt.exec(command);



if (proc.waitFor() != 0) {

return null;

}

LinkedList&lt;String&gt;list = new LinkedList&lt;String&gt;();

InputStreamReader ir = new InputStreamReader(proc.getInputStream());

BufferedReader in = new BufferedReader(ir);

String line = null;

while ((line = in.readLine()) != null) {

list.add(line);

}

return list;

} catch (InterruptedException e) {

e.printStackTrace();

} catch (IOException e) {

e.printStackTrace();

}

return null;

}



public static String getPackageName(){

String strPid =Integer.toString(android.os.Process.myPid());

String cmd = &quot;ps&quot;;



List&lt;String&gt;result = readCommandOutput(cmd);

if(result == null){

return &quot;&quot;;

}



for(String info:result){

if(info.contains(strPid)){

int index = info.lastIndexOf(&quot; &quot;);

if(index &gt;=0){

StringsubStr = info.substring(index+1);

Log.i(TAG,subStr);

return subStr;

}

}

}

return &quot;&quot;;

}



public static boolean needDebug(String packageName){

String debugProcess = android.os.SystemProperties.get(&quot;persist.sys.debug&quot;);

Log.i(TAG,debugProcess);



if(debugProcess.equals(packageName)){

return true;

}

return false;

}



public static void main(Stringargv[]) {



try {

// Start profiling the zygote initialization.

SamplingProfilerIntegration.start();



registerZygoteSocket();

EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,

SystemClock.uptimeMillis());

preload();

EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,

SystemClock.uptimeMillis());



// Finish profiling the zygote initialization.

SamplingProfilerIntegration.writeZygoteSnapshot();



// Do an initial gc to cleanup after startup

gc();



// If requested, start system server directlyfrom Zygote

if (argv.length != 2) {

throw new RuntimeException(argv[0] + USAGE_STRING);

}



if (argv[1].equals(&quot;start-system-server&quot;)) {

startSystemServer();

} else if (!argv[1].equals(&quot;&quot;)) {

throw new RuntimeException(argv[0] + USAGE_STRING);

}



Log.i(TAG, &quot;Accepting command socket connections&quot;);



if (ZYGOTE_FORK_MODE) {

runForkMode();

} else {

runSelectLoopMode();

}



closeServerSocket();

} catch (MethodAndArgsCaller caller) {

String packageName = getPackageName();

if(needDebug(packageName)){

android.ddm.DdmHandleAppName.setAppName(packageName,UserHandle.myUserId());

android.os.Debug.waitForDebugger();

}

caller.run();

} catch (RuntimeException ex) {

Log.e(TAG, &quot;Zygote died with exception&quot;, ex);

closeServerSocket();

throw ex;

}

}
</code>
</RECORD>
<RECORD>
<snippet_key>299533</snippet_key>
<tag>java加强</tag>
<comment>来自CSDN博客：黑马程序员_Java基础加强第二天——Annotation  http://blog.csdn.net/u013676764/article/details/23491955#</comment>
<code>@Target(value = {ElementType.TYPE, ElementType.METHOD})  //Annotation1可应用的目标import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME) //元注解，表示Annotation1是运行时注解
public @interface Annotation1 {

}
@Annotation1
public class AnnotationUser {

}
public class AnnotationReflect {

public static void main(String[] args) {
// TODO Auto-generated method stub
if(AnnotationUser.class.isAnnotationPresent(Annotation1.class)){
Annotation1 ann = AnnotationUser.class.getAnnotation(Annotation1.class);
System.out.println(ann);
}

}

}
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME) //Annotation1是运行时注解
@Target(value = {ElementType.TYPE, ElementType.METHOD}) //Annotation1可应用的目标
public @interface Annotation1 {
String color();
}
@Annotation1(color=&quot;red&quot;)
public class AnnotationUser {

}
public class AnnotationReflect {

public static void main(String[] args) {
// TODO Auto-generated method stub
if(AnnotationUser.class.isAnnotationPresent(Annotation1.class)){
Annotation1 ann = AnnotationUser.class.getAnnotation(Annotation1.class);
System.out.println(ann.color());
}

}

}
</code>
</RECORD>
<RECORD>
<snippet_key>480702</snippet_key>
<tag>106</tag>
<comment>派生自LoveLife/blog_20140210_1_3586774 来自CSDN博客：Android 实现ListView的弹性效果 http://blog.csdn.net/eastman520/article/details/19043973#</comment>
<code>import android.content.Context;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.widget.ListView;
/**
* 弹性ListView。
* @author E
*/
public class FlexiListView extends ListView{
//初始可拉动Y轴方向距离
private static final int MAX_Y_OVERSCROLL_DISTANCE = 100;
//上下文环境
private Context mContext;
//实际可上下拉动Y轴上的距离
private int mMaxYOverscrollDistance;

public FlexiListView(Context context){
super(context);
mContext = context;
initBounceListView();
}

public FlexiListView(Context context, AttributeSet attrs) {
super(context, attrs);
mContext = context;
initBounceListView();
}

public FlexiListView(Context context, AttributeSet attrs, int defStyle) {
super(context, attrs, defStyle);
mContext = context;
initBounceListView();
}

private void initBounceListView(){
final DisplayMetrics metrics = mContext.getResources().getDisplayMetrics();
final float density = metrics.density;
mMaxYOverscrollDistance = (int) (density * MAX_Y_OVERSCROLL_DISTANCE);
}

@Override
protected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX,
int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent) {
//实现的本质就是在这里动态改变了maxOverScrollY的值
return super.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, mMaxYOverscrollDistance, isTouchEvent);
}

}
import android.content.Context;
import android.graphics.Rect;
import android.util.AttributeSet;
import android.view.GestureDetector;
import android.view.GestureDetector.OnGestureListener;
import android.view.MotionEvent;
import android.view.View;
import android.view.animation.TranslateAnimation;
import android.widget.ListView;
/**
* 具有弹性效果的ListView。主要是实现父类dispatchTouchEvent方法和OnGestureListener中onScroll方法。
* @author E
*/
public class FlexibleListView extends ListView implements OnGestureListener{

private Context context = null;
private boolean outBound = false;
private int distance;
private int firstOut;

public FlexibleListView(Context context, AttributeSet attrs) {
super(context, attrs);
this.context = context;
}

public FlexibleListView(Context context, AttributeSet attrs, int defStyle) {
super(context, attrs, defStyle);
this.context = context;
}

public FlexibleListView(Context context) {
super(context);
this.context = context;
}

GestureDetector lisGestureDetector = new GestureDetector(context, this);

@Override
public boolean dispatchTouchEvent(MotionEvent event) {
int act = event.getAction();
if ((act == MotionEvent.ACTION_UP || act == MotionEvent.ACTION_CANCEL)
&amp;&amp; outBound) {
outBound = false;
// scroll back
}
if (!lisGestureDetector.onTouchEvent(event)) {
outBound = false;
} else {
outBound = true;
}
Rect rect = new Rect();
getLocalVisibleRect(rect);
TranslateAnimation am = new TranslateAnimation( 0, 0, -rect.top, 0);
am.setDuration(300);
startAnimation(am);
scrollTo(0, 0);
return super.dispatchTouchEvent(event);
}

@Override
public boolean onDown(MotionEvent e) {
return false;
}

@Override
public void onShowPress(MotionEvent e) {
}

@Override
public boolean onSingleTapUp(MotionEvent e) {
return false;
}

@Override
public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX,
float distanceY) {
int firstPos = getFirstVisiblePosition();
int lastPos = getLastVisiblePosition();
int itemCount = getCount();
// outbound Top
if (outBound &amp;&amp; firstPos != 0 &amp;&amp; lastPos != (itemCount - 1)) {
scrollTo(0, 0);
return false;
}
View firstView = getChildAt(firstPos);
if (!outBound)
firstOut = (int) e2.getRawY();
if (firstView != null&amp;&amp; (outBound || (firstPos == 0
&amp;&amp; firstView.getTop() == 0 &amp;&amp; distanceY &lt; 0))) {
// Record the length of each slide
distance = firstOut - (int) e2.getRawY();
scrollTo(0, distance / 2);
return true;
}
// outbound Bottom
return false;
}

@Override
public void onLongPress(MotionEvent e) {
}

@Override
public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,
float velocityY) {
return false;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>480697</snippet_key>
<tag>来自CSDN博客：Android视图绘制流程完全解析，带你一步步深入了解View(二) http://blog.csdn.net/sinyu890807/article/details/16330267#</tag>
<comment>派生自guolin/blog_20131226_10_3958354</comment>
<code>childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);
childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);
private int getRootMeasureSpec(int windowSize, int rootDimension) {
int measureSpec;
switch (rootDimension) {
case ViewGroup.LayoutParams.MATCH_PARENT:
measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
break;
case ViewGroup.LayoutParams.WRAP_CONTENT:
measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
break;
default:
measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
break;
}
return measureSpec;
}
public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
if ((mPrivateFlags &amp; FORCE_LAYOUT) == FORCE_LAYOUT ||
widthMeasureSpec != mOldWidthMeasureSpec ||
heightMeasureSpec != mOldHeightMeasureSpec) {
mPrivateFlags &amp;= ~MEASURED_DIMENSION_SET;
if (ViewDebug.TRACE_HIERARCHY) {
ViewDebug.trace(this, ViewDebug.HierarchyTraceType.ON_MEASURE);
}
onMeasure(widthMeasureSpec, heightMeasureSpec);
if ((mPrivateFlags &amp; MEASURED_DIMENSION_SET) != MEASURED_DIMENSION_SET) {
throw new IllegalStateException(&quot;onMeasure() did not set the&quot;
+ &quot; measured dimension by calling&quot;
+ &quot; setMeasuredDimension()&quot;);
}
mPrivateFlags |= LAYOUT_REQUIRED;
}
mOldWidthMeasureSpec = widthMeasureSpec;
mOldHeightMeasureSpec = heightMeasureSpec;
}
public static int getDefaultSize(int size, int measureSpec) {
int result = size;
int specMode = MeasureSpec.getMode(measureSpec);
int specSize = MeasureSpec.getSize(measureSpec);
switch (specMode) {
case MeasureSpec.UNSPECIFIED:
result = size;
break;
case MeasureSpec.AT_MOST:
case MeasureSpec.EXACTLY:
result = specSize;
break;
}
return result;
}
protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
final int size = mChildrenCount;
final View[] children = mChildren;
for (int i = 0; i &lt; size; ++i) {
final View child = children[i];
if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) {
measureChild(child, widthMeasureSpec, heightMeasureSpec);
}
}
}
protected void measureChild(View child, int parentWidthMeasureSpec,
int parentHeightMeasureSpec) {
final LayoutParams lp = child.getLayoutParams();
final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
mPaddingLeft + mPaddingRight, lp.width);
final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
mPaddingTop + mPaddingBottom, lp.height);
child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}
public class MyView extends View {

......

@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
setMeasuredDimension(200, 200);
}

}
host.layout(0, 0, host.mMeasuredWidth, host.mMeasuredHeight);
public void layout(int l, int t, int r, int b) {
int oldL = mLeft;
int oldT = mTop;
int oldB = mBottom;
int oldR = mRight;
boolean changed = setFrame(l, t, r, b);
if (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) {
if (ViewDebug.TRACE_HIERARCHY) {
ViewDebug.trace(this, ViewDebug.HierarchyTraceType.ON_LAYOUT);
}
onLayout(changed, l, t, r, b);
mPrivateFlags &amp;= ~LAYOUT_REQUIRED;
if (mOnLayoutChangeListeners != null) {
ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =
(ArrayList&lt;OnLayoutChangeListener&gt;) mOnLayoutChangeListeners.clone();
int numListeners = listenersCopy.size();
for (int i = 0; i &lt; numListeners; ++i) {
listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);
}
}
}
mPrivateFlags &amp;= ~FORCE_LAYOUT;
}
@Override
protected abstract void onLayout(boolean changed, int l, int t, int r, int b);
public class SimpleLayout extends ViewGroup {

public SimpleLayout(Context context, AttributeSet attrs) {
super(context, attrs);
}

@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
super.onMeasure(widthMeasureSpec, heightMeasureSpec);
if (getChildCount() &gt; 0) {
View childView = getChildAt(0);
measureChild(childView, widthMeasureSpec, heightMeasureSpec);
}
}

@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
if (getChildCount() &gt; 0) {
View childView = getChildAt(0);
childView.layout(0, 0, childView.getMeasuredWidth(), childView.getMeasuredHeight());
}
}

}
&lt;com.example.viewtest.SimpleLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot; &gt;

&lt;ImageView
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:src=&quot;@drawable/ic_launcher&quot;
/&gt;

&lt;/com.example.viewtest.SimpleLayout&gt;
@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
if (getChildCount() &gt; 0) {
View childView = getChildAt(0);
childView.layout(0, 0, 200, 200);
}
}
public void draw(Canvas canvas) {
if (ViewDebug.TRACE_HIERARCHY) {
ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
}
final int privateFlags = mPrivateFlags;
final boolean dirtyOpaque = (privateFlags &amp; DIRTY_MASK) == DIRTY_OPAQUE &amp;&amp;
(mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
mPrivateFlags = (privateFlags &amp; ~DIRTY_MASK) | DRAWN;
// Step 1, draw the background, if needed
int saveCount;
if (!dirtyOpaque) {
final Drawable background = mBGDrawable;
if (background != null) {
final int scrollX = mScrollX;
final int scrollY = mScrollY;
if (mBackgroundSizeChanged) {
background.setBounds(0, 0, mRight - mLeft, mBottom - mTop);
mBackgroundSizeChanged = false;
}
if ((scrollX | scrollY) == 0) {
background.draw(canvas);
} else {
canvas.translate(scrollX, scrollY);
background.draw(canvas);
canvas.translate(-scrollX, -scrollY);
}
}
}
final int viewFlags = mViewFlags;
boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;
boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;
if (!verticalEdges &amp;&amp; !horizontalEdges) {
// Step 3, draw the content
if (!dirtyOpaque) onDraw(canvas);
// Step 4, draw the children
dispatchDraw(canvas);
// Step 6, draw decorations (scrollbars)
onDrawScrollBars(canvas);
// we&apos;re done...
return;
}
}
public class MyView extends View {

private Paint mPaint;

public MyView(Context context, AttributeSet attrs) {
super(context, attrs);
mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
}

@Override
protected void onDraw(Canvas canvas) {
mPaint.setColor(Color.YELLOW);
canvas.drawRect(0, 0, getWidth(), getHeight(), mPaint);
mPaint.setColor(Color.BLUE);
mPaint.setTextSize(20);
String text = &quot;Hello View&quot;;
canvas.drawText(text, 0, getHeight() / 2, mPaint);
}
}
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot; &gt;

&lt;com.example.viewtest.MyView
android:layout_width=&quot;200dp&quot;
android:layout_height=&quot;100dp&quot;
/&gt;

&lt;/LinearLayout&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>480692</snippet_key>
<tag>106</tag>
<comment>来自CSDN博客：利用LruCache为GridView异步加载大量网络图片完整示例 http://blog.csdn.net/lfdfhl/article/details/18350601# 派生自lfdfhl/blog_20140116_1_4960869</comment>
<code>package cc.testlrucache;

import android.os.Bundle;
import android.widget.GridView;
import android.app.Activity;
/**
* Demo描述:
* 在GridView中采用LruCache异步加载大量图片,避免OOM
*
* 学习资料:
* http://blog.csdn.net/guolin_blog/article/details/9526203
* Thank you very much
*/

public class MainActivity extends Activity {
private GridView mGridView;
private GridViewAdapter mGridViewAdapter;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
init();
}

private void init(){
mGridView = (GridView) findViewById(R.id.gridView);
mGridViewAdapter = new GridViewAdapter(this, 0, ImagesUrl.Urls, mGridView);
mGridView.setAdapter(mGridViewAdapter);
}

//取消所有的下载任务
@Override
protected void onDestroy() {
super.onDestroy();
mGridViewAdapter.cancelAllTasks();
}

}
package cc.testlrucache;

import java.net.HttpURLConnection;
import java.net.URL;
import java.util.HashSet;
import android.annotation.SuppressLint;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.AsyncTask;
import android.support.v4.util.LruCache;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AbsListView;
import android.widget.AbsListView.OnScrollListener;
import android.widget.ArrayAdapter;
import android.widget.GridView;
import android.widget.ImageView;
/**
* LruCache的流程分析:
* 我们从第一次进入应用的情况下开始
* 1 依据图片的Url从LruCache缓存中取图片.
* 若图片存在缓存中,则显示该图片;否则显示默认图片
* 2 因为是第一次进入该界面所以会执行:
* loadBitmaps(firstVisibleItem, visibleItemCount);
* 我们从loadBitmaps()方法作为切入点,继续往下梳理
* 3 尝试从LruCache缓存中取图片.如果在显示即可,否则进入4
* 4 开启一个异步任务下载图片.下载完成后显示图片,并且将
* 该图片存入LruCache缓存中
*
* 在停止滑动时,会调用loadBitmaps(firstVisibleItem, visibleItemCount)
* 情况与上类似
*/
@SuppressLint(&quot;NewApi&quot;)
public class GridViewAdapter extends ArrayAdapter&lt;String&gt; {

private GridView mGridView;
//图片缓存类
private LruCache&lt;String, Bitmap&gt; mLruCache;
//记录所有正在下载或等待下载的任务
private HashSet&lt;DownloadBitmapAsyncTask&gt; mDownloadBitmapAsyncTaskHashSet;
//GridView中可见的第一张图片的下标
private int mFirstVisibleItem;
//GridView中可见的图片的数量
private int mVisibleItemCount;
//记录是否是第一次进入该界面
private boolean isFirstEnterThisActivity = true;

public GridViewAdapter(Context context, int textViewResourceId,String[] objects, GridView gridView) {
super(context, textViewResourceId, objects);

mGridView = gridView;
mGridView.setOnScrollListener(new ScrollListenerImpl());

mDownloadBitmapAsyncTaskHashSet = new HashSet&lt;DownloadBitmapAsyncTask&gt;();

// 获取应用程序最大可用内存
int maxMemory = (int) Runtime.getRuntime().maxMemory();
// 设置图片缓存大小为maxMemory的1/6
int cacheSize = maxMemory/6;

mLruCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {
@Override
protected int sizeOf(String key, Bitmap bitmap) {
return bitmap.getByteCount();
}
};

}

@Override
public View getView(int position, View convertView, ViewGroup parent) {
String url = getItem(position);
View view;
if (convertView == null) {
view = LayoutInflater.from(getContext()).inflate(R.layout.gridview_item, null);
} else {
view = convertView;
}
ImageView imageView = (ImageView) view.findViewById(R.id.imageView);
//为该ImageView设置一个Tag,防止图片错位
imageView.setTag(url);
//为该ImageView设置显示的图片
setImageForImageView(url, imageView);
return view;
}

/**
* 为ImageView设置图片(Image)
* 1 从缓存中获取图片
* 2 若图片不在缓存中则为其设置默认图片
*/
private void setImageForImageView(String imageUrl, ImageView imageView) {
Bitmap bitmap = getBitmapFromLruCache(imageUrl);
if (bitmap != null) {
imageView.setImageBitmap(bitmap);
} else {
imageView.setImageResource(R.drawable.default_image);
}
}

/**
* 将图片存储到LruCache
*/
public void addBitmapToLruCache(String key, Bitmap bitmap) {
if (getBitmapFromLruCache(key) == null) {
mLruCache.put(key, bitmap);
}
}

/**
* 从LruCache缓存获取图片
*/
public Bitmap getBitmapFromLruCache(String key) {
return mLruCache.get(key);
}



/**
* 为GridView的item加载图片
*
* @param firstVisibleItem
* GridView中可见的第一张图片的下标
*
* @param visibleItemCount
* GridView中可见的图片的数量
*
*/
private void loadBitmaps(int firstVisibleItem, int visibleItemCount) {
try {
for (int i = firstVisibleItem; i &lt; firstVisibleItem + visibleItemCount; i++) {
String imageUrl = ImagesUrl.Urls[i];
Bitmap bitmap = getBitmapFromLruCache(imageUrl);
if (bitmap == null) {
DownloadBitmapAsyncTask downloadBitmapAsyncTask = new DownloadBitmapAsyncTask();
mDownloadBitmapAsyncTaskHashSet.add(downloadBitmapAsyncTask);
downloadBitmapAsyncTask.execute(imageUrl);
} else {
//依据Tag找到对应的ImageView显示图片
ImageView imageView = (ImageView) mGridView.findViewWithTag(imageUrl);
if (imageView != null &amp;&amp; bitmap != null) {
imageView.setImageBitmap(bitmap);
}
}
}
} catch (Exception e) {
e.printStackTrace();
}
}

/**
* 取消所有正在下载或等待下载的任务
*/
public void cancelAllTasks() {
if (mDownloadBitmapAsyncTaskHashSet != null) {
for (DownloadBitmapAsyncTask task : mDownloadBitmapAsyncTaskHashSet) {
task.cancel(false);
}
}
}


private class ScrollListenerImpl implements OnScrollListener{
/**
*
* 我们的本意是通过onScrollStateChanged获知:每次GridView停止滑动时加载图片
* 但是存在一个特殊情况:
* 当第一次入应用的时候,此时并没有滑动屏幕的操作即不会调用onScrollStateChanged,但应该加载图片.
* 所以在此处做一个特殊的处理.
* 即代码:
* if (isFirstEnterThisActivity &amp;&amp; visibleItemCount &gt; 0) {
* loadBitmaps(firstVisibleItem, visibleItemCount);
* isFirstEnterThisActivity = false;
* }
*
* ------------------------------------------------------------
*
* 其余的都是正常情况.
* 所以我们需要不断保存:firstVisibleItem和visibleItemCount
* 从而便于中在onScrollStateChanged()判断当停止滑动时加载图片
*
*/
@Override
public void onScroll(AbsListView view, int firstVisibleItem,int visibleItemCount, int totalItemCount) {
mFirstVisibleItem = firstVisibleItem;
mVisibleItemCount = visibleItemCount;
if (isFirstEnterThisActivity &amp;&amp; visibleItemCount &gt; 0) {
loadBitmaps(firstVisibleItem, visibleItemCount);
isFirstEnterThisActivity = false;
}
}

/**
* GridView停止滑动时下载图片
* 其余情况下取消所有正在下载或者等待下载的任务
*/
@Override
public void onScrollStateChanged(AbsListView view, int scrollState) {
if (scrollState == SCROLL_STATE_IDLE) {
loadBitmaps(mFirstVisibleItem, mVisibleItemCount);
} else {
cancelAllTasks();
}
}

}

/**
* 下载图片的异步任务
*/
class DownloadBitmapAsyncTask extends AsyncTask&lt;String, Void, Bitmap&gt; {
private String imageUrl;
@Override
protected Bitmap doInBackground(String... params) {
imageUrl = params[0];
Bitmap bitmap = downloadBitmap(params[0]);
if (bitmap != null) {
//下载完后,将其缓存到LrcCache
addBitmapToLruCache(params[0], bitmap);
}
return bitmap;
}

@Override
protected void onPostExecute(Bitmap bitmap) {
super.onPostExecute(bitmap);
//下载完成后,找到其对应的ImageView显示图片
ImageView imageView = (ImageView) mGridView.findViewWithTag(imageUrl);
if (imageView != null &amp;&amp; bitmap != null) {
imageView.setImageBitmap(bitmap);
}
mDownloadBitmapAsyncTaskHashSet.remove(this);
}
}

// 获取Bitmap
private Bitmap downloadBitmap(String imageUrl) {
Bitmap bitmap = null;
HttpURLConnection httpURLConnection = null;
try {
URL url = new URL(imageUrl);
httpURLConnection = (HttpURLConnection) url.openConnection();
httpURLConnection.setConnectTimeout(5 * 1000);
httpURLConnection.setReadTimeout(10 * 1000);
httpURLConnection.setDoInput(true);
httpURLConnection.setDoOutput(true);
bitmap = BitmapFactory.decodeStream(httpURLConnection.getInputStream());
} catch (Exception e) {
e.printStackTrace();
} finally {
if (httpURLConnection != null) {
httpURLConnection.disconnect();
}
}
return bitmap;
}

}
package cc.testlrucache;

public class ImagesUrl {

public final static String[] Urls = new String[] {
&quot;https://lh6.googleusercontent.com/-55osAWw3x0Q/URquUtcFr5I/AAAAAAAAAbs/rWlj1RUKrYI/s160-c/A%252520Photographer.jpg&quot;,
&quot;https://lh4.googleusercontent.com/--dq8niRp7W4/URquVgmXvgI/AAAAAAAAAbs/-gnuLQfNnBA/s160-c/A%252520Song%252520of%252520Ice%252520and%252520Fire.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-7qZeDtRKFKc/URquWZT1gOI/AAAAAAAAAbs/hqWgteyNXsg/s160-c/Another%252520Rockaway%252520Sunset.jpg&quot;,
&quot;https://lh3.googleusercontent.com/--L0Km39l5J8/URquXHGcdNI/AAAAAAAAAbs/3ZrSJNrSomQ/s160-c/Antelope%252520Butte.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-8HO-4vIFnlw/URquZnsFgtI/AAAAAAAAAbs/WT8jViTF7vw/s160-c/Antelope%252520Hallway.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-WIuWgVcU3Qw/URqubRVcj4I/AAAAAAAAAbs/YvbwgGjwdIQ/s160-c/Antelope%252520Walls.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-UBmLbPELvoQ/URqucCdv0kI/AAAAAAAAAbs/IdNhr2VQoQs/s160-c/Apre%2525CC%252580s%252520la%252520Pluie.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-s-AFpvgSeew/URquc6dF-JI/AAAAAAAAAbs/Mt3xNGRUd68/s160-c/Backlit%252520Cloud.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-bvmif9a9YOQ/URquea3heHI/AAAAAAAAAbs/rcr6wyeQtAo/s160-c/Bee%252520and%252520Flower.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-n7mdm7I7FGs/URqueT_BT-I/AAAAAAAAAbs/9MYmXlmpSAo/s160-c/Bonzai%252520Rock%252520Sunset.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-4CN4X4t0M1k/URqufPozWzI/AAAAAAAAAbs/8wK41lg1KPs/s160-c/Caterpillar.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-rrFnVC8xQEg/URqufdrLBaI/AAAAAAAAAbs/s69WYy_fl1E/s160-c/Chess.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-WVpRptWH8Yw/URqugh-QmDI/AAAAAAAAAbs/E-MgBgtlUWU/s160-c/Chihuly.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-0BDXkYmckbo/URquhKFW84I/AAAAAAAAAbs/ogQtHCTk2JQ/s160-c/Closed%252520Door.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-PyggXXZRykM/URquh-kVvoI/AAAAAAAAAbs/hFtDwhtrHHQ/s160-c/Colorado%252520River%252520Sunset.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-ZAs4dNZtALc/URquikvOCWI/AAAAAAAAAbs/DXz4h3dll1Y/s160-c/Colors%252520of%252520Autumn.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-GztnWEIiMz8/URqukVCU7bI/AAAAAAAAAbs/jo2Hjv6MZ6M/s160-c/Countryside.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-bEg9EZ9QoiM/URquklz3FGI/AAAAAAAAAbs/UUuv8Ac2BaE/s160-c/Death%252520Valley%252520-%252520Dunes.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-ijQJ8W68tEE/URqulGkvFEI/AAAAAAAAAbs/zPXvIwi_rFw/s160-c/Delicate%252520Arch.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-Oh8mMy2ieng/URqullDwehI/AAAAAAAAAbs/TbdeEfsaIZY/s160-c/Despair.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-gl0y4UiAOlk/URqumC_KjBI/AAAAAAAAAbs/PM1eT7dn4oo/s160-c/Eagle%252520Fall%252520Sunrise.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-hYYHd2_vXPQ/URqumtJa9eI/AAAAAAAAAbs/wAalXVkbSh0/s160-c/Electric%252520Storm.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-PyY_yiyjPTo/URqunUOhHFI/AAAAAAAAAbs/azZoULNuJXc/s160-c/False%252520Kiva.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-PYvLVdvXywk/URqunwd8hfI/AAAAAAAAAbs/qiMwgkFvf6I/s160-c/Fitzgerald%252520Streaks.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-KIR_UobIIqY/URquoCZ9SlI/AAAAAAAAAbs/Y4d4q8sXu4c/s160-c/Foggy%252520Sunset.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-9lzOk_OWZH0/URquoo4xYoI/AAAAAAAAAbs/AwgzHtNVCwU/s160-c/Frantic.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-0X3JNaKaz48/URqupH78wpI/AAAAAAAAAbs/lHXxu_zbH8s/s160-c/Golden%252520Gate%252520Afternoon.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-95sb5ag7ABc/URqupl95RDI/AAAAAAAAAbs/g73R20iVTRA/s160-c/Golden%252520Gate%252520Fog.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-JB9v6rtgHhk/URqup21F-zI/AAAAAAAAAbs/64Fb8qMZWXk/s160-c/Golden%252520Grass.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-EIBGfnuLtII/URquqVHwaRI/AAAAAAAAAbs/FA4McV2u8VE/s160-c/Grand%252520Teton.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-WoMxZvmN9nY/URquq1v2AoI/AAAAAAAAAbs/grj5uMhL6NA/s160-c/Grass%252520Closeup.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-6hZiEHXx64Q/URqurxvNdqI/AAAAAAAAAbs/kWMXM3o5OVI/s160-c/Green%252520Grass.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-6LVb9OXtQ60/URquteBFuKI/AAAAAAAAAbs/4F4kRgecwFs/s160-c/Hanging%252520Leaf.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-zAvf__52ONk/URqutT_IuxI/AAAAAAAAAbs/D_bcuc0thoU/s160-c/Highway%2525201.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-H4SrUg615rA/URquuL27fXI/AAAAAAAAAbs/4aEqJfiMsOU/s160-c/Horseshoe%252520Bend%252520Sunset.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-JhFi4fb_Pqw/URquuX-QXbI/AAAAAAAAAbs/IXpYUxuweYM/s160-c/Horseshoe%252520Bend.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-UGgssvFRJ7g/URquueyJzGI/AAAAAAAAAbs/yYIBlLT0toM/s160-c/Into%252520the%252520Blue.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-CH7KoupI7uI/URquu0FF__I/AAAAAAAAAbs/R7GDmI7v_G0/s160-c/Jelly%252520Fish%2525202.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-pwuuw6yhg8U/URquvPxR3FI/AAAAAAAAAbs/VNGk6f-tsGE/s160-c/Jelly%252520Fish%2525203.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-GoUQVw1fnFw/URquv6xbC0I/AAAAAAAAAbs/zEUVTQQ43Zc/s160-c/Kauai.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-8QdYYQEpYjw/URquwvdh88I/AAAAAAAAAbs/cktDy-ysfHo/s160-c/Kyoto%252520Sunset.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-vPeekyDjOE0/URquwzJ28qI/AAAAAAAAAbs/qxcyXULsZrg/s160-c/Lake%252520Tahoe%252520Colors.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-xBPxWpD4yxU/URquxWHk8AI/AAAAAAAAAbs/ARDPeDYPiMY/s160-c/Lava%252520from%252520the%252520Sky.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-897VXrJB6RE/URquxxxd-5I/AAAAAAAAAbs/j-Cz4T4YvIw/s160-c/Leica%25252050mm%252520Summilux.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-qSJ4D4iXzGo/URquyDWiJ1I/AAAAAAAAAbs/k2pBXeWehOA/s160-c/Leica%25252050mm%252520Summilux.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-dwlPg83vzLg/URquylTVuFI/AAAAAAAAAbs/G6SyQ8b4YsI/s160-c/Leica%252520M8%252520%252528Front%252529.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-R3_EYAyJvfk/URquzQBv8eI/AAAAAAAAAbs/b9xhpUM3pEI/s160-c/Light%252520to%252520Sand.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-fHY5h67QPi0/URqu0Cp4J1I/AAAAAAAAAbs/0lG6m94Z6vM/s160-c/Little%252520Bit%252520of%252520Paradise.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-TzF_LwrCnRM/URqu0RddPOI/AAAAAAAAAbs/gaj2dLiuX0s/s160-c/Lone%252520Pine%252520Sunset.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-4HdpJ4_DXU4/URqu046dJ9I/AAAAAAAAAbs/eBOodtk2_uk/s160-c/Lonely%252520Rock.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-erbF--z-W4s/URqu1ajSLkI/AAAAAAAAAbs/xjDCDO1INzM/s160-c/Longue%252520Vue.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-0CXJRdJaqvc/URqu1opNZNI/AAAAAAAAAbs/PFB2oPUU7Lk/s160-c/Look%252520Me%252520in%252520the%252520Eye.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-D_5lNxnDN6g/URqu2Tk7HVI/AAAAAAAAAbs/p0ddca9W__Y/s160-c/Lost%252520in%252520a%252520Field.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-flsqwMrIk2Q/URqu24PcmjI/AAAAAAAAAbs/5ocIH85XofM/s160-c/Marshall%252520Beach%252520Sunset.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-Y4lgryEVTmU/URqu28kG3gI/AAAAAAAAAbs/OjXpekqtbJ4/s160-c/Mono%252520Lake%252520Blue.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-AaHAJPmcGYA/URqu3PIldHI/AAAAAAAAAbs/lcTqk1SIcRs/s160-c/Monument%252520Valley%252520Overlook.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-vKxfdQ83dQA/URqu31Yq_BI/AAAAAAAAAbs/OUoGk_2AyfM/s160-c/Moving%252520Rock.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-CG62QiPpWXg/URqu4ia4vRI/AAAAAAAAAbs/0YOdqLAlcAc/s160-c/Napali%252520Coast.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-wdGrP5PMmJQ/URqu5PZvn7I/AAAAAAAAAbs/m0abEcdPXe4/s160-c/One%252520Wheel.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-6WS5DoCGuOA/URqu5qx1UgI/AAAAAAAAAbs/giMw2ixPvrY/s160-c/Open%252520Sky.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-u8EHKj8G8GQ/URqu55sM6yI/AAAAAAAAAbs/lIXX_GlTdmI/s160-c/Orange%252520Sunset.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-74Z5qj4bTDE/URqu6LSrJrI/AAAAAAAAAbs/XzmVkw90szQ/s160-c/Orchid.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-lEQE4h6TePE/URqu6t_lSkI/AAAAAAAAAbs/zvGYKOea_qY/s160-c/Over%252520there.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-cauH-53JH2M/URqu66v_USI/AAAAAAAAAbs/EucwwqclfKQ/s160-c/Plumes.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-eDLT2jHDoy4/URqu7axzkAI/AAAAAAAAAbs/iVZE-xJ7lZs/s160-c/Rainbokeh.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-j1NLqEFIyco/URqu8L1CGcI/AAAAAAAAAbs/aqZkgX66zlI/s160-c/Rainbow.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-DRnqmK0t4VU/URqu8XYN9yI/AAAAAAAAAbs/LgvF_592WLU/s160-c/Rice%252520Fields.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-hwh1v3EOGcQ/URqu8qOaKwI/AAAAAAAAAbs/IljRJRnbJGw/s160-c/Rockaway%252520Fire%252520Sky.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-wjV6FQk7tlk/URqu9jCQ8sI/AAAAAAAAAbs/RyYUpdo-c9o/s160-c/Rockaway%252520Flow.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-6cAXNfo7D20/URqu-BdzgPI/AAAAAAAAAbs/OmsYllzJqwo/s160-c/Rockaway%252520Sunset%252520Sky.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-sl8fpGPS-RE/URqu_BOkfgI/AAAAAAAAAbs/Dg2Fv-JxOeg/s160-c/Russian%252520Ridge%252520Sunset.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-gVtY36mMBIg/URqu_q91lkI/AAAAAAAAAbs/3CiFMBcy5MA/s160-c/Rust%252520Knot.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-GHeImuHqJBE/URqu_FKfVLI/AAAAAAAAAbs/axuEJeqam7Q/s160-c/Sailing%252520Stones.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-hBbYZjTOwGc/URqu_ycpIrI/AAAAAAAAAbs/nAdJUXnGJYE/s160-c/Seahorse.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-Iwi6-i6IexY/URqvAYZHsVI/AAAAAAAAAbs/5ETWl4qXsFE/s160-c/Shinjuku%252520Street.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-amhnySTM_MY/URqvAlb5KoI/AAAAAAAAAbs/pFCFgzlKsn0/s160-c/Sierra%252520Heavens.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-dJgjepFrYSo/URqvBVJZrAI/AAAAAAAAAbs/v-F5QWpYO6s/s160-c/Sierra%252520Sunset.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-Z4zGiC5nWdc/URqvBdEwivI/AAAAAAAAAbs/ZRZR1VJ84QA/s160-c/Sin%252520Lights.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-_0cYiWW8ccY/URqvBz3iM4I/AAAAAAAAAbs/9N_Wq8MhLTY/s160-c/Starry%252520Lake.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-A9LMoRyuQUA/URqvCYx_JoI/AAAAAAAAAbs/s7sde1Bz9cI/s160-c/Starry%252520Night.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-KtLJ3k858eY/URqvC_2h_bI/AAAAAAAAAbs/zzEBImwDA_g/s160-c/Stream.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-dFB7Lad6RcA/URqvDUftwWI/AAAAAAAAAbs/BrhoUtXTN7o/s160-c/Strip%252520Sunset.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-at6apgFiN20/URqvDyffUZI/AAAAAAAAAbs/clABCx171bE/s160-c/Sunset%252520Hills.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-7-EHhtQthII/URqvEYTk4vI/AAAAAAAAAbs/QSJZoB3YjVg/s160-c/Tenaya%252520Lake%2525202.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-8MrjV_a-Pok/URqvFC5repI/AAAAAAAAAbs/9inKTg9fbCE/s160-c/Tenaya%252520Lake.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-B1HW-z4zwao/URqvFWYRwUI/AAAAAAAAAbs/8Peli53Bs8I/s160-c/The%252520Cave%252520BW.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-PO4E-xZKAnQ/URqvGRqjYkI/AAAAAAAAAbs/42nyADFsXag/s160-c/The%252520Fisherman.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-iLyZlzfdy7s/URqvG0YScdI/AAAAAAAAAbs/1J9eDKmkXtk/s160-c/The%252520Night%252520is%252520Coming.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-G-k7YkkUco0/URqvHhah6fI/AAAAAAAAAbs/_taQQG7t0vo/s160-c/The%252520Road.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-h-ALJt7kSus/URqvIThqYfI/AAAAAAAAAbs/ejiv35olWS8/s160-c/Tokyo%252520Heights.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-Hy9k-TbS7xg/URqvIjQMOxI/AAAAAAAAAbs/RSpmmOATSkg/s160-c/Tokyo%252520Highway.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-83oOvMb4OZs/URqvJL0T7lI/AAAAAAAAAbs/c5TECZ6RONM/s160-c/Tokyo%252520Smog.jpg&quot;,
&quot;https://lh3.googleusercontent.com/-FB-jfgREEfI/URqvJI3EXAI/AAAAAAAAAbs/XfyweiRF4v8/s160-c/Tufa%252520at%252520Night.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-vngKD5Z1U8w/URqvJUCEgPI/AAAAAAAAAbs/ulxCMVcU6EU/s160-c/Valley%252520Sunset.jpg&quot;,
&quot;https://lh6.googleusercontent.com/-DOz5I2E2oMQ/URqvKMND1kI/AAAAAAAAAbs/Iqf0IsInleo/s160-c/Windmill%252520Sunrise.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-biyiyWcJ9MU/URqvKculiAI/AAAAAAAAAbs/jyPsCplJOpE/s160-c/Windmill.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-PDT167_xRdA/URqvK36mLcI/AAAAAAAAAbs/oi2ik9QseMI/s160-c/Windmills.jpg&quot;,
&quot;https://lh5.googleusercontent.com/-kI_QdYx7VlU/URqvLXCB6gI/AAAAAAAAAbs/N31vlZ6u89o/s160-c/Yet%252520Another%252520Rockaway%252520Sunset.jpg&quot;,
&quot;https://lh4.googleusercontent.com/-e9NHZ5k5MSs/URqvMIBZjtI/AAAAAAAAAbs/1fV810rDNfQ/s160-c/Yosemite%252520Tree.jpg&quot;, };
}
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot; &gt;

&lt;GridView
android:id=&quot;@+id/gridView&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:columnWidth=&quot;90dip&quot;
android:gravity=&quot;center&quot;
android:numColumns=&quot;auto_fit&quot;
android:stretchMode=&quot;columnWidth&quot;
android:verticalSpacing=&quot;10dip&quot;
/&gt;

&lt;/RelativeLayout&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot; &gt;

&lt;ImageView
android:id=&quot;@+id/imageView&quot;
android:layout_width=&quot;90dip&quot;
android:layout_height=&quot;90dip&quot;
android:src=&quot;@drawable/default_image&quot;
android:layout_centerInParent=&quot;true&quot;
/&gt;

&lt;/RelativeLayout&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>480687</snippet_key>
<tag>来自CSDN博客：Android 异步消息处理机制 让你深入理解 Looper、Handler、Message三者关系 http://blog.csdn.net/lmj623565791/article/details/38377229#</tag>
<comment>派生自鸿洋_/blog_20140808_10_3108934</comment>
<code>public static final void prepare() {
if (sThreadLocal.get() != null) {
throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
}
sThreadLocal.set(new Looper(true));
}
private Looper(boolean quitAllowed) {
mQueue = new MessageQueue(quitAllowed);
mRun = true;
mThread = Thread.currentThread();
}
public static void loop() {
final Looper me = myLooper();
if (me == null) {
throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);
}
final MessageQueue queue = me.mQueue;

// Make sure the identity of this thread is that of the local process,
// and keep track of what that identity token actually is.
Binder.clearCallingIdentity();
final long ident = Binder.clearCallingIdentity();

for (;;) {
Message msg = queue.next(); // might block
if (msg == null) {
// No message indicates that the message queue is quitting.
return;
}

// This must be in a local variable, in case a UI event sets the logger
Printer logging = me.mLogging;
if (logging != null) {
logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +
msg.callback + &quot;: &quot; + msg.what);
}

msg.target.dispatchMessage(msg);

if (logging != null) {
logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
}

// Make sure that during the course of dispatching the
// identity of the thread wasn&apos;t corrupted.
final long newIdent = Binder.clearCallingIdentity();
if (ident != newIdent) {
Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;
+ Long.toHexString(ident) + &quot; to 0x&quot;
+ Long.toHexString(newIdent) + &quot; while dispatching to &quot;
+ msg.target.getClass().getName() + &quot; &quot;
+ msg.callback + &quot; what=&quot; + msg.what);
}

msg.recycle();
}
}
public Handler() {
this(null, false);
}
public Handler(Callback callback, boolean async) {
if (FIND_POTENTIAL_LEAKS) {
final Class&lt;? extends Handler&gt; klass = getClass();
if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
(klass.getModifiers() &amp; Modifier.STATIC) == 0) {
Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
klass.getCanonicalName());
}
}

mLooper = Looper.myLooper();
if (mLooper == null) {
throw new RuntimeException(
&quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);
}
mQueue = mLooper.mQueue;
mCallback = callback;
mAsynchronous = async;
}
public final boolean sendMessage(Message msg)
{
return sendMessageDelayed(msg, 0);
}
public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {
Message msg = Message.obtain();
msg.what = what;
return sendMessageDelayed(msg, delayMillis);
}
public final boolean sendMessageDelayed(Message msg, long delayMillis)
{
if (delayMillis &lt; 0) {
delayMillis = 0;
}
return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
}
public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
MessageQueue queue = mQueue;
if (queue == null) {
RuntimeException e = new RuntimeException(
this + &quot; sendMessageAtTime() called with no mQueue&quot;);
Log.w(&quot;Looper&quot;, e.getMessage(), e);
return false;
}
return enqueueMessage(queue, msg, uptimeMillis);
}
private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
msg.target = this;
if (mAsynchronous) {
msg.setAsynchronous(true);
}
return queue.enqueueMessage(msg, uptimeMillis);
}
public void dispatchMessage(Message msg) {
if (msg.callback != null) {
handleCallback(msg);
} else {
if (mCallback != null) {
if (mCallback.handleMessage(msg)) {
return;
}
}
handleMessage(msg);
}
}
/**
* Subclasses must implement this to receive messages.
*/
public void handleMessage(Message msg) {
}

private Handler mHandler = new Handler()
{
public void handleMessage(android.os.Message msg)
{
switch (msg.what)
{
case value:

break;

default:
break;
}
};
};
mHandler.post(new Runnable()
{
@Override
public void run()
{
Log.e(&quot;TAG&quot;, Thread.currentThread().getName());
mTxt.setText(&quot;yoxi&quot;);
}
});
public final boolean post(Runnable r)
{
return sendMessageDelayed(getPostMessage(r), 0);
}
private static Message getPostMessage(Runnable r) {
Message m = Message.obtain();
m.callback = r;
return m;
}
public final boolean sendMessageDelayed(Message msg, long delayMillis)
{
if (delayMillis &lt; 0) {
delayMillis = 0;
}
return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
}
public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
MessageQueue queue = mQueue;
if (queue == null) {
RuntimeException e = new RuntimeException(
this + &quot; sendMessageAtTime() called with no mQueue&quot;);
Log.w(&quot;Looper&quot;, e.getMessage(), e);
return false;
}
return enqueueMessage(queue, msg, uptimeMillis);
}
public void dispatchMessage(Message msg) {
if (msg.callback != null) {
handleCallback(msg);
} else {
if (mCallback != null) {
if (mCallback.handleMessage(msg)) {
return;
}
}
handleMessage(msg);
}
}
new Thread()
{
private Handler handler;
public void run()
{

Looper.prepare();
Looper.loop();
handler = new Handler()
{
public void handleMessage(android.os.Message msg)
{
Log.e(&quot;TAG&quot;,Thread.currentThread().getName());
};
};
};

}.start();
</code>
</RECORD>
<RECORD>
<snippet_key>365837</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：(无聊一java)PrintCalendar http://blog.csdn.net/u012946799/article/details/27229863#</comment>
<code>import java.util.Scanner;
// 课本144页
public class PrintCalendar {
/*Main meehod*/
public static void main(String[] args) {
Scanner input = new Scanner(System.in);

//Pompt the useu to enter year
System.out.print(&quot;Enter full year (e.g., 2001 &quot;);
int year = input.nextInt();

//Prompt the user to enter month
System.out.print(&quot; Enter month in number between 1 and 12: &quot;);
int month = input.nextInt();

//Print calendar for the month of year
printMonth(year, month);
}

/*Print the calendar for a month in a year*/
public static void printMonth(int year, int month) {
//Print the headings of the calendar
printMonthTitle(year, month);

//Print the body of the calendar
printMonthBody(year, month);
}
/**Print the month title. e.g., May, 1999*/
public static void printMonthTitle(int year, int month ) {
System.out.println (&quot; &quot; + getMonthName (month)
+ &quot; &quot; + year);
System.out.println(&quot; __________________________________________&quot;);
System.out.println(&quot; Sun Mon Tue Wed Thu Fri Sat&quot;);
}

/* Get the English name for the month */
public static String getMonthName (int month) {
String monthName = &quot; &quot;;
switch (month) {
case 1: monthName = &quot;January&quot;; break;
case 2: monthName = &quot;February&quot;; break;
case 3: monthName = &quot;March&quot;; break;
case 4: monthName = &quot;April&quot;; break;
case 5: monthName = &quot;May&quot;; break;
case 6: monthName =&quot;June&quot;;break;
case 7: monthName = &quot;July&quot;; break;
case 8: monthName = &quot;August&quot;;break;
case 9: monthName = &quot;September&quot;; break;
case 10: monthName = &quot;October&quot;; break;
case 11: monthName = &quot;November&quot;; break;
case 12: monthName = &quot;December&quot;;
}

return monthName;
}
/* Print month body */
public static void printMonthBody (int year, int month) {
//Get star day of the week for the first date in the month
int startDay = getStartDay (year, month);

//Get number of days in the month
int numberOfDaysInMonth = getNumberOfDaysInMonth (year, month);

//Pad space before the first day of the month
int i = 0;
for ( i = 0; i &lt; startDay;i++)
System.out.print(&quot; &quot;);

for ( i = 1; i &lt;= numberOfDaysInMonth; i++) {
System.out.printf(&quot;%4d&quot;, i);

if ((i + startDay) % 7 == 0)
System.out.println();
}

System.out.println();
}
/* Get the start day of month /1/year */
public static int getStartDay (int year, int month) {
final int START_DAY_FOR_JAN_1_1800 = 3;
//Get total number of days from 1/1/1800 to month/1/year
int totalNumberOfDays = getTotalNumberOfDays (year, month);

//Return the star day for month/1/year
return (totalNumberOfDays + START_DAY_FOR_JAN_1_1800 ) % 7;
}

/** Get the total number of days since January 1. 1800 */
public static int getTotalNumberOfDays (int year, int month) {
int total = 0;

//Get the total days from 1800 to 1/1/year
for (int i = 1800; i &lt; year; i++)
if (isLeapYear(i))
total = total + 366;
else
total = total + 365;

//Add days from Jan to the month prior to the calendar month
for (int i = 1; i &lt; month; i++ )
total = total + getNumberOfDaysInMonth(year, i);
return total;
}

/** Get the number of days in a month */
public static int getNumberOfDaysInMonth (int year, int month) {
if ( month==1 || month==3 || month == 5 ||month == 7||
month == 8 || month == 10 || month ==12)
return 31;

if ( month == 4 || month == 6 || month == 9 || month == 11)
return 30;

if (month == 2 ) return isLeapYear( year) ? 29 : 28;
return 0; //If month is incorrect
}
/* Determine if it is a leap year */
public static boolean isLeapYear (int year ) {
return year % 400 == 0 || ( year % 4 ==0 &amp;&amp; year % 100 != 0 );
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>104205</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Java泛型——通配符和Object的区别 http://blog.csdn.net/uusad/article/details/7898358#</comment>
<code>void function(List&lt;Object&gt;){}
void function(List&lt;?&gt;){}
function(new List&lt;String&gt;()); //对于第一种方法编译错误
</code>
</RECORD>
<RECORD>
<snippet_key>301069</snippet_key>
<tag>457</tag>
<comment>来自CSDN博客：【Java学习笔记】Hashset判断自定义对象是否重复  http://blog.csdn.net/u011613729/article/details/11633061#</comment>
<code>import java.util.HashSet;

public class Car {
private int price;
private enumcolor color;

public enum enumcolor{
red,blue,black,white;
private String value;

public void setcolor(String c){
this.setColor(c);
}
public String getColor() {
return value;
}
public void setColor(String color) {
this.value = color;
}
}

public Car(int pri,enumcolor ecolor){
this.price=pri;
this.color=ecolor;
}

public enumcolor getColor() {
return color;
}

public void setColor(enumcolor color) {
this.color = color;
}

public int getPrice() {
return price;
}

public void setPrice(int price) {
this.price = price;
}

protected void showPrice(){
System.out.println(this.price);
}
public static void main(String args[]){
enumcolor cl1=enumcolor.black;
enumcolor cl2=enumcolor.red;
Car car = new Car(1,cl1);
Car bus = new Car(1,cl1);
HashSet&lt;Car&gt; carSet = new HashSet&lt;Car&gt;();
carSet.add(car);
carSet.add(bus);
System.out.println(carSet);
for(Car ite:carSet){
System.out.println(ite);
}
}
}
@Override
public boolean equals(Object st)
{
Car tempcar= (Car) st;
if (price==tempcar.price) return true;
else return false;
}
public int hashCode()
{
return new Integer(price).hashCode();
}
public String toString(){
return &quot;color:&quot;+color+&quot;,price:&quot;+price;
}
</code>
</RECORD>
<RECORD>
<snippet_key>366861</snippet_key>
<tag>spring 框架 aop</tag>
<comment>来自CSDN博客：Spring框架AOP学习总结（一）  http://blog.csdn.net/Wireless8023/article/details/27322813#</comment>
<code>public class JdkProxyFactory implements InvocationHandler {
// 被代理对象
private Object target;

// 在构造方法对象时，传入被代理对象
public JdkProxyFactory(Object target) {
this.target = target;
}

// 创建代理
public Object createProxy() {
// 三个参数： 类加载器、 实现接口、 invocationhandler
return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
}

@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
System.out.println(&quot;记录日志！！！！！！&quot;);
// 调用目标真实方法
// target 被代理对象， args 方法参数 ， method 被调用的方法
return method.invoke(target, args);
}
}
public class CglibProxyFactory implements MethodInterceptor {
// 被代理目标对象
private Object target;

// 在构造工厂时传入被代理对象
public CglibProxyFactory(Object target) {
this.target = target;
}

// 创建代理对象方法
public Object createProxy() {
// 1、 创建Enhancer对象
Enhancer enhancer = new Enhancer();

// 2、 cglib创建代理，对目标对象，创建子类对象
enhancer.setSuperclass(target.getClass());

// 3、传入 callback对象，对目标增强
enhancer.setCallback(this);

return enhancer.create();
}

@Override
public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
System.out.println(&quot;记录日志......&quot;);
// 按照JDK编程
return method.invoke(target, args);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>236045</snippet_key>
<tag>测试 junit 工作 正则 java 环境变量 环境 jdk 安</tag>
<comment>来自CSDN博客：2014年3月14日 日记  java Matcher Pattern的学习 junit测试  http://blog.csdn.net/pengshuangbao520/article/details/21242663#</comment>
<code>package com.bdr.irts.pojo.util;

import static org.junit.Assert.assertEquals;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.junit.Test;

public class TestWordDealUtil
{
// 测试 wordFormat4DB 正常运行的情况
@Test
public void wordFormat4DBNormal()
{
String target = &quot;employeeInfo&quot;;
String result = WordDealUtil.wordFormat4DB(target);
System.out.println(result);
assertEquals(&quot;employee_info&quot;, result);
}

// 测试方法 appandReplacement 方法 该方法是需要查找的内容替换
@Test
public void testAppendReplace()
{
Pattern p = Pattern.compile(&quot;cat&quot;);
Matcher m = p.matcher(&quot;one cat two cats in the yard catcat cat&quot;);
StringBuffer sb = new StringBuffer();
while (m.find())
{
System.out.println(&quot;group &quot; + m.group());
System.out.println(&quot;sb &quot; + sb);
m.appendReplacement(sb, &quot;dog&quot;);
}
m.appendTail(sb);
System.out.println(sb.toString());
}
  @Test
    public void testMathcerAppend()
    {
        // 在使用\d这样的表达式的时候 前面需要多加上一个\ 来标识这是一个正则
        Pattern p = Pattern.compile(&quot;\\d&quot;);
        Matcher m = p.matcher(&quot;1 dd 343  ddd 333 ddd&quot;);
        // 一个stirngbuffer 将所有符合的替换掉
        StringBuffer sb = new StringBuffer();
        while (m.find())
        {
            // m.group 就是表示当前匹配的
            System.out.println(m.group());
            // 将符合的替换成指定的字符
            m.appendReplacement(sb, &quot;A&quot;);
        }
        System.out.println(sb.toString());
        //将剩余的添加进去
        System.out.println(m.appendTail(sb));

//结果
//A dd AAA  ddd AAA
//A dd AAA  ddd AAA ddd

    }
}
package com.bdr.irts;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;

import com.bdr.irts.pojo.util.TestWordDealUtil;
import com.bdr.irts.test.MyTest;

/**
* 测试套件
* @author pengshuangbao
* @date 2014-3-14
*/
@RunWith(Suite.class)
@Suite.SuiteClasses({ TestWordDealUtil.class, MyTest.class })
public class RunAllUtilTestsSuite
{

}
</code>
</RECORD>
<RECORD>
<snippet_key>301581</snippet_key>
<tag></tag>
<comment>来自CSDN博客：黑马程序员-讲解Colletion共性方法学习日记 http://blog.csdn.net/qq330772290/article/details/24116871#</comment>
<code>//讲解Colletion共性方法
package heimaLog;
import java.util.*;
/* 为什么出现集合类
* |--面向对象语言对事物的体现都是以对象的形式
* |--所以为了方便对多个对象操作，就对对象进行存储，集合就是存储对象最常用的一种方式
* 数组和集合类同是容器，有何不同？
* |--数组虽然也可以存储对象，当长度是固定的，集合长度是可变的（全村Demo，全存Stduent）
* |--数组可以存储基本数据类型，集合只能存储对象。
* 集合类的特点
* |--集合只用于存储对象，集合长度是可变的，集合可以存储不同类型的对象。
*
*容器分为很多种。因为容器中存储数据的数据结构不同
* 集合按照面向对象的特征 进行抽取共同特性形成体系（集合框架）。
*
* 接口 ： Colletion{list,set}
* list{ArrayList,LinkedList,vector}
* set {HashSet,TreeSet}
*
*
*
* */
public class CollectionDemo {

public static void main(String[] args) {
// TODO Auto-generated method stub
//method_2();
method_get();
}
public static void method_get(){

ArrayList al2= new ArrayList();
al2.add(&quot;java01&quot;); //add的方法的参数是Object，以便于接收任意形引用。
//集合中存储的是对象的引用（地址）。
al2.add(&quot;java02&quot;);
al2.add(&quot;java03&quot;);
al2.add(&quot;java04&quot;);

Iterator it = al2.iterator(); //迭代器接口 :对元素中的元素进行遍历,
while(it.hasNext()){ //hasNext:判断集合中有无下一个后继元素

sop(it.next());

}


}
public static void method_2(){

ArrayList al = new ArrayList();
al.add(&quot;java01&quot;); //add的方法的参数是Object，以便于接收任意形引用。
//集合中存储的是对象的引用（地址）。
al.add(&quot;java02&quot;);
al.add(&quot;java03&quot;);
al.add(&quot;java04&quot;);
ArrayList al2 = new ArrayList();


al2.add(&quot;java02&quot;);
al2.add(&quot;java03&quot;);
al2.add(&quot;java04&quot;);


sop(&quot;size：&quot;+al.size());

sop(al); //打印原集合

al.remove(&quot;java02&quot;);//删除元素

sop(al); //打印删除元素后的集合

//al.clear(); //清空集合和
sop(al.contains(&quot;java02&quot;));
sop(al.isEmpty()); //集合是否为空
al.retainAll(al2); //取al中的交集元素


}
public static void sop(Object obj){

System.out.println(obj);

}

}
</code>
</RECORD>
<RECORD>
<snippet_key>105229</snippet_key>
<tag></tag>
<comment>来自CSDN博客：ResultSetHandler http://blog.csdn.net/czzhenmsdn/article/details/17238143#</comment>
<code>/*
* Licensed to the Apache Software Foundation (ASF) under one or more
* contributor license agreements. See the NOTICE file distributed with
* this work for additional information regarding copyright ownership.
* The ASF licenses this file to You under the Apache License, Version 2.0
* (the &quot;License&quot;); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
package org.apache.commons.dbutils;

import java.sql.ResultSet;
import java.sql.SQLException;

/**
* Implementations of this interface convert ResultSets into other objects.
*
* @param &lt;T&gt; the target type the input ResultSet will be converted to.
*/
public interface ResultSetHandler&lt;T&gt; {

/**
* Turn the &lt;code&gt;ResultSet&lt;/code&gt; into an Object.
*
* @param rs The &lt;code&gt;ResultSet&lt;/code&gt; to handle. It has not been touched
* before being passed to this method.
*
* @return An Object initialized with &lt;code&gt;ResultSet&lt;/code&gt; data. It is
* legal for implementations to return &lt;code&gt;null&lt;/code&gt; if the
* &lt;code&gt;ResultSet&lt;/code&gt; contained 0 rows.
*
* @throws SQLException if a database access error occurs
*/
T handle(ResultSet rs) throws SQLException;

}
</code>
</RECORD>
<RECORD>
<snippet_key>172045</snippet_key>
<tag>471</tag>
<comment>来自CSDN博客：Java实现希尔(Shell)排序  http://blog.csdn.net/wwwfgx1/article/details/18796709#</comment>
<code>import java.text.SimpleDateFormat;
import java.util.Date;

public class ShellSort
{
private long[] arr; //要排序的数组
private int size; //初始化数组大小
private int length; //数组实际大小(即有多少个值)

public ShellSort(int size){
this.arr=new long[size];
this.size = size;
length = 0;
}
//往数组添加值
public void add(long value){
if(length &lt; size)
arr[length++] = value;
}
//打印
public void display(){
for(int i=0; i&lt;length; i++){
System.out.print(arr[i]+&quot; &quot;);
}
System.out.println(&quot; &quot;);
}
//交换数组两个位置的数据
public void swap(int left, int right){
long tmp = arr[left];
arr[left] = arr[right];
arr[right] = tmp;
}


/**
* 取数组最后一个数作为&quot;中间值&quot;,将数组分成比&quot;中间值&quot;小和比&quot;中间值&quot;大的两部分
* 将&quot;中间值&quot;交换到两部分数据的中间位置
* 然后对&quot;中间值&quot;两边的数组,递归的执行该操作...
* @param left
* @param right
*/
public void sort(){
int count = 0;
while(count&lt;length){
count = count*3+1;
}
int interval = (count-1)/3;
//逐渐减小增量,直到最后=1
while(interval&gt;=1){
//从0开始以interval为增量的等差数列,进行插入排序
//从1开始以interval为增量的等差数列,进行插入排序
//...
//从interval-1开始以interval为增量的等差数列,进行插入排序
//确保所有数据都进行了排序
for(int i=0; i&lt;interval; i++){
int j=1;
//依次将数据一个个插入前面已排序的序列中;相对于第二个数来说,第一个数就是已排序好的序列
while((i+j*interval)&lt;length){
int tmpj = j;
long tmp = arr[i+j*interval];
while(--tmpj&gt;=0 &amp;&amp; arr[i+tmpj*interval]&gt;tmp){
arr[i+tmpj*interval+interval]=arr[i+tmpj*interval];
}
arr[i+tmpj*interval+interval]=tmp;
j++;
}
}

interval = (interval-1)/3;
}
}

public static void main(String[] args){
ShellSort sort = new ShellSort(1000000);
for(int i=0; i&lt;1000000; i++){
sort.add((long)(Math.random()*100));
}
SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss ms&quot;);
System.out.println(sdf.format(new Date()));
//sort.display();
sort.sort();
//sort.display();
System.out.println(sdf.format(new Date()));
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>106765</snippet_key>
<tag></tag>
<comment>来自CSDN博客：笔试编程题  http://blog.csdn.net/csywwx2008/article/details/17251115#</comment>
<code>package com.gduf.dataStructure.sort;

import java.lang.reflect.Method;

import com.gduf.dataStructure.list.LinList;

public class ReflestTest {

public static void getAllMethods(Object obj)
{
Class&lt;?&gt; objClass = obj.getClass();
Method[] methods = objClass.getDeclaredMethods();

for(Method method : methods)
{
System.out.println(method.toString() + &quot; &quot;);
}

}

public static void main(String args[])
{
LinList list = new LinList();
getAllMethods(list);
}

}
package com.gduf.dataStructure.sort;

import java.io.File;

public class FileTest {

//打印file指定路径下的所有文件夹名
public static void printFolder(File file)
{
File[] files = file.listFiles();

for(File f : files)
{
if(f.isDirectory())
{
System.out.println(&quot; &quot; + f.getName());
}
}

}

//打印file指定路径下的所有文件名
public static void printFile(File file)
{
File[] files = file.listFiles();
for(File f : files)
{
if(f.isFile())
{
System.out.println(&quot; &quot; + f.getName());
}
}
}

//用递归实现：打印file目录下的所有文件和文件夹
public static void printAll(File file)
{
if(!file.isDirectory())
{
System.out.println(&quot;该File对象不是目录&quot;);
return ;
}

//递归出口：当传入的目录为空目录时返回
if(file.listFiles().length == 0)
{
return ;
}

System.out.println(file.toString() + &quot;-&gt;&quot;);
printFolder(file);
printFile(file);

System.out.println(&quot;--------&quot;);

File[] files = file.listFiles();
for(int i = 0; i &lt; files.length; i++)
{
//是文件就跳过
if(!files[i].isDirectory())
{
continue;
}

//如果是目录就递归
printAll(files[i]);
}

}
public static void main(String args[])
{
File file = new File(&quot;F:\\项目\\历史\\PS高手之路&quot;);

printAll(file);

}

}
</code>
</RECORD>
<RECORD>
<snippet_key>172301</snippet_key>
<tag>42</tag>
<comment>来自CSDN博客：eclipse 启动 找不到 JRE JDK的解决方法  http://blog.csdn.net/jueshengtianya/article/details/18799481#</comment>
<code>hadoop@steven:~/eclipse/eclipse$ ./eclipse
No protocol specified
No protocol specified
Eclipse: 无法打开显示：

** (java:12572): WARNING **: 命令 dbus-launch --autolaunch=f231fd4902ec51cc1caeae980000000c --binary-syntax --close-stderr 以非零状态数 1 退出：No protocol specified\nNo protocol specified\nAutolaunch error: X11 initialization failed.\n
No protocol specified
No protocol specified
No protocol specified
No protocol specified
Eclipse: 无法打开显示：
Eclipse:
An error has occurred. See the log file
/home/hadoop/eclipse/eclipse/configuration/1390731601942.log.
hadoop@steven:~/eclipse/eclipse$ cat /home/hadoop/eclipse/eclipse/configuration/1390731601942.log
!SESSION 2014-01-26 18:20:01.405 -----------------------------------------------
eclipse.buildId=4.3.0.M20130911-1000
java.version=1.7.0_45
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=zh_CN
Framework arguments: -product org.eclipse.epp.package.standard.product
Command-line arguments: -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.osgi 4 0 2014-01-26 18:20:12.782
!MESSAGE Application error
!STACK 1
org.eclipse.swt.SWTError: No more handles [gtk_init_check() failed]
at org.eclipse.swt.SWT.error(SWT.java:4423)
at org.eclipse.swt.widgets.Display.createDisplay(Display.java:925)
at org.eclipse.swt.widgets.Display.create(Display.java:909)
at org.eclipse.swt.graphics.Device.&lt;init&gt;(Device.java:156)
at org.eclipse.swt.widgets.Display.&lt;init&gt;(Display.java:507)
at org.eclipse.swt.widgets.Display.&lt;init&gt;(Display.java:498)
at org.eclipse.ui.internal.Workbench.createDisplay(Workbench.java:691)
at org.eclipse.ui.PlatformUI.createDisplay(PlatformUI.java:162)
at org.eclipse.ui.internal.ide.application.IDEApplication.createDisplay(IDEApplication.java:154)
at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:96)
at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:606)
at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636)
at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
at org.eclipse.equinox.launcher.Main.run(Main.java:1450)
at org.eclipse.equinox.launcher.Main.main(Main.java:1426)
&lt;p&gt;&lt;/p&gt;
hadoop@steven:~/eclipse/eclipse$ cat eclipse.ini
-vm
/usr/local/jdk1.7.0_45/jre/bin
-startup
plugins/org.eclipse.equinox.launcher_1.3.0.v20130327-1440.jar
--launcher.library
plugins/org.eclipse.equinox.launcher.gtk.linux.x86_64_1.1.200.v20130807-1835
-product
org.eclipse.epp.package.standard.product
--launcher.defaultAction
openFile
-showsplash
org.eclipse.platform
--launcher.XXMaxPermSize
256m
--launcher.defaultAction
openFile
--launcher.appendVmargs
-vmargs
-Dosgi.requiredJavaVersion=1.6
-XX:MaxPermSize=256m
-Xms40m
-Xmx512m
</code>
</RECORD>
<RECORD>
<snippet_key>237837</snippet_key>
<tag>414</tag>
<comment>来自CSDN博客：判断字符串相等 http://blog.csdn.net/solo_sky/article/details/21296471#</comment>
<code>public class TestDemo {
public static void main(String[] args) {
/**
* isMatch(&quot;a*&quot;,&quot;&quot;)=true;
* isMatch(&quot;a.&quot;,&quot;ab&quot;)=true;
* isMatch(&quot;.&quot;,&quot;&quot;)=false;
* isMatch(&quot;a*.cba*c.&quot;,&quot;xcbcm&quot;) = true;
*/
TestDemo testDemo = new TestDemo();
System.out.println(testDemo.isMatch(&quot;a*&quot;, &quot;&quot;));
System.out.println(testDemo.isMatch(&quot;a.&quot;, &quot;ab&quot;));
System.out.println(testDemo.isMatch(&quot;.&quot;, &quot;&quot;));
System.out.println(testDemo.isMatch(&quot;a*.cba*c.&quot;,&quot;xcbcm&quot;));
}
public boolean isMatch(String src,String des){
//处理*
String srcTmp = this.resolveX(src);
String desTmp = this.resolveX(des);
//System.out.println(srcTmp + &quot; &quot; + desTmp);
//处理.
//1:当存在一个字符串为空时直接返回false
if((srcTmp.length() == 0 &amp;&amp;desTmp.length()&gt;0) || (srcTmp.length() &gt; 0 &amp;&amp;desTmp.length() == 0)){
return false;
}else{
//2.1:双方都为空
if(srcTmp.length() == 0 &amp;&amp; desTmp.length() == 0){
return true;
}else{
//2.2:双方都不为空,则开始处理.
return this.resolveD(srcTmp, desTmp);
}
}
}
/**
* 消除字符串中的*
* @param src 需要处理的字符串
* @return 返回处理后的字符串,可能为空
*/
public String resolveX(String src){
int i=0;
int len = src.length();
int j=0;
char[] tmpArr = src.toCharArray();
while(i&lt;src.length()){
char tmp = src.charAt(i);
if(tmp != &apos;*&apos;){
tmpArr[i-j] = tmpArr[i];
}else{
j = j + 2;
len = len - 2;
if((i+2) &gt; src.length()){
break;
}
}
i++;
}
return new String(tmpArr,0,len);
}
/**
* 处理字符串中的.
* @param src 第一个字符串
* @param des 第二个字符串
* @return 返回处理后的字符串数组
*/
public boolean resolveD(String src,String des){
int i = 0;
char[] srcTmp = src.toCharArray();
char[] desTmp = des.toCharArray();
//如果两个字符串长度不同，返回false
if(src.length() != des.length()){
return false;
}
while(i&lt;srcTmp.length){
//如果字符串相同，逐字符比较
if(srcTmp[i] == desTmp[i]){
i++;
}else{
if(srcTmp[i] == &apos;.&apos; || desTmp[i] == &apos;.&apos;){
i++;
}else{
return false;
}
}
}
return true;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>41741</snippet_key>
<tag>327</tag>
<comment>java调用系统命令封装类，适用于windows平台、linux平台。</comment>
<code>package com.mamy.utils;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;

/**
* 执行系统多条命令
*
* @author mamyoung
* @version v1.0
*/
public class SystemTool {
private static SystemTool systemTool;

private SystemTool() {
}

/**
* 获取当前操作系统名称. return 操作系统名称 例如:windows xp,linux 等.
*/
public String getOSName() {
return System.getProperty(&quot;os.name&quot;).toLowerCase();
}

/**
* 在unix系统执行命令
*
* @param cmdarray
* [] 系统命令数组
* @return
*/
public String getUnixCommand(String[] cmdarray) {
String mac = null;
BufferedReader bufferedReader = null;
Process process = null;
try {
Runtime rt = Runtime.getRuntime();
File file = File.createTempFile(&quot;shell&quot;, &quot;.sh&quot;);
BufferedWriter bw = new BufferedWriter(new FileWriter(file));
bw.write(&quot;#!/bin/bash&quot;);
for (String string : cmdarray) {
bw.newLine();
bw.write(string); // 把命令写入一个文本shell文件
}
bw.flush();
bw.close();
process = rt.exec(&quot;chmod a+x &quot; + file.getAbsolutePath()); // 授权该shell文件可以执行
process.waitFor(); // 等待语句执行结束
process = rt.exec(file.getAbsolutePath());
bufferedReader = new BufferedReader(new InputStreamReader(process
.getInputStream()));
String line = null;
while ((line = bufferedReader.readLine()) != null) {
mac += line + &quot;\n&quot;;
}
} catch (Exception e) {
e.printStackTrace();
} finally {
try {
if (bufferedReader != null) {
bufferedReader.close();
}
} catch (IOException e) {
e.printStackTrace();
}
bufferedReader = null;
process = null;
}

return mac;
}

/**
* 执行windows系统命令
*
* @param cmdarray
* 系统命令数组
* @return 命令返回结果
*/
public String getWindowsCommand(String[] command) {
String mac = null;
BufferedReader bufferedReader = null;
Process process = null;
try {
File file = File.createTempFile(&quot;shell&quot;, &quot;.bat&quot;);
BufferedWriter bw = new BufferedWriter(new FileWriter(file));
bw.write(&quot;@echo off&quot;);
for (String string : command) {
bw.newLine();
bw.write(string);
}
bw.flush();
bw.close();
process = Runtime.getRuntime().exec(file.getAbsolutePath());// windows下的命令，显示信息中包含有mac地址信息
bufferedReader = new BufferedReader(new InputStreamReader(process
.getInputStream()));
String line = null;
while ((line = bufferedReader.readLine()) != null) {
mac += line + &quot;\n&quot;;
}
} catch (IOException e) {
e.printStackTrace();
} finally {
try {
if (bufferedReader != null) {
bufferedReader.close();
}
} catch (IOException e) {
e.printStackTrace();
}
bufferedReader = null;
process = null;
}
return mac;
}

/**
* 执行命令
*
* @param command
* 命令数组
* @return
*/
public String executeCommand(String[] command) {
String os = SystemTool.getSystemTool().getOSName();
String commandString;
if (os.startsWith(&quot;windows&quot;)) {
// 本地是windows
commandString = SystemTool.getSystemTool().getWindowsCommand(
command);
} else {
// 本地是非windows系统 一般就是unix
commandString = SystemTool.getSystemTool().getUnixCommand(command);
}
return commandString;
}

public static SystemTool getSystemTool() {
synchronized (SystemTool.class) {
if (systemTool == null) {
systemTool = new SystemTool();
}
}
return systemTool;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>238349</snippet_key>
<tag>java Effective Java</tag>
<comment>来自CSDN博客：第51条：当心字符串连接性能 http://blog.csdn.net/heminjia888/article/details/21318813#</comment>
<code>public String statement() {
StringBuilder b = new StringBuilder(numItems() * LINE_WIDTH);
for (int i = 0; i &lt; numItems(); i++)
b.append(lineForItem(i));
return b.toString();
}
</code>
</RECORD>
<RECORD>
<snippet_key>173069</snippet_key>
<tag>214</tag>
<comment>来自CSDN博客：android json解析 http://blog.csdn.net/za143567229za/article/details/18815809#</comment>
<code>json数据格式解析我自己分为两种；

一种是普通的，一种是带有数组形式的；




普通形式的：
服务器端返回的json数据格式如下：

{&quot;userbean&quot;:{&quot;Uid&quot;:&quot;100196&quot;,&quot;Showname&quot;:&quot;\u75af\u72c2\u7684\u7334\u5b50&quot;,&quot;Avtar&quot;:null,&quot;State&quot;:1}}

分析代码如下：

// TODO 状态处理 500 200
int res = 0;
res = httpClient.execute(httpPost).getStatusLine().getStatusCode();
if (res == 200) {
/*
* 当返回码为200时，做处理
* 得到服务器端返回json数据，并做处理
* */
HttpResponse httpResponse = httpClient.execute(httpPost);
StringBuilder builder = new StringBuilder();
BufferedReader bufferedReader2 = new BufferedReader(
new InputStreamReader(httpResponse.getEntity().getContent()));
String str2 = &quot;&quot;;
for (String s = bufferedReader2.readLine(); s != null; s = bufferedReader2
.readLine()) {
builder.append(s);
}
Log.i(&quot;cat&quot;, &quot;&gt;&gt;&gt;&gt;&gt;&gt;&quot; + builder.toString());

JSONObject jsonObject = new JSONObject(builder.toString())
.getJSONObject(&quot;userbean&quot;);

String Uid;
String Showname;
String Avtar;
String State;

Uid = jsonObject.getString(&quot;Uid&quot;);
Showname = jsonObject.getString(&quot;Showname&quot;);
Avtar = jsonObject.getString(&quot;Avtar&quot;);
State = jsonObject.getString(&quot;State&quot;);
带数组形式的：
服务器端返回的数据格式为：

{&quot;calendar&quot;:
{&quot;calendarlist&quot;:
[
{&quot;calendar_id&quot;:&quot;1705&quot;,&quot;title&quot;:&quot;(\u4eb2\u5b50)ddssd&quot;,&quot;category_name&quot;:&quot;\u9ed8\u8ba4\u5206\u7c7b&quot;,&quot;showtime&quot;:&quot;1288927800&quot;,&quot;endshowtime&quot;:&quot;1288931400&quot;,&quot;allDay&quot;:false},
{&quot;calendar_id&quot;:&quot;1706&quot;,&quot;title&quot;:&quot;(\u65c5\u884c)&quot;,&quot;category_name&quot;:&quot;\u9ed8\u8ba4\u5206\u7c7b&quot;,&quot;showtime&quot;:&quot;1288933200&quot;,&quot;endshowtime&quot;:&quot;1288936800&quot;,&quot;allDay&quot;:false}
]
}
}

分析代码如下：

// TODO 状态处理 500 200
int res = 0;
res = httpClient.execute(httpPost).getStatusLine().getStatusCode();
if (res == 200) {
/*
* 当返回码为200时，做处理
* 得到服务器端返回json数据，并做处理
* */
HttpResponse httpResponse = httpClient.execute(httpPost);
StringBuilder builder = new StringBuilder();
BufferedReader bufferedReader2 = new BufferedReader(
new InputStreamReader(httpResponse.getEntity().getContent()));
String str2 = &quot;&quot;;
for (String s = bufferedReader2.readLine(); s != null; s = bufferedReader2
.readLine()) {
builder.append(s);
}
Log.i(&quot;cat&quot;, &quot;&gt;&gt;&gt;&gt;&gt;&gt;&quot; + builder.toString());
/**
* 这里需要分析服务器回传的json格式数据，
*/
JSONObject jsonObject = new JSONObject(builder.toString())
.getJSONObject(&quot;calendar&quot;);
JSONArray jsonArray = jsonObject.getJSONArray(&quot;calendarlist&quot;);
for(int i=0;i&lt;jsonArray.length();i++){
JSONObject jsonObject2 = (JSONObject)jsonArray.opt(i);
CalendarInfo calendarInfo = new CalendarInfo();
calendarInfo.setCalendar_id(jsonObject2.getString(&quot;calendar_id&quot;));
calendarInfo.setTitle(jsonObject2.getString(&quot;title&quot;));
calendarInfo.setCategory_name(jsonObject2.getString(&quot;category_name&quot;));
calendarInfo.setShowtime(jsonObject2.getString(&quot;showtime&quot;));
calendarInfo.setEndtime(jsonObject2.getString(&quot;endshowtime&quot;));
calendarInfo.setAllDay(jsonObject2.getBoolean(&quot;allDay&quot;));
calendarInfos.add(calendarInfo);
}

总结，普通形式的只需用JSONObject ，带数组形式的需要使用JSONArray 将其变成一个list。
</code>
</RECORD>
<RECORD>
<snippet_key>42509</snippet_key>
<tag>184</tag>
<comment>http://acm.hdu.edu.cn/showproblem.php?pid=1562#简单题</comment>
<code>import java.util.*;

public class Main {
private static int T, a, b, c;

public static void main(String[] args) {
Scanner in = new Scanner(System.in);
T = in.nextInt();
for(int t=1;t&lt;=T;t++) {
a = in.nextInt();
b = in.nextInt();
c = in.nextInt();
int i, flag = 0;
for(i=1000;i&lt;=9999;i++) {
if((i % a == 0) &amp;&amp; ((i+1) % b == 0) &amp;&amp; ((i+2) % c == 0)) {
flag = 1; break;
}
}
if(flag == 1)
System.out.println(i);
else
System.out.println(&quot;Impossible&quot;);
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>239117</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Lucene-分词器  http://blog.csdn.net/u011417072/article/details/21334333#</comment>
<code>/**
* 经过该方法可以把分词后的结果输出
* @param analyzer
* @param text
* @throws Exception
*/
private void testAnalyzer(Analyzer analyzer,String text)throws Exception{
TokenStream tokenStream = analyzer.tokenStream(&quot;content&quot;, new StringReader(text));
tokenStream.addAttribute(TermAttribute.class);
while(tokenStream.incrementToken()){
TermAttribute termAttribute = tokenStream.getAttribute(TermAttribute.class);
System.out.println(termAttribute.term());
}
}
/**
* 主要針對汉语
* 英语
*
* 汉语
* @author Administrator
*
*/
public class AnalyzerTest {
@Test
public void testEn() throws Exception{
/**
* Creates a searcher searching the index in the named directory
*/
/**
* 1、切分关键词
* 2、去掉停用词
* 3、把大写转化成小写
*/
String text = &quot;Creates a searcher searching the index in the named directory&quot;;
Analyzer analyzer = new StandardAnalyzer(Version.LUCENE_30);
this.testAnalyzer(analyzer, text);
}

@Test
public void testZH() throws Exception{
/**
* 单字分词
*/
Analyzer analyzer = new ChineseAnalyzer();
String text = &quot;传智播客的黎活明是UFO&quot;;
this.testAnalyzer(analyzer, text);
}

@Test
public void testZH2() throws Exception{
/**
* 单字分词
*/
Analyzer analyzer = new CJKAnalyzer(Version.LUCENE_30);
String text = &quot;传智播客的黎活明是UFO&quot;;
this.testAnalyzer(analyzer, text);
}

@Test
public void testZH3() throws Exception{
Analyzer analyzer = new IKAnalyzer();
String text = &quot;北京美女&quot;;
this.testAnalyzer(analyzer, text);
}
/**
* 经过该方法可以把分词后的结果输出
* @param analyzer
* @param text
* @throws Exception
*/
private void testAnalyzer(Analyzer analyzer,String text)throws Exception{
TokenStream tokenStream = analyzer.tokenStream(&quot;content&quot;, new StringReader(text));
tokenStream.addAttribute(TermAttribute.class);
while(tokenStream.incrementToken()){
TermAttribute termAttribute = tokenStream.getAttribute(TermAttribute.class);
System.out.println(termAttribute.term());
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>370189</snippet_key>
<tag>414</tag>
<comment>来自CSDN博客：将整数字符串转换成整数输出（JAVA实现，不能用自带函数） http://blog.csdn.net/Army_War/article/details/27666461#</comment>
<code>/**
* @author PLA
* 将整数字符串转换成整数输出
*/
public static void main(String[] args) {
String s = &quot;-1456542&quot;;
change(s);
}
public static void change(String s){
boolean flag = true;
long num = 0;
int temp;
char[] ch = s.toCharArray();
for(int i=0;i&lt;ch.length;i++){
if((i==0)&amp;&amp;(ch[i] == &apos;+&apos;)){
flag = true;
}
else if((i==0)&amp;&amp;(ch[i] == &apos;-&apos;)){
flag = false;
}
else if((ch[i]&gt;=&apos;0&apos;)&amp;&amp;ch[i]&lt;=&apos;9&apos;){
temp = ch[i]-&apos;0&apos;;
num = num*10 + temp;
}else{
System.out.println(&quot;Wrong!!!&quot;);
return;
}
}
if(flag==false){
System.out.println(-num);
}else{
System.out.println(num);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>108557</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Android通过USB与PC通信  http://blog.csdn.net/snail200802101/article/details/17270785#</comment>
<code>//连接
public bool DoConnect()
{
string strCmd = &quot;adb shell am broadcast -a NotifyServiceStop&quot;;
Execute(strCmd, wait_ms);
Thread.Sleep(wait_ms);
strCmd = &quot;adb forward tcp:12580 tcp:10086&quot;;
Execute(strCmd, wait_ms);
Thread.Sleep(wait_ms);
strCmd = &quot;adb shell am broadcast -a NotifyServiceStart&quot;;
Execute(strCmd, wait_ms);
Thread.Sleep(wait_ms);

IPAddress ipaddress = IPAddress.Parse(&quot;127.0.0.1&quot;);

tcpClient.Connect(ipaddress, 12580);
Thread.Sleep(wait_ms);
if (tcpClient != null)
{
NetworkStream networkkStream = tcpClient.GetStream();
networkkStream.ReadTimeout = timeOut;
networkkStream.WriteTimeout = timeOut;
reader = new BinaryReader(networkkStream);
writer = new BinaryWriter(networkkStream);
return true;
}
else
return false;
}
private string Execute(string command, int seconds)
{
string output = &quot;&quot;; //输出字符串
if (command != null &amp;&amp; !command.Equals(&quot;&quot;))
{
Process process = new Process();//创建进程对象
ProcessStartInfo startInfo = new ProcessStartInfo();
startInfo.FileName = &quot;cmd.exe&quot;;//设定需要执行的命令
startInfo.Arguments = &quot;/C &quot; + command;//“/C”表示执行完命令后马上退出
startInfo.UseShellExecute = false;//不使用系统外壳程序启动
startInfo.RedirectStandardInput = false;//不重定向输入
startInfo.RedirectStandardOutput = true; //重定向输出
startInfo.CreateNoWindow = true;//不创建窗口
process.StartInfo = startInfo;
try
{
if (process.Start())//开始进程
{
if (seconds == 0)
{
process.WaitForExit();//这里无限等待进程结束
}
else
{
process.WaitForExit(seconds); //等待进程结束，等待时间为指定的毫秒
}
output = process.StandardOutput.ReadToEnd();//读取进程的输出
}
}
finally
{
if (process != null)
process.Close();
}
}
return output;
}
public class ServiceBroadcastReceiver extends BroadcastReceiver {

private static String START_ACTION = &quot;NotifyServiceStart&quot;;
private static String STOP_ACTION = &quot;NotifyServiceStop&quot;;

@Override
public void onReceive(Context context, Intent intent) {
Log.d(ConnectService.TAG, Thread.currentThread().getName() + &quot;----&gt;&quot;
+ &quot;ServiceBroadcastReceiver onReceive&quot;);

String action = intent.getAction();
if (START_ACTION.equalsIgnoreCase(action)) {
context.startService(new Intent(context, ConnectService.class));

Log.d(ConnectService.TAG, Thread.currentThread().getName() + &quot;----&gt;&quot;
+ &quot;ServiceBroadcastReceiver onReceive start end&quot;);
} else if (STOP_ACTION.equalsIgnoreCase(action)) {
context.stopService(new Intent(context, ConnectService.class));
Log.d(ConnectService.TAG, Thread.currentThread().getName() + &quot;----&gt;&quot;
+ &quot;ServiceBroadcastReceiver onReceive stop end&quot;);
}
}
}
public class ConnectService extends Service{

public static final String TAG = &quot;chl&quot;;
public static Boolean mainThreadFlag = true;
public static Boolean ioThreadFlag = true;
ServerSocket serverSocket = null;
final int SERVER_PORT = 10086;

@Override
public IBinder onBind(Intent intent)
{
return null;
}

@Override
public void onCreate()
{
super.onCreate();
Log.d(TAG, &quot;androidService---&gt;onCreate()&quot;);
}

@Override
public int onStartCommand(Intent intent, int flags, int startId)
{
mainThreadFlag = true;
new Thread()
{
public void run()
{
doListen();
};
}.start();
return START_NOT_STICKY;
}

private void doListen()
{
serverSocket = null;
try
{
serverSocket = new ServerSocket(SERVER_PORT);
while (mainThreadFlag)
{
Socket socket = serverSocket.accept();
new Thread(new ThreadReadWriterIOSocket(this, socket)).start();
}
} catch (IOException e)
{
e.printStackTrace();
}
}

@Override
public void onDestroy()
{
super.onDestroy();
mainThreadFlag = false;
ioThreadFlag = false;
try
{
if (serverSocket != null)
serverSocket.close();
} catch (IOException e)
{
e.printStackTrace();
}
}
}
public class ThreadReadWriterIOSocket implements Runnable{

private Socket client;
private Context context;
private PigProtocol pigProtocol;

public ThreadReadWriterIOSocket(Context context, Socket client)
{
this.client = client;
this.context = context;
pigProtocol = new PigProtocol();
}

@Override
public void run(){

BufferedOutputStream out;
BufferedInputStream in;

try {

Header header = null;
out = new BufferedOutputStream(client.getOutputStream());
in = new BufferedInputStream(client.getInputStream());
ConnectService.ioThreadFlag = true;
while (ConnectService.ioThreadFlag){
try {

if(!client.isConnected()){
break;
}

header = pigProtocol.readHeaderFromSocket(in);
switch (header.CmdId) {
case 0x0001:
//
break;
case 0x0002:
//
break;
default:
break;
}
}
catch (Exception e)
{
// TODO: handle exception
e.printStackTrace();
}
}
out.close();
in.close();
}
catch (Exception e)
{
// TODO: handle exception
e.printStackTrace();
}
finally
{
try
{
if (client != null)
{
client.close();
}
} catch (IOException e)
{
e.printStackTrace();
}
}
}
}
&lt;!-- 添加权限 --&gt;
&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;


&lt;application&gt;
&lt;!-- 指定接受广播的类 --&gt;
&lt;receiver android:name=&quot;.ServiceBroadcastReceiver&quot;&gt;
&lt;intent-filter &gt;
&lt;action android:name=&quot;NotifyServiceStart&quot;/&gt;
&lt;action android:name=&quot;NotifyServiceStop&quot; /&gt;
&lt;/intent-filter&gt;
&lt;/receiver&gt;

&lt;!--指定服务类--&gt;
&lt;service
android:name=&quot;.ConnectService&quot;&gt;
&lt;/service&gt;
&lt;/application&gt;
&lt;pre code_snippet_id=&quot;108557&quot; snippet_file_name=&quot;blog_20131211_7_4029794&quot;&gt;
try {

String strTmp = gson.toJson(content);
out.write(strTmp.getBytes());
out.flush();
} catch (Exception e) {
// TODO: handle exception
Log.d(&quot;error&quot;,&quot;writeHeaderFromSocket&quot; + e.getMessage());
}
byte[] tempbuffer = new byte[MAX_BUFFER_BYTES];
try
{
int numReadedBytes = in.read(tempbuffer, 0, MAX_BUFFER_BYTES);
String strJson = new String(tempbuffer, 0, numReadedBytes, &quot;utf-8&quot;);
MyType myType = gson.fromJson(strJson, MyType.class);

tempbuffer = null;
} catch (Exception e)
{
e.printStackTrace();
}
byte[] tempbuffer = new byte[MAX_BUFFER_BYTES];
try
{
int numReadedBytes = in.read(tempbuffer, 0, MAX_BUFFER_BYTES);
String strJson = new String(tempbuffer, 0, numReadedBytes, &quot;utf-8&quot;);
List&lt;MyTyoe&gt; listMyType = gson.fromJson(strJson,
new TypeToken&lt;List&lt;listMyType&gt;&gt;(){}.getType());
tempbuffer = null;

return listMyType;
} catch (Exception e)
{
e.printStackTrace();
}
public static string Obj2Json&lt;T&gt;(T data)
{
try
{
DataContractJsonSerializer json = new DataContractJsonSerializer(data.GetType());
using (MemoryStream ms = new MemoryStream())
{
json.WriteObject(ms, data);
return Encoding.UTF8.GetString(ms.ToArray());
}
}
catch (System.Exception ex)
{
throw ex;
}
}

public static object Json2Obj(string strJson, Type t)
{
try
{
DataContractJsonSerializer json = new DataContractJsonSerializer(t);
using (MemoryStream ms = new MemoryStream(Encoding.UTF8.GetBytes(strJson)))
{
return json.ReadObject(ms);
}
}
catch (System.Exception ex)
{
throw ex;
}
}
try {

String strTmp = gson.toJson(content);
out.write(strTmp.getBytes());
out.flush();
} catch (Exception e) {
// TODO: handle exception
Log.d(&quot;error&quot;,&quot;writeHeaderFromSocket&quot; + e.getMessage());
}
byte[] tempbuffer = new byte[MAX_BUFFER_BYTES];
try
{
int numReadedBytes = in.read(tempbuffer, 0, MAX_BUFFER_BYTES);
String strJson = new String(tempbuffer, 0, numReadedBytes, &quot;utf-8&quot;);
MyType myType = gson.fromJson(strJson, MyType.class);

tempbuffer = null;
} catch (Exception e)
{
e.printStackTrace();
}
byte[] tempbuffer = new byte[MAX_BUFFER_BYTES];
try
{
int numReadedBytes = in.read(tempbuffer, 0, MAX_BUFFER_BYTES);
String strJson = new String(tempbuffer, 0, numReadedBytes, &quot;utf-8&quot;);
List&lt;MyType&gt; listMyType = gson.fromJson(strJson,
new TypeToken&lt;List&lt;MyType&gt;&gt;(){}.getType());
tempbuffer = null;

} catch (Exception e)
{
e.printStackTrace();
}
byte[] tempbuffer = new byte[MAX_BUFFER_BYTES];
try
{
int numReadedBytes = in.read(tempbuffer, 0, MAX_BUFFER_BYTES);
String strJson = new String(tempbuffer, 0, numReadedBytes, &quot;utf-8&quot;);
List&lt;MyType&gt; listMyType = gson.fromJson(strJson,
new TypeToken&lt;List&lt;MyType&gt;&gt;(){}.getType());
tempbuffer = null;

} catch (Exception e)
{
e.printStackTrace();
}
</code>
</RECORD>
<RECORD>
<snippet_key>305165</snippet_key>
<tag>Java Web过滤器编码过滤器Filt</tag>
<comment>来自CSDN博客：Java编码过滤器  http://blog.csdn.net/com185272358/article/details/24272327#</comment>
<code>/**
* cn.jbit.struts2.filter.CharFilter
* 编码过滤器A
* 2014-4-21
* gyy
*/
package cn.jbit.struts2.filter;

import java.io.IOException;
import java.util.Map;
import java.util.Set;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class CharFilter implements Filter {

private FilterConfig filterConfig = null;
private String encoding;

// 销毁
public void destroy() {
this.filterConfig = null;
}

@SuppressWarnings(&quot;unchecked&quot;)
public void doFilter(ServletRequest req, ServletResponse response,
FilterChain chain) throws IOException, ServletException {
HttpServletRequest request = (HttpServletRequest) req;
HttpServletResponse resp = (HttpServletResponse) response;
request.setCharacterEncoding(encoding);
resp.setContentType(&quot;text/html;charset=&quot; + encoding);
System.out.println(request.getQueryString());
// 处理GET参数
if (request.getMethod().equalsIgnoreCase(&quot;get&quot;)) {
Map paramMap = req.getParameterMap();
System.out.println(&quot;paramMap.size=&quot; + paramMap.size());
System.out.println(((String[]) paramMap.get(&quot;id&quot;))[0]);
System.out.println(((String[]) paramMap.get(&quot;name&quot;))[0]);
String[] queryStringArray = { &quot;&quot; };
if (request.getQueryString() != null) {
queryStringArray = request.getQueryString().split(&quot;&amp;&quot;);
}
// 获取参数名 $1为获取&quot;=&quot;前(.*)部分
for (int i = 0; i &lt; queryStringArray.length; i++) {
queryStringArray[i] = queryStringArray[i].replaceAll(
&quot;(.*)=(.*)&quot;, &quot;$1&quot;);
}
System.out.println(&quot;-----------------------------------&quot;);
for (String str : queryStringArray) {
System.out.println(str);
}
System.out.println(&quot;-----------------------------------&quot;);
Set&lt;String&gt; keySet = paramMap.keySet();
for (String key : keySet) {
System.out.println(&quot;key=&quot; + key);
boolean isFromGet = false;
for (String paramFromGet : queryStringArray) {
if (key.equals(paramFromGet)) {
isFromGet = true;
}
}
if (!isFromGet) {
continue;
}
String[] paramArray = (String[]) paramMap.get(key);
// 设置编码方式
for (int i = 0; i &lt; paramArray.length; i++) {
paramArray[i] = new String(paramArray[i]
.getBytes(&quot;ISO8859-1&quot;), encoding);
}
}
}
chain.doFilter(req, resp);
}

// 初始化
public void init(FilterConfig filterConfig) throws ServletException {
this.filterConfig = filterConfig;
// 获取编码方式
this.encoding = this.filterConfig.getInitParameter(&quot;encoding&quot;);
}
}
/**
* cn.jbit.struts2.filter.EncodingFilter
* 编码过滤器B
* 2014-4-21
* gyy
*/
package cn.jbit.struts2.filter;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Map;
import java.util.Set;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;

public class EncodingFilter implements Filter {

private FilterConfig filterConfig;
private String encoding;

class MyRequest extends HttpServletRequestWrapper {

// 请求包装类
public MyRequest(HttpServletRequest request) {
super(request);
}

// 编码转换
protected String encodingConvert(String str) {
if (null == str) {
return null;
} else {
try {
byte[] bytes = str.getBytes(&quot;ISO8859-1&quot;);
return new String(bytes, encoding);
} catch (UnsupportedEncodingException e) {
}
}
return null;
}

@Override
public String getParameter(String name) {
return encodingConvert(name);
}

@Override
public String[] getParameterValues(String name) {
String[] values = super.getParameterValues(name);
if (null != values) {
for (int i = 0; i &lt; values.length; i++) {
values[i] = encodingConvert(values[i]);
}
}
return values;
}
}

// 销毁
public void destroy() {
this.filterConfig = null;
this.encoding = null;
}

@SuppressWarnings(&quot;unchecked&quot;)
public void doFilter(ServletRequest request, ServletResponse response,
FilterChain chain) throws IOException, ServletException {
HttpServletRequest httpRequest = (HttpServletRequest) request;
if (&quot;GET&quot;.equals(httpRequest.getMethod())) {
request = new MyRequest(httpRequest);
// 获取请求参数Map
Map paramMap = request.getParameterMap();
Set&lt;String&gt; keySet = paramMap.keySet();
for (String key : keySet) {
String[] param = (String[]) paramMap.get(key);
// System.out.println(paramArray.length);
// 设置编码方式
if (param.length == 1) {// 单值
param[0] = request.getParameter(param[0]);
} else {// 多值
param = request.getParameterValues(key);
}
}
}
chain.doFilter(request, response);
}

// 初始化
public void init(FilterConfig filterConfig) throws ServletException {
this.filterConfig = filterConfig;
this.encoding = this.filterConfig.getInitParameter(&quot;encoding&quot;);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>370701</snippet_key>
<tag>来自CSDN博客：ActionBar http://blog.csdn.net/liu149339750/article/details/8282471#</tag>
<comment>派生自liu149339750/blog_20131211_10_4609036</comment>
<code>actionBar.setDisplayShowHomeEnabled(false);
actionBar.setDisplayShowTitleEnabled(false);
actionBar.setDisplayOptions(0,ActionBar.DISPLAY_SHOW_HOME|ActionBar.DISPLAY_SHOW_TITLE );
View customActionBarView = inflater.inflate(R.layout.editor_custom_action_bar,
null);
View saveMenuItem = customActionBarView.findViewById(R.id.save_menu_item);
saveMenuItem.setOnClickListener(new OnClickListener() {
@Override
public void onClick(View v) {
mFragment.onDoneClicked();
}
});
// Show the custom action bar but hide the home icon and title
actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM,
ActionBar.DISPLAY_SHOW_CUSTOM | ActionBar.DISPLAY_SHOW_HOME |
ActionBar.DISPLAY_SHOW_TITLE);
actionBar.setCustomView(customActionBarView);
actionBar.setDisplayOptions(ActionBar.DISPLAY_HOME_AS_UP|ActionBar.DISPLAY_SHOW_HOME|ActionBar.DISPLAY_SHOW_CUSTOM);
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;&lt;item
android:id=&quot;@+id/menu1&quot;
android:actionLayout=&quot;@layout/list_item&quot;
android:actionViewClass=&quot;android.widget.SearchView&quot;
android:icon=&quot;@drawable/ic_launcher&quot;
android:showAsAction=&quot;ifRoom|collapseActionView&quot;
android:title=&quot;@string/app_name&quot;/&gt;
&lt;item
android:id=&quot;@+id/select&quot;
android:showAsAction=&quot;ifRoom&quot;
android:title=&quot;@string/select_all&quot;&gt;
&lt;/item&gt;
&lt;item
android:id=&quot;@+id/delete&quot;
android:enabled=&quot;false&quot;
android:showAsAction=&quot;ifRoom|withText&quot;
android:title=&quot;@string/delete&quot;&gt;
&lt;/item&gt;
&lt;/menu&gt;
ActionBar actionBar = getActionBar();
actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_LIST);
actionBar.setListNavigationCallbacks(mSpinnerAdapter, mOnNavigationListener);
@Override
public boolean onCreateActionMode(ActionMode mode, Menu menu) {
MenuInflater inflater = mode.getMenuInflater();
inflater.inflate(R.menu.main, menu);
return true;
}
PopupMenu pop = new PopupMenu(this, button);
pop.getMenuInflater().inflate(R.menu.main, pop.getMenu());
pop.show();
&lt;style name=&quot;actionStyle&quot; parent=&quot;@android:style/Widget.Holo.Light.ActionBar.Solid.Inverse&quot;&gt;
&lt;item name=&quot;android:background&quot;&gt;@drawable/title_bg&lt;/item&gt;
&lt;item name=&quot;android:backgroundStacked&quot;&gt;@drawable/title_bg&lt;/item&gt;
&lt;item name=&quot;android:displayOptions&quot;&gt;&lt;/item&gt;
&lt;/style&gt;
&lt;style name=&quot;actionText&quot; parent=&quot;android:TextAppearance.Holo.Widget.ActionBar.Menu&quot;&gt;
&lt;item name=&quot;android:textSize&quot;&gt;20sp&lt;/item&gt;
&lt;item name=&quot;android:textStyle&quot;&gt;italic&lt;/item&gt;
&lt;/style&gt;
&lt;style name=&quot;splitStyle&quot; parent=&quot;android:Widget.Holo.Light.ActionBar.Solid&quot;&gt;
&lt;item name=&quot;android:backgroundSplit&quot;&gt;@drawable/title_bg&lt;/item&gt; &lt;!-- 整个 split的背景--&gt;
&lt;item name=&quot;android:minHeight&quot;&gt;40sp&lt;/item&gt;
&lt;/style&gt;
requestWindowFeature(Window.FEATURE_ACTION_BAR);
requestWindowFeature(Window.FEATURE_ACTION_BAR_OVERLAY);
</code>
</RECORD>
<RECORD>
<snippet_key>479052</snippet_key>
<tag>java 设计模式 模式 UML建模</tag>
<comment>来自CSDN博客：Java设计模式菜鸟系列(二)观察者模式建模与实现  http://blog.csdn.net/JAVE_LOVER/article/details/39755577#</comment>
<code>/** 示例：咱们去菜市场买菜
*
* 小商贩--主题
*/
class Food extends Observable {
/** 菜名 */
private String name;
/** 菜价 */
private float price;

public Food(String name, float price) {
this.name = name;
this.price = price;
}

public String getName() {
return name;
}

public float getPrice() {
return price;
}

public void setPrice(float price) {
this.price = price;
/**
* 设置菜价的状态已经被改变
*/
this.setChanged();
/**
* 通知【所有】正在看菜(已经注册了)的顾客，然后回调Observer的update方法进行更新
*
* 这里可以体现对象的一对多：一个小商贩一旦更新价格(即一个对象改变状态)，便会自动通知所有的顾客(依赖它的对象都会收到通知)
* 并自动update
*/
this.notifyObservers(price);
}

}

/**
* 顾客 --观察者
*/
class Customer implements Observer {
private String name;

public Customer(String name) {
this.name = name;
}

public String getName() {
return name;
}

@Override
public void update(Observable o, Object arg) {
if (o instanceof Food &amp;&amp; arg instanceof Float) {
Food food = (Food) o;
float price = (Float) arg;
System.out.println(&quot;您好：&quot; + this.name + &quot; ,&quot; + food.getName()
+ &quot;的价格已经发生改变，现在的价格为：&quot; + price + &quot;元/斤&quot;);
}
}

}

/**
* 客户端测试类
*
* @author Leo
*/
public class Test {
public static void main(String[] args) {
Food food = new Food(&quot;土豆&quot;, 1.0f);
Customer zhangsan = new Customer(&quot;张三&quot;);
Customer lisi = new Customer(&quot;李四&quot;);
/**
* 添加顾客
*/
food.addObserver(zhangsan);
food.addObserver(lisi);
/**
* 更新价格
*/
food.setPrice(1.5f);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>479050</snippet_key>
<tag>482</tag>
<comment>leetcode dfs 集合来自CSDN博客：LeetCode-Subsets  http://blog.csdn.net/disappearedgod/article/details/39757403#</comment>
<code>public class Solution {
ArrayList&lt;ArrayList&lt;Integer&gt;&gt; retlist = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subsets(int[] S) {
Arrays.sort(S);
int N = 1;
for(int i = 0; i &lt; S.length; ++i)
N = N &lt;&lt; 1;
if(S.length == 0)
return retlist;
for(int i = 0; i &lt; N; i++){// retlist num
retlist.add(new ArrayList&lt;Integer&gt;());
for(int res = i,count = 0; res &gt;0 &amp;&amp; count &lt; S.length; res = res &gt;&gt; 1,count++)
if(res % 2 == 1)
retlist.get(i).add(S[count]);

}
return retlist;
}
}
public class Solution {
ArrayList&lt;ArrayList&lt;Integer&gt;&gt; retlist = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subsets(int[] S) {

ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
Arrays.sort(S);
sub(S, 0, new ArrayList&lt;Integer&gt;());
return retlist;

}
void sub(int[] S, int index, ArrayList&lt;Integer&gt; list){
if(index == S.length){
retlist.add(list);
return;
}



//donot chose S[index]
sub(S, index+1, (ArrayList&lt;Integer&gt;)list.clone());

//chose S[index]
list.add(S[index]);
sub(S, index+1, (ArrayList&lt;Integer&gt;)list.clone());

list.remove(list.size()-1);
}
}
class Solution {
public:
void sub(vector&lt;int&gt; s, int index, vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt;&gt; &amp;solution)
{
if(index == s.size()){solution.push_back(path);return;}
sub(s,index+1,path,solution);
path.push_back(s[index]);
sub(s,index+1,path,solution);
path.pop_back();
}
vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt; &amp;S) {
// Note: The Solution object is instantiated only once.
vector&lt;vector&lt;int&gt;&gt; solution;
vector&lt;int&gt; path;
sort(S.begin(),S.end());
sub(S,0,path,solution);
return solution;
}
};
ArrayList&lt;ArrayList&lt;Integer&gt;&gt; retlist = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subsets(int[] S) {
ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
Arrays.sort(S);
//sub(S, 0, new ArrayList&lt;Integer&gt;());
retlist.add(list);
dfs(retlist, list, S, 0);
return retlist;
}

public void dfs(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; retlist, ArrayList&lt;Integer&gt; list, int[] S, int index){
for(int i = index; i &lt; S.length; ++i ){
list.add(S[i]);
retlist.add(new ArrayList&lt;Integer&gt;(list));
dfs(retlist, list, S, i+1);
list.remove(list.size()-1);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>479049</snippet_key>
<tag></tag>
<comment>来自CSDN博客：遍历Jenkins所有项目的配置  http://blog.csdn.net/sheismylife/article/details/39757397#</comment>
<code>http://your_jenkins_server/api/xml
http://your_jenkins_server/api/json
http://your_jenkins_server/job/your_job/config.xml
</code>
</RECORD>
<RECORD>
<snippet_key>436493</snippet_key>
<tag></tag>
<comment>来自CSDN博客：单例懒汉式的另一种实现  http://blog.csdn.net/nwsuafer/article/details/38176129#</comment>
<code>package cn.interview;

public class SingletonDemo {
static{
System.out.println(&quot;SingletonDemo load&quot;);
}
private SingletonDemo() {

}


public static void anyMethod(){
System.out.println(&quot;other method&quot;);
}

static class ClassHolder{
static{
System.out.println(&quot;ClassHolder load&quot;);
}
private static SingletonDemo instance = new SingletonDemo();
}

public static SingletonDemo getInstance(){
return ClassHolder.instance;//调用这句的时候才会静态初始化ClassHolder
}


}
package cn.interview;

public class SingletonTest {
public static void main(String[] args) {
SingletonDemo.anyMethod();

System.out.println(&quot;-----------------&quot;);
SingletonDemo demo1 = SingletonDemo.getInstance();
SingletonDemo demo2 = SingletonDemo.getInstance();
System.out.println(demo1==demo2);
}
}
SingletonDemo load
other method
-----------------
ClassHolder load
true
</code>
</RECORD>
<RECORD>
<snippet_key>479037</snippet_key>
<tag>Myeclipse注释</tag>
<comment>来自CSDN博客：Myeclipse快捷操作  http://blog.csdn.net/fasfewatgerjhytsjy/article/details/39756859#</comment>
<code>// for(int i=0;i&lt;x.length;i++){
// sum=sum+x[i];
// }
// for(int i=0;i&lt;x.length;i++){
// sum=sum+x[i];
// }
/* for(int i=0;i&lt;x.length;i++){
sum=sum+x[i];
}
for(int i=0;i&lt;x.length;i++){
sum=sum+x[i];
}*/
</code>
</RECORD>
<RECORD>
<snippet_key>240397</snippet_key>
<tag>安卓 LruCache</tag>
<comment>来自CSDN博客：LruCache图片缓存技术应用 http://blog.csdn.net/u012170463/article/details/21391269#</comment>
<code>package com.example.mytest;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Bundle;
import android.os.Environment;
import android.support.v4.util.LruCache;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.ImageView;

public class MainActivity extends Activity {
private ImageView iv;
private Button pre;
private Button next;

private int curPage = 1;
final private int maxPage = 23;

private String parentPath = Environment.getExternalStorageDirectory()
+ &quot;/finger/&quot;;
private String curPath;

private LruCache&lt;String, Bitmap&gt; mMemoryCache;

@Override
protected void onCreate(Bundle savedInstanceState) {
// TODO Auto-generated method stub
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
// 生成当前图片的路径
curPath = parentPath + curPage + &quot;.png&quot;;
pre = (Button) findViewById(R.id.pre);
next = (Button) findViewById(R.id.next);
iv = (ImageView) findViewById(R.id.iv);

final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);
final int cacheSize = maxMemory / 8;

mMemoryCache = new LruCache&lt;String, Bitmap&gt;((cacheSize)) {
@SuppressLint(&quot;NewApi&quot;)
@Override
protected int sizeOf(String key, Bitmap value) {
// TODO Auto-generated method stub
return value.getByteCount() / 1024;
}
};

// 加载第一张图片
Bitmap firstPic = BitmapFactory.decodeFile(curPath);
iv.setImageBitmap(firstPic);

// 缓存当前和下一张图片
savePage(curPage);
if (curPage &lt; maxPage) {
savePage(curPage + 1);
}

/**
* 上一张按钮的监听器
*/
pre.setOnClickListener(new OnClickListener() {

@Override
public void onClick(View v) {
// TODO Auto-generated method stub
if (curPage &lt;= 1) {
return;
}
curPage--;
Bitmap bm = mMemoryCache.get(curPage + &quot;&quot;);
if (bm == null) {
curPath = parentPath + curPage + &quot;.png&quot;;
bm = BitmapFactory.decodeFile(curPath);
}
iv.setImageBitmap(bm);

// 缓存当前和前一张图片
savePage(curPage);
if (curPage &gt; 1) {
savePage(curPage - 1);
}

}
});

/**
* 下一张按钮的监听器
*/
next.setOnClickListener(new OnClickListener() {

@Override
public void onClick(View v) {
// TODO Auto-generated method stub
curPage++;
Bitmap bm = mMemoryCache.get(curPage + &quot;&quot;);
if (bm == null) {
curPath = parentPath + curPage + &quot;.png&quot;;
bm = BitmapFactory.decodeFile(curPath);
}
iv.setImageBitmap(bm);

// 缓存当前和下一张图片
savePage(curPage);
if (curPage &lt; maxPage) {
savePage(curPage + 1);
}
}
});

}

/**
*
* 缓存图片函数
*
* @param page
* ：要缓存图片的页码
*
*
*/
void savePage(int page) {
Bitmap curPic = mMemoryCache.get(page + &quot;&quot;);
if (curPic == null) {
String path = parentPath + page + &quot;.png&quot;;
curPic = BitmapFactory.decodeFile(path);
}
mMemoryCache.put(page + &quot;&quot;, curPic);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>175373</snippet_key>
<tag>PE</tag>
<comment>来自CSDN博客：&lt;MEMORY&gt;Project Euler NO44  http://blog.csdn.net/q2234037172/article/details/18883069#</comment>
<code>public class Problem44
{
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;public static void main(String[] args)
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;{
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;long start = System.currentTimeMillis();
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;System.out.print(&quot;answer: Â &quot;);


&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;howmany();


&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;long end = System.currentTimeMillis();
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;System.out.print(&quot;time: Â &quot;);
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;System.out.println(end - start);
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}


&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;static void howmany()
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;{
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;l1: for (int i = 2;; i++)
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;{
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;l2 : for (int j = i - 1; j &gt; 0; j--)
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;{
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;int t1 = i * (3 * i - 1) / 2;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;int t2 = j * (3 * j - 1) / 2;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;int add = t1 + t2;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;int subtration = t1 - t2;


&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;double tempadd = (Math.sqrt(24 * add + 1) + 1) / 6;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;double tempsub = (Math.sqrt(24 * subtration + 1) + 1) / 6;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;if ((int)tempadd != tempadd)
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;{
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;continue l2;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;if ((int)tempsub != tempsub)
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;{
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;continue l2;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;System.out.println(subtration);
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;break l1;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}


}
</code>
</RECORD>
<RECORD>
<snippet_key>479017</snippet_key>
<tag>297</tag>
<comment> 读取手机短信, 先保存到SQLite，再读取数据库显示</comment>
<code>package com.homer.sms;

import java.sql.Date;
import java.text.SimpleDateFormat;

import org.loon.wsi.R;

import android.app.Activity;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.graphics.Color;
import android.net.Uri;
import android.os.Bundle;
import android.util.Log;
import android.widget.TableLayout;
import android.widget.TableRow;
import android.widget.TableRow.LayoutParams;
import android.widget.TextView;

/**
* 读取手机短信, 先保存到SQLite数据，然后再读取数据库显示
*
* @author sunboy_2050
* @since http://blog.csdn.net/sunboy_2050
* @date 2012.03.06
*/
public class smsRead4 extends Activity {

TableLayout tableLayout;
int index = 0;

@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);

setContentView(R.layout.main);

tableLayout = (TableLayout) findViewById(R.id.tableLayout);
showSMS();
}

private void showSMS() {
SmsHander smsHander = new SmsHander(this);

smsHander.createSMSDatabase(); // 创建SQLite数据库
smsHander.insertSMSToDatabase(); // 读取手机短信，插入SQLite数据库
Cursor cursor = smsHander.querySMSInDatabase(100); // 获取前100条短信（日期排序）

cursor.moveToPosition(-1);
while (cursor.moveToNext()) {
String strAddress = cursor.getString(cursor.getColumnIndex(&quot;address&quot;));
String strDate = cursor.getString(cursor.getColumnIndex(&quot;date&quot;));
String strBody = cursor.getString(cursor.getColumnIndex(&quot;body&quot;));

SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
Date date = new Date(Long.parseLong(strDate));
strDate = dateFormat.format(date);

String smsTitle = strAddress + &quot;\t\t&quot; + strDate;
String smsBody = strBody + &quot;\n&quot;;
Log.i(&quot;tableRow&quot;, smsTitle + smsBody);

// title Row
TableRow trTitle = new TableRow(this);
trTitle.setLayoutParams(new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));

TextView tvTitle = new TextView(this);
tvTitle.setText(smsTitle);
tvTitle.getPaint().setFakeBoldText(true); // 加粗字体
tvTitle.setTextColor(Color.RED);
tvTitle.setLayoutParams(new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));
trTitle.addView(tvTitle);
tableLayout.addView(trTitle, new TableLayout.LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT));

// body Row
TableRow trBody = new TableRow(this);
trBody.setLayoutParams(new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));

TextView tvBody = new TextView(this);
tvBody.setText(smsBody);
tvBody.setLayoutParams(new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));
trBody.addView(tvBody);
tableLayout.addView(trBody, new TableLayout.LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT));
}

if (!cursor.isClosed()) {
cursor.close();
cursor = null;
}

smsHander.closeSMSDatabase();
index = 0;
}

public class SmsHander {

SQLiteDatabase db;
Context context;

public SmsHander(Context context) {
this.context = context;
}

public void createSMSDatabase() {
String sql = &quot;create table if not exists sms(&quot;
+ &quot;_id integer primary key autoincrement,&quot;
+ &quot;address varchar(255),&quot; + &quot;person varchar(255),&quot;
+ &quot;body varchar(1024),&quot; + &quot;date varchar(255),&quot;
+ &quot;type integer)&quot;;
db = SQLiteDatabase.openOrCreateDatabase(context.getFilesDir().toString() + &quot;/data.db3&quot;, null); // 创建数据库
db.execSQL(sql);
}

// 获取手机短信
private Cursor getSMSInPhone() {
Uri SMS_CONTENT = Uri.parse(&quot;content://sms/&quot;);
String[] projection = new String[] { &quot;_id&quot;, &quot;address&quot;, &quot;person&quot;, &quot;body&quot;, &quot;date&quot;, &quot;type&quot; };
Cursor cursor = context.getContentResolver().query(SMS_CONTENT, projection, null, null, &quot;date desc&quot;); // 获取手机短信

while (cursor.moveToNext()) {
System.out.println(&quot;--sms-- : &quot; + cursor.getString(cursor.getColumnIndex(&quot;body&quot;)));
}

return cursor;
}

// 保存手机短信到 SQLite 数据库
public void insertSMSToDatabase() {
Long lastTime;
Cursor dbCount = db.rawQuery(&quot;select count(*) from sms&quot;, null);
dbCount.moveToFirst();
if (dbCount.getInt(0) &gt; 0) {
Cursor dbcur = db.rawQuery(&quot;select * from sms order by date desc limit 1&quot;, null);
dbcur.moveToFirst();
lastTime = Long.parseLong(dbcur.getString(dbcur.getColumnIndex(&quot;date&quot;)));
} else {
lastTime = new Long(0);
}
dbCount.close();
dbCount = null;

Cursor cur = getSMSInPhone(); // 获取短信（游标）
db.beginTransaction(); // 开始事务处理
if (cur.moveToFirst()) {
String address;
String person;
String body;
String date;
int type;

int iAddress = cur.getColumnIndex(&quot;address&quot;);
int iPerson = cur.getColumnIndex(&quot;person&quot;);
int iBody = cur.getColumnIndex(&quot;body&quot;);
int iDate = cur.getColumnIndex(&quot;date&quot;);
int iType = cur.getColumnIndex(&quot;type&quot;);

do {
address = cur.getString(iAddress);
person = cur.getString(iPerson);
body = cur.getString(iBody);
date = cur.getString(iDate);
type = cur.getInt(iType);

if (Long.parseLong(date) &gt; lastTime) {
String sql = &quot;insert into sms values(null, ?, ?, ?, ?, ?)&quot;;
Object[] bindArgs = new Object[] { address, person, body, date, type };
db.execSQL(sql, bindArgs);
} else {
break;
}
} while (cur.moveToNext());

cur.close();
cur = null;
db.setTransactionSuccessful(); // 设置事务处理成功，不设置会自动回滚不提交
db.endTransaction(); // 结束事务处理
}

}

// 获取 SQLite 数据库中的全部短信
public Cursor querySMSFromDatabase() {
String sql = &quot;select * from sms order by date desc&quot;;
return db.rawQuery(sql, null);
}

// 获取 SQLite 数据库中的最新 size 条短信
public Cursor querySMSInDatabase(int size) {
String sql;

Cursor dbCount = db.rawQuery(&quot;select count(*) from sms&quot;, null);
dbCount.moveToFirst();
if (size &lt; dbCount.getInt(0)) { // 不足 size 条短信，则取前 size 条
sql = &quot;select * from sms order by date desc limit &quot; + size;
} else {
sql = &quot;select * from sms order by date desc&quot;;
}
dbCount.close();
dbCount = null;

return db.rawQuery(sql, null);
}

// 获取 SQLite数据库的前 second秒短信
public Cursor getSMSInDatabaseFrom(long second) {
long time = System.currentTimeMillis() / 1000 - second;
String sql = &quot;select * from sms order by date desc where date &gt; &quot; + time;
return db.rawQuery(sql, null);
}

// 关闭数据库
public void closeSMSDatabase() {
if (db != null &amp;&amp; db.isOpen()) {
db.close();
db = null;
}
}

}
}
</code>
</RECORD>
<RECORD>
<snippet_key>479016</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Replica Island 学习笔记 03 - Activity分析  http://blog.csdn.net/BlackMonkey/article/details/39735077#</comment>
<code>public class MainMenuActivity extends Activity {

private boolean mPaused;
private View mStartButton;
private View mOptionsButton;
private View mExtrasButton;
private View mBackground;
private View mTicker;
private Animation mButtonFlickerAnimation;
private Animation mFadeOutAnimation;
private Animation mAlternateFadeOutAnimation;
private Animation mFadeInAnimation;
private boolean mJustCreated;
private String mSelectedControlsString;

private final static int WHATS_NEW_DIALOG = 0;
private final static int TILT_TO_SCREEN_CONTROLS_DIALOG = 1;
private final static int CONTROL_SETUP_DIALOG = 2;

// Create an anonymous implementation of OnClickListener
private View.OnClickListener sContinueButtonListener = new View.OnClickListener() {

public void onClick(View v) {
if (!mPaused) {
Intent i = new Intent(getBaseContext(), AndouKun.class);
v.startAnimation(mButtonFlickerAnimation);
mFadeOutAnimation.setAnimationListener(new StartActivityAfterAnimation(i));
mBackground.startAnimation(mFadeOutAnimation);
mOptionsButton.startAnimation(mAlternateFadeOutAnimation);
mExtrasButton.startAnimation(mAlternateFadeOutAnimation);
mTicker.startAnimation(mAlternateFadeOutAnimation);
mPaused = true;
}
}
};

private View.OnClickListener sOptionButtonListener = new View.OnClickListener() {

public void onClick(View v) {
if (!mPaused) {
Intent i = new Intent(getBaseContext(), SetPreferencesActivity.class);
v.startAnimation(mButtonFlickerAnimation);
mFadeOutAnimation.setAnimationListener(new StartActivityAfterAnimation(i));
mBackground.startAnimation(mFadeOutAnimation);
mStartButton.startAnimation(mAlternateFadeOutAnimation);
mExtrasButton.startAnimation(mAlternateFadeOutAnimation);
mTicker.startAnimation(mAlternateFadeOutAnimation);
mPaused = true;
}
}
};

private View.OnClickListener sExtrasButtonListener = new View.OnClickListener() {

public void onClick(View v) {
if (!mPaused) {
Intent i = new Intent(getBaseContext(), ExtrasMenuActivity.class);
v.startAnimation(mButtonFlickerAnimation);
mButtonFlickerAnimation.setAnimationListener(new StartActivityAfterAnimation(i));
mPaused = true;
}
}
};

private View.OnClickListener sStartButtonListener = new View.OnClickListener() {

public void onClick(View v) {
if (!mPaused) {
Intent i = new Intent(getBaseContext(), DifficultyMenuActivity.class);
i.putExtra(&quot;newGame&quot;, true);
v.startAnimation(mButtonFlickerAnimation);
mButtonFlickerAnimation.setAnimationListener(new StartActivityAfterAnimation(i));
mPaused = true;
}
}
};
@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.mainmenu);
mPaused = true;
mStartButton = findViewById(R.id.startButton);
mOptionsButton = findViewById(R.id.optionButton);
mBackground = findViewById(R.id.mainMenuBackground);

if (mOptionsButton != null) {
mOptionsButton.setOnClickListener(sOptionButtonListener);
}

mExtrasButton = findViewById(R.id.extrasButton);
mExtrasButton.setOnClickListener(sExtrasButtonListener);
// show what&apos;s new message
editor.putInt(PreferenceConstants.PREFERENCE_LAST_VERSION, AndouKun.VERSION);
editor.commit();

showDialog(WHATS_NEW_DIALOG);

// screen controls were added in version 14
if (lastVersion &gt; 0 &amp;&amp; lastVersion &lt; 14
&amp;&amp; prefs.getBoolean(PreferenceConstants.PREFERENCE_TILT_CONTROLS, false)) {
if (touch.supportsMultitouch(this)) {
// show message about switching from tilt to screen controls
showDialog(TILT_TO_SCREEN_CONTROLS_DIALOG);
}
} else if (lastVersion == 0) {
// show message about auto-selected control schemes.
showDialog(CONTROL_SETUP_DIALOG);
}
}
}

if (mBackground != null) {
mBackground.clearAnimation();
}

if (mTicker != null) {
mTicker.clearAnimation();
mTicker.setAnimation(mFadeInAnimation);
}

if (mJustCreated) {
if (mStartButton != null) {
mStartButton
.startAnimation(AnimationUtils.loadAnimation(this, R.anim.button_slide));
}
if (mExtrasButton != null) {
Animation anim = AnimationUtils.loadAnimation(this, R.anim.button_slide);
anim.setStartOffset(500L);
mExtrasButton.startAnimation(anim);
}

if (mOptionsButton != null) {
Animation anim = AnimationUtils.loadAnimation(this, R.anim.button_slide);
anim.setStartOffset(1000L);
mOptionsButton.startAnimation(anim);
}
mJustCreated = false;
SharedPreferences prefs =
getSharedPreferences(PreferenceConstants.PREFERENCE_NAME, MODE_PRIVATE);
final int row = prefs.getInt(PreferenceConstants.PREFERENCE_LEVEL_ROW, 0);
final int index = prefs.getInt(PreferenceConstants.PREFERENCE_LEVEL_INDEX, 0);
int levelTreeResource = R.xml.level_tree;
if (row != 0 || index != 0) {
final int linear = prefs.getInt(PreferenceConstants.PREFERENCE_LINEAR_MODE, 0);
if (linear != 0) {
levelTreeResource = R.xml.linear_level_tree;
}
}

if (!LevelTree.isLoaded(levelTreeResource)) {
LevelTree.loadLevelTree(levelTreeResource, this);
LevelTree.loadAllDialog(this);
}
mTicker = findViewById(R.id.ticker);
if (mTicker != null) {
mTicker.setFocusable(true);
mTicker.requestFocus();
mTicker.setSelected(true);
}
mJustCreated = true;

// Keep the volume control type consistent across all activities.
setVolumeControlStream(AudioManager.STREAM_MUSIC);

// MediaPlayer mp = MediaPlayer.create(this, R.raw.bwv_115);
// mp.start();
}

@Override
protected void onPause() {
super.onPause();
mPaused = true;
}

@Override
protected void onResume() {
super.onResume();
mPaused = false;

mButtonFlickerAnimation.setAnimationListener(null);

if (mStartButton != null) {
// Change &quot;start&quot; to &quot;continue&quot; if there&apos;s a saved game.
SharedPreferences prefs =
getSharedPreferences(PreferenceConstants.PREFERENCE_NAME, MODE_PRIVATE);
final int row = prefs.getInt(PreferenceConstants.PREFERENCE_LEVEL_ROW, 0);
final int index = prefs.getInt(PreferenceConstants.PREFERENCE_LEVEL_INDEX, 0);
if (row != 0 || index != 0) {
((ImageView) mStartButton).setImageDrawable(getResources().getDrawable(
R.drawable.ui_button_continue));
mStartButton.setOnClickListener(sContinueButtonListener);
} else {
((ImageView) mStartButton).setImageDrawable(getResources().getDrawable(
R.drawable.ui_button_start));
mStartButton.setOnClickListener(sStartButtonListener);
}

TouchFilter touch;
final int sdkVersion = Integer.parseInt(Build.VERSION.SDK);
if (sdkVersion &lt; Build.VERSION_CODES.ECLAIR) {
touch = new SingleTouchFilter();
} else {
touch = new MultiTouchFilter();
}
final int lastVersion = prefs.getInt(PreferenceConstants.PREFERENCE_LAST_VERSION, 0);
if (lastVersion == 0) {
// This is the first time the game has been run.
// Pre-configure the control options to match the device.
// The resource system can tell us what this device has.
// TODO: is there a better way to do this? Seems like a kind of neat
// way to do custom device profiles.
final String navType = getString(R.string.nav_type);
mSelectedControlsString = getString(R.string.control_setup_dialog_trackball);
if (navType != null) {
if (navType.equalsIgnoreCase(&quot;DPad&quot;)) {
// Turn off the click-to-attack pref on devices that have a dpad.
SharedPreferences.Editor editor = prefs.edit();
editor.putBoolean(PreferenceConstants.PREFERENCE_CLICK_ATTACK, false);
editor.commit();
mSelectedControlsString = getString(R.string.control_setup_dialog_dpad);
} else if (navType.equalsIgnoreCase(&quot;None&quot;)) {
SharedPreferences.Editor editor = prefs.edit();

// This test relies on the PackageManager if api version &gt;= 5.
if (touch.supportsMultitouch(this)) {
// Default to screen controls.
editor.putBoolean(PreferenceConstants.PREFERENCE_SCREEN_CONTROLS, true);
mSelectedControlsString =
getString(R.string.control_setup_dialog_screen);
} else {
// Turn on tilt controls if there&apos;s nothing else.
editor.putBoolean(PreferenceConstants.PREFERENCE_TILT_CONTROLS, true);
mSelectedControlsString = getString(R.string.control_setup_dialog_tilt);
}
editor.commit();
}
}
}

if (Math.abs(lastVersion) &lt; Math.abs(AndouKun.VERSION)) {
// This is a new install or an upgrade.

// Check the safe mode option.
// Useful reference: http://en.wikipedia.org/wiki/List_of_Android_devices
if (Build.PRODUCT.contains(&quot;morrison&quot;) || // Motorola Cliq/Dext
Build.MODEL.contains(&quot;Pulse&quot;) || // Huawei Pulse
Build.MODEL.contains(&quot;U8220&quot;) || // Huawei Pulse
Build.MODEL.contains(&quot;U8230&quot;) || // Huawei U8230
Build.MODEL.contains(&quot;MB300&quot;) || // Motorola Backflip
Build.MODEL.contains(&quot;MB501&quot;) || // Motorola Quench / Cliq XT
Build.MODEL.contains(&quot;Behold+II&quot;)) { // Samsung Behold II
// These are all models that users have complained about. They likely use
// the same buggy QTC graphics driver. Turn on Safe Mode by default
// for these devices.
SharedPreferences.Editor editor = prefs.edit();
editor.putBoolean(PreferenceConstants.PREFERENCE_SAFE_MODE, true);
editor.commit();
}

SharedPreferences.Editor editor = prefs.edit();

if (lastVersion &gt; 0 &amp;&amp; lastVersion &lt; 14) {
// if the user has beat the game once, go ahead and unlock stuff for them.
if (prefs.getInt(PreferenceConstants.PREFERENCE_LAST_ENDING, -1) != -1) {
editor.putBoolean(PreferenceConstants.PREFERENCE_EXTRAS_UNLOCKED, true);
}
}
} else {
mStartButton.clearAnimation();
mOptionsButton.clearAnimation();
mExtrasButton.clearAnimation();
}
}

@Override
protected Dialog onCreateDialog(int id) {
Dialog dialog;
if (id == WHATS_NEW_DIALOG) {
dialog =
new AlertDialog.Builder(this).setTitle(R.string.whats_new_dialog_title)
.setPositiveButton(R.string.whats_new_dialog_ok, null)
.setMessage(R.string.whats_new_dialog_message).create();
} else if (id == TILT_TO_SCREEN_CONTROLS_DIALOG) {
dialog =
new AlertDialog.Builder(this)
.setTitle(R.string.onscreen_tilt_dialog_title)
.setPositiveButton(R.string.onscreen_tilt_dialog_ok,
new DialogInterface.OnClickListener() {

public void onClick(DialogInterface dialog, int whichButton) {
SharedPreferences prefs =
getSharedPreferences(
PreferenceConstants.PREFERENCE_NAME,
MODE_PRIVATE);
SharedPreferences.Editor editor = prefs.edit();
editor.putBoolean(
PreferenceConstants.PREFERENCE_SCREEN_CONTROLS,
true);
editor.commit();
}
})
.setNegativeButton(R.string.onscreen_tilt_dialog_cancel, null)
.setMessage(R.string.onscreen_tilt_dialog_message).create();
} else if (id == CONTROL_SETUP_DIALOG) {
String messageFormat = getResources().getString(R.string.control_setup_dialog_message);
String message = String.format(messageFormat, mSelectedControlsString);
CharSequence sytledMessage = Html.fromHtml(message); // lame.
dialog =
new AlertDialog.Builder(this)
.setTitle(R.string.control_setup_dialog_title)
.setPositiveButton(R.string.control_setup_dialog_ok, null)
.setNegativeButton(R.string.control_setup_dialog_change,
new DialogInterface.OnClickListener() {

public void onClick(DialogInterface dialog, int whichButton) {
Intent i =
new Intent(getBaseContext(),
SetPreferencesActivity.class);
i.putExtra(&quot;controlConfig&quot;, true);
startActivity(i);
}
}).setMessage(sytledMessage).create();
} else {
dialog = super.onCreateDialog(id);
}
return dialog;
}

protected class StartActivityAfterAnimation implements Animation.AnimationListener {

private Intent mIntent;

StartActivityAfterAnimation(Intent intent) {
mIntent = intent;
}

public void onAnimationEnd(Animation animation) {

startActivity(mIntent);

if (UIConstants.mOverridePendingTransition != null) {
try {
UIConstants.mOverridePendingTransition.invoke(MainMenuActivity.this,
R.anim.activity_fade_in, R.anim.activity_fade_out);
} catch (InvocationTargetException ite) {
DebugLog.d(&quot;Activity Transition&quot;, &quot;Invocation Target Exception&quot;);
} catch (IllegalAccessException ie) {
DebugLog.d(&quot;Activity Transition&quot;, &quot;Illegal Access Exception&quot;);
}
}
}
public void onAnimationRepeat(Animation animation) {
// TODO Auto-generated method stub
}

public void onAnimationStart(Animation animation) {
// TODO Auto-generated method stub
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>371981</snippet_key>
<tag>java</tag>
<comment>来自CSDN博客：一些java的知识 http://blog.csdn.net/nklinux/article/details/26161597#</comment>
<code>File file =new File(&quot;./file/server&quot;); //而windows的路径用 “.\\file\\server”
if (!file .exists() &amp;&amp; !file .isDirectory()) //值得考证，不是文件也不是目录？有没有必要这样写
{
System.out.println(&quot;//不存在&quot;);
file .mkdirs(); //用mkdirs() 可以在不存在的目录下创建目录，而mkdir()不行
} else
{
System.out.println(&quot;//目录存在&quot;);
}
</code>
</RECORD>
<RECORD>
<snippet_key>479013</snippet_key>
<tag>297</tag>
<comment>短信 sqlite 从短信数据库中读取短信</comment>
<code>package com.homer.sms;

import java.sql.Date;
import java.text.SimpleDateFormat;


import android.app.Activity;
import android.database.Cursor;
import android.database.sqlite.SQLiteException;
import android.net.Uri;
import android.os.Bundle;
import android.util.Log;
import android.widget.ScrollView;
import android.widget.TableLayout;
import android.widget.TextView;

/**
* 读取手机短信
*
* @author sunboy_2050
* @since http://blog.csdn.net/sunboy_2050
* @date 2012.03.06
*/
public class smsRead extends Activity {

@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);

TextView tv = new TextView(this);
tv.setText(getSmsInPhone());

ScrollView sv = new ScrollView(this);
sv.addView(tv);

setContentView(sv);
}

public String getSmsInPhone() {
final String SMS_URI_ALL = &quot;content://sms/&quot;;
final String SMS_URI_INBOX = &quot;content://sms/inbox&quot;;
final String SMS_URI_SEND = &quot;content://sms/sent&quot;;
final String SMS_URI_DRAFT = &quot;content://sms/draft&quot;;
final String SMS_URI_OUTBOX = &quot;content://sms/outbox&quot;;
final String SMS_URI_FAILED = &quot;content://sms/failed&quot;;
final String SMS_URI_QUEUED = &quot;content://sms/queued&quot;;

StringBuilder smsBuilder = new StringBuilder();

try {
Uri uri = Uri.parse(SMS_URI_ALL);
String[] projection = new String[] { &quot;_id&quot;, &quot;address&quot;, &quot;person&quot;, &quot;body&quot;, &quot;date&quot;, &quot;type&quot; };
Cursor cur = getContentResolver().query(uri, projection, null, null, &quot;date desc&quot;); // 获取手机内部短信

if (cur.moveToFirst()) {
int index_Address = cur.getColumnIndex(&quot;address&quot;);
int index_Person = cur.getColumnIndex(&quot;person&quot;);
int index_Body = cur.getColumnIndex(&quot;body&quot;);
int index_Date = cur.getColumnIndex(&quot;date&quot;);
int index_Type = cur.getColumnIndex(&quot;type&quot;);

do {
String strAddress = cur.getString(index_Address);
int intPerson = cur.getInt(index_Person);
String strbody = cur.getString(index_Body);
long longDate = cur.getLong(index_Date);
int intType = cur.getInt(index_Type);

SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);
Date d = new Date(longDate);
String strDate = dateFormat.format(d);

String strType = &quot;&quot;;
if (intType == 1) {
strType = &quot;接收&quot;;
} else if (intType == 2) {
strType = &quot;发送&quot;;
} else {
strType = &quot;null&quot;;
}

smsBuilder.append(&quot;[ &quot;);
smsBuilder.append(strAddress + &quot;, &quot;);
smsBuilder.append(intPerson + &quot;, &quot;);
smsBuilder.append(strbody + &quot;, &quot;);
smsBuilder.append(strDate + &quot;, &quot;);
smsBuilder.append(strType);
smsBuilder.append(&quot; ]\n\n&quot;);
} while (cur.moveToNext());

if (!cur.isClosed()) {
cur.close();
cur = null;
}
} else {
smsBuilder.append(&quot;no result!&quot;);
} // end if

smsBuilder.append(&quot;getSmsInPhone has executed!&quot;);

} catch (SQLiteException ex) {
Log.d(&quot;SQLiteException in getSmsInPhone&quot;, ex.getMessage());
}

return smsBuilder.toString();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>241165</snippet_key>
<tag>android应用 android app 应用参数</tag>
<comment>来自CSDN博客：编程回忆之Android回忆（Android应用参数的获取）  http://blog.csdn.net/stop_pig/article/details/21409991#</comment>
<code>package com.prtsdkapp;

import java.lang.ref.WeakReference;
import java.util.List;

import android.app.ActivityManager;
import android.app.ActivityManager.RunningAppProcessInfo;
import android.app.ActivityManager.RunningTaskInfo;
import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.util.Log;

public class getContextParm {
private static final String TAG = &quot;ContextMgr&quot;;

/**
* 两个进程要共用sharedPreferences文件，则context要一样
* @param context
* @return
*/
public static Context getContext(Context context, String appPackageName) {
// String packageName = &quot;com.anyfish.app&quot;;
WeakReference&lt;Context&gt; mContext = new WeakReference&lt;Context&gt;(context);
Context con = mContext.get();
try {
Context contextApp = mContext.get().createPackageContext(
appPackageName, 0);
con = contextApp;

} catch (NameNotFoundException e) {
e.printStackTrace();
}
return con;
}

/**
* 获取当前进程名称
* @param context
* @return
*/
public static String getCurProcessName(Context context) {
Log.d(TAG, &quot;getCurProcessName&quot;);
int pid = android.os.Process.myPid();
ActivityManager mActivityManager = (ActivityManager) context
.getSystemService(Context.ACTIVITY_SERVICE);
for (ActivityManager.RunningAppProcessInfo appProcess : mActivityManager
.getRunningAppProcesses()) {
if (appProcess.pid == pid) {
Log.d(TAG, &quot;getCurProcessName:&quot; + appProcess.processName);
return appProcess.processName;
}
}
return null;
}

/**
* 获取sdk版本号
* @return
*/
public static int getSDKVersionNumber() {
int sdkVersion;
try {
sdkVersion = Integer.valueOf(android.os.Build.VERSION.SDK);
} catch (NumberFormatException e) {
sdkVersion = 0;
}
return sdkVersion;
}

/**
* 检测当前packageName程序是否属于前台程序
*
* @param app
* @param appPackageName
* @return
*/
public static boolean isTopActivity(Context context, String appPackageName) {
ActivityManager activityManager = (ActivityManager) context
.getSystemService(Context.ACTIVITY_SERVICE);
List&lt;RunningTaskInfo&gt; tasksInfo = activityManager.getRunningTasks(1);

if (tasksInfo.size() &gt; 0) {
if (tasksInfo.get(0).topActivity.getPackageName().contains(
appPackageName)) {
return true;
}
}
return false;
}

/**
* 判断当前packageName程序是否切换到后台了
* @param app
* @param appPackageName
* @return
*/
public static boolean isBackgroundActivity(Context context,
String appPackageName) {
if (isTopActivity(context, appPackageName)) {
return false;
}
ActivityManager am = (ActivityManager) context
.getSystemService(Context.ACTIVITY_SERVICE);
List&lt;RunningAppProcessInfo&gt; run = am.getRunningAppProcesses();
for (RunningAppProcessInfo ra : run) {
if (ra.processName.contains(appPackageName)
&amp;&amp; !ra.processName.contains(appPackageName + &quot;:&quot;)) {
return true;
}
}
return false;
}

/**
* 判断程序是否安装
* @param context
* @return
*/
public static boolean isAppInstalled(Context context, String packageName) {
Log.d(TAG, &quot;isAppInstalled&quot;);

PackageManager mPackageManager = context.getPackageManager();

if (mPackageManager == null) {
return false;
}

List&lt;PackageInfo&gt; pkgs = mPackageManager
.getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES);

boolean installed = false;
for (PackageInfo info : pkgs) {
if (info.packageName.equals(packageName)) {
installed = true;
break;
}
}

return installed;
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>479010</snippet_key>
<tag>297</tag>
<comment>短信 通讯录 sqlite 通过address手机号关联Contacts联系人的显示名字 </comment>
<code>package com.homer.phone;

import java.sql.Date;
import java.text.SimpleDateFormat;

import android.app.Activity;
import android.database.Cursor;
import android.database.sqlite.SQLiteException;
import android.net.Uri;
import android.os.Bundle;
import android.provider.ContactsContract;
import android.provider.ContactsContract.CommonDataKinds.Phone;
import android.util.Log;
import android.widget.ScrollView;
import android.widget.TextView;

public class phoneRead2 extends Activity {

@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);

TextView tv = new TextView(this);
tv.setText(getSmsInPhone());

ScrollView sv = new ScrollView(this);
sv.addView(tv);

setContentView(sv);
}

public String getSmsInPhone() {
final String SMS_URI_ALL = &quot;content://sms/&quot;;
final String SMS_URI_INBOX = &quot;content://sms/inbox&quot;;
final String SMS_URI_SEND = &quot;content://sms/sent&quot;;
final String SMS_URI_DRAFT = &quot;content://sms/draft&quot;;
final String SMS_URI_OUTBOX = &quot;content://sms/outbox&quot;;
final String SMS_URI_FAILED = &quot;content://sms/failed&quot;;
final String SMS_URI_QUEUED = &quot;content://sms/queued&quot;;

StringBuilder smsBuilder = new StringBuilder();

try {
Uri uri = Uri.parse(SMS_URI_ALL);
String[] projection = new String[] { &quot;_id&quot;, &quot;address&quot;, &quot;person&quot;, &quot;body&quot;, &quot;date&quot;, &quot;type&quot; };
Cursor cur = getContentResolver().query(uri, projection, null, null, &quot;date desc&quot;); // 获取手机内部短信

if (cur.moveToFirst()) {
int index_Address = cur.getColumnIndex(&quot;address&quot;);
int index_Person = cur.getColumnIndex(&quot;person&quot;);
int index_Body = cur.getColumnIndex(&quot;body&quot;);
int index_Date = cur.getColumnIndex(&quot;date&quot;);
int index_Type = cur.getColumnIndex(&quot;type&quot;);

do {
String strAddress = cur.getString(index_Address);
int intPerson = cur.getInt(index_Person);
String strbody = cur.getString(index_Body);
long longDate = cur.getLong(index_Date);
int intType = cur.getInt(index_Type);

SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);
Date d = new Date(longDate);
String strDate = dateFormat.format(d);

String strType = &quot;&quot;;
if (intType == 1) {
strType = &quot;接收&quot;;
} else if (intType == 2) {
strType = &quot;发送&quot;;
} else {
strType = &quot;null&quot;;
}

String strAddress2 = getPeopleNameFromPerson(strAddress);

smsBuilder.append(&quot;[ &quot;);
// smsBuilder.append(strAddress + &quot;, &quot;);
smsBuilder.append(strAddress + &quot; : &quot; + strAddress2 + &quot;, &quot;);
smsBuilder.append(intPerson + &quot;, &quot;);
smsBuilder.append(strbody + &quot;, &quot;);
smsBuilder.append(strDate + &quot;, &quot;);
smsBuilder.append(strType);
smsBuilder.append(&quot; ]\n\n&quot;);
} while (cur.moveToNext());

if (!cur.isClosed()) {
cur.close();
cur = null;
}
} else {
smsBuilder.append(&quot;no result!&quot;);
} // end if

smsBuilder.append(&quot;getSmsInPhone has executed!&quot;);

} catch (SQLiteException ex) {
Log.d(&quot;SQLiteException in getSmsInPhone&quot;, ex.getMessage());
}

return smsBuilder.toString();
}

// 通过address手机号关联Contacts联系人的显示名字
private String getPeopleNameFromPerson(String address){
if(address == null || address == &quot;&quot;){
return &quot;( no address )\n&quot;;
}

String strPerson = &quot;null&quot;;
String[] projection = new String[] {Phone.DISPLAY_NAME, Phone.NUMBER};

Uri uri_Person = Uri.withAppendedPath(ContactsContract.CommonDataKinds.Phone.CONTENT_FILTER_URI, address); // address 手机号过滤
Cursor cursor = getContentResolver().query(uri_Person, projection, null, null, null);

if(cursor.moveToFirst()){
int index_PeopleName = cursor.getColumnIndex(Phone.DISPLAY_NAME);
String strPeopleName = cursor.getString(index_PeopleName);
strPerson = strPeopleName;
}
cursor.close();

return strPerson;
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>479008</snippet_key>
<tag>297</tag>
<comment>短信 通讯录 sqlite 将address与通讯录中联系人姓名相关联</comment>
<code>// 通过address手机号关联Contacts联系人的显示名字
private String getPeopleNameFromPerson(String address){
if(address == null || address == &quot;&quot;){
return &quot;( no address )\n&quot;;
}

String strPerson = &quot;null&quot;;
String[] projection = new String[] {Phone.DISPLAY_NAME, Phone.NUMBER};

Uri uri_Person = Uri.withAppendedPath(ContactsContract.CommonDataKinds.Phone.CONTENT_FILTER_URI, address); // address 手机号过滤
Cursor cursor = getContentResolver().query(uri_Person, projection, null, null, null);

if(cursor.moveToFirst()){
int index_PeopleName = cursor.getColumnIndex(Phone.DISPLAY_NAME);
String strPeopleName = cursor.getString(index_PeopleName);
strPerson = strPeopleName;
}
cursor.close();

return strPerson;
}
</code>
</RECORD>
<RECORD>
<snippet_key>110349</snippet_key>
<tag>327</tag>
<comment>来自CSDN博客：Hadoop源码分析之开篇 http://blog.csdn.net/guimingyue/article/details/17297965#</comment>
<code>package test.fs;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FSDataInputStream;
import org.apache.hadoop.fs.FileStatus;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;


public class LoadDataFromHDFS {
public static void main(String[] args) throws IOException {
new LoadDataFromHDFS().loadFromHdfs(&quot;hdfs://localhost:9000/user/wordcount/&quot;);
}

public void loadFromHdfs(String hdfsPath) throws IOException {
Configuration conf = new Configuration();

Path hdfs = new Path(hdfsPath);

FileSystem in = FileSystem.get(conf);

FileStatus[] status = in.listStatus(hdfs);
for(int i = 0; i &lt; status.length; i++) {
BufferedReader br = new BufferedReader(new InputStreamReader(new FSDataInputStream(in.open(status[i].getPath()))));
String line = null;
while((line = br.readLine()) != null) {
System.out.println(line);
}
br.close();
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>479001</snippet_key>
<tag>297</tag>
<comment>通讯录 sqlite 读取Contacts代码</comment>
<code>package com.homer.phone;

import java.util.ArrayList;
import java.util.HashMap;

import android.app.Activity;
import android.database.Cursor;
import android.os.Bundle;
import android.provider.ContactsContract;
import android.provider.ContactsContract.CommonDataKinds.Phone;
import android.widget.ListView;
import android.widget.SimpleAdapter;

public class phoneRead extends Activity {

@Override
public void onCreate(Bundle savedInstanceState){
super.onCreate(savedInstanceState);

showListView();
}

private void showListView(){
ListView listView = new ListView(this);

ArrayList&lt;HashMap&lt;String, String&gt;&gt; list = getPeopleInPhone2();
SimpleAdapter adapter = new SimpleAdapter(
this,
list,
android.R.layout.simple_list_item_2,
new String[] {&quot;peopleName&quot;, &quot;phoneNum&quot;},
new int[]{android.R.id.text1, android.R.id.text2}
);
listView.setAdapter(adapter);

setContentView(listView);
}

private ArrayList&lt;HashMap&lt;String, String&gt;&gt; getPeopleInPhone2(){
ArrayList&lt;HashMap&lt;String, String&gt;&gt; list = new ArrayList&lt;HashMap&lt;String, String&gt;&gt;();

Cursor cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, null, null, null); // 获取手机联系人
while (cursor.moveToNext()) {
HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();

int indexPeopleName = cursor.getColumnIndex(Phone.DISPLAY_NAME); // people name
int indexPhoneNum = cursor.getColumnIndex(Phone.NUMBER); // phone number

String strPeopleName = cursor.getString(indexPeopleName);
String strPhoneNum = cursor.getString(indexPhoneNum);

map.put(&quot;peopleName&quot;, strPeopleName);
map.put(&quot;phoneNum&quot;, strPhoneNum);
list.add(map);
}
if(!cursor.isClosed()){
cursor.close();
cursor = null;
}

return list;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>110605</snippet_key>
<tag></tag>
<comment>来自CSDN博客：ICTCLAS2013  Java版本的使用方法  http://blog.csdn.net/hellonlp/article/details/8768611#</comment>
<code>String s = &quot;分词系统 NN&quot;;
byte[] ret = s.getBytes();
testNLPIR.NLPIR_AddUserWord(ret);
String s = &quot;分词系统&quot;;
byte[] ret = s.getBytes();
testNLPIR.NLPIR_DelUsrWord(ret);
</code>
</RECORD>
<RECORD>
<snippet_key>478986</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Climbing Stairs http://blog.csdn.net/yangmicheal/article/details/39755861#</comment>
<code>public class Solution {
public int climbStairs(int n) {
int[] count = new int[n+1];
count[0] = 1;
count[1] = 1;
for(int i=2; i&lt;=n; i++){
count[i] = count[i-1] + count[i-2];
}
return count[n];
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>241933</snippet_key>
<tag></tag>
<comment>来自CSDN博客：工厂方法 （java版）  http://blog.csdn.net/jimmylopez/article/details/21446913#</comment>
<code>&lt;strong&gt;&lt;em&gt;//Product&lt;/em&gt;&lt;/strong&gt;
public interface Work {

void doWork();
}
&lt;strong&gt;&lt;em&gt;

//ConcreteProduct&lt;/em&gt;&lt;/strong&gt;
public class StudentWork implements Work {

public void doWork() {
System.out.println(&quot;学生做作业!&quot;);
}

}
public class TeacherWork implements Work {

public void doWork() {
System.out.println(&quot;老师审批作业!&quot;);
}

}


&lt;strong&gt;&lt;em&gt;//Creator&lt;/em&gt;&lt;/strong&gt;
public interface IWorkFactory {

Work getWork();
}


&lt;strong&gt;&lt;em&gt;//ConcreteCreator&lt;/em&gt;&lt;/strong&gt;
public class StudentWorkFactory implements IWorkFactory {

public Work getWork() {
return new StudentWork();
}

}
public class TeacherWorkFactory implements IWorkFactory {

public Work getWork() {
return new TeacherWork();
}

}


&lt;strong&gt;&lt;em&gt;//Test&lt;/em&gt;&lt;/strong&gt;
public class Test {

public static void main(String[] args) {
IWorkFactory studentWorkFactory = new StudentWorkFactory();
studentWorkFactory.getWork().doWork();

IWorkFactory teacherWorkFactory = new TeacherWorkFactory();
teacherWorkFactory.getWork().doWork();
}

}

&lt;strong&gt;&lt;em&gt;//result&lt;/em&gt;&lt;/strong&gt;
学生做作业!
老师审批作业!
&lt;strong&gt;&lt;em&gt;//ConcreteProduct&lt;/em&gt;&lt;/strong&gt;
public class StudentWork implements Work {

public void doWork() {
System.out.println(&quot;学生做作业!&quot;);
}

}
public class TeacherWork implements Work {

public void doWork() {
System.out.println(&quot;老师审批作业!&quot;);
}

}
&lt;strong&gt;&lt;em&gt;//Creator&lt;/em&gt;&lt;/strong&gt;
public interface IWorkFactory {

Work getWork();
}
&lt;strong&gt;&lt;em&gt;//ConcreteCreator&lt;/em&gt;&lt;/strong&gt;
public class StudentWorkFactory implements IWorkFactory {

public Work getWork() {
return new StudentWork();
}

}
public class TeacherWorkFactory implements IWorkFactory {

public Work getWork() {
return new TeacherWork();
}

}
&lt;strong&gt;&lt;em&gt;//Test&lt;/em&gt;&lt;/strong&gt;
public class Test {

public static void main(String[] args) {
IWorkFactory studentWorkFactory = new StudentWorkFactory();
studentWorkFactory.getWork().doWork();

IWorkFactory teacherWorkFactory = new TeacherWorkFactory();
teacherWorkFactory.getWork().doWork();
}

}
&lt;strong&gt;&lt;em&gt;//result&lt;/em&gt;&lt;/strong&gt;
学生做作业!
老师审批作业!
</code>
</RECORD>
<RECORD>
<snippet_key>307725</snippet_key>
<tag></tag>
<comment>来自CSDN博客：文字根据状态更改颜色 http://blog.csdn.net/zxc1237890/article/details/24352535#</comment>
<code>&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item android:color=&quot;#006600&quot; android:state_selected=&quot;true&quot;/&gt;
    &lt;item android:color=&quot;#006600&quot; android:state_focused=&quot;true&quot;/&gt;
    &lt;item android:color=&quot;#006600&quot; android:state_pressed=&quot;true&quot;/&gt;
    &lt;item android:color=&quot;#999999&quot;/&gt;
&lt;/selector&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>373773</snippet_key>
<tag>327</tag>
<comment>来自CSDN博客：Java I/O  http://blog.csdn.net/bingduanlbd/article/details/28128153#</comment>
<code>import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/**
* @author Brandon B. Lin
*
*/
public class CopyBytes {

/**
* @param args
* @throws IOException
*/
public static void main(String[] args) throws IOException {
FileInputStream in = null;
FileOutputStream out = null;

try {
in = new FileInputStream(&quot;xanadu.txt&quot;);
out = new FileOutputStream(&quot;outagain.txt&quot;);
int c;

while ((c = in.read()) != -1) {
out.write(c);
}
} finally {
if (in != null) {
in.close();
}
if (out != null) {
out.close();
}
}

}

}
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

/**
* @author Brandon B. Lin
*
*/
public class CopyCharacter {

/**
* @param args
* @throws IOException
*/
public static void main(String[] args) throws IOException {
FileReader reader = null;
FileWriter writer = null;

try {
reader = new FileReader(&quot;xanadu.txt&quot;);
writer = new FileWriter(&quot;characteroutput.txt&quot;);
int c;

while ((c = reader.read()) != -1) {
writer.write(c);
}
} finally {
if (reader != null) {
reader.close();
}
if (writer != null) {
writer.close();
}
}

}

}
public class CopyLine {

/**
* @param args
* @throws IOException
*/
public static void main(String[] args) throws IOException {
BufferedReader br = null;
PrintWriter pr = null;

try {
br = new BufferedReader(new FileReader(&quot;xanadu.txt&quot;));
pr = new PrintWriter(new FileWriter(&quot;characteroutput.txt&quot;));
String line;

while( (line = br.readLine()) != null) {
pr.println(line);
}
} finally {
if (br != null) {
br.close();
}
if (pr != null) {
pr.close();
}
}

}
}
br = new BufferedReader(new FileReader(&quot;xanadu.txt&quot;));
pr = new PrintWriter(new FileWriter(&quot;characteroutput.txt&quot;));
public class ObjectStreams {

private static final String dataFile = &quot;invoicedata&quot;;
private static final BigDecimal[] prices = { new BigDecimal(&quot;9.99&quot;),
new BigDecimal(&quot;15.99&quot;), new BigDecimal(&quot;3.99&quot;),
new BigDecimal(&quot;4.99&quot;), };
private static final int[] units = { 12, 8, 13, 29, 50 };
private static final String[] descs = { &quot;Java T-shirt&quot;, &quot;Java Mug&quot;,
&quot;Duke Juggl&quot;, &quot;Java Pin&quot;, &quot;Java key chain&quot; };

public static void main(String[] args) throws IOException, ClassNotFoundException {
ObjectOutputStream out = null;
try { //写
out = new ObjectOutputStream(new BufferedOutputStream(
new FileOutputStream(dataFile)));
out.writeObject(Calendar.getInstance());
for (int i = 0; i &lt; prices.length; i++) {
out.writeObject(prices[i]);
out.writeInt(units[i]);
out.writeUTF(descs[i]);
}
} finally {
out.close();
}
// 读
ObjectInputStream in = null;
try {
in = new ObjectInputStream(new BufferedInputStream(
new FileInputStream(dataFile)));
Calendar date = null;
BigDecimal price;
int unit;
String desc;
BigDecimal total = new BigDecimal(0);

date = (Calendar) in.readObject();

System.out.format(&quot;One %tA, %&lt;tB %&lt;te, %&lt;tY:%n&quot;, date);

try {
while (true) {
price = (BigDecimal) in.readObject();
unit = in.readInt();
desc = in.readUTF();
System.out.format(&quot;You ordered %d units of %s at $%.2f%n&quot;,
unit, desc, price);
total = total.add(price.multiply(new BigDecimal(unit)));
}
} catch (EOFException e) {
System.out.format(&quot;For a TAOTAL of: $%.2f%n&quot;, total);
}
} finally {
in.close();
}

}
}
Object ob = new Object();
out.writeObject(ob);
out.writeObject(ob);
---------------------------
Object ob1 = in.readObject();
Object ob2 = in.readObject();
public static Console console()
public String readLine()
public char[] readPassword(String fmt,
Object... args)
public char[] readPassword()
public char[] readPassword(String fmt,
Object... args)
public class ConsoleTest {

/**
* @param args
*/
public static void main(String[] args) {
String input;
Console con;
char[] pw;
con = System.console();
if (con == null) {
System.out.println(&quot;Not console found!&quot;);
return;
}

input = con.readLine(&quot;Enter a String: &quot;);
con.printf(&quot;here is your string: %s\n&quot;, input);

pw = con.readPassword(&quot;Enter you password: &quot;);
con.printf(&quot;First character is : %s\n&quot;, pw[0]);
// use the password
java.util.Arrays.fill(pw, &apos; &apos;);
con.printf(&quot;Now nothing : %s\n&quot;, pw[0]);

}

}
Scanner sc = new Scanner（System.in)；
int i = sc.nextInt();
public static void main(String[] args) {
String input = &quot;1 fish 2 fish read fish blue fish&quot;;
String delimiter = &quot;\\s*fish\\s*&quot;;
Scanner sc = new Scanner(input).useDelimiter(delimiter);
System.out.println(sc.nextInt());
System.out.println(sc.nextInt());
System.out.println(sc.next());
System.out.println(sc.next());
sc.close();

}
1
2
read
blue
public static void main(String[] args) throws FileNotFoundException {
Scanner sc = null;

try {
sc = new Scanner(new BufferedReader(new FileReader(&quot;xanadu.txt&quot;)));

while (sc.hasNext()) {
System.out.println(sc.next());
}
} finally {
if (sc != null) {
sc.close();
}
}

}
Scanner sc = new ScannerďźSystem.in);
Scanner sc = new Scanner(new FileReader(&quot;test.txt&quot;);
public &lt;span style=&quot;background-color: rgb(255, 255, 0);&quot;&gt;Scanner &lt;/span&gt;useDelimiter(String pattern)ďź
public &lt;span style=&quot;background-color: rgb(255, 255, 0);&quot;&gt;Scanner &lt;/span&gt;useDelimiter(Pattern pattern)ďź
public Pattern delimiter()
public &lt;span style=&quot;background-color: rgb(255, 255, 0);&quot;&gt;Throwable&lt;/span&gt; initCause(Throwable cause)
public boolean hasNext()
public String next()
public boolean hasNext(String pattern)
public String next(String pattern)
public boolean hasNext(Pattern pattern)
public String next(Pattern pattern)
public boolean hasNextLine()
public String nextLine()
public static void main(String[] args) {
Scanner s = new Scanner(&quot;A B C D E \n F G&quot;);
int count = 1;
while (s.hasNext()) {
out.print(&quot;第&quot; + count + &quot;个片段：&quot;);
out.println(s.next());
count++;
if (count == 3 &amp;&amp; s.hasNextLine()) {
out.println(&quot;当前行剩余内容：&quot; + s.nextLine());
}
}

s.close();

}
第1个片段：A
第2个片段：B
當前行剩餘內容： C D E
第3个片段：F
第4个片段：G
public String findInLine(Pattern pattern)
public String findInLine(String pattern)
public static void main(String[] args) {

String s = &quot;Hello World! 3+3.0=6&quot;;

// create a new scanner with the specified String Object
Scanner scanner = new Scanner(s);

// find a string &quot;World&quot;
System.out.println(&quot;&quot; + scanner.findInLine(&quot;World&quot;));

// print the rest of the string
System.out.println(&quot;&quot; + scanner.nextLine());

// close the scanner
scanner.close();
}
World
! 3+3.0=6
public Scanner skip(Pattern pattern)
public Scanner skip(String pattern)
/**
* @param args
*/
public static void main(String[] args) {
String s = &quot;Hello World! Hello 3 + 3.0 = 6.0 true &quot;;

// create a new scanner with the specified String Object
Scanner scanner = new Scanner(s);

// skip the word &quot;Hello&quot;
scanner.skip(&quot;Hello&quot;);

// print a line of the scanner
System.out.println(&quot;&quot; + scanner.nextLine());

// close the scanner
scanner.close();


}
World! Hello 3 + 3.0 = 6.0 true
public static void main(String[] args) {
String s = &quot;Hello World! Hello 3 + 3.0 = 6.0 true &quot;;

// create a new scanner with the specified String Object
Scanner scanner = new Scanner(s);

// skip the word &quot;Hello&quot;
scanner.skip(&quot;Hello W&quot;);

// print a line of the scanner
System.out.println(&quot;&quot; + scanner.nextLine());

// close the scanner
scanner.close();


}
</code>
</RECORD>
<RECORD>
<snippet_key>374029</snippet_key>
<tag>327</tag>
<comment>来自CSDN博客：向文件中写入数据的简单操作  http://blog.csdn.net/u012575573/article/details/28239171#</comment>
<code>&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;//bos.close();
os.close();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>439565</snippet_key>
<tag>36</tag>
<comment>来自CSDN博客：第七课：Activity 及其子类的使用一：LauncherActivity  http://blog.csdn.net/sollor525/article/details/38317571#</comment>
<code>public class OtherActivity extends LauncherActivity
{
//定义两个Activity的名称
String[] names = {&quot;设置程序参数&quot; , &quot;查看星际兵种&quot;};
//定义两个Activity对应的实现类
Class&lt;?&gt;[] clazzs = {PreferenceActivityTest.class
, ExpandableListActivityTest.class};
@Override
public void onCreate(Bundle savedInstanceState)
{
super.onCreate(savedInstanceState);
ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this,
android.R.layout.simple_list_item_1 , names);
// 设置该窗口显示的列表所需的Adapter
setListAdapter(adapter);
}
//根据列表项来返回指定Activity对应的Intent
@Override public Intent intentForPosition(int position)
{
return new Intent(OtherActivity.this , clazzs[position]);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>112141</snippet_key>
<tag>爬虫 java</tag>
<comment>来自CSDN博客：java-httpclient通过title实现从baidu爬取相关网页链接  http://blog.csdn.net/q383965374/article/details/10006751#</comment>
<code>package CrawbaiduLink;

import info.monitorenter.cpdetector.io.ASCIIDetector;
import info.monitorenter.cpdetector.io.ByteOrderMarkDetector;
import info.monitorenter.cpdetector.io.CodepageDetectorProxy;
import info.monitorenter.cpdetector.io.JChardetFacade;
import info.monitorenter.cpdetector.io.UnicodeDetector;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.http.HttpEntity;
import org.apache.http.HttpHost;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.conn.routing.HttpRoute;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DecompressingHttpClient;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.PoolingClientConnectionManager;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.CoreConnectionPNames;
import org.apache.http.params.HttpParams;
import org.apache.http.util.EntityUtils;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;


/**
* 需要commons-logging.jar和commons-lang.jar包才能运行
*/








public class CrawbaiduLink_test {

final private static String URL= &quot;http://www.baidu.com/s?wd=&quot;;


/**
* HTTPCLIENT 连接管理
*/
/**
* 最大连接数
*/
public final static int MAX_TOTAL_CONNECTIONS = 800;
/**
* 获取连接的最大等待时间
*/
public final static int WAIT_TIMEOUT = 60000;
/**
* 每个路由最大连接数
*/
public final static int MAX_ROUTE_CONNECTIONS = 400;
/**
* 连接超时时间
*/
public final static int CONNECT_TIMEOUT = 10000;
/**
* 读取超时时间
*/
public final static int READ_TIMEOUT = 60000;

private static HttpClient httpClient;

private static DecompressingHttpClient decompressHttpClient;








/**
* 初始化HTTPCLIENT 需要包httpclient-4.2.5.jar和httpcore-4.2.4.jar
*/
public static void initHttpClient(){

HttpParams params = new BasicHttpParams();
SchemeRegistry schemeRegistry = new SchemeRegistry();
schemeRegistry.register(new Scheme(&quot;http&quot;, 80, PlainSocketFactory.getSocketFactory()));
schemeRegistry.register(new Scheme(&quot;https&quot;,443,SSLSocketFactory.getSocketFactory()));
PoolingClientConnectionManager cm = new PoolingClientConnectionManager(schemeRegistry);
httpClient = new DefaultHttpClient(cm, params);
decompressHttpClient = new DecompressingHttpClient(httpClient);
cm.setMaxTotal(MAX_TOTAL_CONNECTIONS);
cm.setDefaultMaxPerRoute(MAX_ROUTE_CONNECTIONS);
HttpHost localhost = new HttpHost(&quot;locahost&quot;, 80);
cm.setMaxPerRoute(new HttpRoute(localhost), 50);
httpClient.getParams().setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, CONNECT_TIMEOUT);
httpClient.getParams().setParameter(CoreConnectionPNames.SO_TIMEOUT, READ_TIMEOUT);

}

/**
* 初始化消息头
* @param httpGet
* @param url
* @throws URISyntaxException
*/
public static void initHeader(HttpGet httpGet,String url) throws URISyntaxException{
httpGet.setURI(new URI(url));
httpGet.addHeader(&quot;Accept-Language&quot;, &quot;en-us&quot;);
// httpGet.addHeader(&quot;Accept-Encoding&quot;, &quot;gzip,deflate&quot;);
}


/**
* 爬取网页 上所有内容
* @param httpClient
* @param url
* @return
*/
public static String crawlPageContent(HttpClient httpClient, String url){
HttpGet httpGet = new HttpGet();
InputStream inputStream = null;
try {
initHeader(httpGet,url);
HttpResponse response = httpClient.execute(httpGet);
HttpEntity entity = response.getEntity();
String encode = getEncoding(url);
if(encode.equals(&quot;windows-1252&quot;)){
encode = &quot;GBK&quot;;
}
if (entity != null) {
inputStream = entity.getContent();
String content = EntityUtils.toString(entity,encode);
return content;
}
return null;
} catch (ClientProtocolException e) {
e.printStackTrace();
} catch (IOException e) {
e.printStackTrace();
} catch (URISyntaxException e) {
e.printStackTrace();
} finally {
if (inputStream != null) {
try {
inputStream.close();
} catch (IOException e) {
e.printStackTrace();
}
}
}
return null;
}


/**
*分析页面编码 用到包cpdetector.jar,chardet.jar
*/

private static CodepageDetectorProxy detector;

public static String getEncoding(File document) {

CodepageDetectorProxy detector = CodepageDetectorProxy.getInstance();
detector.add(new ByteOrderMarkDetector());
detector.add(ASCIIDetector.getInstance());
detector.add(UnicodeDetector.getInstance());
detector.add(JChardetFacade.getInstance());
java.nio.charset.Charset charset = null;
try {
charset = detector.detectCodepage(document.toURI().toURL());
} catch (MalformedURLException e1) {
e1.printStackTrace();
} catch (IOException e1) {
e1.printStackTrace();
}
return charset.toString();
}

public static String getEncoding(String url) {
java.nio.charset.Charset charset = null;
detector = CodepageDetectorProxy.getInstance();
detector.add(new ByteOrderMarkDetector());
detector.add(ASCIIDetector.getInstance());
detector.add(UnicodeDetector.getInstance());
detector.add(JChardetFacade.getInstance());
try {
charset = detector.detectCodepage(new URL(url));
} catch (MalformedURLException e1) {
e1.printStackTrace();
} catch (IOException e1) {
e1.printStackTrace();
}
if (charset == null) {
return &quot;utf-8&quot;;
}
return charset.toString();
}

private final static Pattern regBaidu = Pattern
.compile(&quot;(?:(?:site:([^&apos;]+))?&apos;\\s*}\&quot;\\s*href=\&quot;)(http://www\\.baidu\\.com/link\\?url=[^\&quot;]+)&quot;);


/**
* 解析百度搜索出的页面提取链接
*
* @param content
* @return
*/
public static List&lt;Link&gt; parseBaiduSearchLinks(String content) {
List&lt;Link&gt; rst = new ArrayList&lt;Link&gt;();
Matcher mt = regBaidu.matcher(content);
while (mt.find()) {
Link tlink = new Link();
tlink.setDepth(0);
tlink.setParent(initPrimiryLink(&quot;www.baidu.com&quot;));
if (mt.group(1) != null) {
tlink.setSource(mt.group(1));
}
if (mt.group(2) != null) {
tlink.setUrl(mt.group(2));
rst.add(tlink);
}
}
return rst;
}

private static Link initPrimiryLink(String url){
Link link = new Link();
link.setDepth(0);
link.setParent(null);
link.setUrl(url);
return link;
}

public static void main(String[] args) {

String keyword=&quot;httpclient&quot;; //要查找的关键字
String Title=&quot;+博客园&quot;;//要找的网页的title内容
String url = URL + keyword + Title;

initHttpClient();

String content =crawlPageContent(httpClient,url);

List&lt;Link&gt; links = parseBaiduSearchLinks(content);

for(Link l : links ){
String pageContent = crawlPageContent(httpClient,l.getUrl());
Document doc = Jsoup.parse(pageContent);
String title = doc.title();
System.out.println(l.getUrl() + &quot; &quot; + title);
}


}


}
package CrawbaiduLink;
import java.util.Date;



public class Link {
private String uuid;
private String url;
private Date lastAccess; //上次访问时间
private Link parent; //父节点
private String source;
private int depth;

public int getDepth() {
return depth;
}
public void setDepth(int depth) {
this.depth = depth;
}
public String getUuid() {
return uuid;
}
public void setUuid(String uuid) {
this.uuid = uuid;
}
public String getUrl() {
return url;
}
public void setUrl(String url) {
this.url = url;
}
public Date getLastAccess() {
return lastAccess;
}
public void setLastAccess(Date lastAccess) {
this.lastAccess = lastAccess;
}
public Link getParent() {
return parent;
}
public void setParent(Link parent) {
this.parent = parent;
}
public String getSource() {
return source;
}
public void setSource(String source) {
this.source = source;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>478945</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Best Time to Buy and Sell Stock II http://blog.csdn.net/yangmicheal/article/details/39755289#</comment>
<code>public class Solution {
public int maxProfit(int[] prices) {
int profit = 0;
for(int i=0; i&lt;prices.length-1; i++){
if (prices[i]&lt;prices[i+1]){
profit += prices[i+1] - prices[i];
}
}
return profit;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>439821</snippet_key>
<tag></tag>
<comment>来自CSDN博客：How tomcat work 之 第十五章之Digester之ContextConfig之the defaultConfig Method  http://blog.csdn.net/luccs624061082/article/details/38324955#</comment>
<code>private void defaultConfig() {
// Open the default web.xml file, if it exists
File file = new File(Constants.DefaultWebXml);
if (!file.isAbsolute())
file = new File(System.getProperty(&quot;catalina.base&quot;),Constants.DefaultWebXml);
FileInputStream stream = null;
try{
stream = new FileInputStream(file.getCanonicalPath());
stream.close();
stream = null;
}
catch (FileNotFoundException e) {
log(sm.getString(&quot;contextConfig.defaultMissing&quot;));
return;
}
catch (IOException e) {
log(sm.getString(&quot;contextConfig.defaultMissing&quot;), e);
return;
}
// Process the default web.xml file
synchronized (webDigester) {
try {
InputSource is =new InputSource(&quot;file://&quot; + file.getAbsolutePath());
stream = new FileInputStream(file);
is.setByteStream(stream);
webDigester.setDebug(getDebug());
if (context instanceof StandardContext)
((StandardContext) context).setReplaceWelcomeFiles(true);
webDigester.clear();
webDigester.push(context);
webDigester.parse(is);
catch (SAXParseException e) {
log(sm.getString(&quot;contextConfig.defaultParse&quot;), e);
log(sm.getString(&quot;contextConfig.defaultPosition&quot;,&quot;&quot; + e.getLineNumber(), &quot;&quot; + e.getColumnNumber()));
ok = false;
}
catch (Exception e) {
log(sm.getString(&quot;contextConfig.defaultParse&quot;), e);
ok = false;
}
finally {
try {
if (stream != null) {
stream.close();
}
}
catch (IOException e) {
log(sm.getString(&quot;contextConfig.defaultClose&quot;), e);
}
}
}
}
synchronized (webDigester) {
try {
InputSource is =
new InputSource(&quot;file://&quot; + file.getAbsolutePath());
stream = new FileInputStream(file);
is.setByteStream(stream);
webDigester.setDebug(getDebug());
if (context instanceof StandardContext)
((StandardContext) context).setReplaceWelcomeFiles(true);
webDigester.clear();
webDigester.push(context);
webDigester.parse(is);
private void applicationConfig() {
// Open the application web.xml file, if it exists
InputStream stream = null;
ServletContext servletContext = context.getServletContext();
if (servletContext != null)
stream = servletContext.getResourceAsStream(Constants.ApplicationWebXml);
if (stream == null) {
log(sm.getString(&quot;contextConfig.applicationMissing&quot;));
return;
}

// Process the application web.xml file
synchronized (webDigester) {
try {
URL url =
servletContext.getResource(Constants.ApplicationWebXml);

InputSource is = new InputSource(url.toExternalForm());
is.setByteStream(stream);
webDigester.setDebug(getDebug());
if (context instanceof StandardContext) {
((StandardContext) context).setReplaceWelcomeFiles(true);
}
webDigester.clear();
webDigester.push(context);
webDigester.parse(is);
}
catch (SAXParseException e) {
log(sm.getString(&quot;contextConfig.applicationParse&quot;), e);
log(sm.getString(&quot;contextConfig.applicationPosition&quot;,&quot;&quot; + e.getLineNumber(),&quot;&quot; + e.getColumnNumber()));
ok = false;
}
catch (Exception e) {
log(sm.getString(&quot;contextConfig.applicationParse&quot;), e);
ok = false;
}
finally {
try {
if (stream != null){
stream.close();
}
}
catch (IOException e) {
log(sm.getString(&quot;contextConfig.applicationClose&quot;),e);
}
}
}
}
private static Digester createWebDigester() {
URL url = null;
Digester webDigester = new Digester();
webDigester.setValidating(true);
url = ContextConfig.class.getResource(Constants.WebDtdResourcePath_22);
webDigester.register(Constants.WebDtdPublicId_22,url.toString());
url = ContextConfig.class.getResource(Constants.WebDtdResourcePath_23);
webDigester.register(Constants.WebDtdPublicId_23,url.toString());
url.toString());
webDigester.addRuleSet(new WebRuleSet());
return (webDigester);
}

package org.apache.catalina.startup;

import java.lang.reflect.Method;
import org.apache.catalina.Context;
import org.apache.catalina.Wrapper;
import org.apache.catalina.deploy.SecurityConstraint;
import org.apache.commons.digester.Digester;
import org.apache.commons.digester.Rule;
import org.apache.commons.digester.RuleSetBase;
import org.xml.sax.Attributes;


public class WebRuleSet extends RuleSetBase {
protected String prefix = null;
public WebRuleSet () {
this(&quot;&quot;);
}

public WebRuleSet(String prefix) {
super();
this.namespaceURI = null;
this.prefix = prefix;
}

public void addRuleInstances(Digester digester) {
digester.addRule(prefix + &quot;web-app&quot;,new SetPublicIdRule(digester, &quot;setPublicId&quot;));
digester.addCallMethod(prefix + &quot;web-app/context-param&quot;,&quot;addParameter&quot;, 2);
digester.addCallParam(prefix +&quot;web-app/context-param/param-name&quot;, 0);
digester.addCallParam(prefix +&quot;web-app/context-param/param-value&quot;, 1);
digester.addCallMethod(prefix + &quot;web-app/display-name&quot;,&quot;setDisplayName&quot;, 0);
digester.addRule(prefix + &quot;web-app/distributable&quot;,new SetDistributableRule(digester));
...
digester.addObjectCreate(prefix + &quot;web-app/filter&quot;,&quot;org.apache.catalina.deploy.FilterDef&quot;);
digester.addSetNext(prefix + &quot;web-app/filter&quot;, &quot;addFilterDef&quot;,&quot;org.apache.catalina.deploy.FilterDef&quot;);
digester.addCallMethod(prefix + &quot;web-app/filter/description&quot;,&quot;setDescription&quot;, 0);
digester.addCallMethod(prefix + &quot;web-app/filter/display-name&quot;, &quot;setDisplayName&quot;, 0);
digester.addCallMethod(prefix + &quot;web-app/filter/filter-class&quot;,&quot;setFilterClass&quot;, 0);
digester.addCallMethod(prefix + &quot;web-app/filter/filter-name&quot;,&quot;setFilterName&quot;, 0);
digester.addCallMethod(prefix + &quot;web-app/filter/large-icon&quot;,&quot;setLargeIcon&quot;, 0);
digester.addCallMethod(prefix + &quot;web-app/filter/small-icon&quot;,&quot;setSmallIcon&quot;, 0);
digester.addCallMethod(prefix + &quot;web-app/filter/init-param&quot;,&quot;addInitParameter&quot;, 2);
digester.addCallParam(prefix +&quot;web-app/filter/init-param/param-name&quot;, 0);
digester.addCallParam(prefix +&quot;web-app/filter/init-param/param-value&quot;, 1);
digester.addObjectCreate(prefix + &quot;web-app/filter-mapping&quot;,&quot;org.apache.catalina.deploy.FilterMap&quot;);
digester.addSetNext(prefix + &quot;web-app/filter-mapping&quot;,&quot;addFilterMap&quot;, &quot;org.apache.catalina.deploy.FilterMap&quot;);
digester.addCallMethod(prefix +&quot;web-app/filter-mapping/filter-name&quot;, &quot;setFilterName&quot;, 0);
digester.addCallMethod(prefix +&quot;web-app/filter-mapping/servlet-name&quot;, &quot;setServletName&quot;, 0);
digester.addCallMethod(prefix +&quot;web-app/filter-mapping/url-pattern&quot;, &quot;setURLPattern&quot;, 0);
digester.addCallMethod (prefix +&quot;web-app/listener/listener-class&quot;, &quot;addApplicationListener&quot;, 0);
...
digester.addRule(prefix + &quot;web-app/servlet&quot;,new WrapperCreateRule(digester));
digester.addSetNext(prefix + &quot;web-app/servlet&quot;,&quot;addChild&quot;, &quot;org.apache.catalina.Container&quot;);
digester.addCallMethod(prefix + &quot;web-app/servlet/init-param&quot;,&quot;addInitParameter&quot;, 2);
digester.addCallParam(prefix +&quot;web-app/servlet/init-param/param-name&quot;, 0);
digester.addCallParam(prefix +&quot;web-app/servlet/init-param/param-value&quot;, 1);
digester.addCallMethod(prefix + &quot;web-app/servlet/jsp-file&quot;,&quot;setJspFile&quot;, 0);
digester.addCallMethod(prefix +&quot;web-app/servlet/load-on-startup&quot;, &quot;setLoadOnStartupString&quot;, 0);
digester.addCallMethod(prefix +&quot;web-app/servlet/run-as/role-name&quot;, &quot;setRunAs&quot;, 0);
digester.addCallMethod(prefix +&quot;web-app/servlet/security-role-ref&quot;, &quot;addSecurityReference&quot;, 2);
digester.addCallParam(prefix +&quot;web-app/servlet/security-role-ref/role-link&quot;, 1);
digester.addCallParam(prefix +&quot;web-app/servlet/security-role-ref/role-name&quot;, 0);
digester.addCallMethod(prefix + &quot;web-app/servlet/servlet-class&quot;,&quot;setServletdass&quot;, 0);
digester.addCallMethod(prefix + &quot;web-app/servlet/servlet-name&quot;,&quot;setName&quot;, 0);
digester.addCallMethod(prefix + &quot;web-app/servlet-mapping&quot;,&quot;addServletMapping&quot;, 2);
digester.addCallParam(prefix +&quot;web-app/servlet-mapping/servlet-name&quot;/ 1);
digester.addCallParam(prefix +&quot;web-app/servlet-mapping/url-pattern&quot;, 0);
digester.addCallMethod (prefix +&quot;web-app/session-config/session-timeout&quot;, &quot;setSessionTimeout&quot;, 1,new Class[] { Integer.TYPE });
digester.addCallParam(prefix +&quot;web-app/session-config/session-timeout&quot;, 0);
digester.addCallMethod(prefix + &quot;web-app/taglib&quot;,&quot;addTaglib&quot;, 2);
digester.addCallParam(prefix + &quot;web-app/taglib/taglib-location&quot;,1);
digester.addCallParam(prefix + &quot;web-app/taglib/taglib-uri&quot;, 0);
digester.addCallMethod(prefix +&quot;web-app/welcome-file-list/welcome-file&quot;, &quot;addWelcomeFile&quot;, 0);
}
}

// --------------------------------------------- Private Classes
final class SetAuthConstraintRule extends Rule {
public SetAuthConstraintRule(Digester digester) {
super(digester);
}
public void begin(Attributes attributes) throws Exception {
SecurityConstraint securityConstraint = (SecurityConstraint) digester.peek();
securityConstraint.setAuthConstraint(true);
if (digester.getDebug() &gt; 0)
digester.log(&quot;Calling
SecurityConstraint.setAuthConstraint(true)&quot;);
}
}

...

final class WrapperCreateRule extends Rule {
public WrapperCreateRule(Digester digester) {
super(digester);
}

public void begin(Attributes attributes) throws Exception {
Context context =(Context) digester.peek(digester.getCount() - 1);
Wrapper wrapper = context.createWrapper();
digester.push(wrapper);
if (digester.getDebug() &gt; 0)
digester.log(&quot;new &quot; + wrapper.getClass().getName());
}

public void end() throws Exception {
Wrapper wrapper = (Wrapper) digester.pop();
if (digester.getDebug() &gt; 0)
digester.log(&quot;pop &quot; + wrapper.getclass().getName());
}
}



</code>
</RECORD>
<RECORD>
<snippet_key>478938</snippet_key>
<tag>327</tag>
<comment>来自CSDN博客：groovy : poi 读取 Excel xlsx  http://blog.csdn.net/belldeep/article/details/39721345#</comment>
<code>package xlsx;
import javax.swing.JFileChooser
import javax.swing.filechooser.FileFilter
import javax.swing.filechooser.FileNameExtensionFilter
import java.io.File;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

class ReadExcel {

//取得日期列
private static String getDataCellVal(XSSFCell cell) {
Date date = cell.getDateCellValue();
def format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
return format.format(date);
}

private static String getCellVal(XSSFCell cell) {
if (cell.getCellType() == XSSFCell.CELL_TYPE_BLANK) {
return &quot;&quot;
} else if (cell.getCellType() == XSSFCell.CELL_TYPE_BOOLEAN) {
return cell.getBooleanCellValue();
} else if (cell.getCellType() == XSSFCell.CELL_TYPE_ERROR) {
return cell.getErrorCellValue();
} else if (cell.getCellType() == XSSFCell.CELL_TYPE_NUMERIC) {
return cell.getNumericCellValue();
} else if (cell.getCellType() == XSSFCell.CELL_TYPE_STRING) {
return cell.getStringCellValue();
} else {
return cell.getStringCellValue();
}
}

private static String getFilename(String initDir) {
if (initDir==null || initDir==&apos;&apos;) initDir=&apos;.&apos;;
def chooser=new JFileChooser(initDir)
def filter = new FileNameExtensionFilter(&apos;Excel&apos;, &apos;xlsx&apos;)
chooser.setFileFilter(filter)
chooser.setDialogTitle(&quot;Open&quot;)
if(chooser.showSaveDialog() == JFileChooser.APPROVE_OPTION)
return chooser.getSelectedFile()
else if(chooser.showSaveDialog() == JFileChooser.CANCEL_OPTION)
return null
else
return null
}

void readExcel(String initDir) {
def filename = getFilename(initDir)
if (filename==null) return;
def outfile = new File(filename.replace(&apos;xlsx&apos;,&apos;txt&apos;));
def fp = outfile.newPrintWriter();
println filename
XSSFWorkbook wb = new XSSFWorkbook(new FileInputStream(filename));

(0..&lt;wb.numberOfSheets).each{
XSSFSheet sheet = wb.getSheetAt(it)
int rows = sheet.physicalNumberOfRows
println &quot; sheet:\&quot;&quot; + wb.getSheetName(it) + &quot;\&quot; has &quot; + rows + &quot; row(s).&quot;
(0..&lt;rows).each{ r -&gt;
XSSFRow row = sheet.getRow(r)
if (row != null) {
int cells = row.physicalNumberOfCells
// println &quot;\nROW &quot; + row.rowNum + &quot; has &quot; + cells + &quot; cell(s).&quot;
(0..&lt;cells).each{ c -&gt;
XSSFCell cell = row.getCell(c)
if (cell == null){
if(c==(cells-1)) fp.println &apos;&apos;;
else fp.print &apos;\t&apos;;
}else{
if(c==(cells-1)) fp.println getCellVal(cell);
else fp.print getCellVal(cell)+&apos;\t&apos;;
}
}
}
}
}
fp.flush();
fp.close();
}

static void main(args) {
def app = new ReadExcel();
if (args.size()==1)
app.readExcel(args[0]);
else
app.readExcel(&apos;.&apos;);
}
}
@echo off
set JarPATH=%GROOVY_HOME%/embeddable/groovy-all-1.8.9.jar
set JarPATH=%JarPATH%;%GROOVY_HOME%/lib/poi-3.10-FINAL-20140208.jar
set JarPATH=%JarPATH%;%GROOVY_HOME%/lib/poi-ooxml-3.10-FINAL-20140208.jar
set JarPATH=%JarPATH%;%GROOVY_HOME%/lib/poi-ooxml-schemas-3.10-FINAL-20140208.jar
set JarPATH=%JarPATH%;%GROOVY_HOME%/lib/dom4j-1.6.1.jar
set JarPATH=%JarPATH%;%GROOVY_HOME%/lib/stax-api-1.0.1.jar
set JarPATH=%JarPATH%;%GROOVY_HOME%/lib/xmlbeans-2.3.0.jar
java -cp %JarPATH%;. xlsx.ReadExcel

pause
package xlsx;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;
import java.io.File;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

class ReadExcel {

//取得日期列
private static String getDataCellVal(XSSFCell cell) {
Date date = cell.getDateCellValue();
def format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
return format.format(date);
}

private static String getCellVal(XSSFCell cell) {
if (cell.getCellType() == XSSFCell.CELL_TYPE_BLANK) {
return &quot;&quot;
} else if (cell.getCellType() == XSSFCell.CELL_TYPE_BOOLEAN) {
return cell.getBooleanCellValue();
} else if (cell.getCellType() == XSSFCell.CELL_TYPE_ERROR) {
return cell.getErrorCellValue();
} else if (cell.getCellType() == XSSFCell.CELL_TYPE_NUMERIC) {
return cell.getNumericCellValue();
} else if (cell.getCellType() == XSSFCell.CELL_TYPE_STRING) {
return cell.getStringCellValue();
} else {
return cell.getStringCellValue();
}
}

private static String getFilename(String initDir) {
if (initDir==null || initDir==&apos;&apos;) initDir=&apos;.&apos;;
def chooser=new JFileChooser(initDir)
def filter = new FileNameExtensionFilter(&apos;Excel&apos;, &apos;xlsx&apos;)
chooser.setFileFilter(filter)
chooser.setDialogTitle(&quot;Open&quot;)
if(chooser.showSaveDialog() == JFileChooser.APPROVE_OPTION)
return chooser.getSelectedFile()
else if(chooser.showSaveDialog() == JFileChooser.CANCEL_OPTION)
return null
else
return null
}

void readExcel(String filename) {
if (filename==null || filename==&apos;&apos;) return;
def outfile = new File(filename.replace(&apos;.xlsx&apos;,&apos;.txt&apos;));
def fp = outfile.newPrintWriter();
println filename
XSSFWorkbook wb = new XSSFWorkbook(new FileInputStream(filename));

(0..&lt;wb.numberOfSheets).each{
XSSFSheet sheet = wb.getSheetAt(it)
int rows = sheet.physicalNumberOfRows
println &quot; sheet:\&quot;&quot; + wb.getSheetName(it) + &quot;\&quot; has &quot; + rows + &quot; row(s).&quot;
(0..&lt;rows).each{ r -&gt;
XSSFRow row = sheet.getRow(r)
if (row != null) {
int cells = row.physicalNumberOfCells
// println &quot;\nROW &quot; + row.rowNum + &quot; has &quot; + cells + &quot; cell(s).&quot;
(0..&lt;cells).each{ c -&gt;
XSSFCell cell = row.getCell(c)
if (cell == null){
if(c==(cells-1)) fp.println &apos;&apos;;
else fp.print &apos;\t&apos;;
}else{
if(c==(cells-1)) fp.println getCellVal(cell);
else fp.print getCellVal(cell)+&apos;\t&apos;;
}
}
}
}
}
fp.flush();
fp.close();
}

static void main(args) {
def filename =null;
if (args.size()==1)
filename = getFilename(args[0]);
else
filename = getFilename(&apos;.&apos;);
if (filename==null) return;
def app = new ReadExcel();
app.readExcel(filename);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>46861</snippet_key>
<tag>303,184</tag>
<comment>自己写的一个递归分析指定页面链接重复度的类</comment>
<code>import java.net.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.io.*;

public class FindHttp {
public static void setProxy(String host, String port) {
System.setProperty(&quot;proxySet&quot;, &quot;true&quot;);
System.setProperty(&quot;proxyHost&quot;, host);
System.setProperty(&quot;proxyPort&quot;, port);
}

/**
* @param args
* @throws IOException
*/
public static void main(String[] args) throws IOException {
// TODO Auto-generated method stub
setProxy(ip, port);
Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();
ObjectOutputStream outFile = new ObjectOutputStream(new FileOutputStream(new File(&quot;result.txt&quot;)));
FileOutputStream console_to_file = new FileOutputStream(new File(&quot;console.txt&quot;));
PrintStream new_console = new PrintStream(console_to_file);
System.setOut(new_console);
String sURL = &quot;http://www.163.com&quot;;
queue.add(sURL);
int i = 5;
while (i-- &gt; 0&amp;&amp; !queue.isEmpty()) {
String s = queue.remove();
System.out.println(&quot;visiting &quot;+s);
URL url = new URL(s);
BufferedReader in = new BufferedReader(new InputStreamReader(url
.openStream()));
String tmp;
StringBuilder sb = new StringBuilder();
while ((tmp = in.readLine()) != null)
sb.append(tmp + &quot;\n&quot;);// out.write(s);
String test = sb.toString();

String regEx_ref = &quot;&lt;a.*?/a&gt;&quot;;
Pattern p = Pattern.compile(regEx_ref, Pattern.DOTALL);
Matcher m = p.matcher(test);
String ss = &quot;&quot;;
while (m.find())
ss += m.group();

String regEx_link = &quot;(http:.*?)\&quot;&quot;;
p = Pattern.compile(regEx_link, Pattern.DOTALL);
m = p.matcher(ss);
while (m.find())
{
String result = m.group(1);
//System.out.println(m.group(1));
map.put(result, map.get(result)==null?1:map.get(result)+1);
queue.offer(result);
}
}

List&lt;Map.Entry&lt;String, Integer&gt;&gt; infoIds =
new ArrayList&lt;Map.Entry&lt;String, Integer&gt;&gt;(map.entrySet());
Collections.sort(infoIds,new Comparator&lt;Map.Entry&lt;String,Integer&gt;&gt;(){
public int compare(Map.Entry&lt;String,Integer&gt; o1,Map.Entry&lt;String,Integer&gt; o2){
return o1.getValue()-o2.getValue();
}
}
);
for (int i2 = 0; i2 &lt; infoIds.size(); i2++) {
String id = infoIds.get(i2).toString();
System.out.println(id);
}
System.out.println(infoIds.size());
outFile.writeObject(map);
//System.out.println(map);

}

}
</code>
</RECORD>
<RECORD>
<snippet_key>478935</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Single Number http://blog.csdn.net/yangmicheal/article/details/39755115#</comment>
<code>public class Solution {
public int singleNumber(int[] A) {
int[] bits = new int[32];
int result = 0;
for (int i=0; i&lt;bits.length; i++){
for (int j=0; j&lt;A.length; j++){
bits[i] += A[j]&gt;&gt;i&amp;1;
bits[i] %= 2;
}
result |= (bits[i]&lt;&lt;i);
}
return result;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>243725</snippet_key>
<tag></tag>
<comment>来自CSDN博客：android 开机启动程序 http://blog.csdn.net/yanggz888/article/details/21483919#</comment>
<code>public class StartupReceiver extends BroadcastReceiver {

@Override
public void onReceive(Context context, Intent intent) {
// TODO Auto-generated method stub
Intent i = new Intent(context,Hello.class);
i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
//将intent以startActivity传送给操作系统
context.startActivity(i);

}

}
</code>
</RECORD>
<RECORD>
<snippet_key>440333</snippet_key>
<tag></tag>
<comment>来自CSDN博客：判断当前art 还是dalvik http://blog.csdn.net/lm43336193/article/details/38339555#</comment>
<code>private CharSequence getCurrentRuntimeValue() {
try {
Class&lt;?&gt; systemProperties = Class.forName(&quot;android.os.SystemProperties&quot;);
try {
Method get = systemProperties.getMethod(&quot;get&quot;,
String.class, String.class);
if (get == null) {
return &quot;WTF?!&quot;;
}
try {
final String value = (String)get.invoke(
systemProperties, SELECT_RUNTIME_PROPERTY,
/* Assuming default is */&quot;Dalvik&quot;);
if (LIB_DALVIK.equals(value)) {
return &quot;Dalvik&quot;;
} else if (LIB_ART.equals(value)) {
return &quot;ART&quot;;
} else if (LIB_ART_D.equals(value)) {
return &quot;ART debug build&quot;;
}

return value;
} catch (IllegalAccessException e) {
return &quot;IllegalAccessException&quot;;
} catch (IllegalArgumentException e) {
return &quot;IllegalArgumentException&quot;;
} catch (InvocationTargetException e) {
return &quot;InvocationTargetException&quot;;
}
} catch (NoSuchMethodException e) {
return &quot;SystemProperties.get(String key, String def) method is not found&quot;;
}
} catch (ClassNotFoundException e) {
return &quot;SystemProperties class is not found&quot;;
}
}}
</code>
</RECORD>
<RECORD>
<snippet_key>47373</snippet_key>
<tag>39</tag>
<comment>jdk7中java.util中一级类 </comment>
<code>AbstractCollection.java
AbstractList.java
AbstractMap.java
AbstractQueue.java
AbstractSequentialList.java
AbstractSet.java
ArrayDeque.java
ArrayList.java
Arrays.java
BitSet.java
Calendar.java
Collection.java
Collections.java
ComparableTimSort.java
Comparator.java
ConcurrentModificationException.java
Currency.java
Date.java
Deque.java
Dictionary.java
DualPivotQuicksort.java
DuplicateFormatFlagsException.java
EmptyStackException.java
Enumeration.java
EnumMap.java
EnumSet.java
EventListener.java
EventListenerProxy.java
EventObject.java
FormatFlagsConversionMismatchException.java
Formattable.java
FormattableFlags.java
Formatter.java
FormatterClosedException.java
GregorianCalendar.java
HashMap.java
HashSet.java
Hashtable.java
IdentityHashMap.java
IllegalFormatCodePointException.java
IllegalFormatConversionException.java
IllegalFormatException.java
IllegalFormatFlagsException.java
IllegalFormatPrecisionException.java
IllegalFormatWidthException.java
IllformedLocaleException.java
InputMismatchException.java
InvalidPropertiesFormatException.java
Iterator.java
JapaneseImperialCalendar.java
JumboEnumSet.java
LinkedHashMap.java
LinkedHashSet.java
LinkedList.java
List.java
ListIterator.java
ListResourceBundle.java
Locale.java
LocaleISOData.java
Map.java
MissingFormatArgumentException.java
MissingFormatWidthException.java
MissingResourceException.java
NavigableMap.java
NavigableSet.java
NoSuchElementException.java
Objects.java
Observable.java
Observer.java
PriorityQueue.java
Properties.java
PropertyPermission.java
PropertyResourceBundle.java
Queue.java
Random.java
RandomAccess.java
RegularEnumSet.java
ResourceBundle.java
Scanner.java
ServiceConfigurationError.java
ServiceLoader.java
Set.java
SimpleTimeZone.java
SortedMap.java
SortedSet.java
Stack.java
StringTokenizer.java
Timer.java
TimerTask.java
TimeZone.java
TimSort.java
TooManyListenersException.java
TreeMap.java
TreeSet.java
UnknownFormatConversionException.java
UnknownFormatFlagsException.java
UUID.java
Vector.java
WeakHashMap.java
XMLUtils.java
</code>
</RECORD>
<RECORD>
<snippet_key>112909</snippet_key>
<tag>453</tag>
<comment>来自CSDN博客：Merge k Sorted Lists 合并k个有序链表@LeetCode  http://blog.csdn.net/hellobinfeng/article/details/17333189#</comment>
<code>package Level3;

import java.util.ArrayList;

import Utility.ListNode;

/**
* Merge k Sorted Lists
* Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
*
*/
public class S23 {

public static void main(String[] args) {
int[] a = {1,2,3};
ListNode aLN = ListNode.create(a);
ArrayList&lt;ListNode&gt; lists = new ArrayList&lt;ListNode&gt;();
lists.add(aLN);
ListNode h = mergeKLists(lists);
h.print();
}

public static ListNode mergeKLists(ArrayList&lt;ListNode&gt; lists) {
ListNode mergedHead = new ListNode(-1); // 利用dummy作为表头
ListNode[] ptrs = new ListNode[lists.size()]; // 指针指向每一个ListNode

for(int i=0; i&lt;lists.size(); i++){ // 初始化指针数组
ptrs[i] = lists.get(i);
}

ListNode mergedCur = mergedHead;
boolean run = true;
while(true){
run = false; // run用来检测是否所有的链表都已经遍历完了，即指针为null
int val = Integer.MAX_VALUE;
int minIndex = 0;
for(int j=0; j&lt;ptrs.length; j++){ // 找到最小的那一个表头
if(ptrs[j] != null){
run = true;
if(ptrs[j].val &lt; val){
val = ptrs[j].val;
minIndex = j;
}
}
}
if(!run){ // 及时退出
break;
}
mergedCur.next = new ListNode(ptrs[minIndex].val); // 更新merged链表和最小的表头指针
ptrs[minIndex] = ptrs[minIndex].next;
mergedCur = mergedCur.next;
}

return mergedHead.next;
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>309517</snippet_key>
<tag>leetcode recursion</tag>
<comment>来自CSDN博客：LeetCode刷题笔录 Pow(x,n) http://blog.csdn.net/likecool21/article/details/24407153#</comment>
<code>public class Solution {
public double pow(double x, int n) {
double result = powHelper(x, n);
if(n &lt; 0)
result = 1 / result;
return result;
}

public double powHelper(double x, int n){
if(n == 0)
return 1.0;
double w = powHelper(x, n / 2);
if(n % 2 == 0)
return w * w;
else
return w * w * x;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>113165</snippet_key>
<tag>Hadoop hdfs 文件读写</tag>
<comment>来自CSDN博客：访问Hadoop的HDFS文件系统的Java实现  http://blog.csdn.net/wzhg0508/article/details/17335589#</comment>
<code>Configuration config = new Configuration();
config.set(&quot;fs.default.name&quot;,&quot;hdfs://127.0.0.1:9000/&quot;);
FileSystem dfs = FileSystem.get(config);
String dirName = &quot;TestDirectory&quot;;
Path src = new Path(dfs.getWorkingDirectory()+&quot;/&quot;+dirName);
dfs.mkdirs(src);
String subDirName = &quot;subDirectory&quot;;
Path src = new Path(dfs.getWorkingDirectory()+&quot;/TestDirectory/&quot;+ subDirName);
dfs.mkdirs(src);
String dirName = &quot;TestDirectory&quot;;
Path src = new Path(dfs.getWorkingDirectory()+&quot;/&quot;+dirName);
Dfs.delete(src);
Path src = new Path(&quot;E://HDFS/file1.txt&quot;);

Path dst = new Path(dfs.getWorkingDirectory()+&quot;/TestDirectory/subDirectory/&quot;);

dfs.copyFromLocalFile(src, dst);
Path src = new Path(dfs.getWorkingDirectory()+&quot;/TestDirectory/subDirectory/file1.txt&quot;);

Path dst = new Path(&quot;E://HDFS/&quot;);

dfs.copyToLocalFile(src, dst);
Path src = new Path(dfs.getWorkingDirectory()+&quot;/TestDirectory/subDirectory/file2.txt&quot;);

dfs.createNewFile(src);
Path src = new Path(dfs.getWorkingDirectory()+&quot;/TestDirectory/subDirectory/file2.txt&quot;);

FileInputStream fis = new FileInputStream(&quot;E://HDFS/file1.txt&quot;);

int len = fis.available();

byte[] btr = new byte[len];

fis.read(btr);

FSDataOutputStream fs = dfs.create(src);

fs.write(btr);

fs.close();
Path src = new Path(dfs.getWorkingDirectory()+&quot;/TestDirectory/subDirectory/file1.txt&quot;);

FSDataInputStream fs = dfs.open(src);

String str = null;

while ((str = fs.readline())!= null)
{
System.out.println(str);
}
Path src = new Path(dfs.getWorkingDirectory()+&quot;/TestDirectory/HDFS/file1.txt&quot;);

System.out.println(dfs.exists(src));
System.out.println(dfs.getDefaultBlockSize());
System.out.println(dfs.getDefaultReplication());
Path src = new Path(dfs.getWorkingDirectory()+&quot;/TestDirectory/subDirectory/file1.txt&quot;);
System.out.println(dfs.isDirectory(src));
System.out.println(dfs.isFile(src));
</code>
</RECORD>
<RECORD>
<snippet_key>47885</snippet_key>
<tag>414</tag>
<comment>java 生成code128b字符串</comment>
<code>/**
* 生成code128b字符串
* &lt;p&gt;
* &lt;div&gt;Code128编码规则：开始位 ＋［FNC1(为EAN128码时加)］ ＋数据位 ＋检验位 ＋结束位&lt;/div&gt;
* &lt;div&gt;Code128检验位计算：（开始位对应的ID值 ＋每位数据在整个数据中的位置×每位数据对应的ID值）% 103&lt;/div&gt;
* &lt;div&gt;“起始符、要打印的字符串、校验码、终止符”其中起始符，字符集A为：Ë、字符集B为：Ì、字符集C为：Í ；终止符：Î&lt;/div&gt;
* &lt;table&gt;
* &lt;tr&gt;&lt;td&gt; 编码方式 &lt;/td&gt; &lt;td&gt; 开始位 &lt;/td&gt; &lt;td&gt; FNC1 &lt;/td&gt; &lt;td&gt; 数据位 &lt;/td&gt; &lt;td&gt; 检验位 &lt;/td&gt; &lt;td&gt; 结束位 &lt;/td&gt;&lt;/tr&gt;
* &lt;tr&gt;&lt;td&gt;Code128A&lt;/td&gt; &lt;td&gt;StartA&lt;/td&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;9 + 5&lt;/td&gt; &lt;td&gt;(103 + 1*25 + 2*21) % 103 = 66&lt;/td&gt; &lt;td&gt;Stop&lt;/td&gt;&lt;/tr&gt;
* &lt;tr&gt;&lt;td&gt;Code128B&lt;/td&gt; &lt;td&gt;StartB&lt;/td&gt; &lt;td&gt; 无&lt;/td&gt; &lt;td&gt;9 + 5&lt;/td&gt; &lt;td&gt;(104 + 1*25 + 2*21) % 103 = 67&lt;/td&gt; &lt;td&gt;Stop &lt;/td&gt;&lt;/tr&gt;
* &lt;tr&gt;&lt;td&gt;Code128C&lt;/td&gt; &lt;td&gt;StartC &lt;/td&gt; &lt;td&gt;无 &lt;/td&gt; &lt;td&gt;95&lt;/td&gt; &lt;td&gt;(105 + 1*95) % 103 = 97 &lt;/td&gt; &lt;td&gt;Stop&lt;/td&gt;&lt;/tr&gt;
* &lt;tr&gt;&lt;td&gt;EAN128&lt;/td&gt; &lt;td&gt; StartC&lt;/td&gt; &lt;td&gt;FNC1&lt;/td&gt; &lt;td&gt; 95&lt;/td&gt; &lt;td&gt;(105 + 1*102 + 2*95) % 103 = 88&lt;/td&gt; &lt;td&gt;Stop &lt;/td&gt;&lt;/tr&gt;
* &lt;/table&gt;
* &lt;/p&gt;
* @param vIN_code
* @return code128b
*/
public String createCode128b(String vIN_code){
int checkB = 1;//code128B 开始位的码值为104 mod 103 =1
for(int i=0;i&lt; vIN_code.length();i++){
String str = vIN_code.substring(i,i+1);
int j = str.charAt(0);
if( j &lt; 135 ){
j = j - 32;
}else if( j &gt; 134 ){ //有的资料直接求103的模,解说不充分,因为有的校验位超过127时,系统会&quot;吃&quot;掉它们(连带休止符).
j = j - 100;
}
checkB = (checkB + (i+1) * j )% 103; //计算校验码
}
if( checkB &lt; 95 &amp;&amp; checkB &gt;0){//增加32到校验数上，然后找出打印的ASCII字符
checkB = checkB + 32;
}else if( checkB &gt; 94 ){//code128编码在94后没有字符（unicode中有）
checkB = checkB + 100;
}
/**unicode码对应的值 204----Ì 206-----Î 32----空格 */
return (char)204 + vIN_code +( checkB != 0 ? (char)checkB :(char)32 ) + (char)206 ;
}
</code>
</RECORD>
<RECORD>
<snippet_key>113421</snippet_key>
<tag>java</tag>
<comment>来自CSDN博客：黑马程序员之基础加强之反射  http://blog.csdn.net/lovecx24/article/details/17075117#</comment>
<code>&lt;span style=&quot;font-size:12px;&quot;&gt;package com.lee.homework;

import java.lang.reflect.Field;

public class StringRegulate {

/**
* @param args
*/
public static void main(String[] args) {
// TODO Auto-generated method stub
Dog dog = new Dog(&quot;ouby&quot;,&quot;blue&quot;,4);
Field[] fields = dog.getClass().getDeclaredFields();
for(Field field:fields){
if(field.getType()==String.class){
try {
String value = (String) field.get(dog);
String newValue=value.replace(&apos;b&apos;, &apos;a&apos;);
field.set(dog, newValue);
} catch (IllegalArgumentException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} catch (IllegalAccessException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}
}
System.out.println(dog.dogName);
System.out.println(dog.color);

}

}&lt;/span&gt;
&lt;span style=&quot;font-size:12px;&quot;&gt;import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class MainTest {

/**
* 调用另外一个类中的main方法
*/
public static void main(String[] args) {
// TODO Auto-generated method stub
MainReflect mr = new MainReflect();
try {
Method method = mr.getClass().getMethod(&quot;main&quot;, String[].class);
try {
method.invoke(null, (Object)new String[]{&quot;a&quot;,&quot;bc&quot;});
} catch (IllegalArgumentException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} catch (IllegalAccessException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} catch (InvocationTargetException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
} catch (SecurityException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} catch (NoSuchMethodException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}

}
&lt;/span&gt;
package com.lee.reflect;

import java.lang.reflect.Array;
/*
* 数组的反射应用举例
*/

public class ArrayReflectDemo {

/**
* @param args
*/
public static void main(String[] args) {
//创建一个长度为10的char型数组
Object array = Array.newInstance(Character.class, 10);
//分别为数组的前三个元素赋值
Array.set(array, 0, &apos;a&apos;);
Array.set(array, 1, &apos;b&apos;);
Array.set(array, 2, &apos;c&apos;);
//取出数组首元素，注意返回值
Object ch = Array.get(array, 0);
//如果是这样，编译器就会报错，因为定义数组时是Character类型，并不是char类型
char ch1 =Array.getChar(array, 0);
System.out.println(ch1);

}

}
</code>
</RECORD>
<RECORD>
<snippet_key>310029</snippet_key>
<tag>326</tag>
<comment>来自CSDN博客：hibernate one-to-one mapping 的 mapping file 怎么写  http://blog.csdn.net/u014722030/article/details/24421933#</comment>
<code>package tanghao.xmlmapping.one2one.entity;

public class Account implements java.io.Serializable {
/**
*
*/
private static final long serialVersionUID = 7661590583678153237L;
private String email;
private String accountName;
private AccountParticulars particulars;
private Integer accountId;


public String getEmail() {
return email;
}
public void setEmail(String email) {
this.email = email;
}
public String getAccountName() {
return accountName;
}
public void setAccountName(String accountName) {
this.accountName = accountName;
}
public AccountParticulars getParticulars() {
return particulars;
}
public void setParticulars(AccountParticulars particulars) {
this.particulars = particulars;
}
public Integer getAccountId() {
return accountId;
}
public void setAccountId(Integer accountId) {
this.accountId = accountId;
}
}
package tanghao.xmlmapping.one2one.entity;

public class AccountParticulars implements java.io.Serializable {

/**
*
*/
private static final long serialVersionUID = -4346433899011070419L;
private Integer accountId;
private String email;
private String ownerName;
private String gender;
private Account account;
public String getEmail() {
return email;
}
public void setEmail(String email) {
this.email = email;
}
public String getOwnerName() {
return ownerName;
}
public void setOwnerName(String ownerName) {
this.ownerName = ownerName;
}
public String getGender() {
return gender;
}
public void setGender(String gender) {
this.gender = gender;
}
public Account getAccount() {
return account;
}
public void setAccount(Account account) {
this.account = account;
}
public Integer getAccountId() {
return accountId;
}
public void setAccountId(Integer accountId) {
this.accountId = accountId;
}
}
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
&quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;
&lt;hibernate-mapping package=&quot;tanghao.xmlmapping.one2one.entity&quot;&gt;
&lt;class name=&quot;Account&quot; table=&quot;account&quot;&gt;
&lt;id name=&quot;accountId&quot; type=&quot;java.lang.Integer&quot;&gt;
&lt;column name=&quot;ACCOUNT_ID&quot;/&gt;
&lt;generator class=&quot;identity&quot;/&gt;
&lt;/id&gt;

&lt;property name=&quot;email&quot; type=&quot;string&quot;&gt;
&lt;column name=&quot;EMAIL&quot; length=&quot;50&quot; not-null=&quot;true&quot; /&gt;
&lt;/property&gt;

&lt;property name=&quot;accountName&quot; type=&quot;string&quot;&gt;
&lt;column name=&quot;ACCOUNT_NAME&quot; length=&quot;50&quot; not-null=&quot;true&quot; /&gt;
&lt;/property&gt;

&lt;one-to-one name=&quot;particulars&quot; class=&quot;tanghao.xmlmapping.one2one.entity.AccountParticulars&quot; cascade=&quot;save-update&quot;&gt;&lt;/one-to-one&gt;

&lt;/class&gt;
&lt;/hibernate-mapping&gt;
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
&quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;
&lt;hibernate-mapping package=&quot;tanghao.xmlmapping.one2one.entity&quot;&gt;
&lt;class name=&quot;AccountParticulars&quot; table=&quot;account_particulars&quot;&gt;
&lt;id name=&quot;accountId&quot; type=&quot;java.lang.Integer&quot;&gt;
&lt;column name=&quot;ACCOUNT_ID&quot;/&gt;
&lt;generator class=&quot;foreign&quot;&gt;
&lt;param name=&quot;property&quot;&gt;account&lt;/param&gt;
&lt;/generator&gt;
&lt;/id&gt;

&lt;property name=&quot;email&quot; type=&quot;string&quot;&gt;
&lt;column name=&quot;EMAIL&quot; length=&quot;50&quot; not-null=&quot;true&quot; /&gt;
&lt;/property&gt;

&lt;property name=&quot;ownerName&quot; type=&quot;string&quot;&gt;
&lt;column name=&quot;OWNER_NAME&quot; length=&quot;50&quot; not-null=&quot;true&quot;/&gt;
&lt;/property&gt;
&lt;property name=&quot;gender&quot; type=&quot;string&quot;&gt;
&lt;column name=&quot;GENDER&quot; length=&quot;10&quot; not-null=&quot;true&quot;/&gt;
&lt;/property&gt;
&lt;one-to-one name=&quot;account&quot; class=&quot;tanghao.xmlmapping.one2one.entity.Account&quot; constrained=&quot;true&quot;/&gt;
&lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>478908</snippet_key>
<tag>429</tag>
<comment>来自CSDN博客：JVM 内存泄露简单示例  http://blog.csdn.net/yyywyr/article/details/39754235#</comment>
<code>package cn.com.yy;

import java.util.Vector;

/**
* 简单的内存泄露例子
* @author yy
* @time 2014-10-3 上午10:41:42
*/
public class MemoryLeakTest {

public static void main(String[] args) {
Vector v = new Vector(100000000);
for(int i=0;i&lt;v.size();i++){
Object o = new Object();
v.add(o);
o = null;
}
}
}
Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space
at java.util.Vector.&lt;init&gt;(Vector.java:131)
at java.util.Vector.&lt;init&gt;(Vector.java:144)
at cn.com.yy.MemoryLeakTest.main(MemoryLeakTest.java:13)
</code>
</RECORD>
<RECORD>
<snippet_key>48141</snippet_key>
<tag>jsp 教育 视频</tag>
<comment>美乐思教育网视频频道的JSP播放器程序</comment>
<code>videoList.jsp

&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%
String path = request.getContextPath();
String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;
%&gt;

&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;

&lt;title&gt;视频播放列表&lt;/title&gt;
&lt;style type=&quot;text/css&quot;&gt;
a{ color:#800000; text-decoration:none;}
a:link{color:#800000; text-decoration:none;}
a:visited{color:#888888; text-decoration:none;}
a:hover{color:#FFFFFF; text-decoration:underline;}
&lt;/style&gt;
&lt;/head&gt;
&lt;body bgcolor=&quot;#E1F0FF&quot;&gt;
&lt;table width=&quot;661&quot; height=&quot;368&quot; border=&quot;0&quot; align=&quot;center&quot;&gt;
&lt;tr&gt;
&lt;td height=&quot;30&quot;&gt;
&lt;div align=&quot;center&quot;&gt;&lt;b&gt;
&lt;font color=&quot;#336699&quot; size=&quot;4px&quot;&gt;视&amp;nbsp;频&amp;nbsp;播&amp;nbsp;放&amp;nbsp;列&amp;nbsp;表&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;
&lt;hr color=&quot;#336699&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td height=&quot;202&quot;&gt;&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;a href=&quot;videoList_do.jsp?videoName=video1&quot;&gt;***-1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;videoList_do.jsp?videoName=video2&quot;&gt;***-2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;videoList_do.jsp?videoName=video3&quot;&gt;***-3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;videoList_do.jsp?videoName=video4&quot;&gt;***-4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;videoList_do.jsp?videoName=video5&quot;&gt;***-5&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;hr color=&quot;#336699&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td height=&quot;96&quot;&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;FONT size=&quot;2px&quot;&gt;Copyright ? 2010 ************************, All Rights Reserved&lt;/FONT&gt;&lt;/p&gt;
&lt;p&gt;&lt;FONT size=&quot;2px&quot;&gt;**************************************** &lt;/FONT&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;



videoList_do.jsp

&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%
String path = request.getContextPath();
String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;
%&gt;

&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;

&lt;title&gt;视频播放&lt;/title&gt;
&lt;style type=&quot;text/css&quot;&gt;
&lt;!--
#Layer1 {
position:absolute;
left:2px;
top:91px;
width:100px;
height:192px;
z-index:1;
}
--&gt;
&lt;/style&gt;

&lt;/head&gt;
&lt;body bgcolor=&quot;#E1F0FF&quot;&gt;
&lt;%
//按照video1,video2,video3...这样传参和命名upload目录下的wmv文件
String videoName = request.getParameter(&quot;videoName&quot;);
if(videoName == null || &quot;&quot;.equals(videoName)){

out.print(&quot;&lt;h3&gt;请求参数错误!&lt;/h3&gt;&quot;);
}
else{
//out.print(videoName);
String filename = basePath + &quot;upload/&quot; + videoName + &quot;.wmv&quot;;
//out.print(filename);
%&gt;
&lt;div id=&quot;Layer1&quot; style=&quot;margin-left:0px;&quot; align=&quot;center&quot;&gt;
&lt;font color=&quot;#336699&quot; size=&quot;2px&quot;&gt;视频列表&lt;p/&gt;
&lt;%
for(int i=1; i&lt;=5; i++){

String temp = &quot;video&quot; + i;
if(temp.equals(videoName)){ //如果当前接收的参数和upload目录wmv文件命名一致,播放列表的名称就显示红色,否则显示深蓝色
%&gt;
&lt;font size=&quot;2px&quot;&gt;
&lt;a href=&quot;&lt;%=path%&gt;/videoList_do.jsp?videoName=&lt;%=temp%&gt;&quot; style=&quot;color:#E24B50;text-decoration:none&quot;&gt;&lt;%=&quot;******-&quot;+i%&gt;&lt;/a&gt;
&lt;/font&gt; &lt;p/&gt;
&lt;%
}
else{
%&gt;
&lt;font size=&quot;2px&quot;&gt;
&lt;a href=&quot;&lt;%=path%&gt;/videoList_do.jsp?videoName=&lt;%=temp%&gt;&quot; style=&quot;color:#336699;text-decoration:none&quot;&gt;&lt;%=&quot;******-&quot;+i%&gt;&lt;/a&gt;
&lt;/font&gt; &lt;p/&gt;
&lt;%
}
}
%&gt;
&lt;/font&gt;
&lt;/div&gt;


&lt;table width=&quot;801&quot; height=&quot;641&quot; border=&quot;0&quot; align=&quot;center&quot;&gt;
&lt;tr&gt;
&lt;td height=&quot;620&quot;&gt;
&lt;object id=&quot;player&quot; height=&quot;600&quot; width=&quot;800&quot; classid=&quot;CLSID:6BF52A52-394A-11d3-B153-00C04F79FAA6&quot;&gt;
&lt;param NAME=&quot;AutoStart&quot; VALUE=&quot;1&quot;&gt; &lt;!-- -1为不自动播放 --&gt;
&lt;!--是否自动播放--&gt;

&lt;param NAME=&quot;Balance&quot; VALUE=&quot;0&quot;&gt;
&lt;!--调整左右声道平衡,同上面旧播放器代码--&gt;

&lt;param name=&quot;enabled&quot; value=&quot;1&quot;&gt;
&lt;!--播放器是否可人为控制--&gt;

&lt;param NAME=&quot;EnableContextMenu&quot; VALUE=&quot;-1&quot;&gt;
&lt;!--是否启用上下文菜单--&gt;

&lt;param NAME=&quot;url&quot; VALUE=&quot;&lt;%=filename%&gt;&quot;&gt;
&lt;!--播放的文件地址--&gt;

&lt;param NAME=&quot;PlayCount&quot; VALUE=&quot;1&quot;&gt;
&lt;!--播放次数控制,为整数--&gt;

&lt;param name=&quot;rate&quot; value=&quot;1&quot;&gt;
&lt;!--播放速率控制,1为正常,允许小数,1.0-2.0--&gt;

&lt;param name=&quot;currentPosition&quot; value=&quot;0&quot;&gt;
&lt;!--控件设置:当前位置--&gt;



&lt;param name=&quot;currentMarker&quot; value=&quot;0&quot;&gt;
&lt;!--控件设置:当前标记--&gt;

&lt;param name=&quot;defaultFrame&quot; value=&quot;&quot;&gt;
&lt;!--显示默认框架--&gt;

&lt;param name=&quot;invokeURLs&quot; value=&quot;0&quot;&gt;
&lt;!--脚本命令设置:是否调用URL--&gt;

&lt;param name=&quot;baseURL&quot; value=&quot;&quot;&gt;
&lt;!--脚本命令设置:被调用的URL--&gt;

&lt;param name=&quot;stretchToFit&quot; value=&quot;1&quot;&gt;
&lt;!--是否按比例伸展--&gt;

&lt;param name=&quot;volume&quot; value=&quot;50&quot;&gt;
&lt;!--默认声音大小0%-100%,50则为50%--&gt;

&lt;param name=&quot;mute&quot; value=&quot;0&quot;&gt;
&lt;!--是否静音--&gt;

&lt;param name=&quot;uiMode&quot; value=&quot;full&quot;&gt;
&lt;!--播放器显示模式:Full显示全部;mini最简化;None不显示播放控制,只显示视频窗口;invisible全部不显示--&gt;

&lt;param name=&quot;windowlessVideo&quot; value=&quot;0&quot;&gt;

&lt;!--如果是0可以允许全屏,否则只能在窗口中查看--&gt;
&lt;param name=&quot;fullScreen&quot; value=&quot;0&quot;&gt;
&lt;!--开始播放是否自动全屏--&gt;

&lt;param name=&quot;enableErrorDialogs&quot; value=&quot;-1&quot;&gt;
&lt;!--是否启用错误提示报告--&gt;

&lt;param name=&quot;SAMIStyle&quot; value&gt;
&lt;!--SAMI样式--&gt;

&lt;param name=&quot;SAMILang&quot; value&gt;
&lt;!--SAMI语言--&gt;

&lt;param name=&quot;SAMIFilename&quot; value&gt;
&lt;!--字幕ID--&gt;
&lt;/object&gt;

&lt;%
}
%&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>441357</snippet_key>
<tag></tag>
<comment>来自CSDN博客：java汉字转拼音，取汉字首字母，支持繁体 http://blog.csdn.net/zhaifengmin/article/details/38356361#</comment>
<code>import net.sourceforge.pinyin4j.PinyinHelper;
import net.sourceforge.pinyin4j.format.HanyuPinyinCaseType;
import net.sourceforge.pinyin4j.format.HanyuPinyinOutputFormat;
import net.sourceforge.pinyin4j.format.HanyuPinyinToneType;
import net.sourceforge.pinyin4j.format.HanyuPinyinVCharType;
import net.sourceforge.pinyin4j.format.exception.BadHanyuPinyinOutputFormatCombination;

public class Pinyin {
/**
* 将汉字转换为全拼
*
* @param src
* @return String
*/
public static String getPinYin(String src) {
char[] t1 = null;
t1 = src.toCharArray();
// System.out.println(t1.length);
String[] t2 = new String[t1.length];
// System.out.println(t2.length);
// 设置汉字拼音输出的格式
HanyuPinyinOutputFormat t3 = new HanyuPinyinOutputFormat();
t3.setCaseType(HanyuPinyinCaseType.LOWERCASE);
t3.setToneType(HanyuPinyinToneType.WITHOUT_TONE);
t3.setVCharType(HanyuPinyinVCharType.WITH_V);
String t4 = &quot;&quot;;
int t0 = t1.length;
try {
for (int i = 0; i &lt; t0; i++) {
// 判断是否为汉字字符
// System.out.println(t1[i]);
if (Character.toString(t1[i]).matches(&quot;[\\u4E00-\\u9FA5]+&quot;)) {
t2 = PinyinHelper.toHanyuPinyinStringArray(t1[i], t3);// 将汉字的几种全拼都存到t2数组中
t4 += t2[0];// 取出该汉字全拼的第一种读音并连接到字符串t4后
} else {
// 如果不是汉字字符，直接取出字符并连接到字符串t4后
t4 += Character.toString(t1[i]);
}
}
} catch (BadHanyuPinyinOutputFormatCombination e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
return t4;
}

/**
* 提取每个汉字的首字母
*
* @param str
* @return String
*/
public static String getPinYinHeadChar(String str) {
String convert = &quot;&quot;;
for (int j = 0; j &lt; str.length(); j++) {
char word = str.charAt(j);
// 提取汉字的首字母
String[] pinyinArray = PinyinHelper.toHanyuPinyinStringArray(word);
if (pinyinArray != null) {
convert += pinyinArray[0].charAt(0);
} else {
convert += word;
}
}
return convert;
}

/**
* 将字符串转换成ASCII码
*
* @param cnStr
* @return String
*/
public static String getCnASCII(String cnStr) {
StringBuffer strBuf = new StringBuffer();
// 将字符串转换成字节序列
byte[] bGBK = cnStr.getBytes();
for (int i = 0; i &lt; bGBK.length; i++) {
// System.out.println(Integer.toHexString(bGBK[i] &amp; 0xff));
// 将每个字符转换成ASCII码
strBuf.append(Integer.toHexString(bGBK[i] &amp; 0xff)+&quot; &quot;);
}
return strBuf.toString();
}

public static void main(String[] args) {
String cnStr = &quot;中华人民共和国&quot;;
System.out.println(getPinYin(cnStr));
System.out.println(getPinYinHeadChar(cnStr));
// System.out.println(getCnASCII(cnStr));
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>113933</snippet_key>
<tag>327</tag>
<comment>来自CSDN博客：java 文件复制 http://blog.csdn.net/wuer0520/article/details/17349089#</comment>
<code>import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
/*
* 就是将一个文件中的数据存储到另一个文件中
* 1. 创建一个用于存储(写入)数据的文件流并指定文件名，这样文件会自动创建
* 2. 创建一个用于读取数据的文件流并指定被复制的文件的文件名，使流和文件关联
* 3. 不断的从输入流中读取数据，通过输出流写入到复制后的文件
* 4. 关闭流
* 在不断读写的时候有两种方式：
* 1. 读写单个字符
* 2. 读写字符数组
* 用第二种方式显然效率高
*/
public class FileCopy {

public static void main(String[] args) {
copy_1();
copy_2();
}

/*
* 读写字符数组
* 用这种方式显然效率高
*/
public static void copy_2() {
FileWriter fw = null;
FileReader fr = null;
try {
fw = new FileWriter(&quot;Template.java&quot;);
fr = new FileReader(&quot;src/Template.java&quot;);
char[] buf = new char[1024];
for (int len; (len = fr.read(buf)) != -1;) {
fw.write(buf, 0, len);
fw.flush();
}
} catch (FileNotFoundException e) {
throw new RuntimeException(&quot;找不到文件&quot;);
} catch (IOException e) {
throw new RuntimeException(&quot;读写失败&quot;);
} finally {
try {
if (fr != null) {
fr.close();
fr = null;
}
if (fw != null) {
fw.close();
fw = null;
}
} catch (IOException e) {
e.printStackTrace();
}
}
}

/*
* 读写单个字符
*/
public static void copy_1() {
FileWriter fw = null;
FileReader fr = null;
try {
fw = new FileWriter(&quot;Singleton.java&quot;);
fr = new FileReader(&quot;src/Singleton.java&quot;);
for (int ch; (ch = fr.read()) != -1;) {
fw.write(ch);
}
fw.flush();
} catch (IOException e) {
throw new RuntimeException(&quot;读写失败&quot;);
} finally {
try {
if (fr != null) {
fr.close();
fr = null;
}
if (fw != null) {
fw.close();
fw = null;
}
} catch (IOException e) {
e.printStackTrace();
}
}
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>478896</snippet_key>
<tag>java leetcode string</tag>
<comment>来自CSDN博客：【Leetcode】Decode Ways http://blog.csdn.net/yyz20002008/article/details/39754119#</comment>
<code>public int numDecodings(String s) {
if(s==null || s.length()==0 || s.charAt(0)==&apos;0&apos;)
{
return 0;
}
int num1=1;
int num2=1;
int num3=1;
for(int i=1;i&lt;s.length();i++)
{
if(s.charAt(i)==&apos;0&apos;)
{
if(s.charAt(i-1)==&apos;1&apos; || s.charAt(i-1)==&apos;2&apos;)
num3 = num1;
else
return 0;
}
else
{
if(s.charAt(i-1)==&apos;0&apos; || s.charAt(i-1)&gt;=&apos;3&apos;)
num3 = num2;
else
{
if(s.charAt(i-1)==&apos;2&apos; &amp;&amp; s.charAt(i)&gt;=&apos;7&apos; &amp;&amp; s.charAt(i)&lt;=&apos;9&apos;)
num3 = num2;
else
num3 = num1+num2;
}
}
num1 = num2;
num2 = num3;
}
return num2;
}
</code>
</RECORD>
<RECORD>
<snippet_key>478895</snippet_key>
<tag>高精度</tag>
<comment>来自CSDN博客：hdu1715(高精度····JAVA版) http://blog.csdn.net/u013447865/article/details/39754157#</comment>
<code>import java.math.*;
import java.util.Scanner;

public class Main {
public static void main(String[] args) {
Scanner cin = new Scanner(System.in);
BigInteger m[] = new BigInteger[1001];
BigInteger start = new BigInteger(&quot;1&quot;);
m[1] = start;
m[2] = start;
for(int i = 3 ; i &lt; 1001 ; i ++){
m[i] = m[i-1].add(m[i-2]);
}
int n = cin.nextInt();
while(n != 0){
int key = cin.nextInt();
System.out.println(m[key]);
n--;
}

}
}
</code>
</RECORD>
<RECORD>
<snippet_key>478894</snippet_key>
<tag>214</tag>
<comment>来自CSDN博客：Android 利用fastjson进行json解析 http://blog.csdn.net/haifengzhilian/article/details/39754149#</comment>
<code>package com.example.FastJson.util;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.TypeReference;

import java.util.List;
import java.util.Map;

/**
* Created by chang on 14-10-3.
*/
public class jsonUtil {

public static &lt;T&gt; T getObject(String jsonString, Class&lt;T&gt; cls) {
return JSON.parseObject(jsonString,cls);
}

public static &lt;T&gt; List&lt;T&gt; getObjects(String jsonString, Class&lt;T&gt; cls) {
return JSON.parseArray(jsonString,cls);
}

public static List&lt;Map&lt;String,String&gt;&gt; getKeyMapsList(String jsonString) {
List&lt;Map&lt;String,String&gt;&gt; list;
list = JSON.parseObject(jsonString, new TypeReference&lt;List&lt;Map&lt;String, String&gt;&gt;&gt;(){});
return list;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>478892</snippet_key>
<tag></tag>
<comment>来自CSDN博客：为什么Java里的Arrays.asList不能用add和remove方法？  http://blog.csdn.net/loveaborn/article/details/39754031#</comment>
<code>public class MainFacade {
public static void main(String[] args) {
List&lt;Integer&gt; list = Arrays.asList(1,2,3);
list.add(5);
System.out.print(list.toString());
}
}
Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at java.util.AbstractList.add(AbstractList.java:148) at java.util.AbstractList.add(AbstractList.java:108) at org.popkit.MainFacade.main(MainFacade.java:14) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
implements RandomAccess, java.io.Serializable
public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt;
public void add(int index, E element) {
throw new UnsupportedOperationException();
}

public E set(int index, E element) {
throw new UnsupportedOperationException();
}

public E remove(int index) {
throw new UnsupportedOperationException();
}
List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1,2,3));
</code>
</RECORD>
<RECORD>
<snippet_key>478891</snippet_key>
<tag>java 数字转换</tag>
<comment>来自CSDN博客：将中文数字转换成英文表示 http://blog.csdn.net/ankeyuan/article/details/39754093#</comment>
<code>public class NumberToWords {

private final String[] tensNames = {
&quot;&quot;,
&quot; ten&quot;,
&quot; twenty&quot;,
&quot; thirty&quot;,
&quot; forty&quot;,
&quot; fifty&quot;,
&quot; sixty&quot;,
&quot; seventy&quot;,
&quot; eighty&quot;,
&quot; ninety&quot;
};

private final String[] numNames = {
&quot;&quot;,
&quot; one&quot;,
&quot; two&quot;,
&quot; three&quot;,
&quot; four&quot;,
&quot; five&quot;,
&quot; six&quot;,
&quot; seven&quot;,
&quot; eight&quot;,
&quot; nine&quot;,
&quot; ten&quot;,
&quot; eleven&quot;,
&quot; twelve&quot;,
&quot; thirteen&quot;,
&quot; fourteen&quot;,
&quot; fifteen&quot;,
&quot; sixteen&quot;,
&quot; seventeen&quot;,
&quot; eighteen&quot;,
&quot; nineteen&quot;
};

private String convertLessThanOneThousand(int number) {
String soFar;

if (number % 100 &lt; 20){
soFar = numNames[number % 100];
number /= 100;
}else {
soFar = numNames[number % 10];
number /= 10;

if(soFar.equals(&quot;&quot;)){
soFar = tensNames[number % 10] + soFar;
}else{
soFar = tensNames[number % 10] + &quot; and &quot; + soFar;
}
number /= 10;
}
if (number == 0){
return soFar;
}
return numNames[number] + &quot; hundred&quot; + soFar;
}


public String convert(long number) {
// 0 to 999 999 999 999
if (number == 0) { return &quot;zero&quot;; }

String snumber = Long.toString(number);

// pad with &quot;0&quot;
String mask = &quot;000000000000&quot;;
DecimalFormat df = new DecimalFormat(mask);
snumber = df.format(number);

// XXXnnnnnnnnn
int billions = Integer.parseInt(snumber.substring(0,3));
// nnnXXXnnnnnn
int millions = Integer.parseInt(snumber.substring(3,6));
// nnnnnnXXXnnn
int hundredThousands = Integer.parseInt(snumber.substring(6,9));
// nnnnnnnnnXXX
int thousands = Integer.parseInt(snumber.substring(9,12));

String tradBillions;
switch (billions) {
case 0:
tradBillions = &quot;&quot;;
break;
case 1 :
tradBillions = convertLessThanOneThousand(billions)
+ &quot; billion &quot;;
break;
default :
tradBillions = convertLessThanOneThousand(billions)
+ &quot; billion &quot;;
}
String result = tradBillions;

String tradMillions;
switch (millions) {
case 0:
tradMillions = &quot;&quot;;
break;
case 1 :
tradMillions = convertLessThanOneThousand(millions)
+ &quot; million &quot;;
break;
default :
tradMillions = convertLessThanOneThousand(millions)
+ &quot; million &quot;;
}
result = result + tradMillions;

String tradHundredThousands;
switch (hundredThousands) {
case 0:
tradHundredThousands = &quot;&quot;;
break;
case 1 :
tradHundredThousands = &quot;one thousand &quot;;
break;
default :
tradHundredThousands = convertLessThanOneThousand(hundredThousands)
+ &quot; thousand &quot;;
}
result = result + tradHundredThousands;

String tradThousand;
tradThousand = convertLessThanOneThousand(thousands);
result = result + tradThousand;

// remove extra spaces!
return result.replaceAll(&quot;^\\s+&quot;, &quot;&quot;).replaceAll(&quot;\\b\\s{2,}\\b&quot;, &quot; &quot;);
}

/**
* testing
* @param args
*/
public static void main(String[] args) {
NumberToWords nw = new NumberToWords();

System.out.println(&quot;*** &quot; + nw.convert(1031));
System.out.println(&quot;*** &quot; + nw.convert(1030));
System.out.println(&quot;*** &quot; + nw.convert(0));
System.out.println(&quot;*** &quot; + nw.convert(1));
System.out.println(&quot;*** &quot; + nw.convert(36));
System.out.println(&quot;*** &quot; + nw.convert(136));
System.out.println(&quot;*** &quot; + nw.convert(1030));
System.out.println(&quot;*** &quot; + nw.convert(1036));
System.out.println(&quot;*** &quot; + nw.convert(1236));

System.out.println(&quot;*** &quot; + nw.convert(3000000010L));


/*
*** zero
*** one
*** sixteen
*** one hundred
*** one hundred eighteen
*** two hundred
*** two hundred nineteen
*** eight hundred
*** eight hundred one
*** one thousand three hundred sixteen
*** one million
*** two millions
*** three millions two hundred
*** seven hundred thousand
*** nine millions
*** nine millions one thousand
*** one hundred twenty three millions four hundred
** fifty six thousand seven hundred eighty nine
*** two billion one hundred forty seven millions
** four hundred eighty three thousand six hundred forty seven
*** three billion ten
**/
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>310797</snippet_key>
<tag>android oom bitmap recycle BitmapFactory.Option</tag>
<comment>来自CSDN博客：android 管理Bitmap内存 - 开发文档翻译  http://blog.csdn.net/su1216/article/details/10397757#</comment>
<code>private int mCacheRefCount = 0;
private int mDisplayRefCount = 0;
...
// Notify the drawable that the displayed state has changed.
// Keep a count to determine when the drawable is no longer displayed.
public void setIsDisplayed(boolean isDisplayed) {
synchronized (this) {
if (isDisplayed) {
mDisplayRefCount++;
mHasBeenDisplayed = true;
} else {
mDisplayRefCount--;
}
}
// Check to see if recycle() can be called.
checkState();
}

// Notify the drawable that the cache state has changed.
// Keep a count to determine when the drawable is no longer being cached.
public void setIsCached(boolean isCached) {
synchronized (this) {
if (isCached) {
mCacheRefCount++;
} else {
mCacheRefCount--;
}
}
// Check to see if recycle() can be called.
checkState();
}

private synchronized void checkState() {
// If the drawable cache and display ref counts = 0, and this drawable
// has been displayed, then recycle.
if (mCacheRefCount &lt;= 0 &amp;&amp; mDisplayRefCount &lt;= 0 &amp;&amp; mHasBeenDisplayed
&amp;&amp; hasValidBitmap()) {
getBitmap().recycle();
}
}

private synchronized boolean hasValidBitmap() {
Bitmap bitmap = getBitmap();
return bitmap != null &amp;&amp; !bitmap.isRecycled();
}
HashSet&lt;SoftReference&lt;Bitmap&gt;&gt; mReusableBitmaps;
private LruCache&lt;String, BitmapDrawable&gt; mMemoryCache;

// If you&apos;re running on Honeycomb or newer, create
// a HashSet of references to reusable bitmaps.
if (Utils.hasHoneycomb()) {
mReusableBitmaps = new HashSet&lt;SoftReference&lt;Bitmap&gt;&gt;();
}

mMemoryCache = new LruCache&lt;String, BitmapDrawable&gt;(mCacheParams.memCacheSize) {

// Notify the removed entry that is no longer being cached.
@Override
protected void entryRemoved(boolean evicted, String key,
BitmapDrawable oldValue, BitmapDrawable newValue) {
if (RecyclingBitmapDrawable.class.isInstance(oldValue)) {
// The removed entry is a recycling drawable, so notify it
// that it has been removed from the memory cache.
((RecyclingBitmapDrawable) oldValue).setIsCached(false);
} else {
// The removed entry is a standard BitmapDrawable.
if (Utils.hasHoneycomb()) {
// We&apos;re running on Honeycomb or later, so add the bitmap
// to a SoftReference set for possible use with inBitmap later.
mReusableBitmaps.add
(new SoftReference&lt;Bitmap&gt;(oldValue.getBitmap()));
}
}
}
....
}
public static Bitmap decodeSampledBitmapFromFile(String filename,
int reqWidth, int reqHeight, ImageCache cache) {

final BitmapFactory.Options options = new BitmapFactory.Options();
...
BitmapFactory.decodeFile(filename, options);
...

// If we&apos;re running on Honeycomb or newer, try to use inBitmap.
if (Utils.hasHoneycomb()) {
addInBitmapOptions(options, cache);
}
...
return BitmapFactory.decodeFile(filename, options);
}
private static void addInBitmapOptions(BitmapFactory.Options options,
ImageCache cache) {
// inBitmap only works with mutable bitmaps, so force the decoder to
// return mutable bitmaps.
options.inMutable = true;

if (cache != null) {
// Try to find a bitmap to use for inBitmap.
Bitmap inBitmap = cache.getBitmapFromReusableSet(options);

if (inBitmap != null) {
// If a suitable bitmap has been found, set it as the value of
// inBitmap.
options.inBitmap = inBitmap;
}
}
}

// This method iterates through the reusable bitmaps, looking for one
// to use for inBitmap:
protected Bitmap getBitmapFromReusableSet(BitmapFactory.Options options) {
Bitmap bitmap = null;

if (mReusableBitmaps != null &amp;&amp; !mReusableBitmaps.isEmpty()) {
final Iterator&lt;SoftReference&lt;Bitmap&gt;&gt; iterator
= mReusableBitmaps.iterator();
Bitmap item;

while (iterator.hasNext()) {
item = iterator.next().get();

if (null != item &amp;&amp; item.isMutable()) {
// Check to see it the item can be used for inBitmap.
if (canUseForInBitmap(item, options)) {
bitmap = item;

// Remove from reusable set so it can&apos;t be used again.
iterator.remove();
break;
}
} else {
// Remove from the set if the reference has been cleared.
iterator.remove();
}
}
}
return bitmap;
}
private static boolean canUseForInBitmap(
Bitmap candidate, BitmapFactory.Options targetOptions) {
int width = targetOptions.outWidth / targetOptions.inSampleSize;
int height = targetOptions.outHeight / targetOptions.inSampleSize;

// Returns true if &quot;candidate&quot; can be used for inBitmap re-use with
// &quot;targetOptions&quot;.
return candidate.getWidth() == width &amp;&amp; candidate.getHeight() == height;
}
</code>
</RECORD>
<RECORD>
<snippet_key>478888</snippet_key>
<tag>327</tag>
<comment>来自CSDN博客：Java文本文档的读写操作（复习笔记）  http://blog.csdn.net/XX_123_1_RJ/article/details/39753987#</comment>
<code>package com.xing.test;

import java.io.*;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
/**
*
* @author LiuYinxing
*
*/
public class T5
{
public static void main(String args[])throws Exception
{
HashMap&lt;Integer, LinkedList&lt;String&gt;&gt; readtxt = new HashMap&lt;&gt;();
File file = new File(&quot;file.txt&quot;);//Text文件
BufferedReader br = new BufferedReader(new FileReader(file));//构造一个BufferedReader类来读取文件
String s = null;
int lin = 0;
while((s = br.readLine())!=null)
{//使用readLine方法，一次读一行
System.out.println(s);
LinkedList&lt;String&gt; strings = new LinkedList&lt;&gt;();
String[] temp = s.toString().split(&quot; &quot;);
for (int i = 0; i &lt; temp.length; i++)
{
strings.add(temp[i]);
}
readtxt.put(lin, strings);
lin++;
}
br.close();
for (int i = 0; i &lt; readtxt.size(); i++)
{
Iterator&lt;String&gt; iter = readtxt.get(i).iterator();
while (iter.hasNext())
{
System.out.print(iter.next()+&quot;,&quot;);
}
System.out.println();
}

}
}
package com.xing.test;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
/**
*
* @author LiuYinXing
*
*/
public class T2
{
public void dbToFile() throws Exception{
BufferedWriter bufferedWriter=null;
String teString = &quot;我爱你 程序员&quot;;
String filepath = &quot;D:\\1.txt&quot;;
File file = new File(filepath);
try
{
bufferedWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file)));
bufferedWriter.write(teString);
bufferedWriter.newLine();
}
catch (FileNotFoundException e)
{
e.printStackTrace();
}
finally
{
bufferedWriter.close();
}
}
public static void main(String[] args) throws Exception
{
T2 dbToFile =new T2();
dbToFile.dbToFile();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>245517</snippet_key>
<tag>java ACM 蓝桥杯 蓝桥</tag>
<comment>来自CSDN博客：[JAVA][2013蓝桥杯预赛 JAVA本科B组][振兴中华] http://blog.csdn.net/liuhsfyliu/article/details/21554619#</comment>
<code>public class Main {

static int dot[][] = new int[7][7];
static int routine = 0;
static char road[] = new char[10];

public static void dfs(int x, int y, int n) {
if (n == 8) {
routine++;
// for (int i = 1; i &lt;= 8; i++) {
// System.out.print(road[i]);
// }
// System.out.println();
} else {
if (dot[x][y + 1] == n + 1) {
road[n] = &apos;â&apos;;
dfs(x, y + 1, n + 1);
}
if (dot[x + 1][y] == n + 1) {
road[n] = &apos;â&apos;;
dfs(x + 1, y, n + 1);
}
}
}

public static void main(String[] args) {
for (int i = 1; i &lt;= 4; i++) {
for (int j = 1; j &lt;= 5; j++) {
dot[i][j] = j + i - 1;
}
}
dfs(1, 1, 1);
System.out.println(routine);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>442125</snippet_key>
<tag></tag>
<comment>来自CSDN博客：java程序性能优化 http://blog.csdn.net/yangyz_love/article/details/38369927#</comment>
<code>import java.util.vector;
class cel {
void method (vector vector) {
for (int i = 0; i &lt; vector.size (); i++) // violation
; // ...
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>478880</snippet_key>
<tag>java leetcode path Minimum</tag>
<comment>来自CSDN博客：【Leetcode】Minimum Path Sum http://blog.csdn.net/yyz20002008/article/details/39753603#</comment>
<code>public class Solution {
public int minPathSum(int[][] grid) {
if(grid==null||grid.length==0||grid[0].length==0) return 0;
int[] res= new int[grid[0].length];
res[0]=grid[0][0];
for(int i=1;i&lt;grid[0].length;i++)
{
res[i]=res[i-1]+grid[0][i];
}
for(int i=1;i&lt;grid.length;i++)
{

for(int j=0;j&lt;grid[0].length;j++)
{
if(j==0)
res[j]+=grid[i][j];
else
res[j]=Math.min(res[j-1],res[j])+grid[i][j];
}
}
return res[grid[0].length-1];
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>478878</snippet_key>
<tag>java leetcode Median array</tag>
<comment>来自CSDN博客：【Leetcode】Median of Two Sorted Arrays  http://blog.csdn.net/yyz20002008/article/details/39752821#</comment>
<code>public class Solution {
public double findMedianSortedArrays(int A[], int B[]) {
if((A.length+B.length)%2==1)
return helper(A,B,0,A.length-1,0,B.length-1,(A.length+B.length)/2+1);
else {
return (helper(A,B,0,A.length-1,0,B.length-1,(A.length+B.length)/2)+
helper(A,B,0,A.length-1,0,B.length-1,(A.length+B.length)/2+1))/2.0;
}
}
//
public double helper(int A[], int B[], int i, int i2, int j, int j2, int k) {
int m = i2-i + 1;
int n = j2-j + 1;
if (m &gt; n) return helper(B, A, j, j2,i, i2, k); //
if (m==0) return B[j + k - 1];
if (k == 1) return Math.min(A[i], B[j]);
int posA = Math.min(k/2, m);
int posB = k - posA;

if (A[i + posA - 1] ==B[j + posB - 1])
return A[i+posA-1];
else if(A[i + posA - 1] &lt;B[j + posB - 1])
return helper(A, B, i + posA, i2, j,j+posB-1,k-posA);
else
return helper(A, B, i,i+posA-1, j+posB, j2,k-posB);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>478877</snippet_key>
<tag>457</tag>
<comment>hashmap 来自CSDN博客：【Leetcode】Substring with Concatenation of All Words http://blog.csdn.net/yyz20002008/article/details/39752289#</comment>
<code>public class Solution {
public ArrayList&lt;Integer&gt; findSubstring(String S, String[] L) {
ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
if(S==null||S.length()==0||L==null||L.length==0) return res;

HashMap&lt;String,Integer&gt; map= new HashMap&lt;String,Integer&gt;();
// build dic using L
for(int i=0;i&lt;L.length;i++)
{
if(map.containsKey(L[i]))
{
map.put(L[i],map.get(L[i])+1);
}
else{
map.put(L[i],1);
}
}
//
for(int i=0;i&lt;L[0].length();i++)
{
HashMap&lt;String,Integer&gt; curMap= new HashMap&lt;String,Integer&gt;();
int count=0;
int left=i;
for(int j=i;j&lt;=S.length()-L[0].length();j+=L[0].length())
{
String str= S.substring(j,j+L[0].length());
if(map.containsKey(str))
{
if(curMap.containsKey(str))
{
curMap.put(str,curMap.get(str)+1);
}
else{
curMap.put(str,1);
}
if(curMap.get(str)&lt;=map.get(str))
{
count++;
}
else
{
while(curMap.get(str)&gt;map.get(str))
{
String temp=S.substring(left,left+L[0].length());
if(curMap.containsKey(temp))
{
curMap.put(temp,curMap.get(temp)-1);
if(curMap.get(temp)&lt;map.get(temp))
count--;
}
left+=L[0].length();
}
}
if(count==L.length)
{
res.add(left);
//if(left&lt;)
String temp = S.substring(left,left+L[0].length());
if(curMap.containsKey(temp))
{
curMap.put(temp,curMap.get(temp)-1);

}
count--;
left+=L[0].length();
}

}
else{
curMap.clear();
count=0;
left=j+L[0].length();

}
}
}
return res;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>311309</snippet_key>
<tag>327</tag>
<comment>来自CSDN博客：Apache POI组件操作Excel(导入和导出)  http://blog.csdn.net/hiping_cao/article/details/24460423#</comment>
<code>import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;

import org.apache.poi.hssf.usermodel.HSSFCell;
import org.apache.poi.hssf.usermodel.HSSFDateUtil;
import org.apache.poi.hssf.usermodel.HSSFRow;
import org.apache.poi.hssf.usermodel.HSSFSheet;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.poifs.filesystem.POIFSFileSystem;



import org.apache.poi.hssf.usermodel.HSSFCellStyle;
import org.apache.poi.hssf.usermodel.HSSFFont;
import org.apache.poi.hssf.usermodel.HSSFRichTextString;
import org.apache.poi.hssf.util.Region;


public class ExcelUtils {

/**
* 读取EXCEL
* @param firstrow 从第几行开始读取
* @return 读取后返回数组
*/
@SuppressWarnings(&quot;deprecation&quot;)
public static String[][] importExcel(File file, int firstrow)
throws FileNotFoundException, IOException {
List&lt;String[]&gt; result = new ArrayList&lt;String[]&gt;();
int rowSize = 0;
BufferedInputStream in = new BufferedInputStream(new FileInputStream(
file));
POIFSFileSystem fs = new POIFSFileSystem(in);
HSSFWorkbook wb = new HSSFWorkbook(fs);
HSSFCell cell = null;
for (int sheetIndex = 0; sheetIndex &lt; wb.getNumberOfSheets(); sheetIndex++) {
HSSFSheet st = wb.getSheetAt(sheetIndex);
for (int rowIndex = firstrow; rowIndex &lt;= st.getLastRowNum(); rowIndex++) {
HSSFRow row = st.getRow(rowIndex);
if (row == null) {
continue;
}
int tempRowSize = row.getLastCellNum() + 1;
if (tempRowSize &gt; rowSize) {
rowSize = tempRowSize;
}
String[] values = new String[rowSize];
Arrays.fill(values, &quot;&quot;);
boolean hasValue = false;

for (short columnIndex = 0; columnIndex &lt;= row.getLastCellNum(); columnIndex++) {
String value = &quot;&quot;;
cell = row.getCell(columnIndex);
if (cell != null) {
switch (cell.getCellType()) {
case HSSFCell.CELL_TYPE_STRING://读取的格式为字符串
value = cell.getStringCellValue();
break;
case HSSFCell.CELL_TYPE_NUMERIC://读取的格式为数组
//如果格式为日期格式，自定义格式输出
if (HSSFDateUtil.isCellDateFormatted(cell)) {
Date date = cell.getDateCellValue();
if (date != null) {
value = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;)
.format(date);
} else {
value = &quot;&quot;;
}
} else {
//如果格式为数值，自定义格式输出
value = new DecimalFormat().format(cell
.getNumericCellValue());
}
break;
case HSSFCell.CELL_TYPE_FORMULA:
// 导入时如果为公式生成的数据则无值
value = &quot;&quot;;
break;
// 导入时如果为空
case HSSFCell.CELL_TYPE_BLANK:
break;
case HSSFCell.CELL_TYPE_ERROR:
value = &quot;&quot;;
break;
// 导入时如果为BOOLEAN型 自定义格式输出
case HSSFCell.CELL_TYPE_BOOLEAN:
value = (cell.getBooleanCellValue() == true ? &quot;Y&quot;
: &quot;N&quot;);
break;
default:
value = &quot;&quot;;
}
}

values[columnIndex] = rightTrim(value);
hasValue = true;
}

if (hasValue) {
result.add(values);
}
}

in.close();
String[][] returnArray = new String[result.size()][rowSize];
for (int i = 0; i &lt; returnArray.length; i++) {
returnArray[i] = (String[]) result.get(i);
}
return returnArray;
}
return null;

}

/**
* 去掉字符串右边的空格
*
* @param str 要处理的字符串
* @return 处理后的字符串
*/
public static String rightTrim(String str) {
if (str == null) {
return &quot;&quot;;
}
int length = str.length();
for (int i = length - 1; i &gt;= 0; i--) {
if (str.charAt(i) != 0x20) {
break;
}
length--;
}
return str.substring(0, length);
}

/**
* 创建通用EXCEL头部
*
* @param headString 头部显示的字符
* @param colSum 该报表的列数
*/
@SuppressWarnings(&quot;deprecation&quot;)
public void createNormalHead(String headString, int colSum,HSSFSheet sheet,HSSFWorkbook wb) {

HSSFRow row1 = sheet.createRow(0);

// 设置第一行
HSSFCell cell = row1.createCell(0);
row1.setHeight((short) 800);

// 定义单元格为字符串类型
cell.setCellType(HSSFCell.ENCODING_UTF_16);
cell.setCellValue(new HSSFRichTextString(headString));

// 指定合并区域
sheet.addMergedRegion(new Region(0, (short) 0, 0, (short) colSum));

HSSFCellStyle cellStyle = wb.createCellStyle();

cellStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER); // 指定单元格居中对齐
cellStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);// 指定单元格垂直居中对齐
//cellStyle.setWrapText(true);// 指定单元格自动换行

// 设置单元格字体
HSSFFont font = wb.createFont();
font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);
font.setFontName(&quot;宋体&quot;);
font.setFontHeight((short) 300);
cellStyle.setFont(font);

cell.setCellStyle(cellStyle);
}

/**
* 创建通用报表第二行的格式
*
*/
public HSSFCellStyle getCellStyle(HSSFWorkbook wb) {
// 创建单元格样式
HSSFCellStyle cellStyle = wb.createCellStyle();
// 指定单元格居中对齐
cellStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);
// 指定单元格垂直居中对齐
cellStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);
// 指定当单元格内容显示不下时自动换行
//cellStyle.setWrapText(true);
// 设置单元格字体
HSSFFont font = wb.createFont();
font.setBoldweight(HSSFFont.BOLDWEIGHT_NORMAL);
font.setFontName(&quot;宋体&quot;);
font.setFontHeight((short) 200);
//font.setFontHeightInPoints((short) 22);
cellStyle.setFont(font);
return cellStyle;

}

}
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletResponse;

import org.apache.poi.hssf.usermodel.HSSFCell;
import org.apache.poi.hssf.usermodel.HSSFCellStyle;
import org.apache.poi.hssf.usermodel.HSSFFont;
import org.apache.poi.hssf.usermodel.HSSFRichTextString;
import org.apache.poi.hssf.usermodel.HSSFRow;
import org.apache.poi.hssf.usermodel.HSSFSheet;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.hssf.util.HSSFColor;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.util.CellRangeAddress;

public class ExcelUtil&lt;T&gt; {
/**
* 从excel导入,返回一个list集合
*
* @author
* @param file
* 导入的excel文件
* @param pattern
* @return
* */
Class&lt;T&gt; clazz;

public ExcelUtil(Class&lt;T&gt; clazz) {
this.clazz = clazz;
}

@SuppressWarnings(&quot;unchecked&quot;)
public Collection&lt;T&gt; importExcel(File file, String... pattern)
throws Exception {
Collection&lt;T&gt; dist = new ArrayList&lt;T&gt;();
try {
/**
* 类反射得到调用方法
*/
// 得到目标目标类的所有的字段列表
Field filed[] = clazz.getDeclaredFields();
// 将所有标有Annotation的字段，也就是允许导入数据的字段,放入到一个map中
Map fieldmap = new HashMap();
// 循环读取所有字段
for (int i = 0; i &lt; filed.length; i++) {
Field f = filed[i];
// 得到单个字段上的Annotation
ExcelAnnotation exa = f.getAnnotation(ExcelAnnotation.class);
// 如果标识了Annotationd的话
if (exa != null) {
// 构造设置了Annotation的字段的Setter方法
String fieldname = f.getName();
String setMethodName = &quot;set&quot;
+ fieldname.substring(0, 1).toUpperCase()
+ fieldname.substring(1);
// 构造调用的method，
Method setMethod = clazz.getMethod(setMethodName,
new Class[] { f.getType() });
// 将这个method以Annotaion的名字为key来存入。
fieldmap.put(exa.exportName(), setMethod);
}
}
/**
* excel的解析开始
*/
// 将传入的File构造为FileInputStream;
FileInputStream in = new FileInputStream(file);
// // 得到工作表
HSSFWorkbook book = new HSSFWorkbook(in);
// // 得到第一页
HSSFSheet sheet = book.getSheetAt(0);
// // 得到第一面的所有行
Iterator&lt;Row&gt; row = sheet.rowIterator();

/**
* 标题解析
*/
// 得到第一行，也就是标题行
Row title = row.next();
// 得到第一行的所有列
Iterator&lt;Cell&gt; cellTitle = title.cellIterator();
// 将标题的文字内容放入到一个map中。
Map titlemap = new HashMap();
// 从标题第一列开始
int i = 0;
// 循环标题所有的列
while (cellTitle.hasNext()) {
Cell cell = cellTitle.next();
String value = cell.getStringCellValue();
// 还是把表头trim一下
value = value.trim();
titlemap.put(i, value);
i = i + 1;
}
/**
* 解析内容行
*/
// 用来格式化日期的DateFormat
SimpleDateFormat sf;
if (pattern.length &lt; 1) {
sf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
} else
sf = new SimpleDateFormat(pattern[0]);
while (row.hasNext()) {
// 标题下的第一行
Row rown = row.next();

// 行的所有列
Iterator&lt;Cell&gt; cellbody = rown.cellIterator();
// 得到传入类的实例
T tObject = clazz.newInstance();
int k = 0;
// 遍历一行的列
while (cellbody.hasNext()) {
Cell cell = cellbody.next();
// 这里得到此列的对应的标题
String titleString = (String) titlemap.get(k);
// 如果这一列的标题和类中的某一列的Annotation相同，那么则调用此类的的set方法，进行设值
if (fieldmap.containsKey(titleString)) {
Method setMethod = (Method) fieldmap.get(titleString);
// 得到setter方法的参数
Type[] ts = setMethod.getGenericParameterTypes();
// 只要一个参数
String xclass = ts[0].toString();
// 判断参数类型
try {
switch (cell.getCellType()) {
case HSSFCell.CELL_TYPE_NUMERIC: // 数字
if (xclass.equals(&quot;class java.lang.String&quot;)) {
if ((cell.getNumericCellValue() + &quot;&quot;)
.indexOf(&quot;.&quot;) &gt; 0) {
setMethod
.invoke(tObject,
(cell.getNumericCellValue() + &quot;&quot;)
.substring(
0,
(cell.getNumericCellValue() + &quot;&quot;)
.lastIndexOf(&quot;.&quot;)));
}
} else if (xclass
.equals(&quot;class java.lang.Integer&quot;)) {
setMethod.invoke(tObject,
(int) cell.getNumericCellValue());
} else if (xclass.equals(&quot;int&quot;)) {
setMethod.invoke(tObject,
(int) cell.getNumericCellValue());
}
break;
case HSSFCell.CELL_TYPE_STRING: // 字符串
if (xclass.equals(&quot;class java.lang.Integer&quot;)) {
setMethod.invoke(tObject,
Integer.parseInt(cell
.getStringCellValue()));
} else if (xclass
.equals(&quot;class java.lang.String&quot;)) {
setMethod.invoke(tObject, cell
.getStringCellValue().trim());
} else if (xclass.equals(&quot;int&quot;)) {
int temp = Integer.parseInt(cell
.getStringCellValue());
setMethod.invoke(tObject, temp);
}
break;
case HSSFCell.CELL_TYPE_BOOLEAN: // Boolean
Boolean boolname = true;
if (cell.getStringCellValue().equals(&quot;否&quot;)) {
boolname = false;
}
setMethod.invoke(tObject, boolname);
break;
case HSSFCell.CELL_TYPE_FORMULA: // 公式
System.out.print(cell.getCellFormula() + &quot; &quot;);
break;
case HSSFCell.CELL_TYPE_BLANK: // 空值
System.out.println(&quot; &quot;);
break;
case HSSFCell.CELL_TYPE_ERROR: // 故障
System.out.println(&quot; &quot;);
break;
default:
System.out.print(&quot;未知类型 &quot;);
break;
}
} catch (Exception e) {// 转换出错
e.printStackTrace();

}
}
// 下一列
k = k + 1;
}
dist.add(tObject);
}
} catch (Exception e) {
e.printStackTrace();
// 将异常抛出去
throw e;
}
return dist;
}

// 格式化日期
SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);

/**
* 导出到excel中去,
*
* @author Administrator
* @param title
* excel的工作表名
* @param fileName
* excel 文件名
* @param dateset
* 导出的数据集合
* @param out
* 输出流
* @throws IOException
*/
@SuppressWarnings({ &quot;static-access&quot; })
public void exportExcel(String title, String fileName, List&lt;T&gt; dataset, String totalMoney,
HttpServletResponse response) throws IOException {
OutputStream out = response.getOutputStream();// 取得输出流
response.reset();// 清空输出流
response.setContentType(&quot;application/ms-excel;charset=GB2312&quot;);
response.setHeader(&quot;Content-disposition&quot;, &quot;attachment; filename=&quot;
+ new String(fileName.getBytes(&quot;gb2312&quot;), &quot;iso8859-1&quot;) + &quot;.xls&quot;);
// 声明一个工作薄
try {
HSSFWorkbook workbook = new HSSFWorkbook();
// 首先检查数据看是否是正确的
if (dataset == null || dataset.size() == 0 || title == null
|| out == null) {
throw new Exception(&quot;传入的数据不对！&quot;);
}
// 取得实际泛型类
T ts = (T) dataset.get(0);
Class&lt;?&gt; tCls = ts.getClass();
// 生成一个表格
HSSFSheet sheet = workbook.createSheet(title);
// 设置表格默认列宽度为15个字节
sheet.setDefaultColumnWidth(15);
// 生成一个样式
HSSFCellStyle style = workbook.createCellStyle();
// 设置标题样式
style = this.setHeadStyle(workbook, style);

// 得到所有字段

Field filed[] = ts.getClass().getDeclaredFields();
// 标题
List&lt;String&gt; exportfieldtile = new ArrayList&lt;String&gt;();
// 导出的字段的get方法
List&lt;Method&gt; methodObj = new ArrayList&lt;Method&gt;();
// 遍历整个filed
for (int i = 0; i &lt; filed.length; i++) {
Field f = filed[i];
ExcelAnnotation exa = f.getAnnotation(ExcelAnnotation.class);
// 如果设置了annottion
if (exa != null) {
String exprot = exa.exportName();
// 添加到标题
exportfieldtile.add(exprot);
// 添加到需要导出的字段的方法
String fieldname = f.getName();
String getMethodName = &quot;get&quot;
+ fieldname.substring(0, 1).toUpperCase()
+ fieldname.substring(1);

Method getMethod = tCls.getMethod(getMethodName,
new Class[] {});

methodObj.add(getMethod);
}
}
sheet.addMergedRegion(new CellRangeAddress(0, 0, 0, exportfieldtile
.size() - 1));
HSSFRow titleRow = sheet.createRow(0);
HSSFCell titleCell = titleRow.createCell(0);
titleCell.setCellValue(title);
titleCell.setCellStyle(this.setTitleStyle(workbook,
workbook.createCellStyle()));
// 产生表格标题行
HSSFRow row = sheet.createRow(1);
for (int i = 0; i &lt; exportfieldtile.size(); i++) {
HSSFCell cell = row.createCell(i);
cell.setCellStyle(style);
HSSFRichTextString text = new HSSFRichTextString(
exportfieldtile.get(i));
cell.setCellValue(text);
}

int index = 1;

// 循环整个list
for (int j = 0; j &lt; dataset.size(); j++) {
// 从第二行开始写，第一行是标题
T t = (T) dataset.get(j);
row = sheet.createRow(index + 1);
for (int k = 0; k &lt; methodObj.size(); k++) {
HSSFCell cell = row.createCell(k);
Method getMethod = methodObj.get(k);
Object value = getMethod.invoke(t, new Object[] {});
String textValue = getValue(value);
cell.setCellValue(textValue);
}
index++;
}

//总的项目笔数
HSSFRow totalNumRow = sheet.createRow(index + 2);
HSSFCell totalNumCellTitle = totalNumRow.createCell(0);
totalNumCellTitle.setCellStyle(setStatStyle(workbook, workbook.createCellStyle()));
totalNumCellTitle.setCellValue(&quot;项目笔数&quot;);
HSSFCell totalNumCell = totalNumRow.createCell(1);
totalNumCell.setCellStyle(setStatStyle(workbook, workbook.createCellStyle()));
totalNumCell.setCellValue(dataset.size());

//总金额
HSSFRow totalMoneyRow = sheet.createRow(index + 3);
HSSFCell totalMoneyCellTitle = totalMoneyRow.createCell(0);
totalMoneyCellTitle.setCellStyle(setStatStyle(workbook, workbook.createCellStyle()));
totalMoneyCellTitle.setCellValue(&quot;总金额&quot;);
HSSFCell totalMoneyCell = totalMoneyRow.createCell(1);
totalMoneyCell.setCellStyle(setStatStyle(workbook, workbook.createCellStyle()));
totalMoneyCell.setCellValue(totalMoney + &quot;万元&quot;);
workbook.write(out);
} catch (Exception e) {
e.printStackTrace();
}

}

public String getValue(Object value) {
String textValue = &quot;&quot;;
if (value == null)
return textValue;

if (value instanceof Boolean) {
boolean bValue = (Boolean) value;
textValue = &quot;是&quot;;
if (!bValue) {
textValue = &quot;否&quot;;
}
} else if (value instanceof Date) {
Date date = (Date) value;

textValue = sdf.format(date);
} else
textValue = value.toString();

return textValue;
}

/**
* 初始化导出的excel标题的样式
* */
public static HSSFCellStyle setTitleStyle(HSSFWorkbook workbook,
HSSFCellStyle style) {

style.setFillForegroundColor(HSSFColor.WHITE.index);
style.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND);
style.setBorderBottom(HSSFCellStyle.BORDER_THIN);
style.setBorderLeft(HSSFCellStyle.BORDER_THIN);
style.setBorderRight(HSSFCellStyle.BORDER_THIN);
style.setBorderTop(HSSFCellStyle.BORDER_THIN);
style.setAlignment(HSSFCellStyle.ALIGN_CENTER);
// 生成字体
HSSFFont font = workbook.createFont();
font.setColor(HSSFColor.BLACK.index);
font.setFontHeightInPoints((short) 16);
font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);
// 把字体应用到当前的样样式
style.setFont(font);
return style;

}

/**
* 统计部分的样式
* @param workbook
* @param style
* @return
*/
public static HSSFCellStyle setStatStyle(HSSFWorkbook workbook,
HSSFCellStyle style) {

style.setFillForegroundColor(HSSFColor.WHITE.index);
style.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND);
style.setBorderBottom(HSSFCellStyle.BORDER_NONE);
style.setBorderLeft(HSSFCellStyle.BORDER_NONE);
style.setBorderRight(HSSFCellStyle.BORDER_NONE);
style.setBorderTop(HSSFCellStyle.BORDER_NONE);
style.setAlignment(HSSFCellStyle.ALIGN_LEFT);
// 生成字体
HSSFFont font = workbook.createFont();
font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);
// 把字体应用到当前的样样式
style.setFont(font);
return style;

}

/**
* 初始化导出的excel样式
* */
public static HSSFCellStyle setHeadStyle(HSSFWorkbook workbook,
HSSFCellStyle style) {

style.setFillForegroundColor(HSSFColor.SKY_BLUE.index);
style.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND);
style.setBorderBottom(HSSFCellStyle.BORDER_THIN);
style.setBorderLeft(HSSFCellStyle.BORDER_THIN);
style.setBorderRight(HSSFCellStyle.BORDER_THIN);
style.setBorderTop(HSSFCellStyle.BORDER_THIN);
style.setAlignment(HSSFCellStyle.ALIGN_CENTER);
// 生成字体
HSSFFont font = workbook.createFont();
font.setColor(HSSFColor.VIOLET.index);
font.setFontHeightInPoints((short) 12);
font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);
// 把字体应用到当前的样样式
style.setFont(font);
return style;

}

public static HSSFCellStyle setbodyStyle(HSSFWorkbook workbook,
HSSFCellStyle style2) {
style2.setFillForegroundColor(HSSFColor.LIGHT_YELLOW.index);
style2.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND);
style2.setBorderBottom(HSSFCellStyle.BORDER_THIN);
style2.setBorderLeft(HSSFCellStyle.BORDER_THIN);
style2.setBorderRight(HSSFCellStyle.BORDER_THIN);
style2.setBorderTop(HSSFCellStyle.BORDER_THIN);
style2.setAlignment(HSSFCellStyle.ALIGN_CENTER);
style2.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);
// 生成字体
HSSFFont font2 = workbook.createFont();
font2.setBoldweight(HSSFFont.BOLDWEIGHT_NORMAL);
// 把字体应用到当前的样样式
style2.setFont(font2);
return style2;
}
}
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
* 用于Excel导出时给每个pojo对象的字段添加字段名称，作为excel的表头
*
* */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface ExcelAnnotation {
// excel导出时标题显示的名字，如果没有设置Annotation属性，将不会被导出和导入
public String exportName();
}
</code>
</RECORD>
<RECORD>
<snippet_key>478876</snippet_key>
<tag>leetcode string</tag>
<comment>来自CSDN博客：LeetCode刷题笔录Length of Last Word http://blog.csdn.net/likecool21/article/details/39751105#</comment>
<code>public class Solution {
public int lengthOfLastWord(String s) {
int end = s.length() - 1;
//search from the end, find the first non-space char
while(end &gt;= 0 &amp;&amp; s.charAt(end) == &apos; &apos;)
end--;
if(end == -1)
return 0;

int start = end;

while(start &gt;= 0 &amp;&amp; s.charAt(start) != &apos; &apos;)
start--;
return end - start;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>478875</snippet_key>
<tag>319</tag>
<comment>来自CSDN博客：【Android开发日记】初次探秘Android Service！Service开机启动+重力感应+弹窗  http://blog.csdn.net/GeekLei/article/details/39749799#</comment>
<code>package com.service;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.util.Log;

public class PopupService extends Service {

&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt; &lt;/span&gt;@Override
&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt; &lt;/span&gt;public IBinder onBind(Intent intent) {
// TODO Auto-generated method stub
return null;
&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt; &lt;/span&gt;}

@Override
public void onCreate() {
super.onCreate();
System.out.println(&quot;Service is Created&quot;);

&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt; &lt;/span&gt;Â }

@Override
public int onStartCommand(Intent intent, int flags, int startId) {
System.out.println(&quot;Service is Started&quot;);


return START_STICKY;
}

@Override
public void onDestroy() {
super.onDestroy();
System.out.println(&quot;Service is Destroyed&quot;);

}

}
&lt;service
android:name=&quot;com.service.PopupService&quot;
android:priority = &quot;1000&quot; &lt;!-- 提高优先级--&gt;
android:persistent=&quot;true&quot;&gt; &lt;!-- 免杀，不知道有没有起作用--&gt;
&lt;intent-filter&gt;
&lt;action android:name=&quot;com.service.POPUP_SERVICE&quot; /&gt;
&lt;/intent-filter&gt;
&lt;/service&gt;
package com.service;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

public class StartupReceiver extends BroadcastReceiver
{
@Override
public void onReceive(Context context, Intent intent)
{
// 启动一个Service
Intent serviceIntent = new Intent(context, PopupService.class);
context.startService(serviceIntent);
}
}
&lt;receiver android:name=&quot;com.service.StartupReceiver&quot;&gt;
&lt;intent-filter&gt;
&lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;
&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
&lt;/intent-filter&gt;
&lt;/receiver&gt;
&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;
Intent popupintent=new Intent();
popupintent.setAction(&quot;com.service.POPUP_SERVICE&quot;);
startService(popupintent);
Intent activityIntent = new Intent(this, SelectFriendsActivity.class);
//要想在Service中启动Activity，必须设置如下标志
activityIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
startActivity(activityIntent);
package com.service;

import com.task.SelectFriendsActivity;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.os.IBinder;
import android.os.Vibrator;
import android.util.Log;

public class PopupService extends Service implements SensorEventListener{

&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt; &lt;/span&gt;//sensorManager
&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt; &lt;/span&gt;private SensorManager sensorManager;
&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt; &lt;/span&gt;private Vibrator vibrator;
&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt; &lt;/span&gt;Intent activityIntent;

&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt; &lt;/span&gt;@Override
&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt; &lt;/span&gt;public IBinder onBind(Intent intent) {
// TODO Auto-generated method stub
return null;
&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt; &lt;/span&gt;}

@Override
public void onCreate() {
super.onCreate();
System.out.println(&quot;Service is Created&quot;);
//&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt;&lt;/span&gt;监听器
sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
vibrator = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
}

@Override
public int onStartCommand(Intent intent, int flags, int startId) {
System.out.println(&quot;Service is Started&quot;);
//启动service，将serviceon置为TRUE，可弹窗。
SelectFriendsActivity.serviceon = true;
if (sensorManager != null) {// 注册监听器
sensorManager.registerListener(this, sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_NORMAL);
// 第一个参数是Listener，第二个参数是所得传感器类型，第三个参数值获取传感器信息的频率
}
&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt; activityIntent = new Intent(this, SelectFriendsActivity.class);
// 要想在Service中启动Activity，必须设置如下标志
activityIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
&lt;style name=&quot;dialogTheme&quot; parent=&quot;android:Theme.Dialog&quot;&gt;
&lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;
&lt;/style&gt;
&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;
@Override
public void onDestroy() {
// super.onDestroy();
// System.out.println(&quot;Service is Destroyed&quot;);
&lt;font size=&quot;4&quot; face=&quot;Microsoft YaHei&quot;&gt;&lt;span style=&quot;font-family:Microsoft YaHei;font-size:18px;&quot;&gt;&lt;span style=&quot;font-family:Microsoft YaHei;font-size:18px;&quot;&gt;&lt;span style=&quot;font-family:Microsoft YaHei;font-size:18px;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/font&gt;&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt; System.out.println(&quot;Service is Destroyed,and is Restarted&quot;);
Intent popupintent=new Intent();
popupintent.setAction(&quot;com.service.POPUP_SERVICE&quot;);
stopService(popupintent);
</code>
</RECORD>
<RECORD>
<snippet_key>180493</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Android中的Parcel机制(下)  http://blog.csdn.net/jiangwei0910410003/article/details/18988827#</comment>
<code>package com.demo.entity;

import java.util.ArrayList;
import java.util.HashMap;

import android.os.Parcel;
import android.os.Parcelable;

/**
* 用户信息，实现Parcelable接口
* String,int,String[],ArrayList&lt;HashMap&lt;String,Object&gt;&gt;这四种类型测试
* @author weijiang204321
*
*/
public class UserInfo implements Parcelable{

private String id;
private String name;
private int age;
private String[] boyfriendAry = new String[3];
private ArrayList&lt;HashMap&lt;String,SonInfo&gt;&gt; listData = new ArrayList&lt;HashMap&lt;String,SonInfo&gt;&gt;();
private SonInfo sonInfo;

public UserInfo(){
}

public UserInfo(String id,String name,int age,String[] boyfriendAry,ArrayList&lt;HashMap&lt;String,SonInfo&gt;&gt; listData){
this.id = id;
this.name = name;
this.age = age;
this.boyfriendAry = boyfriendAry;
this.listData = listData;
}

public UserInfo(Parcel source){
id = source.readString();
name = source.readString();
age = source.readInt();
sonInfo = source.readParcelable(SonInfo.class.getClassLoader());
source.readStringArray(boyfriendAry);
source.readList(listData, SonInfo.class.getClassLoader());
}

public String getId() {
return id;
}

public void setId(String id) {
this.id = id;
}

public String getName() {
return name;
}

public void setName(String name) {
this.name = name;
}

public int getAge() {
return age;
}

public void setAge(int age) {
this.age = age;
}

public SonInfo getSonInfo(){
return sonInfo;
}

public void setSonInfo(SonInfo sonInfo){
this.sonInfo = sonInfo;
}

public String[] getBoyfriendAry() {
return boyfriendAry;
}

public void setBoyfriendAry(String[] boyfriendAry) {
this.boyfriendAry = boyfriendAry;
}

public ArrayList&lt;HashMap&lt;String, SonInfo&gt;&gt; getListData() {
return listData;
}

public void setListData(ArrayList&lt;HashMap&lt;String, SonInfo&gt;&gt; listData) {
this.listData = listData;
}


@Override
public int describeContents() {
return 0;
}

//进行序列化存储
@Override
public void writeToParcel(Parcel dest, int flags) {
dest.writeString(id);
dest.writeString(name);
dest.writeInt(age);
dest.writeParcelable(sonInfo, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);

dest.writeStringArray(boyfriendAry);
dest.writeList(listData);
}

public static final Parcelable.Creator&lt;UserInfo&gt; CREATOR = new Creator&lt;UserInfo&gt;() {
@Override
public UserInfo[] newArray(int size) {
return new UserInfo[size];
}

//将Parcel对象反序列化为UserInfo
@Override
public UserInfo createFromParcel(Parcel source) {
return new UserInfo(source);
}
};

}
package com.demo.entity;

import android.os.Parcel;
import android.os.Parcelable;

public class SonInfo implements Parcelable{

private String id;
private String name;

public SonInfo(){

}

public SonInfo(String id,String name){
this.id = id;
this.name = name;
}

public SonInfo(Parcel source){
this.id = source.readString();
this.name = source.readString();
}

public String getId() {
return id;
}
public void setId(String id) {
this.id = id;
}
public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}

@Override
public int describeContents() {
return 0;
}

@Override
public void writeToParcel(Parcel dest, int flags) {
dest.writeString(id);
dest.writeString(name);
}

public static final Parcelable.Creator&lt;SonInfo&gt; CREATOR = new Creator&lt;SonInfo&gt;() {
@Override
public SonInfo[] newArray(int size) {
return new SonInfo[size];
}

//将Parcel对象反序列化为UserInfo
@Override
public SonInfo createFromParcel(Parcel source) {
return new SonInfo(source);
}
};

}
package com.demo.parcel;

import java.util.ArrayList;
import java.util.HashMap;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;

import com.demo.entity.SonInfo;
import com.demo.entity.UserInfo;

public class MainActivity extends Activity {

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

Intent intent = new Intent(this,StubActivity.class);
ArrayList&lt;HashMap&lt;String,SonInfo&gt;&gt; listData = new ArrayList&lt;HashMap&lt;String,SonInfo&gt;&gt;();
HashMap&lt;String,SonInfo&gt; tempMap = new HashMap&lt;String,SonInfo&gt;();
tempMap.put(&quot;one_child&quot;, new SonInfo(&quot;001_1&quot;,&quot;jiangwei_one_child&quot;));
listData.add(tempMap);

UserInfo userInfo = new UserInfo(&quot;001&quot;,&quot;jiangwei&quot;,24,new String[]{&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;},listData);
SonInfo sonInfo = new SonInfo();
sonInfo.setId(&quot;001_1&quot;);
sonInfo.setName(&quot;jiangwei_child&quot;);
userInfo.setSonInfo(sonInfo);
intent.putExtra(&quot;userinfo&quot;, userInfo);
startActivity(intent);

}

}
package com.demo.parcel;

import java.util.ArrayList;
import java.util.HashMap;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;

import com.demo.entity.SonInfo;
import com.demo.entity.UserInfo;

public class StubActivity extends Activity {

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_stub);

UserInfo userInfo = (UserInfo)this.getIntent().getParcelableExtra(&quot;userinfo&quot;);
SonInfo sonInfo = userInfo.getSonInfo();

String[] boyfriend = userInfo.getBoyfriendAry();
for(int i=0;i&lt;boyfriend.length;i++){
Log.e(&quot;boyfriend_name:&quot;,boyfriend[i]);
}

ArrayList&lt;HashMap&lt;String,SonInfo&gt;&gt; listData = userInfo.getListData();
for(int j=0;j&lt;listData.size();j++){
SonInfo temp_soninfo = listData.get(j).get(&quot;one_child&quot;);
Log.e(&quot;OneChildId:&quot;,temp_soninfo.getId()+&quot;&quot;);
Log.e(&quot;OneChildName:&quot;,temp_soninfo.getName()+&quot;&quot;);
}



Log.e(&quot;UserId:&quot;,userInfo.getId()+&quot;&quot;);
Log.e(&quot;UserName:&quot;,userInfo.getName()+&quot;&quot;);
Log.e(&quot;UserAge:&quot;,userInfo.getAge()+&quot;&quot;);
Log.e(&quot;Son_id:&quot;,sonInfo.getId()+&quot;&quot;);
Log.e(&quot;Son_name:&quot;,sonInfo.getName()+&quot;&quot;);

}

}
</code>
</RECORD>
<RECORD>
<snippet_key>246029</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：PAT-1007. Maximum Subsequence Sum(最大连续子数列)  http://blog.csdn.net/very_caiing/article/details/21565843#</comment>
<code>import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main{

public static class SubMax{
int begin;
int end;
int sum;
}
public static List&lt;Integer&gt; allList;

public static void main(String[] args) {

//List&lt;Integer&gt; allList = new ArrayList&lt;Integer&gt;();
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
allList = new ArrayList&lt;Integer&gt;();
for(int i = 0; i &lt; n; i ++)
allList.add(sc.nextInt());

SubMax res = GetMaxSub(allList.size()-1);
if(res.sum &lt; 0)
{
res.sum = 0;
res.begin = 0;
res.end = allList.size()-1;
}
System.out.print(res.sum + &quot; &quot;);
System.out.print(allList.get(res.begin) + &quot; &quot;);
System.out.print(allList.get(res.end));

sc.close();
}

public static SubMax GetMaxSub(int nEnd)
{
SubMax sub = new SubMax();
if(nEnd == 0)
{
sub.begin = 0;
sub.end = 0;
sub.sum = allList.get(0);
return sub;
}
SubMax sub2 = GetMaxSub(nEnd-1);

int lastSum = 0;
int lastBegin = 0;
int tmpSum = 0;
if(allList.get(nEnd) &lt;= 0)
{
return sub2;
}
else
{

int i = nEnd;
while(i &gt;= 0)
{
tmpSum += allList.get(i);
if(tmpSum &gt; lastSum)
{
lastSum = tmpSum;
lastBegin = i;
}
i = i - 1;
}
if(lastSum &gt; sub2.sum)
{
sub2.sum = lastSum;
sub2.begin = lastBegin;
sub2.end = nEnd;
}
}
return sub2;
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>442637</snippet_key>
<tag>JavaMail Spring</tag>
<comment>来自CSDN博客：JavaMail http://blog.csdn.net/brushli/article/details/38376481#</comment>
<code>package com.javamail;

/**
* 邮件服务接口
*/
public interface MailSendService {

/**
* 发送纯文本的邮件.
*/
public void sendText(String subject,String content,String[] mailto) throws Exception;

/**
* 发送HTML格式邮件
*/
public void sendHtml(String subject,String content,String[] mailto) throws Exception;

/**
* 发送带附件的HTML邮件
*/
public void sendHtmlWithAttachment(String subject, String content,String[] mailto,String[] filepaths) throws Exception;

/**
* 发送带附件的HTML邮件,区分收件人和抄送
*/
public void sendHtmlWithAttachmentAndCopyTo(String subject, String content,String[] mailto,String copyTo[],String[] filepaths) throws Exception;
}
</code>
</RECORD>
<RECORD>
<snippet_key>49677</snippet_key>
<tag>273</tag>
<comment>android绘制一条虚线的方法</comment>
<code>import android.annotation.SuppressLint;
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.DashPathEffect;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.PathEffect;
import android.util.AttributeSet;
import android.view.View;

@SuppressLint(&quot;DrawAllocation&quot;)
/**
* 绘制间断的直线 e.g:- - - - -
*
*/
public class DashLine extends View{

public int mLeft;
public int mRight;
public int mTop;
public int mBottom;
public DashLine(Context context, AttributeSet attrs) {
super(context, attrs);
}

@Override
protected void onDraw(Canvas canvas) {
Paint linePaint = new Paint();
linePaint.setColor(0xFFd6d6d6);
//linePaint.setCo
linePaint.setStyle(Paint.Style.STROKE);
//绘制模式
PathEffect effect = new DashPathEffect(new float[] { 4,4}, 1);
linePaint.setAntiAlias(true);
linePaint.setPathEffect(effect);
linePaint.setStrokeWidth(1);
Path path=new Path();
path.moveTo(mLeft-4, ((mBottom-mTop)/2));
path.lineTo(mRight+4, ((mBottom-mTop)/2));
canvas.drawPath(path, linePaint);
}

@Override
protected void onLayout(boolean changed, int left, int top, int right,
int bottom) {
mLeft=left;
mRight=right;
mTop=top;
mBottom=bottom;
super.onLayout(changed, left, top, right, bottom);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>478863</snippet_key>
<tag>36</tag>
<comment>来自CSDN博客：Activity的生命周期函数  http://blog.csdn.net/yan309271291/article/details/39743617#</comment>
<code>package com.away.b_02_lifecycle;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.Menu;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;

public class MainActivity extends Activity {

private Button button;

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
button = (Button) findViewById(R.id.Button);
button.setOnClickListener(new ButtonListener());
System.out.println(&quot;MainActivity:OnCreate&quot;);
}

class ButtonListener implements OnClickListener {
@Override
public void onClick(View v) {
Intent intent = new Intent();
intent.setClass(MainActivity.this, OtherActivity.class);
startActivity(intent);
}
}

@Override
protected void onDestroy() {
super.onDestroy();
System.out.println(&quot;MainActivity:onDestroy&quot;);
}

@Override
protected void onPause() {
super.onPause();
System.out.println(&quot;MainActivity:onPause&quot;);
}

@Override
protected void onRestart() {
super.onRestart();
System.out.println(&quot;MainActivity:onRestart&quot;);
}

@Override
protected void onResume() {
super.onResume();
System.out.println(&quot;MainActivity:onResume&quot;);
}

@Override
protected void onStart() {
super.onStart();
System.out.println(&quot;MainActivity:onStart&quot;);
}

@Override
protected void onStop() {
super.onStop();
System.out.println(&quot;MainActivity:onStop&quot;);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>115469</snippet_key>
<tag></tag>
<comment>来自CSDN博客：java中表格选择行列返回-1的问题  http://blog.csdn.net/u010571913/article/details/17370977#</comment>
<code>System.out.println(table.getSelectedRow()); Â 
System.out.println(table.getSelectedColumn());
middle.add(new JScrollPane(table));//
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;initTable();
js.setViewportView(table);
middle.add(js);
</code>
</RECORD>
<RECORD>
<snippet_key>478857</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：JavaSE 之 如何将一个用逗号分隔的字符串转换成字符数组 http://blog.csdn.net/u011863275/article/details/39744289#</comment>
<code>package com.test.string;//构建自己的包
import java.util.StringTokenizer;//导入StringTokenizer 类，后面要用到此类来创建对象和此类的方法。
public class StrToArray{

public static void main(String[] args) {
String str=&quot;a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z&quot;;
String[] strArray=null;
System.out.println(&quot;调用convertStrToArray结果：&quot;);
strArray = convertStrToArray(str);
printArray(strArray);

System.out.println(&quot;调用convertStrToArray2结果：&quot;);
strArray = convertStrToArray2(str);
printArray(strArray);
}
//使用String的split 方法
public static String[] convertStrToArray(String str){
String[] strArray = null;
strArray = str.split(&quot;,&quot;); //拆分字符为&quot;,&quot; ,然后把结果交给数组strArray
return strArray;
}

//使用StringTokenizer实现
//api说明：StringTokenizer 是出于兼容性的原因而被保留的遗留类
//（虽然在新代码中并不鼓励使用它）。建议所有寻求此功能的人使用
//String 的 split 方法或 java.util.regex 包
public static String[] convertStrToArray2(String str){
StringTokenizer st = new StringTokenizer(str,&quot;,&quot;);//把&quot;,&quot;作为分割标志，然后把分割好的字符赋予StringTokenizer对象。
String[] strArray = new String[st.countTokens()];//通过StringTokenizer 类的countTokens方法计算在生成异常之前可以调用此 tokenizer 的 nextToken 方法的次数。
int i=0;
while(st.hasMoreTokens()){//看看此 tokenizer 的字符串中是否还有更多的可用标记。
strArray[i++] = st.nextToken();//返回此 string tokenizer 的下一个标记。
}
return strArray;
}
//输出数组
public static void printArray(String[] array){
for(int i=0;i&lt;array.length;i++){
System.out.print(array[i]);
if(i==array.length-1){
System.out.print(&quot;\n&quot;);
}else{
System.out.print(&quot;,&quot;);
}
}
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>443149</snippet_key>
<tag>map Hadoop reduce WordCount</tag>
<comment>来自CSDN博客：hadoop之WordCount源码分析  http://blog.csdn.net/christprince007/article/details/38382835#</comment>
<code>&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;

package org.apache.hadoop.mapred;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapred.FileInputFormat;
import org.apache.hadoop.mapred.FileOutputFormat;
import org.apache.hadoop.mapred.JobClient;
import org.apache.hadoop.mapred.JobConf;
import org.apache.hadoop.mapred.MapReduceBase;
import org.apache.hadoop.mapred.Mapper;
import org.apache.hadoop.mapred.OutputCollector;
import org.apache.hadoop.mapred.Reducer;
import org.apache.hadoop.mapred.Reporter;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;


public class WordCount extends Configured implements Tool {

/*
这个类实现mapper接口的map方法，输入的是文本总的每一行。利用StringTokenizer将字符串拆分成单词。然后将输出结果(word, 1)写入到OutputCollector中去
OutputCollector有hadoop框架提供，负责收集mapper和reducer的输出数据，实现map函数和reduce函数时。只需要将输出的&lt;key,value&gt;对向OutputCollector一丢即可，其余的事情框架会自己处理。
*/
public static class MapClass extends MapReduceBase
implements Mapper&lt;LongWritable, Text, Text, IntWritable&gt; {

private final static IntWritable one = new IntWritable(1);
private Text word = new Text();
/*类中的LongWritable, Text, IntWritable是hadoop中实现的用于封装Java数据类型的类，这些类都能够被串行化从而便于在分布式系统中进行数据交换，可以将它们等同的视为long,string,int的替代品
*/
public void map(LongWritable key, Text value,
OutputCollector&lt;Text, IntWritable&gt; output,
Reporter reporter) throws IOException {
String line = value.toString();
StringTokenizer itr = new StringTokenizer(line);
while (itr.hasMoreTokens()) {
word.set(itr.nextToken());
output.collect(word, one);//输出结果（word，1）
}
}
}

/*
此类实现的是Reducer接口中的reduce方法，函数中的参数key.value是由mapper输出的中间结果，values是一个iterator（迭代器）
*/
public static class Reduce extends MapReduceBase
implements Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {

public void reduce(Text key, Iterator&lt;IntWritable&gt; values,
OutputCollector&lt;Text, IntWritable&gt; output,
Reporter reporter) throws IOException {
int sum = 0;
/*
遍历这个迭代器，就能够得到有相同的key的所有的value值。
此处的key是一个单词，而value则是词频
*/
while (values.hasNext()) {
sum += values.next().get();
}
//遍历后得到这个单词出现的总次数。
output.collect(key, new IntWritable(sum));
}
}

static int printUsage() {
System.out.println(&quot;wordcount [-m &lt;maps&gt;] [-r &lt;reduces&gt;] &lt;input&gt; &lt;output&gt;&quot;);//输入输入路径
ToolRunner.printGenericCommandUsage(System.out);
return -1;
}

/*
Wordcount 中map/reduce项目的主要驱动程序，调用此方法提交的map / reduce任务。在hadoop中一次计算任务成为一个job，可以通过以一个JobConf对象设置如何运行这个job，此处定义了输出的key 类型是text,而value的类型是IntWritable
*/
public int run(String[] args) throws Exception {
JobConf conf = new JobConf(getConf(), WordCount.class);
conf.setJobName(&quot;wordcount&quot;);

// key是text（words）
conf.setOutputKeyClass(Text.class);
// value是IntWritable (ints)
conf.setOutputValueClass(IntWritable.class);

conf.setMapperClass(MapClass.class);
conf.setCombinerClass(Reduce.class);
conf.setReducerClass(Reduce.class);

List&lt;String&gt; other_args = new ArrayList&lt;String&gt;();
for(int i=0; i &lt; args.length; ++i) {
try {
if (&quot;-m&quot;.equals(args[i])) {
conf.setNumMapTasks(Integer.parseInt(args[++i]));
} else if (&quot;-r&quot;.equals(args[i])) {
conf.setNumReduceTasks(Integer.parseInt(args[++i]));
} else {
other_args.add(args[i]);
}
} catch (NumberFormatException except) {
System.out.println(&quot;ERROR: Integer expected instead of &quot; + args[i]);
return printUsage();
} catch (ArrayIndexOutOfBoundsException except) {
System.out.println(&quot;ERROR: Required parameter missing from &quot; +
args[i-1]);
return printUsage();
}
}
// Make sure there are exactly 2 parameters left.
if (other_args.size() != 2) {
System.out.println(&quot;ERROR: Wrong number of parameters: &quot; +
other_args.size() + &quot; instead of 2.&quot;);
return printUsage();
}
FileInputFormat.setInputPaths(conf, other_args.get(0));
FileOutputFormat.setOutputPath(conf, new Path(other_args.get(1)));

JobClient.runJob(conf);
return 0;
}


public static void main(String[] args) throws Exception {
/* ToolRunner的run方法开始,run方法有三个参数。第一个是Configuration类的实例，第二个是wordcount的实例，args则是从控制台接收到的命令行数组
*/
int res = ToolRunner.run(new Configuration(), new WordCount(), args);
System.exit(res);
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>478846</snippet_key>
<tag>319</tag>
<comment>来自CSDN博客：ActionBar详解(六)---&gt;利用ActionBar结合Fragment实现下拉式导航 http://blog.csdn.net/lfdfhl/article/details/12526527# 派生自lfdfhl/blog_20140605_1_5198017</comment>
<code>package cc.testsimpleactionbar5;

import android.os.Bundle;
import android.widget.ArrayAdapter;
import android.app.ActionBar;
import android.app.ActionBar.OnNavigationListener;
import android.app.Activity;
import android.app.FragmentTransaction;
/**
* Demo描述:
* 利用ActionBar结合Fragment实现下拉式导航.
* 且根据不同的导航利用Fragment显示不同的内容
*
* 备注说明:
* 该示例和TestSimpleActionBar4示例的布局文件一致.
* 代码实现也类似,只是导航方式不同罢了
*
* 参考资料:
* 1 Android疯狂讲义(第二版)
* Thank you very much
*
*/
public class MainActivity extends Activity {
private ActionBar mActionBar;
private final static String SELECTED_PAGE_INDEX=&quot;selected_page&quot;;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
initActionBar();
}

private void initActionBar(){
mActionBar=getActionBar();
//设置是否显示ActionBar的标题
mActionBar.setDisplayShowTitleEnabled(true);
//设置导航方式为LIST
mActionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_LIST);

ArrayAdapter&lt;String&gt; arrayAdapter=new ArrayAdapter&lt;String&gt;(
MainActivity.this,
android.R.layout.simple_list_item_1,
android.R.id.text1,
new String[]{&quot;第一页&quot;,&quot;第二页&quot;,&quot;第三页&quot; });
//为ActionBar设置ArrayAdapter和导航监听
mActionBar.setListNavigationCallbacks(arrayAdapter,new NavigationListenerImpl());

}

private class NavigationListenerImpl implements OnNavigationListener{
@Override
public boolean onNavigationItemSelected(int position, long id) {
System.out.println(&quot; onNavigationItemSelected &quot;);
TestFragment testFragment=new TestFragment();
Bundle bundle=new Bundle();
bundle.putString(TestFragment.KEY, &quot;这是第&quot;+(position+1)+&quot;页&quot;);
testFragment.setArguments(bundle);
FragmentTransaction fragmentTransaction=getFragmentManager().beginTransaction();
fragmentTransaction.replace(R.id.relativeLayoutContainer, testFragment);
fragmentTransaction.commit();
return false;
}

}


// 以下处理横竖屏的切换

// 将当前选中页的索引保存到Bundle中
@Override
protected void onSaveInstanceState(Bundle bundle) {
super.onSaveInstanceState(bundle);
bundle.putInt(SELECTED_PAGE_INDEX,mActionBar.getSelectedNavigationIndex());
}

// 获取已经保存的被选中页的索引,且设置ActionBar.
// setSelectedNavigationItem()方法会调用onNavigationItemSelected()
@Override
protected void onRestoreInstanceState(Bundle bundle) {
super.onRestoreInstanceState(bundle);
mActionBar.setSelectedNavigationItem(bundle.getInt(SELECTED_PAGE_INDEX));
}


}
package cc.testsimpleactionbar5;

import android.app.Fragment;
import android.os.Bundle;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

public class TestFragment extends Fragment {
public static final String KEY=&quot;key&quot;;
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container,Bundle savedInstanceState) {
TextView textView=new TextView(getActivity());
textView.setGravity(Gravity.CENTER);
Bundle bundle=this.getArguments();
String content=bundle.getString(KEY);
textView.setText(content);
textView.setTextSize(30);
return textView;
}
}
&lt;RelativeLayout
xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot;
android:id=&quot;@+id/relativeLayoutContainer&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
&gt;

&lt;/RelativeLayout&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>478843</snippet_key>
<tag>位图 bitmap</tag>
<comment>来自CSDN博客：bitmap排序 http://blog.csdn.net/cow__sky/article/details/39743705#</comment>
<code>public class BitmapSort {

public static void bitmapsort(int[] num){
if(num==null)
return;
int max = num[0];
//找出最大的数，以确定位图数组的大小
for(int i = 0 ; i&lt;num.length ; i++){
max = max&gt;num[i]?max:num[i];
}
//位图数组长度
int len = max/Character.SIZE + (max%Character.SIZE==0?0:1);
//创建位图数组，采用char类型即可
char[] sort = new char[len];
//记录每个数出现的次数
Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
//开始统计
for(int i = 0 ; i &lt; num.length ; i++){
int index = num[i]/Character.SIZE;
sort[index] = (char)(sort[index]|(0x01&lt;&lt;num[i]%Character.SIZE));
if(map.containsKey(num[i]))
map.put(num[i],map.get(num[i])+1);
else
map.put(num[i], 1);
}

System.out.println(map.size());
int index = 0 ;
//得出排序结果
for(int i = 0 ;i &lt; sort.length ;i++){
for(int j = 0 ; j &lt; Character.SIZE ; j++){
int tmp = sort[i]&amp;(0x01&lt;&lt;j);
if(tmp &gt; 0){
int number = i*Character.SIZE+j;
int count = map.get(number);
while(count&gt;0){
num[index++] = number;
count--;
}//while
}
}//for
}//for
}
</code>
</RECORD>
<RECORD>
<snippet_key>377869</snippet_key>
<tag>449</tag>
<comment>来自CSDN博客：tomcat启动报错，找不到对应的 queue，从而引发内存泄漏 http://blog.csdn.net/u011453631/article/details/28616035#</comment>
<code>tomcat启动报错,无法创建 bean listenerStatusChangeDealHandler, no queue &apos;STOCK.NOTIFY_CHANGE.INTER.CACHE.QUEUE&apos; in vhost
Jun 5, 2014 1:39:42 PM org.apache.catalina.core.StandardContext listenerStart
SEVERE: Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListener
org.springframework.context.ApplicationContextException: Failed to start bean &apos;listenerStatusChangeDealHandler&apos;;
nested exception is org.springframework.amqp.AmqpIllegalStateException: Fatal exception on listener startup
at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:169)
...
Caused by: org.springframework.amqp.AmqpIllegalStateException: Fatal exception on listener startup
at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.doStart(SimpleMessageListenerContainer.java:339)
at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.start(AbstractMessageListenerContainer.java:363)
at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:166)
... 33 more
Caused by: org.springframework.amqp.rabbit.listener.FatalListenerStartupException: Cannot prepare queue for listener.
Either the queue doesn&apos;t exist or the broker will not allow us to use it.
at org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.start(BlockingQueueConsumer.java:228)
at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer$AsyncMessageProcessingConsumer.run(SimpleMessageListenerContainer.java:524)
at java.lang.Thread.run(Thread.java:662)
Caused by: com.rabbitmq.client.ShutdownSignalException: channel error; reason: {#method&lt;channel.close&gt;(reply-code=404, reply-text=NOT_FOUND - no queue &apos;STOCK.NOTIFY_CHANGE.INTER.CACHE.QUEUE&apos; in vhost &apos;/&apos;, class-id=50, method-id=10), null, &quot;&quot;}
at com.rabbitmq.utility.ValueOrException.getValue(ValueOrException.java:67)
at com.rabbitmq.utility.BlockingValueOrException.uninterruptibleGetValue(BlockingValueOrException.java:33)
at com.rabbitmq.client.impl.AMQChannel$BlockingRpcContinuation.getReply(AMQChannel.java:343)
at com.rabbitmq.client.impl.AMQChannel.privateRpc(AMQChannel.java:216)
at com.rabbitmq.client.impl.AMQChannel.exnWrappingRpc(AMQChannel.java:118)
... 11 more
Caused by: com.rabbitmq.client.ShutdownSignalException: channel error; reason: {#method&lt;channel.close&gt;(reply-code=404, reply-text=NOT_FOUND - no queue &apos;STOCK.NOTIFY_CHANGE.INTER.CACHE.QUEUE&apos; in vhost &apos;/&apos;, class-id=50, method-id=10), null, &quot;&quot;}
at com.rabbitmq.client.impl.ChannelN.asyncShutdown(ChannelN.java:454)
at com.rabbitmq.client.impl.ChannelN.processAsync(ChannelN.java:294)
at com.rabbitmq.client.impl.AMQChannel.handleCompleteInboundCommand(AMQChannel.java:144)
at com.rabbitmq.client.impl.AMQChannel.handleFrame(AMQChannel.java:91)
at com.rabbitmq.client.impl.AMQConnection$MainLoop.run(AMQConnection.java:526)
Jun 5, 2014 1:39:42 PM org.apache.catalina.core.StandardContext start
SEVERE: Error listenerStart
Jun 5, 2014 1:39:42 PM org.apache.catalina.core.StandardContext start
SEVERE: Context [/TravelHubPkgStock] startup failed due to previous errors
Jun 5, 2014 1:39:42 PM org.apache.catalina.core.ApplicationContext log
INFO: Closing Spring root WebApplicationContext
Jun 5, 2014 1:39:42 PM org.apache.catalina.loader.WebappClassLoader clearReferencesJdbc
SEVERE: The web application [/TravelHubPkgStock] registered the JDBC driver [oracle.jdbc.driver.OracleDriver] but failed to unregister it when the web application was stopped. To prevent a memory leak, the JDBC Driver has been forcibly unregistered.
Jun 5, 2014 1:39:42 PM org.apache.catalina.loader.WebappClassLoader clearReferencesThreads
SEVERE: The web application [/TravelHubPkgStock] appears to have started a thread named [Thread-2] but has failed to stop it. This is very likely to create a memory leak.
Jun 5, 2014 1:39:42 PM org.apache.catalina.loader.WebappClassLoader clearReferencesThreads
SEVERE: The web application [/TravelHubPkgStock] appears to have started a thread named [Thread-3] but has failed to stop it. This is very likely to create a memory leak.
Jun 5, 2014 1:39:47 PM org.apache.coyote.http11.Http11Protocol start
INFO: Starting Coyote HTTP/1.1 on http-8080
Jun 5, 2014 1:39:48 PM org.apache.jk.common.ChannelSocket init
INFO: JK: ajp13 listening on /0.0.0.0:9090
Jun 5, 2014 1:39:48 PM org.apache.jk.server.JkMain start
INFO: Jk running ID=0 time=0/121 config=null
Jun 5, 2014 1:39:48 PM org.apache.catalina.startup.Catalina start
INFO: Server startup in 324602 ms
</code>
</RECORD>
<RECORD>
<snippet_key>116237</snippet_key>
<tag>184</tag>
<comment>该段代码用来演示子线程向主线程传递消息，并更改UI控件。</comment>
<code>package com.elephant.handlerdemo2;

import android.app.Activity;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.TextView;

public class MainActivity extends Activity {
private Button butt;
private TextView textView;
private NetworkHandler networkHandler;

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

butt = (Button) findViewById(R.id.clickButt);
textView = (TextView) findViewById(R.id.textZone);
networkHandler = new NetworkHandler();

butt.setOnClickListener(new ClickButtListener());
}

class NetworkThread extends Thread {
@Override
public void run() {
try {
Thread.sleep(3 * 1000);
} catch (InterruptedException e) {
e.printStackTrace();
}
System.out.println(&quot;NetworkThread-------&gt;&quot; + Thread.currentThread().getName());

Message msg = networkHandler.obtainMessage();
msg.obj = &quot;我从网络而来，只为见你一面！&quot;;
networkHandler.sendMessage(msg);
}
}

class NetworkHandler extends Handler {
@Override
public void handleMessage(Message msg) {
System.out.println(&quot;NetworkHandler-------&gt;&quot; + Thread.currentThread().getName());

String networkInfo = (String) msg.obj;
textView.setText(networkInfo);
}
}

/**
* @author zhangxy
* 接收网络消息按钮监听器
*/
class ClickButtListener implements OnClickListener {
@Override
public void onClick(View v) {
new NetworkThread().start();
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>181773</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Struts旅程（四）MVC向struts MVC框架演变过程  http://blog.csdn.net/lovesummerforever/article/details/18963959#</comment>
<code>package com.bjpowernode.servlet;

public class UserManager {

public void add(String username)
{
System.out.println(&quot;UserManager.add()--&gt;&gt;&quot;+ username);
}
}
&lt;servlet&gt;
&lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.bjpowernode.servlet.TestServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;


&lt;servlet-mapping&gt;
&lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt;

&lt;url-pattern&gt;/servlet/TestServlet&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
package com.bjpowernode.servlet;

import java.io.IOException;
import java.util.List;

import javax.servlet.ServletException;
importjavax.servlet.http.HttpServlet;
importjavax.servlet.http.HttpServletRequest;
importjavax.servlet.http.HttpServletResponse;

public class TestServlet extendsHttpServlet {

@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {
String username = request.getParameter(“username”);
UserManager userManager = new UserManager();
userManager.add(username);
request.getRequestDispatcher(“/add_success.jsp”).forward(request,response);
}


@Override
protected void doPost(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {

doGet(request,response);
}
}
&lt;form action=&quot;servlet/queryUser.action&quot; method=&quot;post&quot;&gt;
姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;
&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt;
&lt;/form&gt;
import java.io.IOException;
import java.util.List;

importjavax.servlet.ServletException;
importjavax.servlet.http.HttpServlet;
importjavax.servlet.http.HttpServletRequest;
importjavax.servlet.http.HttpServletResponse;

public class TestServlet extendsHttpServlet {

@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {
//截取url.
String requestURI = request.getRequestURI();
//System.out.println(&quot;requestURI=&quot;+ requestURI);

//截取http://localhost:8080/test_servlet/servlet/addUser.action test_servlet后面的东西。
String path = requestURI.substring(requestURI.indexOf(&quot;/&quot;, 1),requestURI.indexOf(&quot;.&quot;));
//截取得到虚目录。/servlet/addUser
System.out.println(&quot;path=&quot;+ path);



String username = request.getParameter(&quot;username&quot;);
UserManager userManager = new UserManager();

String forward = &quot;&quot;;
//判断截取的path和哪个要加载的页面相等.
if(&quot;/servlet/delUser&quot;.equals(path))
{
userManager.del(username);
forward = &quot;del_success.jsp&quot;;
//request.getRequestDispatcher(&quot;/del_success.jsp&quot;).forward(request,response);
}else if(&quot;/servlet/addUser&quot;.equals(path))
{
userManager.add(username);
forward= &quot;add_success.jsp&quot;;
//request.getRequestDispatcher(&quot;/add_success.jsp&quot;).forward(request,response);
}else if(&quot;/servlet/modifyUser&quot;.equals(path))
{
userManager.modify(username);
forward= &quot;modify_success.jsp&quot;;
//request.getRequestDispatcher(&quot;/modify_success.jsp&quot;).forward(request,response);

}else if(&quot;/servlet/queryUser&quot;.equals(path))
{
List userList = userManager.query(username);
request.setAttribute(&quot;userList&quot;,userList);

forward= &quot;query_success.jsp&quot;;

//request.getRequestDispatcher(&quot;/query_success.jsp&quot;).forward(request,response);
}else
{
throw new RuntimeException(&quot;请求失败!&quot;);
}

request.getRequestDispatcher(forward).forward(request,response);

}
@Override
protected void doPost(HttpServletRequest request, HttpServletResponse response)
throwsServletException, IOException {

doGet(request,response);
}

}
package com.bjpowernode.servlet;

import java.util.ArrayList;
import java.util.List;

public class UserManager {

public void add(String username)
{
System.out.println(&quot;UserManager.add()--&gt;&gt;&quot;+ username);
}

public void del(String username)
{
System.out.println(&quot;UserManager.del()--&gt;&gt;&quot;+ username);
}


public void modify(String username)
{
System.out.println(&quot;UserManager.modify()--&gt;&gt;&quot;+ username);
}

public List query(String username)
{
System.out.println(&quot;UserManager.query()--&gt;&gt;&quot;+ username);

List userList = new ArrayList();
userList.add(&quot;a&quot;);
userList.add(&quot;b&quot;);
userList.add(&quot;c&quot;);

return userList;
}

}
&lt;body&gt;

&lt;form action=&quot;servlet/queryUser.action&quot; method=&quot;post&quot;&gt;
姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;
&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt;
&lt;/form&gt;
&lt;/body&gt;
String username = request.getParameter(&quot;username&quot;);
UserManager userManager = new UserManager();

String forward = &quot;&quot;;
//判断截取的path和哪个要加载的页面相等.
if(&quot;/servlet/delUser&quot;.equals(path))
{
userManager.del(username);
forward= &quot;del_success.jsp&quot;;
}else if(&quot;/servlet/addUser&quot;.equals(path))
{
userManager.add(username);
forward= &quot;add_success.jsp&quot;;
}elseif(&quot;/servlet/modifyUser&quot;.equals(path))
{
userManager.modify(username);
forward= &quot;modify_success.jsp&quot;;


}else if(&quot;/servlet/queryUser&quot;.equals(path))
{
List userList = userManager.query(username);
request.setAttribute(&quot;userList&quot;,userList);

forward= &quot;query_success.jsp&quot;;

}else
{
thrownew RuntimeException(&quot;请求失败!&quot;);
}
request.getRequestDispatcher(forward).forward(request,response);
package com.bjpowernode.servlet;

importjavax.servlet.http.HttpServletRequest;
importjavax.servlet.http.HttpServletResponse;

public interface Action {

public String execute(HttpServletRequest request, HttpServletResponse response) throws Exception;

}
package com.bjpowernode.servlet;

importjavax.servlet.http.HttpServletRequest;
importjavax.servlet.http.HttpServletResponse;

public class AddUserActionimplements Action {

@Override
public String execute(HttpServletRequest request,HttpServletResponse response) throws Exception {
String username = request.getParameter(&quot;username&quot;);
//Stringsex = request.getParameter(&quot;sex&quot;);
//...........
//调用业务逻辑.

UserManager userManager = new UserManager();
userManager.add(username);

return&quot;/add_success.jsp&quot;;


}

}

package com.bjpowernode.servlet;

importjavax.servlet.http.HttpServletRequest;
importjavax.servlet.http.HttpServletResponse;

public class DelUserActionimplements Action {

@Override
public String execute(HttpServletRequest request,HttpServletResponse response) throws Exception {
String username = request.getParameter(&quot;username&quot;);
//String sex = request.getParameter(&quot;sex&quot;);
//...........
//调用业务逻辑.
UserManager userManager = new UserManager();
try
{
userManager.del(username);
}catch(Exceptione)
{
return&quot;del_error.jsp&quot;;
}



return&quot;/del_success.jsp&quot;;


}

}

package com.bjpowernode.servlet;

importjavax.servlet.http.HttpServletRequest;
importjavax.servlet.http.HttpServletResponse;

public class ModifyUserActionimplements Action {

@Override
public String execute(HttpServletRequest request,HttpServletResponse response) throwsException {
String username = request.getParameter(&quot;username&quot;);
//String sex = request.getParameter(&quot;userId&quot;);
//...........等其他...

//调用业务逻辑.

UserManager userManager = new UserManager();
userManager.modify(username);

return&quot;/modify_success.jsp&quot;;


}

}

package com.bjpowernode.servlet;

import java.util.List;

importjavax.servlet.http.HttpServletRequest;
importjavax.servlet.http.HttpServletResponse;

public class QueryUserActionimplements Action {

@Override
public String execute(HttpServletRequest request,HttpServletResponse response) throwsException {
String username = request.getParameter(&quot;username&quot;);
//Stringsex = request.getParameter(&quot;userId&quot;);
//其他查询条件.
//...........等其他...

//调用业务逻辑.

UserManager userManager = new UserManager();
List userList = userManager.query(username);
request.setAttribute(&quot;userList&quot;,userList);

return&quot;/query_success.jsp&quot;;//转向路径都可以通过配置文件读取。


}

}
//用多态的方式.
Action action = null;
if(&quot;/servlet/delUser&quot;.equals(path))
{
action= new DelUserAction();
}else if(&quot;/servlet/addUser&quot;.equals(path))
{
action= new AddUserAction();
}else if(&quot;/servlet/modifyUser&quot;.equals(path))
{
action= new ModifyUserAction();

}else if(&quot;/servlet/queryUser&quot;.equals(path))
{
action= new QueryUserAction();

}else
{
throw new RuntimeException(&quot;请求失败!&quot;);
}
//取得action后传递过去。动态调用ACtion中的execute方法。
String forward = null;
try{
forward= action.execute(request,response);
}catch (Exception e) {
e.printStackTrace();
}

//根据路径完成转向。
request.getRequestDispatcher(forward).forward(request, response);

&lt;action-config&gt;
&lt;action path=&quot;/servlet/delUser&quot; type=&quot;com.bjpowernode.servlet.DelUserAction&quot;&gt;
&lt;forward name=&quot;success&quot;&gt;/del_success.jsp&lt;/forward&gt;
&lt;forward name=&quot;error&quot;&gt;/del_error.jsp&lt;/forward&gt;
&lt;/action&gt;

&lt;action path=&quot;/servlet/addUser&quot; type=&quot;com.bjpowernode.servlet.AddUserAction&quot;&gt;
&lt;forward name=&quot;success&quot;&gt;/add_success.jsp&lt;/forward&gt;
&lt;forward name=&quot;error&quot;&gt;/add_error.jsp&lt;/forward&gt;
&lt;/action&gt;

&lt;action path=&quot;/servlet/modifyUser&quot; type=&quot;com.bjpowernode.servlet.ModifyUserAction&quot;&gt;
&lt;forward name=&quot;success&quot;&gt;/modify_success.jsp&lt;/forward&gt;
&lt;forward name=&quot;error&quot;&gt;/modify_error.jsp&lt;/forward&gt;
&lt;/action&gt;

&lt;action path=&quot;/servlet/queryUser&quot; type=&quot;com.bjpowernode.servlet.QueryUserAction&quot;&gt;
&lt;forward name=&quot;success&quot;&gt;/query_success.jsp&lt;/forward&gt;
&lt;forward name=&quot;error&quot;&gt;/query_error.jsp&lt;/forward&gt;
&lt;/action&gt;
&lt;/action-config&gt;
ActionMapping
{
private String path;
private String type;
Map forwardMap;
}

forwardMap
{
key=&quot;success&quot;;
value=&quot;/del_success.jsp&quot;
key=&quot;error&quot;;
value=&quot;/del_error.jsp&quot;;
}

Map map = new HashMap();
map.put(&quot;/servlet/delUser&quot;,);
map.put(&quot;/servlet/addUser&quot;,);
map.put(&quot;/servlet/modifyUser&quot;,);
map.put(&quot;/servlet/queryUser&quot;,);


//如果是删除的ActionMapping存储如下：
actionMapping
{
path=&quot;/servlet/delUser&quot;;
type=&quot;com.bjpowernode.servlet.DelUserAction&quot;;
forwardMap
{
key=&quot;success&quot;,value=&quot;/del_success.jsp&quot;;
key=&quot;error&quot;,value=&quot;/del_error.jsp&quot;;
}
}
String path =&quot;/servlet/delUser&quot;;


//根据截取的URL请求，到Map中取得本次请求对应的Action。
ActionMapping actionMapping =(ActionMappint)map.get(path);

// 取得本次请求对应的Action类的完成路径。
String type =actionMappint.getType();//com.bjpowernode.servlet.DelUserAction

//通过反射动态实例化Action
Aciton action =(Action)class.forName(type).newInstance();


//取得action后传递过去。动态调用ACtion中的execute方法。
String forward =action.execute(request,response);

//根据路径完成转向。
request.getRequestDispatcher(forward).forward(request,response);
</code>
</RECORD>
<RECORD>
<snippet_key>478824</snippet_key>
<tag>来自CSDN博客：Android语音识别功能使用总结 http://blog.csdn.net/zpf8861/article/details/33758723#</tag>
<comment>派生自zpf8861/blog_20140623_1_4538126</comment>
<code>&lt;span style=&quot;font-size:18px;&quot;&gt; createSpeechRecognizer() //创建语音识别器
setRecognitionListener() //设置监听器
startListening() //开始语音识别
stopListening() //结束语音识别&lt;/span&gt;
SpeechRecognizer sr = SpeechRecognizer.createSpeechRecognizer(this, new ComponentName(getPackageName(),
BDRecognitionService.class.getName()));
sr.setRecognitionListener(new listener());
sr.startListening(new Intent(getIntent().getAction()).putExtras(getIntent()));
&lt;div style=&quot;text-indent: 24px;&quot;&gt;&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;
//回调方法，识别过程的各个阶段
&lt;span style=&quot;text-indent: 24px; background-color: rgb(240, 240, 240);&quot;&gt;class listener implements RecognitionListener{&lt;/span&gt;
@Override
public void onReadyForSpeech(Bundle params) {

}

@Override
public void onBeginningOfSpeech() {

}

@Override
public void onRmsChanged(float rmsdB) {

}

@Override
public void onBufferReceived(byte[] buffer) {

}

@Override
public void onEndOfSpeech() {

}

@Override
public void onError(int error) {


}

@Override
public void onResults(Bundle results) {

//具体处理识别结果
}

@Override
public void onPartialResults(Bundle partialResults) {


}

@Override
public void onEvent(int eventType, Bundle params) {

}

}
</code>
</RECORD>
<RECORD>
<snippet_key>378381</snippet_key>
<tag>android menu</tag>
<comment>来自CSDN博客：onMenuOpened不调用问题  http://blog.csdn.net/babc_mutou/article/details/28642061#</comment>
<code>return false;
//【流程1】
① 头次按下menu键，执行onCreateOptionsMenu() --&gt; onMenuOpened()；
② 后面再按menu，执行onMenuOpened()
//【流程2】
① 头次按下menu键，执行onCreateOptionsMenu()；
② 后面再按menu，均无反应
② 后面再按menu，均无反应&lt;/span&gt;
menu.add(&quot;menu&quot;);
//【流程3】
① 头次按下menu键，执行onCreateOptionsMenu() --&gt; onMenuOpened()，界面显示menu菜单；
② 再按menu键，执行onOptionsMenuClosed()，关闭菜单；
③ 再按menu键，执行onMenuOpened()，界面显示menu菜单；
④ 按menu菜单项，执行onOptionsItemSelected，按键操作，这里什么也没做，然后onOptionsMenuClosed()，关闭菜单
② 再按menu键，执行onOptionsMenuClosed()，关闭菜单；
③ 再按menu键，执行onMenuOpened()，界面显示menu菜单；
④ 按menu菜单项，执行onOptionsItemSelected，按键操作，这里什么也没做，然后onOptionsMenuClosed()，关闭菜单
</code>
</RECORD>
<RECORD>
<snippet_key>478821</snippet_key>
<tag>36</tag>
<comment>来自CSDN博客：定义多个Activity及跳转  http://blog.csdn.net/yan309271291/article/details/39736075#</comment>
<code>package com.away.b_01_multiactivity;

import android.app.Activity;
import android.os.Bundle;

public class SecondActivity extends Activity{

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.second);
}

}
&lt;TextView
android:id=&quot;@+id/secondTextView&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;第二个Activity&quot;/&gt;
&lt;activity
android:name=&quot;com.away.b_01_multiactivity.MainActivity&quot;
android:label=&quot;@string/app_name&quot; &gt;
&lt;intent-filter&gt;
&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
&lt;/intent-filter&gt;
&lt;/activity&gt;
&lt;activity
android:name=&quot;com.away.b_01_multiactivity.SecondActivity&quot;
android:label=&quot;second&quot; &gt;
&lt;/activity&gt;
&lt;Button
android:id=&quot;@+id/Button&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:layout_below=&quot;@id/TextView&quot;
android:text=&quot;ĺŻĺ¨SecondAtivity&quot;/&gt;
package com.away.b_01_multiactivity;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.Menu;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;

public class MainActivity extends Activity {

private Button button;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

button=(Button)findViewById(R.id.Button);
button.setOnClickListener(new ButtonListener());
}


class ButtonListener implements OnClickListener{
@Override
public void onClick(View v) {
Intent intent=new Intent();
//setClass函数的第一个参数是一个Context对象
//Context是一个类,Activity是Context类的子类,也就是说,所有的Activity对象都可以向上转型为Context对象
//setClass函数的第二个参数是Class对象,在当前场景下,应该传入需要被启动的Activity的class对象
intent.setClass(MainActivity.this, SecondActivity.class);
startActivity(intent);
}
}
}
Intent intent = new Intent(MainActivity.this, SecondActivity.class);
startActivity(intent);
startActivity(new Intent(MainActivity.this, SecondActivity.class));
</code>
</RECORD>
<RECORD>
<snippet_key>478818</snippet_key>
<tag>设计模式</tag>
<comment>来自CSDN博客：工厂之OPC问题  http://blog.csdn.net/hxj135812/article/details/39740423#</comment>
<code>

public class TVFactory {
public static final String Hai_Er=&quot;海尔&quot;;
public static final String CHANG_HONG=&quot;长虹&quot;;
publicstatic TV createTV(String type){
TVtv=null;
if(Hai_Er.equals(type)){
tv=newHaiErTV();
}elseif(CHANG_HONG.equals(type)){
tv=newChangHongTV();
}else{
throw new RuntimeException(&quot;无法产生！&quot;);
}
returntv;
}
}


public interface TV {
public void turnOn();//打开电视
public void turnOff();//关闭电视
}

public class HaiErTV implements TV {

@Override
publicvoid turnOn() {
//TODO Auto-generated method stub
System.out.println(&quot;HaiErTV.turnOn()&quot;);
}

@Override
publicvoid turnOff() {
//TODO Auto-generated method stub
System.out.println(&quot;HaiErTV.turnOff()&quot;);

}

}


public class ChangHongTV implements TV {

@Override
publicvoid turnOn() {
System.out.println(&quot;ChangHongTV.turnOn()&quot;);


}

@Override
publicvoid turnOff() {

System.out.println(&quot;ChangHongTV.turnOff()&quot;);
}

}


public class Client {

/**
* 函数功能说明
* huxj 2014-10-1
* @参数： @param args
* @return void
* @throws
*/

publicstatic void main(String[] args) {
TV tv=TVFactory.createTV(&quot;海尔&quot;);

tv.turnOn();
tv.turnOff();
}

}

public class TVFactory {
public static final String Hai_Er=&quot;海尔&quot;;
public static final String CHANG_HONG=&quot;长虹&quot;;
publicstatic TV createTV(String type){
TVtv=null;
if(Hai_Er.equals(type)){
tv=newHaiErTV();
}elseif(CHANG_HONG.equals(type)){
tv=newChangHongTV();
}else{
throw new RuntimeException(&quot;无法产生！&quot;);
}
returntv;
}
}

public interface TV {
public void turnOn();//打开电视
public void turnOff();//关闭电视
}

public class HaiErTV implements TV {

@Override
publicvoid turnOn() {
//TODO Auto-generated method stub
System.out.println(&quot;HaiErTV.turnOn()&quot;);
}

@Override
publicvoid turnOff() {
//TODO Auto-generated method stub
System.out.println(&quot;HaiErTV.turnOff()&quot;);

}

}


public class ChangHongTV implements TV {

@Override
publicvoid turnOn() {
System.out.println(&quot;ChangHongTV.turnOn()&quot;);


}

@Override
publicvoid turnOff() {

System.out.println(&quot;ChangHongTV.turnOff()&quot;);
}

}


public class Client {

/**
* 函数功能说明
* huxj 2014-10-1
* @参数： @param args
* @return void
* @throws
*/

publicstatic void main(String[] args) {
TV tv=TVFactory.createTV(&quot;长虹&quot;);

tv.turnOn();
tv.turnOff();
}

}

public interface TVFactory{
publicTV createTV();

}

publicclass TVFactoryHaiEr implements TVFactory {

/**
*
*/
@Override
publicTV createTV() {

returnnew HaiErTV();
}

}



publicclass TVFactoryChangHong implements TVFactory {

/**
*
*/
@Override
publicTV createTV() {

returnnew ChangHongTV();
}

}


publicclass Client {

/**
* 函数功能说明
* huxj 2014-10-1
* @参数： @param args
* @return void
* @throws
*/

publicstatic void main(String[] args) {
TVFactorynewFactory=new TVFactoryHaiEr();
//TVFactorynewFactory=new TVFactoryChangHong();
newFactory.createTV().turnOn();
newFactory.createTV().turnOff();
}

}

public static voidmain(String[] args) {
TVFactorynewFactory=new TVFactoryHaiEr();
//TVFactorynewFactory=new TVFactoryChangHong();
newFactory.createTV().turnOn();
newFactory.createTV().turnOff();
}

}
sys-config.xml
&lt;?xmlversion=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;config&gt;
&lt;dao-factory&gt;
&lt;item-dao-factory&gt;test.TVFactoryHaiEr&lt;/item-dao-factory&gt;
&lt;/dao-factory&gt;
&lt;/config&gt;
/**
* 采用单例模式解析sys-config.xml文件
* @author Administrator
*
*/
public classXmlConfigReader {


//懒汉式（延迟加载lazy）
privatestatic XmlConfigReader instance = null;

//key表示&lt;dao-factory&gt;标签名
//value标签中的值，具体完整路径(成员变量)
privateMap&lt;String,String&gt; daoFactoryMap=new HashMap&lt;String,String&gt;();

privateXmlConfigReader() {
SAXReaderreader = new SAXReader();
InputStreamin =Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;sys-config.xml&quot;);
try {
Documentdoc = reader.read(in);
//读取DaoFactory信息
ListdaoFactoryList=doc.selectNodes(&quot;/config/dao-factory/*&quot;);
//获得子节点标签值
for(inti=0;i&lt;daoFactoryList.size();i++){
ElementdaoFactoryElt=(Element)daoFactoryList.get(i);
StringtagName=daoFactoryElt.getName();
StringtagText=daoFactoryElt.getText();
//System.out.println(tagName);
//System.out.println(daoFactoryElt.elementText(&quot;item-dao-factory&quot;));
//System.out.println(&quot;读取的内容是：&quot;+tagText);

//把取的值放入map当中
daoFactoryMap.put(tagName,tagText);
}
}catch (DocumentException e) {
//TODO Auto-generated catch block
e.printStackTrace();
}
}

publicstatic synchronized XmlConfigReader getInstance() {
if(instance == null) {
instance= new XmlConfigReader();
}
returninstance;
}

/**
* @param name
* 返回工厂类的具体路径。
*
*@return value值
*
*/
publicString getDaoFactory(String name){
returndaoFactoryMap.get(name);
}
}

/**
* @类功能说明：工厂方法+反射 解决：工厂方法违背开闭原则的问题
* @作者：huxj
* @创建时间：2014-10-1下午12:16:37
* @版本：V1.0
*/

public class Client {

/**
* 函数功能说明
* huxj 2014-10-1
* @参数： @param args
* @return void
* @throws
*/

publicstatic void main(String[] args) {
//通过配置文件获取，工厂类,解决修改代码的功能。
StringclassName=XmlConfigReader.getInstance().getDaoFactory(&quot;item-dao-factory&quot;);
//把类装载到内存里
TVFactoryfactory=null;
try {
factory= (TVFactory)Class.forName(className).newInstance();
}catch (InstantiationException e) {
e.printStackTrace();
}catch (IllegalAccessException e) {
e.printStackTrace();
}catch (ClassNotFoundException e) {
e.printStackTrace();
}
factory.createTV().turnOn();
factory.createTV().turnOff();
}

}

</code>
</RECORD>
<RECORD>
<snippet_key>182541</snippet_key>
<tag>java 编码 struts2 语言 freemarker</tag>
<comment>来自CSDN博客：freemarker  简单模板 http://blog.csdn.net/u012809273/article/details/19042657#</comment>
<code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;${title}&lt;/title&gt;

&lt;body&gt;
&lt;style type=&quot;text/css&quot;&gt;
.odd
{
background-color:red;
}
.even
{
background-color:green;
}
&lt;/style&gt;

&lt;h1&gt;展示&lt;/h1&gt;
&lt;table border=&quot;1px solid red&quot;&gt;

&lt;#assign x=0 /&gt;
&lt;#list k as t&gt;
&lt;#assign x=x+1 /&gt;
&lt;tr &lt;#if x%2 == 0&gt;style=&quot; background:red&quot; &lt;#else&gt;style=&quot; background:green&quot; &lt;/#if&gt;&gt;
&lt;#list t?keys as m&gt;
&lt;td style=&quot;width:200px&quot;&gt;
&lt;#if m=&quot;phone&quot;&gt;
电话:${t[m]}
&lt;/#if&gt;
&lt;#if m=&quot;email&quot;&gt;
邮箱:${t[m]}
&lt;/#if&gt;
&lt;#if m=&quot;address&quot;&gt;
籍贯:${t[m]}
&lt;/#if&gt;
&lt;/td&gt;
&lt;/#list&gt;
&lt;/tr&gt;
&lt;/#list&gt;
&lt;/table&gt;

&lt;table border=&quot;1px&quot;&gt;
&lt;tr&gt;
&lt;td style=&quot;width:200px&quot;&gt;姓名&lt;/td&gt;
&lt;td style=&quot;width:200px&quot;&gt;年龄&lt;/td&gt;
&lt;/tr&gt;
&lt;#list obj as o&gt;
&lt;tr &lt;#if o_index%2==0&gt;style=&quot; background:red&quot; &lt;#else&gt;style=&quot; background:blue&quot; &lt;/#if&gt;&gt;
&lt;td style=&quot;width:200px&quot;&gt;${o.name}&lt;/td&gt;
&lt;td style=&quot;width:200px&quot;&gt;${o.age}&lt;/td&gt;
&lt;/tr&gt;
&lt;/#list&gt;
&lt;/table&gt;

&lt;#assign str= &quot;20131012&quot;&gt;

??判断对象是否为空：&lt;#if str??&gt;str对象不为空&lt;/#if&gt;&lt;br&gt;

?exists判断对象是否为空：&lt;#if str?exists&gt;str对象不为空&lt;/#if&gt;&lt;br&gt;

默认$：${str}&lt;br&gt;

substring截串(0,1)：${str?substring(0,1)}&lt;br&gt;&lt;#--从0开始包前不包后--&gt;

字符串：${str?string}&lt;br&gt;&lt;#-- 转换为string --&gt;
数值： ${str?number}&lt;br&gt;&lt;#-- 转换为数值 --&gt;
百分比:${str?number?string(&quot;percent&quot;)}&lt;br&gt;

货币：:${str?number?string.currency}&lt;br&gt;
ends_with 判断某个字符串是否由某个子串结尾，返回布尔值:${str?ends_with(&quot;12&quot;)?string}&lt;br&gt; &lt;#--返回结果为布尔类型--&gt;
html 用于将字符串中的&lt;、&gt;、&amp;和“替换为对应得&lt;&gt;&quot;:&amp;:${&quot;&lt;span&gt;span标签&lt;/span&gt;&quot;?html}&lt;br&gt; &lt;#--如果存在str则输出str的html形式--&gt;
contains是否包含某字符：
&lt;#if str?contains(&quot;1&quot;) &gt;
包含
&lt;#else&gt;
不包含
&lt;/#if&gt;&lt;br&gt;

&lt;#assign foo=true /&gt;
${foo?string(&quot;是true&quot;,&quot;非true&quot;)}&lt;br&gt;


&lt;#assign lastUpdated = &quot;2009-01-07 15:05&quot;?datetime(&quot;yyyy-MM-dd HH:mm&quot;) /&gt;
默认：${lastUpdated}&lt;br&gt;
中国标准时间：${lastUpdated?string(&quot;yyyy-MM-dd HH:mm:ss a hh:mm:ss zzzz&quot;)}&lt;br&gt; &lt;#--zzzz中国标准时间 zzzcst--&gt;
日期的转换string(&quot;E,M dd,y&quot;)：${lastUpdated?string(&quot;E,M dd,y&quot;)};&lt;br&gt;&lt;#--E星期几 MMM 月 M数字月 MM2位的数字月 MMM3个以上 中文月--&gt;
${lastUpdated?string(&quot;yy,MM,dd,HH:mm:ss E am &apos;(&apos;zzzz&apos;)&apos;&quot;)};&lt;br&gt; &lt;#--hh 12制 HH24制 a 下午 am下午几时--&gt;
${lastUpdated?string.short};&lt;br&gt;&lt;#--短日期--&gt;
${lastUpdated?string.long};&lt;br&gt;&lt;#--长日期--&gt;
${lastUpdated?string.full};&lt;br&gt;&lt;#-- date只使用年月日 time只是用时分秒 datetime都是用 --&gt;



&lt;#--??和?的区别--&gt;
&lt;#--??判断对象是否为空--&gt;
&lt;#--?后面要加关键字--&gt;d

&lt;#if o??&gt;object对象不为空（即object存在）&lt;/#if&gt;&lt;br&gt;
&lt;#if str??&gt;${str?string}&lt;/#if&gt;&lt;br&gt;

&lt;#assign x=2.582/&gt;
&lt;#assign y=4/&gt;
M2:#{x;M2}&lt;br&gt;&lt;#--小数点后最大2位 如果后一位大于5就进行四舍五入--&gt;
M2:#{y;M2}&lt;br&gt;&lt;#--小数点后最大2位 如果后一位大于5就进行四舍五入--&gt;
m2:#{x;m2}&lt;br&gt;&lt;#--小数点后最大2位 如果后一位大于5就进行四舍五入--&gt;
m2:#{y;m2}&lt;br&gt;&lt;#--小数点后最大2位 如果后一位大于5就进行四舍五入--&gt;
m1M3:#{x;m1M3}&lt;br&gt;&lt;#--小数点后最大2位 如果后一位大于5就进行四舍五入--&gt;
m1M3:#{y;m1M3}&lt;br&gt;&lt;#--小数点后最大2位 如果后一位大于5就进行四舍五入--&gt;


&lt;#setting number_format=&quot;currency&quot;/&gt;&lt;#--number型的值转换为货币型--&gt;
&lt;#assign answer=42/&gt;
${answer} &lt;br&gt;
${answer?string}&lt;br&gt;&lt;#--thesameas${answer}--&gt;
${answer?string.number}&lt;br&gt;
${answer?string.currency}&lt;br&gt;
${answer?string.percent}&lt;br&gt;
aaa:${2+4}&lt;br&gt;
&lt;#--!号的使用--&gt;
${answer!&quot;123&quot;}&lt;#--如果answer为空或不存在用123代替--&gt;
&lt;/body&gt;
&lt;/html&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>248077</snippet_key>
<tag>327</tag>
<comment>来自CSDN博客：hdu1008  Elevator http://blog.csdn.net/wuli2496/article/details/21657849#</comment>
<code>import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.OutputStreamWriter;
import java.util.Scanner;

class Main
{
public static final boolean DEBUG = false;
StreamTokenizer tokenizer;
public int n;
public int[] request;

public void init() throws IOException
{
BufferedReader reader;
if (DEBUG) {
reader = new BufferedReader(new FileReader(&quot;d:\\OJ\\uva_in.txt&quot;));
} else {
reader = new BufferedReader(new InputStreamReader(System.in));
}

tokenizer = new StreamTokenizer(reader);
}

public boolean input() throws IOException
{
tokenizer.nextToken();
if (tokenizer.ttype == StreamTokenizer.TT_NUMBER) {
n = (int)tokenizer.nval;
}


if (n == 0) return false;

request = new int[n + 1];
request[0] = 0;
for (int i = 1; i &lt;= n; i++) {
tokenizer.nextToken();
if (tokenizer.ttype == StreamTokenizer.TT_NUMBER) {
request[i] = (int)tokenizer.nval;
} else if (tokenizer.ttype == StreamTokenizer.TT_EOL);
}
return true;
}

public int solve()
{
int ans = 0;
for (int i = 1; i &lt;= n; i++) {
if (request[i] &gt; request[i - 1]) {
ans += (request[i] - request[i -1]) * 6 + 5;
} else {
ans += (request[i - 1] - request[i]) * 4 + 5;
}
}

return ans;
}

public static void main(String[] args) throws IOException
{
Main solver = new Main();
solver.init();

while (solver.input()) {
int ans = solver.solve();
System.out.println(ans);
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>478800</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：求字符串中出现次数最多的字符及其出现次数 http://blog.csdn.net/puyangmengxue/article/details/39739675#</comment>
<code>import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;
/*
* 找出字符串中出现次数最多字符及次数：使用Map存储
*/
public class FrequencyOfChar {
public static void main(String[] args) {
String str=&quot;aavzcadaaaaavvvvvvv&quot;;
Map&lt;Character,Integer&gt; mapOfFrequency=getFrequencyOfChar(str);
System.out.println(mapOfFrequency);
Map&lt;Character,Integer&gt; mapOfMaxFrequency=getMaxFrequencyOfChar(mapOfFrequency);
System.out.println(mapOfMaxFrequency);
}
/**
* 得到字符串中字符的出现次数
*/
public static Map&lt;Character,Integer&gt; getFrequencyOfChar(String str){
Map&lt;Character,Integer&gt; mapOfFrequency=new HashMap&lt;Character,Integer&gt;();
char[] charArrayOfStr=str.toCharArray();
for(char ch:charArrayOfStr){
if(mapOfFrequency.get(ch)==null){//该字符第一次出现
mapOfFrequency.put(ch,1);
}else{//该字符已出现过
mapOfFrequency.put(ch, mapOfFrequency.get(ch)+1);//出现次数加1
}
}
return mapOfFrequency;
}
/**
* 得到出现次数最多的字符及出现次数的Map
*/
public static Map&lt;Character,Integer&gt; getMaxFrequencyOfChar(Map&lt;Character,Integer&gt; mapOfFrequency){
Map&lt;Character,Integer&gt; maxFrequencyOfChar=new TreeMap&lt;Character,Integer&gt;();
//循环遍历map，保存出现次数最大的
int num=0;//保存最大的出现次数
for(Character ch:mapOfFrequency.keySet()){
System.out.println(maxFrequencyOfChar);
if(num==0){//访问第一个字符
num=mapOfFrequency.get(ch);
maxFrequencyOfChar.put(ch, num);//将第一条映射加入
}
else{
if(mapOfFrequency.get(ch)&gt;num){//当前字符的出现次数大于之前最大出现次数
num=mapOfFrequency.get(ch);
maxFrequencyOfChar.clear();
maxFrequencyOfChar.put(ch,mapOfFrequency.get(ch));
}
else if(mapOfFrequency.get(ch).equals(num)){//当前字符的出现次数等于之前最大出现次数
System.out.println();
maxFrequencyOfChar.put(ch,mapOfFrequency.get(ch));
}
}
}
return maxFrequencyOfChar;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>444941</snippet_key>
<tag>netty netty in action netty in action中文版</tag>
<comment>来自CSDN博客：Netty In Action中文版 - 第十五章：选择正确的线程模型  http://blog.csdn.net/abc_key/article/details/38419469#</comment>
<code>Channel ch = ...;
ch.eventLoop().execute(new Runnable() {
@Override
public void run() {
System.out.println(&quot;run in the eventloop&quot;);
}
});
Channel ch = ...;
Future&lt;?&gt; future = ch.eventLoop().submit(new Runnable() {
@Override
public void run() {

}
});
if(future.isDone()){
System.out.println(&quot;task complete&quot;);
}else {
System.out.println(&quot;task not complete&quot;);
}
Channel ch = ...;
if(ch.eventLoop().inEventLoop()){
System.out.println(&quot;in the EventLoop&quot;);
}else {
System.out.println(&quot;outside the EventLoop&quot;);
}
ScheduledExecutorService executor = Executors.newScheduledThreadPool(10);
ScheduledFuture&lt;?&gt; future = executor.schedule(new Runnable() {
@Override
public void run() {
System.out.println(&quot;now it is 60 seconds later&quot;);
}
}, 60, TimeUnit.SECONDS);
if(future.isDone()){
System.out.println(&quot;scheduled completed&quot;);
}
//.....
executor.shutdown();
Channel ch = ...;
ch.eventLoop().schedule(new Runnable() {
@Override
public void run() {
System.out.println(&quot;now it is 60 seconds later&quot;);
}
}, 60, TimeUnit.SECONDS);
Channel ch = ...;
ScheduledFuture&lt;?&gt; future = ch.eventLoop().scheduleAtFixedRate(new Runnable() {
@Override
public void run() {
System.out.println(&quot;after run 60 seconds,and run every 60 seconds&quot;);
}
}, 60, 60, TimeUnit.SECONDS);
// cancel the task
future.cancel(false);
</code>
</RECORD>
<RECORD>
<snippet_key>478798</snippet_key>
<tag>类 class 泛型</tag>
<comment>来自CSDN博客：获取父类的泛型类型 http://blog.csdn.net/u013239111/article/details/39739671#</comment>
<code>import java.lang.reflect.ParameterizedType;

public class GenericClass {

/**
* 获取父类的泛型类型
*/
public static Class getGenericClass(Class clazz) {
ParameterizedType type=(ParameterizedType)clazz.getGenericSuperclass();
Class entityClass=(Class) type.getActualTypeArguments()[0];
return entityClass;
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>445197</snippet_key>
<tag>源码 hive hiveUDF udf hive-exec</tag>
<comment>来自CSDN博客：hive udf  http://blog.csdn.net/zj360202/article/details/38423891#</comment>
<code>add jar /home/hadoop/hive_udf/hiveUDF.jar;
create temporary function hash_code as &apos;org.apache.hadoop.hive.ql.udf.UDFHashCode&apos;;
\ql\src\java\org\apache\hadoop\hive\ql\exec\FunctionRegistry.java
registerUDF(&quot;hash_code&quot;, UDFHashCode.class, false);
</code>
</RECORD>
<RECORD>
<snippet_key>478782</snippet_key>
<tag>13</tag>
<comment>来自CSDN博客：java--继承之--点，面，圆柱 http://blog.csdn.net/u012370105/article/details/39738291#</comment>
<code>/*烟台大学计算机学院学生
*All right reserved.
*文件名称:java--继承之--点，面，圆柱
*作者：杨飞
*完成日期：2014年10月2日
*版本号：v1.0
*对任务及求解方法的描述部分:java--继承之--点，面，圆柱
*我的程序：*/
public class Point {
private double x;
private double y;
public Point()
{

}
public Point(double x ,double y)
{
this.x = x;
this.y = y;

}
public double getX() {
return x;
}
public void setXY(double x,double y) {
this.x = x;
this.y = y;

}
public double getY() {
return y;
}
}
class Circle extends Point
{
private double r;
public Circle()
{

}
public Circle(double x,double y,double r)
{
super(x,y);
this.r = r;
}
public double getR() {
return r;
}

public void setR(double r) {
this.r = r;
}
public double area()
{

return 3.1415926*r*r;
}

}
class Cylinder extends Circle
{
private double h;

public Cylinder()
{

}
public Cylinder(double x,double y,double r,double h)
{
super(x,y,r);
this.h=h;
}
public double getH() {
return h;
}

public void setH(double h) {
this.h = h;
}
public double tiji()
{
return area()*h;

}


}
class test
{
public static void main(String []args)
{
Cylinder s=new Cylinder(2,2,4,2);
System.out.println(&quot;轴心坐标 （&quot;+s.getX()+&quot;,&quot;+s.getY()+&quot;)&quot;);
System.out.println(&quot;半径是：&quot;+s.getR());
System.out.println(&quot;圆的面积是：&quot;+s.area());
System.out.println(&quot;圆柱的高是：&quot;+s.getH());
System.out.println(&quot;圆柱体积是：&quot;+s.tiji());
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>478781</snippet_key>
<tag></tag>
<comment>来自CSDN博客：单例模式（单件模式）  http://blog.csdn.net/wuhao492760804/article/details/39738251#</comment>
<code>&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;package learning.design.patterns;

public class Singleton {
private static Singleton uniqueInstance; //利用一个静态变量来记录Singleton类的唯一实例

private Singleton(){
//把构造器声明为私有的，只有Singleton类内才可以调用构造器
}

public static Singleton getInstance(){
//getInstance()方法实例化对象，并返回这个实例
if(uniqueInstance == null){
uniqueInstance = new Singleton();
}
return uniqueInstance;
}

//other methods

//在多线程情况下，两个线程可以能同时执行getInstance方法，生成连个实例对象，因此加以改进
/*public static synchronized Singleton getInstance(){
//通过增加synchronized关键字到getInstance()方法中，我们迫使每个线程进入这个方法之前
//要先等候别的线程离开该方法。也就是说，不会有两个线程可以同时进入该方法，原子操作。
if(uniqueInstance == null)
{
uniqueInstance = new Singleton();
}
return uniqueInstance;
}*/

/*但是，这种同步方法会降低性能，因为只有第一次至此那个此方法，才真正需要同步。换句话说，一旦设置好
*uniqueInstance变量，就不再需要同步这个方法了。之后每次调用这个方法，同步都是一种累赘。进一步改进。
*“饿汉”式单例类
*以来JVM在加载这个类时马上创建此唯一的单例实例。JVM保证在任何线程访问uniqueInstance静态变量之前，
一定先创建此实例。*/

/*public class Singleton_Hungry{
private static Singleton_Hungry uniqueInstance_Hungy = new Singleton_Hungry();

private Singleton_Hungry(){

}

public static Singleton_Hungry getInstance(){
return uniqueInstance_Hungy;
}
}*/

/*
*更进一步的改进，利用“双重检查加锁”，在getInstance()中减少使用同步
*/

/*public class Singleton{
//volatile关键词确保：当uniqueInstance变量被初始化成Singleton实例时，
//多个线程正确地处理uniqueInstance变量
//volatile告诉jvm， 它所修饰的变量不保留拷贝，直接访问主内存中的
private volatile static Singleton uniqueInstance;

private Singleton() {}

public static Singleton getInstance() {
if(uniqueInstance == null){
//检查实例，如果不存在，就进入同步区块
synchronized (Singleton.class) {
//只有第一次才彻底执行这里的代码
if(uniqueInstance == null)
{
uniqueInstance = new Singleton();
}
}
}
return uniqueInstance;
}
}*/
}
import java.util.HashMap;
import java.util.Map;
//登记式单例类.
//类似Spring里面的方法，将类名注册，下次从里面直接获取。
public class Singleton3 {
private static Map&lt;String,Singleton3&gt; map = new HashMap&lt;String,Singleton3&gt;();
static{
Singleton3 single = new Singleton3();
map.put(single.getClass().getName(), single);
}
//保护的默认构造子
protected Singleton3(){}
//静态工厂方法,返还此类惟一的实例
public static Singleton3 getInstance(String name) {
if(name == null) {
name = Singleton3.class.getName();
System.out.println(&quot;name == null&quot;+&quot;---&gt;name=&quot;+name);
}
if(map.get(name) == null) {
try {
map.put(name, (Singleton3) Class.forName(name).newInstance());
} catch (InstantiationException e) {
e.printStackTrace();
} catch (IllegalAccessException e) {
e.printStackTrace();
} catch (ClassNotFoundException e) {
e.printStackTrace();
}
}
return map.get(name);
}
//一个示意性的商业方法
public String about() {
return &quot;Hello, I am RegSingleton.&quot;;
}
public static void main(String[] args) {
Singleton3 single3 = Singleton3.getInstance(null);
System.out.println(single3.about());
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>118029</snippet_key>
<tag></tag>
<comment>来自CSDN博客：在tomcat日志里打印memcache日志,并实现session共享  http://blog.csdn.net/weiweicao0429/article/details/17399141#</comment>
<code>&lt;Manager className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot;
memcachedNodes=&quot;n1:123.23.223.23:11211&quot;
requestUriIgnorePattern=&quot;.*\.(png|gif|jpg|css|js)$&quot;
sticky=&quot;false&quot; //保证每次都去重新请求，如果本地已经有了，也要重新请求，避免混乱
sessionBackupAsync=&quot;false&quot;
sessionBackupTimeout=&quot;1800000&quot;
copyCollectionsForSerialization=&quot;false&quot;
transcoderFactoryClass=&quot;de.javakaffee.web.msm.serializer.javolution.JavolutionTranscoderFactory&quot;
/&gt;
#memcache log config
de.javakaffee.web.msm.level=FINE
CATALINA_OPTS=&quot;-Dnet.spy.log.LoggerImpl=net.spy.memcached.compat.log.SunLogger&quot;
</code>
</RECORD>
<RECORD>
<snippet_key>183565</snippet_key>
<tag>36</tag>
<comment>来自CSDN博客：activity间传递数据  http://blog.csdn.net/u013628732/article/details/19075107#</comment>
<code>public class CustomeClass implements Serializable{

private static final long serialVersionUID = -7060210544600464481L;
private String name;
private String id;
private int age;
private String sex;

public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
public String getId() {
return id;
}
public void setId(String id) {
this.id = id;
}
public int getAge() {
return age;
}
public void setAge(int age) {
this.age = age;
}
public String getSex() {
return sex;
}
public void setSex(String sex) {
this.sex = sex;
}

}
       发送部分:
      
CustomeClass cc = new CustomeClass();
cc.setAge(21);
cc.setId(&quot;123456&quot;);
cc.setName(&quot;mingkg21&quot;);
cc.setSex(&quot;çˇ&quot;);

Intent intent = new Intent(this, PersonInfo.class);
intent.putExtra(&quot;PERSON_INFO&quot;, cc);
startActivity(intent);
       
       接收部分:
      
Intent intent = getIntent();
CustomeClass cc = CustomeClass)intent.getSerializableExtra(&quot;PERSON_INFO&quot;);
setTextView(R.id.id, cc.getId());
setTextView(R.id.name, cc.getName());
setTextView(R.id.sex, cc.getSex());
setTextView(R.id.age, String.valueOf(cc.getAge()));
public class CustomeParcelable implements Parcelable {

private String name;
private String id;
private int age;
private String sex;

public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
public String getId() {
return id;
}
public void setId(String id) {
this.id = id;
}
public int getAge() {
return age;
}
public void setAge(int age) {
this.age = age;
}
public String getSex() {
return sex;
}
public void setSex(String sex) {
this.sex = sex;
}
public static final Parcelable.Creator&lt;CustomeParcelable&gt; CREATOR = new Creator&lt;CustomeParcelable&gt;(){

public CustomeParcelable createFromParcel(Parcel source) {
// TODO Auto-generated method stub
CustomeParcelable cus = new CustomeParcelable();
cus.name = source.readString();
cus.id = source.readString();
cus.age = source.readInt();
cus.sex = source.readString();
return cus;
}

public CustomeParcelable[] newArray(int size) {
// TODO Auto-generated method stub
return new CustomeParcelable[size];
}

};

public int describeContents() {
// TODO Auto-generated method stub
return 0;
}

public void writeToParcel(Parcel dest, int flags) {
// TODO Auto-generated method stub
dest.writeString(name);
dest.writeString(id);
dest.writeInt(age);
dest.writeString(sex);
}
}
       发送部分:
      
CustomeParcelable cc = new CustomeParcelable();
cc.setAge(21);
cc.setId(&quot;123456&quot;);
cc.setName(&quot;mingkg21&quot;);
cc.setSex(&quot;çˇ&quot;);

Intent intent = new Intent(this, PersonInfo.class);
intent.putExtra(&quot;PERSON_INFO&quot;, cc);
startActivity(intent);
        接受部分:
       
Intent intent = getIntent();
CustomeParcelable cc = intent.getParcelableExtra(&quot;PERSON_INFO&quot;);
setTextView(R.id.id, cc.getId());
setTextView(R.id.name, cc.getName());
setTextView(R.id.sex, cc.getSex());
setTextView(R.id.age, String.valueOf(cc.getAge()));
以上为Parcelable传递一个对象,若要实现传递多个对象,
传递部分:
Bundle bundle = new Bundle();
bundle.putParcelableArrayList(&quot;mP3TagForNetDTOs&quot;,mP3TagForNetDTOs);
msg.setData(bundle);
endDocNotice.sendMessage(msg);
接受部分:
Bundle bundle = msg.getData();
mP3TagForNetDTOs = bundle.getParcelableArrayList(&quot;mP3TagForNetDTOs&quot;);
</code>
</RECORD>
<RECORD>
<snippet_key>201733</snippet_key>
<tag>mybatis</tag>
<comment>来自CSDN博客：mybatis返回List&lt;domain&gt;  http://blog.csdn.net/shanhuhau/article/details/19815575#</comment>
<code>package com.liuc.domain;

public class User {
private int id;
private String name;
private Integer age;
public String getName() {
return name;
}
public int getId() {
return id;
}
public void setId(int id) {
this.id = id;
}
public void setName(String name) {
this.name = name;
}
public Integer getAge() {
return age;
}
public void setAge(Integer age) {
this.age = age;
}
public User() {
}

}
package com.liuc.dao;

import java.util.List;

import com.liuc.domain.User;



public interface UserMapper {
public User findById(String Id);

&lt;span style=&quot;color:#ff0000;&quot;&gt;public List&lt;User&gt; getUserList();&lt;/span&gt;
}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC
&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!--这块等于dao接口的实现 namespace必须和接口的类路径一样 --&gt;
&lt;mapper namespace=&quot;com.liuc.dao.UserMapper&quot;&gt;
&lt;!-- findById必须和接口中的方法名一样 返回一个User 就是刚才的别名 如果不弄别名要连类路径一起写 麻烦 --&gt;
&lt;select id=&quot;findById&quot; parameterType=&quot;HashMap&quot; resultType=&quot;User&quot;&gt;
select * from t_user where id=#{id}
&lt;/select&gt;
&lt;!--配置一个resultMap 指定返回的类型 --&gt;
&lt;span style=&quot;color:#ff0000;&quot;&gt; &lt;resultMap type=&quot;User&quot; id=&quot;userListMap&quot;&gt;
&lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
&lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
&lt;result column=&quot;age&quot; property=&quot;age&quot;/&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;getUserList&quot; resultMap=&quot;userListMap&quot;&gt;
select * from t_user
&lt;/select&gt;&lt;/span&gt;
&lt;/mapper&gt;
&lt;span style=&quot;color:#ff0000;&quot;&gt;List&lt;User&gt; usersList=userMapper.getUserList();&lt;/span&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>249869</snippet_key>
<tag>java 交通灯管理系统</tag>
<comment>来自CSDN博客：java学习札记之交通灯管理系统  http://blog.csdn.net/taoshuizhongren/article/details/8882424#</comment>
<code>public enum Lamp {
//12条线路
S2N(&quot;N2S&quot;,&quot;S2W&quot;,false),S2W(&quot;N2E&quot;,&quot;E2W&quot;,false),E2W(&quot;W2E&quot;,&quot;E2S&quot;,false),E2S(&quot;W2N&quot;,&quot;W2S&quot;,false),
N2S(null,null,false),N2E(null,null,false),W2E(null,null,false),W2N(null,null,false),
S2E(null,null,true),E2N(null,null,true),N2W(null,null,true),W2S(null,null,true);

private String opposite;//对面的灯
private boolean lighted;//交通灯是否亮着
private String next;//
private Lamp() {} //空构造器

private Lamp(String opposite ,String next ,boolean lighted) {
this.opposite = opposite;
this.next = next;
this.lighted = lighted;
}


public boolean isLighted() {
return lighted;
}

//某个方向和对面方向的交通灯亮了
public void light() {
this.lighted = true;
if(opposite != null) {
Lamp.valueOf(opposite).light();//递归 自己调用自己
}
System.out.println(name() + &quot; lamp is green，下面总共应该有6个方向能看到汽车穿过！&quot;);
}

//上面的灯亮了意味着其垂直方向的灯灭了
public Lamp blackOut() {
this.lighted = false;
if(opposite != null) {
Lamp.valueOf(opposite).blackOut();
}
Lamp nextLamp = null;
if(next != null) {
nextLamp = Lamp.valueOf(next);
System.out.println(&quot;绿灯从&quot; + name() + &quot;--------&gt;切换为&quot; + next);
nextLamp.light();
}
return nextLamp;
}
}
/**
* 这是一个交通灯控制其的类，用于控制每一盏灯
*
*/
public class LampController {
private Lamp currentLamp;

public LampController() {
currentLamp = Lamp.S2N; //初始化方向为S2N
currentLamp.light(); //S2N方向的和N2S方向的灯亮着

//创建1个线程池 定时器
ScheduledExecutorService timer = Executors.newScheduledThreadPool(1);
/* Runnable command 线程动作
long initialDelay, 延时时间
long period, 执行频率
TimeUnit unit 时间单位
*/
timer.scheduleAtFixedRate(
new Runnable(){
@Override
public void run() {
System.out.println(&quot;laile--&quot;);
currentLamp = currentLamp.blackOut();
}
},
10,
10,
TimeUnit.SECONDS);
}
}
public class Road {
//将所有的汽车放入到一个集合中
List&lt;String&gt; vechicles = new ArrayList&lt;String&gt;();

private String direction = null; //车流的方向 有12种
public Road(String direction) {
this.direction = direction;

//不断的集合中有车辆加入
ExecutorService vechiclePool = Executors.newSingleThreadExecutor();
vechiclePool.execute(new Runnable(){
//访问外部类的成员变量
@Override
public void run() {
for(int i = 1; i &lt; 1000 ; i++) {
try {
Thread.sleep((new Random().nextInt(10) + 1) * 1000);
} catch (InterruptedException e) {
e.printStackTrace();
}
//匿名内部类要向取到外部成员变量 要通过上下文对象取得
vechicles.add(Road.this.direction + &quot;_&quot; + i);
}
}
});

//当一辆汽车通过十字路口时 从集合中去掉这辆车
ScheduledExecutorService timer = Executors.newScheduledThreadPool(1);
timer.scheduleAtFixedRate(
new Runnable(){
@Override
public void run() {
//检查是否有车
if(vechicles.size() &gt; 0) {
boolean lighted =
Lamp.valueOf(Road.this.direction).isLighted();
if(lighted) {
System.out.println(vechicles.remove(0) + &quot; is traversing...&quot;);
}
}
}
},
1,
1,
TimeUnit.SECONDS);
}
}
public class MainClass {
public static void main(String[] args) {
String [] directions = new String[]{&quot;S2N&quot;,&quot;S2W&quot;,&quot;E2W&quot;,&quot;E2S&quot;,
&quot;N2S&quot;,&quot;N2E&quot;,&quot;W2E&quot;,&quot;W2N&quot;,
&quot;S2E&quot;,&quot;E2N&quot;,&quot;N2W&quot;,&quot;W2S&quot;};
for(int i=0;i&lt;directions.length;i++) {
new Road(directions[i]);
}

new LampController();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>398597</snippet_key>
<tag></tag>
<comment>来自CSDN博客：移动开发:Android数据连接浅析  http://blog.csdn.net/tronteng/article/details/32320257#</comment>
<code>private static class ConnectivityThread extends Thread {
private Context mContext;

private ConnectivityThread(Context context) {
super(&quot;ConnectivityThread&quot;);
mContext = context;
}

@Override
public void run() {
Looper.prepare();
synchronized (this) {
sServiceInstance = new ConnectivityService(mContext);
notifyAll();
}
Looper.loop();
}

public static ConnectivityService getServiceInstance(Context context) {
ConnectivityThread thread = new ConnectivityThread(context);
thread.start();

synchronized (thread) {
while (sServiceInstance == null) {
try {
// Wait until sServiceInstance has been initialized.
thread.wait();
} catch (InterruptedException ignore) {
Slog.e(TAG,
&quot;Unexpected InterruptedException while waiting&quot;+
&quot; for ConnectivityService thread&quot;);
}
}
}

return sServiceInstance;
}
}
boolean noMobileData = !getMobileDataEnabledByPhoneId(TelephonyManager
.getDefaultDataPhoneId(mContext));
for (int netType : mPriorityList) {
switch (mNetAttributes[netType].mRadio) {
case ConnectivityManager.TYPE_WIFI:
if (DBG) Slog.v(TAG, &quot;Starting Wifi Service.&quot;);
WifiStateTracker wst = new WifiStateTracker(context, mHandler);
WifiService wifiService = new WifiService(context, wst);
ServiceManager.addService(Context.WIFI_SERVICE, wifiService);
wifiService.startWifi();
mNetTrackers[ConnectivityManager.TYPE_WIFI] = wst;
wst.startMonitoring();

break;
case ConnectivityManager.TYPE_MOBILE:
mNetTrackers[netType] = new MobileDataStateTracker(context, mHandler,
netType, mNetAttributes[netType].mName);
mNetTrackers[netType].startMonitoring();
if (noMobileData) {
if (DBG) Slog.d(TAG, &quot;tearing down Mobile networks due to setting&quot;);
mNetTrackers[netType].teardown();
}
break;
case ConnectivityManager.TYPE_WIMAX:
NetworkStateTracker nst = makeWimaxStateTracker();
if (nst != null) {
nst.startMonitoring();
}
mNetTrackers[netType] = nst;
if (noMobileData) {
if (DBG) Slog.d(TAG, &quot;tearing down WiMAX networks due to setting&quot;);
mNetTrackers[netType].teardown();
}
break;
default:
Slog.e(TAG, &quot;Trying to create a DataStateTracker for an unknown radio type &quot; +
mNetAttributes[netType].mRadio);
continue;
}
}
protected int beginMmsConnectivity() throws IOException {
........................
............................
int result = mConnMgr.startUsingNetworkFeature(
ConnectivityManager.TYPE_MOBILE, PhoneFactory.getFeature(Phone.FEATURE_ENABLE_MMS, mPhoneId));
..........................
............................
}
String[] naStrings = context.getResources().getStringArray(
com.android.internal.R.array.networkAttributes);
for (String naString : naStrings) {
try {
NetworkAttributes n = new NetworkAttributes(naString);
..........................
mNetAttributes[n.mType] = n;
mNetworksDefined++;
} catch(Exception e) {
// ignore it - leave the entry null
}
}
public int startUsingNetworkFeature(int networkType, String feature) {
try {
return mService.startUsingNetworkFeature(networkType, feature,
new Binder());
} catch (RemoteException e) {
return -1;
}
}
FeatureUser f = new FeatureUser(networkType, feature, binder);
synchronized(this) {
if (isMmsFeature(feature)) {
if (mMmsFeatureRequest.isEmpty()) {
// current data connection is default
mMmsFeatureRequest.add(f);
mMmsFeatureState = FeatureState.CONNECTING;
} else {
// current data connection is mms
FeatureUser k = (FeatureUser)mMmsFeatureRequest.get(0);
if (TextUtils.equals(k.mFeature, feature) &amp;&amp; mMmsFeatureState != FeatureState.DISCONNECTING) {
mMmsFeatureState = FeatureState.CONNECTING;
} else {
boolean found = false;
for (int i = 0; i &lt; mMmsFeatureRequest.size(); i++) {
FeatureUser u = (FeatureUser)mMmsFeatureRequest.get(i);
if (TextUtils.equals(feature, u.mFeature)) {
found = true;
break;
}
}
if (!found) {
if (DBG) {
Slog.d(TAG, &quot;startUsing Mms pending &quot; + feature);
}
mMmsFeatureRequest.add(f);
} else {
if (DBG) {
Slog.d(TAG, &quot;startUsing duplicate Mms pending &quot; + feature);
}
}
return Phone.APN_REQUEST_STARTED;
}
}
}
if (!ConnectivityManager.isNetworkTypeValid(networkType) ||
mNetAttributes[networkType] == null) {
return Phone.APN_REQUEST_FAILED;
}
boolean skipAvailableCheck = false;
// TODO - move this into the MobileDataStateTracker
int usedNetworkType = networkType;
if(networkType == ConnectivityManager.TYPE_MOBILE) {
if (!getMobileDataEnabledByPhoneId(getPhoneIdByFeature(feature)) &amp;&amp;
!(feature.indexOf(Phone.FEATURE_ENABLE_MMS)!=-1) &amp;&amp;
!(feature.indexOf(Phone.FEATURE_ENABLE_WAP)!=-1)) {
return Phone.APN_TYPE_NOT_AVAILABLE;
}
if (TextUtils.equals(feature, Phone.FEATURE_ENABLE_DM)) {
usedNetworkType = ConnectivityManager.TYPE_MOBILE_DM;
} else if (TextUtils.equals(feature.substring(0, Phone.FEATURE_ENABLE_MMS.length()), Phone.FEATURE_ENABLE_MMS)) {
skipAvailableCheck = true;
usedNetworkType = ConnectivityManager.getMmsTypeByPhoneId(getPhoneIdByFeature(feature));
} else if (TextUtils.equals(feature, Phone.FEATURE_ENABLE_SUPL)) {
usedNetworkType = ConnectivityManager.TYPE_MOBILE_SUPL;
} else if (TextUtils.equals(feature, Phone.FEATURE_ENABLE_DUN)) {
usedNetworkType = ConnectivityManager.TYPE_MOBILE_DUN;
} else if (TextUtils.equals(feature, Phone.FEATURE_ENABLE_HIPRI)) {
usedNetworkType = ConnectivityManager.TYPE_MOBILE_HIPRI;
} else if (TextUtils.equals(feature, Phone.FEATURE_ENABLE_WAP)) {
usedNetworkType = ConnectivityManager.getMmsTypeByPhoneId(getPhoneIdByFeature(feature));
}
}
NetworkStateTracker network = mNetTrackers[usedNetworkType];
if (network != null) {
if (usedNetworkType != networkType) {

..........................

} else {
synchronized(this) {
mFeatureUsers.add(f);
}
mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_RESTORE_DEFAULT_NETWORK,
f), getRestoreDefaultNetworkDelay());

return network.startUsingNetworkFeature(feature,
getCallingPid(), getCallingUid());
}
}
return Phone.APN_TYPE_NOT_AVAILABLE;
/**
* Tells the phone sub-system that the caller wants to
* begin using the named feature. The only supported features at
* this time are {@code Phone.FEATURE_ENABLE_MMS}, which allows an application
* to specify that it wants to send and/or receive MMS data, and
* {@code Phone.FEATURE_ENABLE_SUPL}, which is used for Assisted GPS.
* @param feature the name of the feature to be used
* @param callingPid the process ID of the process that is issuing this request
* @param callingUid the user ID of the process that is issuing this request
* @return an integer value representing the outcome of the request.
* The interpretation of this value is feature-specific.
* specific, except that the value {@code -1}
* always indicates failure. For {@code Phone.FEATURE_ENABLE_MMS},
* the other possible return values are
*/
public int startUsingNetworkFeature(String feature, int callingPid, int callingUid) {
return -1;
}
if (usedNetworkType != networkType) {
Integer currentPid = new Integer(getCallingPid());

NetworkStateTracker radio = mNetTrackers[networkType];
NetworkInfo ni = network.getNetworkInfo();

// TODO: using serviceState to check is better for Msms
if (!skipAvailableCheck &amp;&amp; ni.isAvailable() == false) {
if (DBG) Slog.d(TAG, &quot;special network not available&quot;);
return Phone.APN_TYPE_NOT_AVAILABLE;
}
..........................

if (DBG) Slog.d(TAG, &quot;ni.isConnectedOrConnecting()=&quot;+ni.isConnectedOrConnecting());

if ((ni.isConnectedOrConnecting() == true) &amp;&amp;
!network.isTeardownRequested()) {
if (ni.isConnected() == true) {
// add the pid-specific dns
handleDnsConfigurationChange(networkType);
if (DBG) Slog.d(TAG, &quot;special network already active&quot;);
return Phone.APN_ALREADY_ACTIVE;
}
if (DBG) Slog.d(TAG, &quot;special network already connecting&quot;);
return Phone.APN_REQUEST_STARTED;
}

if (!isAlreadyConnecting) {
if (DBG) Slog.d(TAG, &quot;reconnecting to special network&quot;);
synchronized(this) {
if(!network.reconnect()){
if (isMmsFeature(feature) &amp;&amp; mMmsFeatureRequest.size() &gt; 0) {
mMmsFeatureRequest.remove(0);
}
return Phone.APN_TYPE_NOT_AVAILABLE;
}
}
} else {
if (DBG) Slog.d(TAG, &quot;already reconnecting to special network&quot;);
}
return Phone.APN_REQUEST_STARTED;
}
public boolean reconnect() {
setTeardownRequested(false);
if (DBG) Log.d(TAG, &quot; reconnect :setEnableApn&quot;+ mApnType );
switch (setEnableApn(mApnType, true)) {
case Phone.APN_ALREADY_ACTIVE:
..........................
case Phone.APN_REQUEST_STARTED:
..........................
case Phone.APN_REQUEST_FAILED:
..........................
case Phone.APN_TYPE_NOT_AVAILABLE:
..........................
default:
..........................
}
return mEnabled;
}
private int setEnableApn(String apnType, boolean enable) {
getPhoneService(false);
/*
* If the phone process has crashed in the past, we&apos;ll get a
* RemoteException and need to re-reference the service.
*/
for (int retry = 0; retry &lt; 2; retry++) {
if (mPhoneService == null) {
Log.w(TAG,
&quot;Ignoring feature request because could not acquire PhoneService&quot;);
break;
}

try {
if (enable) {
return mPhoneService.enableApnType(apnType);
} else {
return mPhoneService.disableApnType(apnType);
}
} catch (RemoteException e) {
if (retry == 0) getPhoneService(true);
}
}

Log.w(TAG, &quot;Could not &quot; + (enable ? &quot;enable&quot; : &quot;disable&quot;)
+ &quot; APN type \&quot;&quot; + apnType + &quot;\&quot;&quot;);
return Phone.APN_REQUEST_FAILED;
}
public int enableApnType(String type) {
return mDataConnection.enableApnType(type);
}
public synchronized int enableApnType(String type) {
int id = apnTypeToId(type);

..........................

// just because it&apos;s active doesn&apos;t mean we had it explicitly requested before
// (a broad default may handle many types). make sure we mark it enabled
// so if the default is disabled we keep the connection for others
setEnabled(id, true);

..........................

return Phone.APN_REQUEST_STARTED;
}
protected synchronized void onEnableApn(int apnId, int enabled) {

if (enabled == ENABLED) {
if (!dataEnabled[apnId]) {
dataEnabled[apnId] = true;
enabledCount++;
}
String type = apnIdToType(apnId);
if (!isApnTypeActive(type) || state == State.DISCONNECTING) {
log2(&quot;type:&quot; + type+&quot;mRequestedApnType:&quot;+mRequestedApnType);
mRequestedApnType = type;
onEnableNewApn();
}
}

..........................

}
protected void onEnableNewApn() {
// change our retry manager to use the appropriate numbers for the new APN
if (mRequestedApnType.equals(Phone.APN_TYPE_DEFAULT)) {
mRetryMgr = mDefaultRetryManager;
} else {
mRetryMgr = mSecondaryRetryManager;
}
mRetryMgr.resetRetryCount();

log(&quot;onEnableNewApn REASON_APN_SWITCHED&quot;);

if (isAllPdpDisconnectDone()) {
trySetupData(Phone.REASON_APN_SWITCHED);
} else {
cleanUpConnection(true, Phone.REASON_APN_SWITCHED);
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>464133</snippet_key>
<tag>63</tag>
<comment>来自CSDN博客：注解的应用(注入信息,注入对象)  http://blog.csdn.net/wchb1990/article/details/39056141#</comment>
<code>package cn.itcast.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;



@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
@Inherited
public @interface DbInfo {

String url() default &quot;jdbc:mysql://localhost:3306/test&quot;;
String username() default &quot;root&quot;;
String password() default &quot;root&quot;;

}
package cn.itcast.annotation;

import java.sql.Connection;

public class JdbcUtils {

@DbInfo(url=&quot;jdbc:mysql://localhost:3306/test&quot;,username=&quot;flx&quot;,password=&quot;root&quot;)
public static Connection getConnection(String url,String username,String password){

System.out.println(url);
System.out.println(username);
System.out.println(password);

return null;
}
}
package cn.itcast.annotation;

import java.lang.reflect.Method;

public class Demo1 {

/**
* @param args
* @throws Exception
* @throws SecurityException
*/
public static void main(String[] args) throws SecurityException, Exception {

Class clazz = JdbcUtils.class;
Method method = clazz.getMethod(&quot;getConnection&quot;, String.class,
String.class, String.class);

DbInfo di = method.getAnnotation(DbInfo.class);
String url = di.url();
String username = di.username();
String password = di.password();

method.invoke(null, url, username, password);

}

}
</code>
</RECORD>
<RECORD>
<snippet_key>250381</snippet_key>
<tag>java this</tag>
<comment>来自CSDN博客：java this 关键字  作用汇总  http://blog.csdn.net/u011117467/article/details/21789649#</comment>
<code>&lt;span style=&quot;font-size:14px;&quot;&gt;public class Dog
{
public void jump()
{
System.out.println(&quot;jump&quot;);
}
public void run()
{
//下面这两种调用是等效的
this.jump();
//jump();

System.out.println(&quot;run&quot;);
}&lt;/span&gt;
}
&lt;span style=&quot;font-size:14px;&quot;&gt;public class Test
{
private long salary;
public Test fun(long s)
{
long salary;
this.salary=s;
}
public static void main(String[] args) {

}
}&lt;/span&gt;
&lt;span style=&quot;font-size:14px;&quot;&gt;public class Returnthis
{
public int age;
public Returnthis fun()
{
age++;
return Returnthis;//Returnthis 作为常量引用，返回
}

public static void main(String[] args)
{
Returnthis r=new Returnthis();
//下面的这句真是有意思，连续调用，起到多次使变量自增
//但代码简洁后，不熟悉的，可读性略差
r.fun().fun().fun();

}

}&lt;/span&gt;
&lt;span style=&quot;font-size:14px;&quot;&gt;public class Returnthis
{
public int age;
public Returnthis fun()
{
age++;
return Returnthis;//Returnthis 作为常量引用，返回
}

public static void main(String[] args)
{
Returnthis r=new Returnthis();
//下面的这句真是有意思，连续调用，起到多次使变量自增
//但代码简洁后，不熟悉的，可读性略差
r.fun().fun().fun();

}

}&lt;/span&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>202245</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Android内存优化  http://blog.csdn.net/u012081562/article/details/19827775#</comment>
<code>public class ClassName {
private static Context mContext;
//省略
}
private static Drawable sBackground;


@Override
protected void onCreate(Bundle state) {
super.onCreate(state);


TextView label = new TextView(this);
label.setText(&quot;Leaks are bad&quot;);


if (sBackground == null) {
sBackground = getDrawable(R.drawable.large_bitmap);
}
label.setBackgroundDrawable(sBackground);


setContentView(label);
}
public class BasicActivity extends Activity {
@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
new MyThread().start();
}


private class OneThread extends Thread{
@Override
public void run() {
super.run();
//do somthing
}
}
}
if(!bitmap.isRecycled()){
bitmap.recycle()
}
private ImageView preview;
BitmapFactory.Options options = new BitmapFactory.Options();
options.inSampleSize = 2;//图片宽高都为原来的二分之一，即图片为原来的四分之一
Bitmap bitmap = BitmapFactory.decodeStream(cr.openInputStream(uri), null, options);
preview.setImageBitmap(bitmap);
第三、巧妙的运用软引用（SoftRefrence）
有些时候，我们使用Bitmap后没有保留对它的引用，因此就无法调用Recycle函数。这时候巧妙的运用软引用，可以使Bitmap在内存快不足时得到有效的释放。如下例：
private class MyAdapter extends BaseAdapter {

private ArrayList&gt; mBitmapRefs = new ArrayList&gt;();
public View getView(int i, View view, ViewGroup viewGroup) {
View newView = null;
if(view != null) {
newView = view;
} else {
newView =(View)mInflater.inflate(R.layout.image_view, false);
}

Bitmap bitmap = BitmapFactory.decodeFile(mValues.get(i).fileName);
mBitmapRefs.add(new SoftReference(bitmap)); //此处加入ArrayList
((ImageView)newView).setImageBitmap(bitmap);

return newView;
}
}
IntentFilter postFilter = new IntentFilter();
postFilter.addAction(getPackageName() + &quot;.background.job&quot;);
this.registerReceiver(receiver, postFilter);
Cursor cursor = null;
try {
cursor = mContext.getContentResolver().query(uri,null, null,null,null);
if(cursor != null) {
cursor.moveToFirst();
//do something
}
} catch (Exception e) {
e.printStackTrace();
} finally {
if (cursor != null) {
cursor.close();
}
}
@Override
protected void onDestroy() {
if (mAdapter != null &amp;&amp; mAdapter.getCurosr() != null) {
mAdapter.getCursor().close();
}
super.onDestroy();
}
private ImageView preview;
BitmapFactory.Options options = new BitmapFactory.Options();
options.inSampleSize = 2;//图片宽高都为原来的二分之一，即图片为原来的四分之一
Bitmap bitmap = BitmapFactory.decodeStream(cr.openInputStream(uri), null, options);
preview.setImageBitmap(bitmap);
private class MyAdapter extends BaseAdapter {

private ArrayList&gt; mBitmapRefs = new ArrayList&gt;();
public View getView(int i, View view, ViewGroup viewGroup) {
View newView = null;
if(view != null) {
newView = view;
} else {
newView =(View)mInflater.inflate(R.layout.image_view, false);
}

Bitmap bitmap = BitmapFactory.decodeFile(mValues.get(i).fileName);
mBitmapRefs.add(new SoftReference(bitmap)); //此处加入ArrayList
((ImageView)newView).setImageBitmap(bitmap);

return newView;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>446989</snippet_key>
<tag>来自CSDN博客：Java 8实现BASE64编解码 http://blog.csdn.net/chszs/article/details/17027649#</tag>
<comment>派生自架构师/blog_20131129_1_1710087</comment>
<code>// 编码
String asB64 = Base64.getEncoder().encodeToString(&quot;some string&quot;.getBytes(&quot;utf-8&quot;));
System.out.println(asB64); // 输出为: c29tZSBzdHJpbmc=

// 解码
byte[] asBytes = Base64.getDecoder().decode(&quot;c29tZSBzdHJpbmc=&quot;);
System.out.println(new String(asBytes, &quot;utf-8&quot;)); // 输出为: some string
String basicEncoded = Base64.getEncoder().encodeToString(&quot;subjects?abcd&quot;.getBytes(&quot;utf-8&quot;));
System.out.println(&quot;Using Basic Alphabet: &quot; + basicEncoded);

String urlEncoded = Base64.getUrlEncoder().encodeToString(&quot;subjects?abcd&quot;.getBytes(&quot;utf-8&quot;));
System.out.println(&quot;Using URL Alphabet: &quot; + urlEncoded);
// 输出为:
Using Basic Alphabet: c3ViamVjdHM/YWJjZA==
Using URL Alphabet: c3ViamVjdHM_YWJjZA==
StringBuilder sb = new StringBuilder();
for (int t = 0; t &lt; 10; ++t) {
sb.append(UUID.randomUUID().toString());
}

byte[] toEncode = sb.toString().getBytes(&quot;utf-8&quot;);
String mimeEncoded = Base64.getMimeEncoder().encodeToString(toEncode);
System.out.println(mimeEncoded);
// 输出为:
NDU5ZTFkNDEtMDVlNy00MDFiLTk3YjgtMWRlMmRkMWEzMzc5YTJkZmEzY2YtM2Y2My00Y2Q4LTk5
ZmYtMTU1NzY0MWM5Zjk4ODA5ZjVjOGUtOGMxNi00ZmVjLTgyZjctNmVjYTU5MTAxZWUyNjQ1MjJj
NDMtYzA0MC00MjExLTk0NWMtYmFiZGRlNDk5OTZhMDMxZGE5ZTYtZWVhYS00OGFmLTlhMjgtMDM1
ZjAyY2QxNDUyOWZiMjI3NDctNmI3OC00YjgyLThiZGQtM2MyY2E3ZGNjYmIxOTQ1MDVkOGQtMzIz
Yi00MDg0LWE0ZmItYzkwMGEzNDUxZTIwOTllZTJiYjctMWI3MS00YmQzLTgyYjUtZGRmYmYxNDA4
Mjg3YTMxZjMxZmMtYTdmYy00YzMyLTkyNzktZTc2ZDc5ZWU4N2M5ZDU1NmQ4NWYtMDkwOC00YjIy
LWIwYWItMzJiYmZmM2M0OTBm
public void wrapping() throws IOException {
String src = &quot;This is the content of any resource read from somewhere&quot; +
&quot; into a stream. This can be text, image, video or any other stream.&quot;;

// 编码器封装OutputStream, 文件/tmp/buff-base64.txt的内容是BASE64编码的形式
try (OutputStream os = Base64.getEncoder().wrap(newFileOutputStream(&quot;/tmp/buff-base64.txt&quot;))) {
os.write(src.getBytes(&quot;utf-8&quot;));
}

// 解码器封装InputStream, 以及以流的方式解码, 无需缓冲
// is being consumed. There is no need to buffer the content of the file just for decoding it.
try (InputStream is = Base64.getDecoder().wrap(newFileInputStream(&quot;/tmp/buff-base64.txt&quot;))) {
int len;
byte[] bytes = new byte[100];
while ((len = is.read(bytes)) != -1) {
System.out.print(new String(bytes, 0, len, &quot;utf-8&quot;));
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>185101</snippet_key>
<tag>android</tag>
<comment>来自CSDN博客：SlidingFragment  http://blog.csdn.net/LeoThink/article/details/19118013#</comment>
<code>&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;// 设置滑动菜单的属性值&lt;/span&gt;
getSlidingMenu().setMode(SlidingMenu.LEFT_RIGHT);
getSlidingMenu().setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);
getSlidingMenu().setShadowWidthRes(R.dimen.shadow_width);
getSlidingMenu().setShadowDrawable(R.drawable.shadow);
getSlidingMenu().setBehindOffsetRes(R.dimen.slidingmenu_offset);
getSlidingMenu().setFadeDegree(0.35f);

// 设置主界面的视图
setContentView(R.layout.content_frame);
getSupportFragmentManager().beginTransaction().replace(R.id.content_frame, new SampleListFragment()).commit();

// 设置滑动菜单的左视图界面
setBehindContentView(R.layout.menu_frame);
getSupportFragmentManager().beginTransaction().replace(R.id.menu_frame, new SampleListFragment()).commit();

// 设置滑动菜单的右视图界面
getSlidingMenu().setSecondaryMenu(R.layout.menu_frame_two);
getSlidingMenu().setSecondaryShadowDrawable(R.drawable.shadowright);
getSupportFragmentManager().beginTransaction().replace(R.id.menu_frame_two, new SampleListFragment()).commit();
</code>
</RECORD>
<RECORD>
<snippet_key>334085</snippet_key>
<tag></tag>
<comment>来自CSDN博客：ehcache缓存介绍及使用 http://blog.csdn.net/l498948617/article/details/25308479#</comment>
<code>&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;&lt;defaultCache
maxElementsInMemory=&quot;10000&quot;
eternal=&quot;false&quot;
timeToIdleSeconds=&quot;120&quot;
timeToLiveSeconds=&quot;120&quot;
overflowToDisk=&quot;true&quot;
diskSpoolBufferSizeMB=&quot;30&quot;
maxElementsOnDisk=&quot;10000000&quot;
diskPersistent=&quot;false&quot;
diskExpiryThreadIntervalSeconds=&quot;120&quot;
memoryStoreEvictionPolicy=&quot;LRU&quot;
/&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>185613</snippet_key>
<tag>leetcode</tag>
<comment>来自CSDN博客：[Leetcode] Sum Root to Leaf Numbers (Java) http://blog.csdn.net/StarCXDJ/article/details/19126441#</comment>
<code>public class Solution {
public int sumNumbers(TreeNode root) {

if(root==null)
return 0;

int ret=0;
ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;();

dfs(tmp,root,&quot;&quot;);

for(int i:tmp){
ret+=i;
}
return ret;
}
private void dfs(ArrayList&lt;Integer&gt; tmp, TreeNode root,String string) {

string+=root.val;

if(root.left==null&amp;&amp;root.right==null){
tmp.add(Integer.parseInt(string));
return;
}
if(root.left!=null)
dfs(tmp, root.left, string);
if(root.right!=null)
dfs(tmp, root.right, string);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>203269</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Android调用WebService http://blog.csdn.net/zkcharge/article/details/19897755#</comment>
<code>publicclass WebService extends Activity {
privatestaticfinal String NAMESPACE =&quot;http://WebXml.com.cn/&quot;;
// WebService地址
privatestatic String URL =&quot;http://www.webxml.com.cn/
webservices/weatherwebservice.asmx&quot;;
privatestaticfinal String METHOD_NAME =&quot;getWeatherbyCityName&quot;;
privatestatic String SOAP_ACTION =&quot;http://WebXml.com.cn/
getWeatherbyCityName&quot;;

private String weatherToday;

private Button okButton;
private SoapObject detail;

@Override
publicvoid onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
okButton = (Button) findViewById(R.id.ok);

okButton.setOnClickListener(new Button.OnClickListener() {
publicvoid onClick(View v) {
showWeather();
}
});
}

privatevoid showWeather() {
String city =&quot;武汉&quot;;
getWeather(city);
}

@SuppressWarnings(&quot;deprecation&quot;)
publicvoid getWeather(String cityName) {
try {
System.out.println(&quot;rpc------&quot;);
SoapObject rpc =new SoapObject(NAMESPACE, METHOD_NAME);
System.out.println(&quot;rpc&quot;+ rpc);
System.out.println(&quot;cityName is &quot;+ cityName);
rpc.addProperty(&quot;theCityName&quot;, cityName);

AndroidHttpTransport ht =new AndroidHttpTransport(URL);
ht.debug =true;

SoapSerializationEnvelope envelope =new SoapSerializationEnvelope(
SoapEnvelope.VER11);

envelope.bodyOut = rpc;
envelope.dotNet =true;
envelope.setOutputSoapObject(rpc);

ht.call(SOAP_ACTION, envelope);

SoapObject result = (SoapObject) envelope.bodyIn;
detail = (SoapObject) result
.getProperty(&quot;getWeatherbyCityNameResult&quot;);

System.out.println(&quot;result&quot;+ result);
System.out.println(&quot;detail&quot;+ detail);
Toast.makeText(WebService.this, detail.toString(),
Toast.LENGTH_LONG).show();
parseWeather(detail);

return;
} catch (Exception e) {
e.printStackTrace();
}
}

privatevoid parseWeather(SoapObject detail)
throws UnsupportedEncodingException {
String date = detail.getProperty(6).toString();
weatherToday =&quot;今天：&quot;+ date.split(&quot;&quot;)[0];
weatherToday = weatherToday +&quot;\n天气：&quot;+ date.split(&quot;&quot;)[1];
weatherToday = weatherToday +&quot;\n气温：&quot;
+ detail.getProperty(5).toString();
weatherToday = weatherToday +&quot;\n风力：&quot;
+ detail.getProperty(7).toString() +&quot;\n&quot;;
System.out.println(&quot;weatherToday is &quot;+ weatherToday);
Toast.makeText(WebService.this, weatherToday,
Toast.LENGTH_LONG).show();

}
}
</code>
</RECORD>
<RECORD>
<snippet_key>138245</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：mainServlet  http://blog.csdn.net/wangjin237/article/details/17101127#</comment>
<code>/*jadclipse*/// Decompiled by Jad v1.5.8e2. Copyright 2001 Pavel Kouznetsov.

package com.csii.pe.dynamic.http;

import com.csii.pe.channel.http.Constants;
import com.csii.pe.channel.http.servlet.*;
import com.csii.pe.core.PeRuntimeException;
import java.io.IOException;
import java.util.*;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.*;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.propertyeditors.LocaleEditor;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartHttpServletRequest;
import org.springframework.web.multipart.MultipartResolver;
import org.springframework.web.servlet.LocaleResolver;
import org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver;

public class MainServlet extends HttpServlet implements ApplicationContextAware {

public MainServlet() {
logger = LogFactory.getLog(getClass());
publishContext = true;
allowedLocales = new HashSet();
localeParamName = &quot;_locale&quot;;
synchronizeOnSession = false;
}

public final void init() throws ServletException {
ServletConfig config = getServletConfig();
if (config.getInitParameter(&quot;localeParamName&quot;) != null)
localeParamName = config.getInitParameter(&quot;localeParamName&quot;);
String locales[] = (String[]) null;
if (config.getInitParameter(&quot;allowedLocales&quot;) != null)
locales = StringUtils.tokenizeToStringArray(
config.getInitParameter(&quot;allowedLocales&quot;), &quot;,&quot;);
else
locales = DEFAULT_ALLOWED_LOCALES;
allowedLocales.addAll(Arrays.asList(locales));
if (config.getInitParameter(&quot;synchronizeOnSession&quot;) != null)
synchronizeOnSession = Boolean.valueOf(
config.getInitParameter(&quot;synchronizeOnSession&quot;))
.booleanValue();
}

private void initMultipartResolver() throws BeansException {
try {
multipartResolver = (MultipartResolver) applicationContext
.getBean(&quot;multipartResolver&quot;);
if (logger.isInfoEnabled())
logger.info((new StringBuilder(&quot;Using MultipartResolver [&quot;))
.append(multipartResolver).append(&quot;]&quot;).toString());
} catch (NoSuchBeanDefinitionException ex) {
multipartResolver = null;
if (logger.isInfoEnabled())
logger.info(&quot;Unable to locate MultipartResolver with name [multipartResolver]: no multipart handling provided&quot;);
}
}

private void initLocaleResolver() throws BeansException {
try {
localeResolver = (LocaleResolver) applicationContext
.getBean(&quot;localeResolver&quot;);
if (logger.isInfoEnabled())
logger.info((new StringBuilder(&quot;Using LocaleResolver [&quot;))
.append(localeResolver).append(&quot;]&quot;).toString());
} catch (NoSuchBeanDefinitionException ex) {
localeResolver = new AcceptHeaderLocaleResolver();
if (logger.isInfoEnabled())
logger.info((new StringBuilder(
&quot;Unable to locate LocaleResolver with name &apos;localeResolver&apos;: using default [&quot;))
.append(localeResolver).append(&quot;]&quot;).toString());
}
}

private void initController() throws BeansException {
try {
controller = (Controller) applicationContext
.getBean(&quot;mainController&quot;);
} catch (NoSuchBeanDefinitionException ex) {
logger.fatal(&quot;Unable to locate Controller with name &apos;mainController&quot;);
}
}

private void initViewResolver() throws BeansException {
try {
viewResolver = (CsiiViewResolver) applicationContext
.getBean(&quot;mainViewResolver&quot;);
} catch (NoSuchBeanDefinitionException ex) {
logger.fatal(&quot;Unable to locate view resolver with name &apos;mainViewResolver&quot;);
}
}

protected final void doGet(HttpServletRequest request,
HttpServletResponse response) throws ServletException, IOException {
if (synchronizeOnSession) {
javax.servlet.http.HttpSession session = request.getSession(false);
if (session != null) {
synchronized (session) {
process(request, response);
}
return;
}
}
process(request, response);
}

protected final void doPost(HttpServletRequest request,
HttpServletResponse response) throws ServletException, IOException {
HttpServletRequest processedRequest = request;
if (multipartResolver != null &amp;&amp; multipartResolver.isMultipart(request))
if (request instanceof MultipartHttpServletRequest)
logger.info(&quot;Request is already a MultipartHttpServletRequest - if not in a forward, this typically results from an additional MultipartFilter in web.xml&quot;);
else
processedRequest = multipartResolver.resolveMultipart(request);
if (synchronizeOnSession) {
javax.servlet.http.HttpSession session = processedRequest
.getSession(false);
if (session != null) {
synchronized (session) {
process(processedRequest, response);
}
return;
}
}
process(processedRequest, response);
}

private void process(HttpServletRequest request,
HttpServletResponse response) {
if (logger.isDebugEnabled())
logger.debug(&quot;process begin&quot;);
try {
request.setAttribute(
Constants.MAINSERVLET_APPLICATION_CONTEXT_ATTRIBUTE,
applicationContext);
String newLocale = request.getParameter(localeParamName);
if (newLocale != null) {
if (!allowedLocales.contains(newLocale)) {
logger.error((new StringBuilder(&quot;Invalid locale &quot;))
.append(newLocale).append(&quot;, allowed locales: &quot;)
.append(allowedLocales).toString());
throw new PeRuntimeException(
&quot;invalid_locale&quot;,
new Object[] { newLocale, allowedLocales.toString() });
}
LocaleEditor localeEditor = new LocaleEditor();
localeEditor.setAsText(newLocale);
localeResolver.setLocale(request, response,
(Locale) localeEditor.getValue());
}
Locale locale = localeResolver.resolveLocale(request);
if (locale.toString().indexOf(&quot;en&quot;) &gt;= 0)
locale = new Locale(&quot;en&quot;, &quot;US&quot;);
Object model = null;
model = controller.process(request, response, locale);
response.setLocale(locale);
request.setAttribute(localeParamName, locale);
localeResolver.setLocale(request, response, locale);
render(model, request, response, locale);
} catch (Exception e) {
logger.error(&quot;process error:&quot;, e);
}
}

public void destroy() {
}

public String getServletContextAttributeName() {
return (new StringBuilder(String.valueOf(SERVLET_CONTEXT_PREFIX)))
.append(getServletName()).toString();
}

private void render(Object model, HttpServletRequest request,
HttpServletResponse response, Locale locale) {
String viewName = (String) request.getAttribute(&quot;_viewReferer&quot;);
String splittedViewName[] = resolverViewResolverName(viewName);
CsiiView view = viewResolver.resolveView(splittedViewName[0]);
if (view != null)
view.render(splittedViewName[1], model, locale, request, response);
else
throw new PeRuntimeException(&quot;pe.cannot_resolve_view&quot;,
new Object[] { splittedViewName[0], viewName });
}

private String[] resolverViewResolverName(String viewName) {
String resolverNames[] = new String[2];
String splits[] = StringUtils.delimitedListToStringArray(viewName, &quot;,&quot;);
if (splits.length == 1) {
resolverNames[0] = &quot;default&quot;;
resolverNames[1] = splits[0];
} else if (splits.length == 2) {
resolverNames[0] = splits[0];
resolverNames[1] = splits[1];
}
return resolverNames;
}

public void setLocaleParamName(String localeParamName) {
this.localeParamName = localeParamName;
}

public void setApplicationContext(ApplicationContext applicationContext) {
this.applicationContext = applicationContext;
initMultipartResolver();
initLocaleResolver();
initViewResolver();
initController();
}

protected static String DEFAULT_ALLOWED_LOCALES[] = { &quot;en_US&quot;, &quot;zh_CN&quot;,
&quot;zh_TW&quot; };
protected Log logger;
private boolean publishContext;
public static final String SERVLET_CONTEXT_PREFIX = (new StringBuilder(
String.valueOf(com / csii / pe / dynamic / http
/ MainServlet.getName()))).append(&quot;.CONTEXT.&quot;).toString();
private String namespace;
private MultipartResolver multipartResolver;
private LocaleResolver localeResolver;
private Set allowedLocales;
private Controller controller;
private CsiiViewResolver viewResolver;
private String localeParamName;
private boolean synchronizeOnSession;
private ApplicationContext applicationContext;

}


/*
DECOMPILATION REPORT

Decompiled from: D:\workspace\nanchangyinhang\other\bundles3\com.csii.pe.dynamic.http_6.0.0.201012181045.jar
Total time: 97 ms
Jad reported messages/errors:
The class file version is 49.0 (only 45.3, 46.0 and 47.0 are supported)
Overlapped try statements detected. Not all exception handlers will be resolved in the method doGet
Overlapped try statements detected. Not all exception handlers will be resolved in the method doPost
Exit status: 0
Caught exceptions:
*/
public void setApplicationContext(ApplicationContext applicationContext) {
this.applicationContext = applicationContext;
initMultipartResolver();
initLocaleResolver();
initViewResolver();
initController();
}
private void process(HttpServletRequest request,
HttpServletResponse response) {
if (logger.isDebugEnabled())
logger.debug(&quot;process begin&quot;);
try {
request.setAttribute(
Constants.MAINSERVLET_APPLICATION_CONTEXT_ATTRIBUTE,
applicationContext);
String newLocale = request.getParameter(localeParamName);
if (newLocale != null) {
if (!allowedLocales.contains(newLocale)) {
logger.error((new StringBuilder(&quot;Invalid locale &quot;))
.append(newLocale).append(&quot;, allowed locales: &quot;)
.append(allowedLocales).toString());
throw new PeRuntimeException(
&quot;invalid_locale&quot;,
new Object[] { newLocale, allowedLocales.toString() });
}
LocaleEditor localeEditor = new LocaleEditor();
localeEditor.setAsText(newLocale);
localeResolver.setLocale(request, response,
(Locale) localeEditor.getValue());
}
Locale locale = localeResolver.resolveLocale(request);
if (locale.toString().indexOf(&quot;en&quot;) &gt;= 0)
locale = new Locale(&quot;en&quot;, &quot;US&quot;);
Object model = null;
model = controller.process(request, response, locale);
response.setLocale(locale);
request.setAttribute(localeParamName, locale);
localeResolver.setLocale(request, response, locale);
render(model, request, response, locale);
} catch (Exception e) {
logger.error(&quot;process error:&quot;, e);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>334853</snippet_key>
<tag>java stringbuilder string 程序员 stackoverflow</tag>
<comment>来自CSDN博客：一道很不错的字符分割题 http://blog.csdn.net/u012859193/article/details/25335421#</comment>
<code>/**
author :marksaas
blog: http://www.marksaas.com
交流群：199326422
time:2014/5/8

*/
public class StringTest{
// Tokenize words
private static String s1=&quot;This is my world. This has to be broken.&quot;;
private static final String[] words = s1.split( &quot; &quot; );

// Apply word-wrapping
private static final StringBuilder sb = new StringBuilder();
public static void main(String[] args){
int limit = 10;
for( String word : words ) {
if( sb.length() + word.length() &gt; limit ) {
// Next word wraps
System.out.println( sb );
sb.setLength( 0 );
}
else {
// Otherwise add to current line
if( sb.length() &gt; 0 ) sb.append( &apos; &apos; );
}
sb.append( word );
}

// Handle final line
System.out.println( sb );
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>7429</snippet_key>
<tag>j2ee</tag>
<comment>在开发中，我们在attachmen表中仅仅是保存着一个文件的信息（名称，描述，路径）而已，而真正地文件保存则需要我们自己定义。</comment>
<code>/**
* 保存附件
*
* @param basePath 要保存的基路径
* @param in 文件的字节流
* @param extension 文件的扩展名
* @return
*/
public static String saveAttachment(String basePath, File file, String extension) {

// a, 计算路径
SimpleDateFormat sdf = new SimpleDateFormat(&quot;/yyyy/MM/dd/&quot;);
String datePath = sdf.format(new Date());
String uuidFileName = UUID.randomUUID().toString();

// 创建文件夹
File dir = new File(basePath + datePath);
if (!dir.exists()) {
dir.mkdirs();
}

String path = basePath + datePath + uuidFileName + &quot;.&quot; + extension;

// b, 保存
FileOutputStream out = null;
FileInputStream in = null;
try {
in = new FileInputStream(file);
out = new FileOutputStream(path);
IOUtils.copy(in, out);
} catch (Exception e) {
throw new RuntimeException(e);
} finally {
IOUtils.closeQuietly(in);
IOUtils.closeQuietly(out);
}

return datePath + uuidFileName + &quot;.&quot; + extension;
}
</code>
</RECORD>
<RECORD>
<snippet_key>204037</snippet_key>
<tag>327</tag>
<comment>来自CSDN博客：【九度】 题目1547：出入栈  http://blog.csdn.net/u013027996/article/details/19915653#</comment>
<code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;

public class Main {
/*
* 1547
*/
public static void main(String[] args) throws IOException {
StreamTokenizer st = new StreamTokenizer(new BufferedReader(
new InputStreamReader(System.in)));
while (st.nextToken() != StreamTokenizer.TT_EOF) {
int n = (int)st.nval;
if((n &amp; 1) == 1 || n == 0){
System.out.println(0);
continue;
}
int dp[][] = new int[n][n];
for (int j = 0; j &lt; n; j++) {
dp[0][j] = 1;
}
for (int i = 1; i &lt; n/2+1; i++) {
for (int j = i; j &lt; n/2+1; j++) {
dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % 1000000007;
}
}
System.out.println(dp[n/2][n/2]);
}
}
}

/**************************************************************
Problem: 1547
User: wzqwsrf
Language: Java
Result: Accepted
Time:440 ms
Memory:26932 kb
****************************************************************/
#include &lt;stdio.h&gt;
const int maxn = 502;
const int mod = 1000000007;
int n,i,j;

int main(){
while(scanf(&quot;%d&quot;,&amp;n) != EOF){
if(n &amp; 1 == 1 || n==0){
printf(&quot;0\n&quot;);
continue;
}
int dp[maxn][maxn] = {0};

for(j = 0; j &lt;= n/2; j++){
dp[0][j] = 1;
}
for(i = 1; i &lt;= n/2; i++){
for(j = i; j &lt;= n/2; j++){
dp[i][j] = (dp[i-1][j]+dp[i][j-1]) % mod;
}
}
printf(&quot;%d\n&quot;,dp[n/2][n/2]);
}
return 0;
}

/**************************************************************
Problem: 1547
User: wangzhenqing
Language: C++
Result: Accepted
Time:50 ms
Memory:1936 kb
****************************************************************/
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;

public class Main {
/*
* 1547
*/
public static int maxNum;
public static void main(String[] args) throws IOException {
StreamTokenizer st = new StreamTokenizer(new BufferedReader(
new InputStreamReader(System.in)));
while (st.nextToken() != StreamTokenizer.TT_EOF) {
int n = (int)st.nval;
maxNum = 0;
dfs(n/2, 0, 0);
System.out.println(maxNum % 1000000007);
}
}
public static void dfs(int n,int leftNum, int rightNum) {
if (leftNum == n) {
maxNum++;
return;
}
dfs(n, leftNum+1, rightNum);
if (leftNum &gt; rightNum) {
dfs(n, leftNum, rightNum+1);
}
}
}
/**************************************************************
Problem: 1547
User: wzqwsrf
Language: Java
Result: Time Limit Exceed
****************************************************************/
</code>
</RECORD>
<RECORD>
<snippet_key>335109</snippet_key>
<tag>36</tag>
<comment>来自CSDN博客：Android 使用setContentView在一个Activity进行界面切换 http://blog.csdn.net/lezong2011/article/details/25342491#</comment>
<code>/**
* 使用setContentView在一个Activity
* 进行界面的切换
*/
public class MyActivity extends Activity {

private TextView tv;
private View mainView;
private View subView;

@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
mainView = getLayoutInflater().inflate(R.layout.main,null);
subView = getLayoutInflater().inflate(R.layout.page_view,null);
setContentView(mainView);

Button btn1 = (Button) mainView.findViewById(R.id.button1);
tv = (TextView)mainView.findViewById(R.id.tv_message);
btn1.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
setContentView(subView);
}
});

Button btn2 = (Button) subView.findViewById(R.id.button2);
btn2.setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
tv.setText(&quot;Hello Android&quot;);
setContentView(mainView);
}
});
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>317709</snippet_key>
<tag></tag>
<comment>来自CSDN博客：使用 Blobstore Java API 在Java App Engine 中存放大文件 http://blog.csdn.net/afeiluo/article/details/24649301#</comment>
<code>&lt;pre name=&quot;code&quot; class=&quot;plain&quot;&gt;Applications can use the Blobstore to accept large files as uploads from users and to serve those files. Files are called blobs once they&apos;re uploaded. Applications don&apos;t access blobs directly. Instead, applications work with blobs through blob info entities (represented by the BlobInfo class) in the datastore.

The user creates a blob by submitting an HTML form that includes one or more file input fields. Your application sets blobstoreService.createUploadUrl() as the destination (action) of this form, passing the function a URL path of a handler in your application. When the user submits the form, the user&apos;s browser uploads the specified files directly to the Blobstore. The Blobstore rewrites the user&apos;s request and stores the uploaded file data, replacing the uploaded file data with one or more corresponding blob keys, then passes the rewritten request to the handler at the URL path you provided to blobstoreService.createUploadUrl(). This handler can do additional processing based on the blob key.

The application can read portions of a Blobstore value using a file-like streaming interface. See the BlobstoreInputStream class.
</code>
</RECORD>
<RECORD>
<snippet_key>400645</snippet_key>
<tag>214</tag>
<comment>来自CSDN博客：在web端和android端通过JSON格式实现数据交互  http://blog.csdn.net/u013189665/article/details/32732365#</comment>
<code>public class NewsAction extends ActionSupport {

private News news;

private int pageNo;
private int pageSize;

public int getPageNo() {
return pageNo;
}

public void setPageNo(int pageNo) {
this.pageNo = pageNo;
}

public int getPageSize() {
return pageSize;
}

public void setPageSize(int pageSize) {
this.pageSize = pageSize;
}

public News getNews() {
return news;
}

public void setNews(News news) {
this.news = news;
}

public String insertPre() throws Exception {
List&lt;NewsType&gt; all = ServiceFactory.getINewsServiceInstance()
.insertPre();

JSONArray array = new JSONArray();

Iterator&lt;NewsType&gt; iter = all.iterator();
while (iter.hasNext()) {
NewsType t = iter.next();

JSONObject obj = new JSONObject();
obj.put(&quot;tid&quot;, t.getTid());
obj.put(&quot;tname&quot;, t.getTname());

array.put(obj);
}

HttpServletResponse response = ServletActionContext.getResponse();

response.setCharacterEncoding(&quot;UTF-8&quot;);
response.setContentType(&quot;text/html&quot;);

PrintWriter out = response.getWriter();
out.print(array);
out.close();

return null;
}

public String list() throws Exception {
Map&lt;String, Object&gt; map = ServiceFactory.getINewsServiceInstance()
.list(pageNo, pageSize);
List&lt;News&gt; allNews = (List&lt;News&gt;) map.get(&quot;allNews&quot;);
int count = (Integer) map.get(&quot;count&quot;);

JSONObject root = new JSONObject();

JSONArray array = new JSONArray();

SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);

Iterator&lt;News&gt; iter = allNews.iterator();
while (iter.hasNext()) {
News n = iter.next();

JSONObject obj = new JSONObject();
obj.put(&quot;id&quot;, n.getId());
obj.put(&quot;title&quot;, n.getTitle());
obj.put(&quot;content&quot;, n.getContent());
obj.put(&quot;pubDate&quot;, sf.format(n.getPubDate()));
obj.put(&quot;typeId&quot;, n.getTypeId());

array.put(obj);
}
&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;
public class NetworkUtils {

private static final String URL_BASE = &quot;http://192.168.2.106:8080/AndroidNewsDemo/&quot;;

public static final String GET_ALL_NEWS_TYPE_URL = URL_BASE
+ &quot;news!insertPre.action&quot;;

public static final String NEWS_INSERT_URL = URL_BASE
+ &quot;news!insert.action&quot;;

public static final String NEWS_LIST_URL = URL_BASE + &quot;news!list.action&quot;;

public static String getDataByUrl(String urlStr) throws Exception {
URL url = new URL(urlStr);
URLConnection conn = url.openConnection();
InputStream is = conn.getInputStream();

BufferedReader reader = new BufferedReader(new InputStreamReader(is));
String line = null;
StringBuilder builder = new StringBuilder();

while ((line = reader.readLine()) != null) {
builder.append(line);
}
reader.close();

return builder.toString();
}

public static JSONArray getJSONArrayByUrl(String urlStr) throws Exception {
return new JSONArray(getDataByUrl(urlStr));
}

public static JSONObject getJSONObjectByUrl(String urlStr) throws Exception {
return new JSONObject(getDataByUrl(urlStr));
}

public static String postDataByUrl(String url, Map&lt;String, String&gt; params)
throws Exception {
// 使用HttpClient来完成post提交
HttpClient client = new DefaultHttpClient();
HttpPost post = new HttpPost(url);

// 准备参数集合
List&lt;NameValuePair&gt; allParams = new ArrayList&lt;NameValuePair&gt;();

Iterator&lt;Entry&lt;String, String&gt;&gt; iter = params.entrySet().iterator();
while (iter.hasNext()) {
Entry&lt;String, String&gt; entry = iter.next();
allParams.add(new BasicNameValuePair(entry.getKey(), entry
.getValue()));
}

// 设置参数
post.setEntity(new UrlEncodedFormEntity(allParams));

HttpResponse response = client.execute(post);

return EntityUtils.toString(response.getEntity());
}

public static JSONArray postJSONArrayByUrl(String urlStr,
Map&lt;String, String&gt; params) throws Exception {
return new JSONArray(postDataByUrl(urlStr, params));
}

public static JSONObject postJSONObjectByUrl(String urlStr,
Map&lt;String, String&gt; params) throws Exception {
return new JSONObject(postDataByUrl(urlStr, params));
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>466181</snippet_key>
<tag>326</tag>
<comment>来自CSDN博客：Android开发系列（六）：Android应用中文件的操作模式  http://blog.csdn.net/u010800530/article/details/39154751#</comment>
<code>public void save(String filename, String content) throws Exception {
//私有操作模式：创建出来的文件只能被本应用访问，其他应用无法访问该文件。
//另外采用私有操作模式创建的文件，写入文件中的内容会覆盖源文件内容
FileOutputStream outStream = context.openFileOutput(filename,Context.MODE_PRIVATE); //采用私有操作模式打开输出流
outStream.write(content.getBytes());
outStream.close();
}
public void saveAppend(String filename, String content) throws Exception {
FileOutputStream outStream = context.openFileOutput(filename,Context.MODE_APPEND);
outStream.write(content.getBytes());
outStream.close();
}
public void saveReadable(String filename, String content) throws Exception {

FileOutputStream outStream = context.openFileOutput(filename,Context.MODE_WORLD_READABLE);

outStream.write(content.getBytes());
outStream.close();
}
public void saveWriteable(String filename, String content) throws Exception {

FileOutputStream outStream = context.openFileOutput(filename,Context.MODE_WORLD_WRITEABLE);

outStream.write(content.getBytes());
outStream.close();
}
public void saveWriteable(String filename, String content) throws Exception {
FileOutputStream outStream = context.openFileOutput(filename,Context.MODE_WORLD_READABLE+Context.MODE_WORLD_WRITEABLE);

outStream.write(content.getBytes());
outStream.close();
}
public void saveWriteable(String filename, String content) throws Exception {

FileOutputStream outStream = context.openFileOutput(filename,Context.MODE_APPEND+Context.MODE_WORLD_READABLE+Context.MODE_WORLD_WRITEABLE);

outStream.write(content.getBytes());
outStream.close();
}
</code>
</RECORD>
<RECORD>
<snippet_key>186893</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Android 利用ListView制作带竖线的多彩表格  http://blog.csdn.net/zuoan2008/article/details/19166905#</comment>
<code>public View getView(final int position, View convertView, ViewGroup parent){

//第一个参数position为listview的item序号，每个item的序号都是不同的。

//第二个参数convertView为View的缓存，当listview的item过多时，拖动会遮住一部分item，被遮住的item的view就是convertView保存着。

// 第三个参数parent表示是一个ViewGroup（view组）

}
/*author:conowen
* date:2012.4.2
* GridActivity
*/
package com.conowen.grid;

import android.app.Activity;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.os.Bundle;
import android.widget.ListAdapter;
import android.widget.ListView;

public class GridActivity extends Activity {

SQLiteDatabase sqldb;
public String DB_NAME = &quot;DB.sqlite&quot;;
public String DB_TABLE = &quot;num&quot;;
public int DB_VERSION = 1;
final DataHelper helper = new DataHelper(this, DB_NAME, null, DB_VERSION);
// DbHelper类在DbHelper.java文件里面创建的
ListView lv;

@Override
public void onCreate(Bundle savedInstanceState) {
// TODO Auto-generated method stub
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
sqldb = helper.getWritableDatabase();
lv = (ListView) findViewById(R.id.lv);
updatelistview();
}

// 更新listview
public void updatelistview() {

//
Cursor cr = sqldb.query(&quot;JobChecker&quot;, null, null, null, null, null,
null);

String id = cr.getColumnName(0);// 获取第1列
String job = cr.getColumnName(2);// 获取第3列
String address = cr.getColumnName(4);// 获取第5列
String student = cr.getColumnName(5);// 获取第6列
String[] ColumnNames = { id, job, address, student };

ListAdapter adapter = new MySimpleCursorAdapter(this,
R.layout.listviewlayout, cr, ColumnNames, new int[] { R.id.id,
R.id.job, R.id.addr, R.id.student });
// layout为listView的布局文件，包括三个TextView，用来显示三个列名所对应的值
// ColumnNames为数据库的表的列名
// 最后一个参数是int[]类型的，为view类型的id，用来显示ColumnNames列名所对应的值。view的类型为TextView
lv.setAdapter(adapter);

}

@Override
protected void onDestroy() {// 关闭数据库
// TODO Auto-generated method stub
super.onDestroy();
if (helper != null) {
helper.close();
}
}

}
/*author:conowen
* date:2012.4.2
* MySimpleCursorAdapter
*/
package com.conowen.grid;

import android.content.Context;
import android.database.Cursor;
import android.graphics.Color;
import android.view.View;
import android.view.ViewGroup;
import android.widget.SimpleCursorAdapter;

public class MySimpleCursorAdapter extends SimpleCursorAdapter {

public MySimpleCursorAdapter(Context context, int layout, Cursor c,
String[] from, int[] to) {
super(context, layout, c, from, to);
// TODO Auto-generated constructor stub

}

@Override
public View getView(final int position, View convertView, ViewGroup parent) {
// TODO Auto-generated method stub
// listview每次得到一个item，都要view去绘制，通过getView方法得到view
// position为item的序号
View view = null;
if (convertView != null) {
view = convertView;
// 使用缓存的view,节约内存
// 当listview的item过多时，拖动会遮住一部分item，被遮住的item的view就是convertView保存着。
// 当滚动条回到之前被遮住的item时，直接使用convertView，而不必再去new view()

} else {
view = super.getView(position, convertView, parent);

}

int[] colors = { Color.WHITE, Color.rgb(219, 238, 244) };//RGB颜色

view.setBackgroundColor(colors[position % 2]);// 每隔item之间颜色不同

return super.getView(position, view, parent);
}

}
/*author:conowen
* date:2012.4.2
* DataHelper
*/
package com.conowen.grid;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteDatabase.CursorFactory;
import android.database.sqlite.SQLiteOpenHelper;

public class DataHelper extends SQLiteOpenHelper {

@Override
public synchronized void close() {
// TODO Auto-generated method stub
super.close();
}

public DataHelper(Context context, String name, CursorFactory factory,
int version) {
super(context, name, factory, version);
// TODO Auto-generated constructor stub

}

@Override
public void onCreate(SQLiteDatabase db) {
// TODO Auto-generated method stub

String sql = &quot;CREATE TABLE JobChecker (_id INTEGER PRIMARY KEY , department VARCHAR, job VARCHAR,teacher VARCHAR,address VARCHAR,student VARCHAR,isworking VARCHAR)&quot;;
db.execSQL(sql);

}

@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
// TODO Auto-generated method stub

}

}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;fill_parent&quot;
android:orientation=&quot;vertical&quot; &gt;

&lt;LinearLayout
xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:orientation=&quot;horizontal&quot; &gt;

&lt;TextView
android:layout_width=&quot;40dip&quot;
android:layout_height=&quot;30dp&quot;
android:text=&quot;序号&quot;
android:textSize=&quot;20sp&quot; /&gt;

&lt;TextView
android:id=&quot;@+id/job&quot;
android:layout_width=&quot;200dip&quot;
android:layout_height=&quot;30dp&quot;
android:text=&quot;岗位名称&quot;
android:textSize=&quot;20sp&quot; /&gt;

&lt;TextView
android:id=&quot;@+id/addr&quot;
android:layout_width=&quot;150dip&quot;
android:layout_height=&quot;30dp&quot;
android:text=&quot;详细地点&quot;
android:textSize=&quot;20sp&quot; /&gt;

&lt;TextView
android:id=&quot;@+id/student&quot;
android:layout_width=&quot;100dip&quot;
android:layout_height=&quot;30dp&quot;
android:text=&quot;工作学生&quot;
android:textSize=&quot;20sp&quot; /&gt;

&lt;TextView
android:id=&quot;@+id/isworking&quot;
android:layout_width=&quot;80dip&quot;
android:layout_height=&quot;30dp&quot;
android:text=&quot;备注&quot;
android:textSize=&quot;20sp&quot; /&gt;
&lt;/LinearLayout&gt;

&lt;ListView
android:id=&quot;@+id/lv&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot; &gt;
&lt;/ListView&gt;

&lt;/LinearLayout&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;fill_parent&quot;
android:orientation=&quot;horizontal&quot; &gt;

&lt;View
android:layout_width=&quot;0.5px&quot;
android:layout_height=&quot;fill_parent&quot;
android:background=&quot;#B8B8B8&quot;
android:visibility=&quot;visible&quot; /&gt;

&lt;TextView
android:id=&quot;@+id/id&quot;
android:layout_width=&quot;40dip&quot;
android:layout_height=&quot;55dip&quot;
android:textColor=&quot;#CD3700&quot;
android:textSize=&quot;20sp&quot; /&gt;

&lt;View
android:layout_width=&quot;0.5px&quot;
android:layout_height=&quot;fill_parent&quot;
android:background=&quot;#B8B8B8&quot;
android:visibility=&quot;visible&quot; /&gt;

&lt;TextView
android:id=&quot;@+id/job&quot;
android:layout_width=&quot;200dip&quot;
android:layout_height=&quot;wrap_content&quot;
android:textColor=&quot;#000000&quot;
android:textSize=&quot;17sp&quot; /&gt;

&lt;View
android:layout_width=&quot;0.5px&quot;
android:layout_height=&quot;fill_parent&quot;
android:background=&quot;#B8B8B8&quot;
android:visibility=&quot;visible&quot; /&gt;

&lt;TextView
android:id=&quot;@+id/addr&quot;
android:layout_width=&quot;150dip&quot;
android:layout_height=&quot;wrap_content&quot;
android:textColor=&quot;#000000&quot;
android:textSize=&quot;17sp&quot; /&gt;

&lt;View
android:layout_width=&quot;0.5px&quot;
android:layout_height=&quot;fill_parent&quot;
android:background=&quot;#B8B8B8&quot;
android:visibility=&quot;visible&quot; /&gt;

&lt;TextView
android:id=&quot;@+id/student&quot;
android:layout_width=&quot;100dip&quot;
android:layout_height=&quot;wrap_content&quot;
android:textColor=&quot;#000000&quot;
android:textSize=&quot;20sp&quot; /&gt;

&lt;View
android:layout_width=&quot;0.5px&quot;
android:layout_height=&quot;fill_parent&quot;
android:background=&quot;#B8B8B8&quot;
android:visibility=&quot;visible&quot; /&gt;




&lt;/LinearLayout&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>121613</snippet_key>
<tag>来自CSDN博客：如何判断android 短信发送(sendTextMessage)是否成功 http://blog.csdn.net/garybook/article/details/16887627#</tag>
<comment>派生自只是纸老虎/blog_20131126_1_6573798</comment>
<code>SmsManager smsManager = SmsManager.getDefault();
smsManager.sendTextMessage(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent);
/**
* 参数说明
* destinationAddress:收信人的手机号码
* scAddress:发信人的手机号码
* text:发送信息的内容
* sentIntent:发送是否成功的回执，用于监听短信是否发送成功。
* DeliveryIntent:接收是否成功的回执，用于监听短信对方是否接收成功。
*/
for (int i = 0; i &lt; contactList.size(); i++) {
Intent itSend = new Intent(SENT_SMS_ACTION);
itSend.putExtra(KEY_PHONENUM, contactList.get(i));
PendingIntent mSendPI = PendingIntent.getBroadcast(getApplicationContext(), i/××requestCode××/, itSend, PendingIntent.FLAG_ONE_SHOT/××flag××/);//这里requestCode和flag的设置很重要，影响数据KEY_PHONENUM的传递。
String content = mContext.getString(R.string.test);
smsManager.sendTextMessage(contactList.get(i), null, content, mSendPI, null);
}
public static final String SENT_SMS_ACTION = &quot;SENT_SMS_ACTION&quot;;
private SMSSendResultReceiver mSMSReceiver = new SMSSendResultReceiver();
private IntentFilter mSMSResultFilter = new IntentFilter();
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
mSMSFilter.addAction(SENT_SMS_ACTION);
registerReceiver(mSMSReceiver, mSMSResultFilter);
...
}
class SMSSendResultReceiver extends BroadcastReceiver
{
@Override
public void onReceive(Context context, Intent intent)
{
String phoneNum = intent.getStringExtra(KEY_PHONENUM);
// TODO Auto-generated method stub
switch(getResultCode())
{
case Activity.RESULT_OK:
System.out.println(&quot;Send Message to &quot;+phoneNum+&quot; success!&quot;);
break;
case SmsManager.RESULT_ERROR_GENERIC_FAILURE:
case SmsManager.RESULT_ERROR_RADIO_OFF:
case SmsManager.RESULT_ERROR_NULL_PDU:
default:
System.err.println(&quot;Send Message to &quot;+phoneNum+&quot; fail!&quot;);
break;
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>139013</snippet_key>
<tag>liferay站点的建立及模板的引用</tag>
<comment>来自CSDN博客：在liferay中封装一个Util类用于站点模板的引用  http://blog.csdn.net/u013310075/article/details/17757173#</comment>
<code>Organization organization = OrganizationLocalServiceUtil.addOrganization(userId, parentOrganizationId, name, type, recursable, regionId, countryId, statusId, comments, site, serviceContext);
package com.example.util;

import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.exception.SystemException;
import com.liferay.portal.kernel.util.MethodKey;
import com.liferay.portal.kernel.util.PortalClassInvoker;
import com.liferay.portal.model.Group;
import com.liferay.portal.model.LayoutSet;
import com.liferay.portal.model.LayoutSetPrototype;
import com.liferay.portal.service.GroupLocalServiceUtil;
import com.liferay.portal.service.LayoutSetLocalServiceUtil;
import com.liferay.portal.service.LayoutSetPrototypeLocalServiceUtil;

public class LayoutsetUtil {
public static void setupSitesFromSiteTemplate(long groupId,
long publicSiteTemplateId, long privateSiteTemplateId)
throws PortalException, SystemException {
Group group = GroupLocalServiceUtil.getGroup(groupId);
if (publicSiteTemplateId != 0)
setSiteTemplate(group, publicSiteTemplateId, false);
if (privateSiteTemplateId != 0)
setSiteTemplate(group, privateSiteTemplateId, true);
}

public static void setSiteTemplate(Group group, long siteTemplateId,
boolean isPrivateLayout) throws PortalException, SystemException {
long groupId = group.getGroupId();
LayoutSetPrototype prototype = LayoutSetPrototypeLocalServiceUtil
.getLayoutSetPrototype(siteTemplateId);
boolean layoutSetPrototypeLinkEnabled = true;
LayoutSetLocalServiceUtil.updateLayoutSetPrototypeLinkEnabled(groupId,
isPrivateLayout, layoutSetPrototypeLinkEnabled,
prototype.getUuid());
try {
LayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(
groupId, isPrivateLayout);
mergeLayoutSetProtypeLayouts(group, layoutSet);
} catch (Exception e) {
e.printStackTrace();
}
}

public static void mergeLayoutSetProtypeLayouts(Group group,
LayoutSet layoutSet) throws Exception {

MethodKey key = SitesUtilMethodKey(&quot;mergeLayoutSetProtypeLayouts&quot;,
Group.class, LayoutSet.class);
invokePortalClassMethod(key, group, layoutSet);
}

/*
* copied from
* http://www.liferay.com/community/forums/-/message_boards/view_message
* /10488983#_19_message_10488983 post by Jelmer Kuperus
*
* key: key of method to be called, e.g.
* com.liferay.portlet.sites.util.SitesUtil arguments: arguments to be
* passed to the invoked method returns: result of the invoked method
*/
private static Object invokePortalClassMethod(MethodKey key,
Object... arguments) throws PortalException {
try {
// noinspection unchecked
return PortalClassInvoker.invoke(false, key, arguments);
} catch (PortalException e) {
throw e;
} catch (Exception e) {
throw new RuntimeException(e);
}
}

private static final String SITES_UTIL_CLASS_NAME = &quot;com.liferay.portlet.sites.util.SitesUtil&quot;;

private static MethodKey SitesUtilMethodKey(String methodName,
Class&lt;?&gt;... parameterTypes) {
return new MethodKey(SITES_UTIL_CLASS_NAME, methodName, parameterTypes);
}
}
//给站点添加自定义字段
Group group = GroupLocalServiceUtil.getGroup(organization.getGroupId());
//调用这个设置自定义字段group.getExpandoBridge().setAttribute(name, value);
&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;group.getExpandoBridge().setAttribute(&quot;appCode&quot;, &quot;cg&quot;);
</code>
</RECORD>
<RECORD>
<snippet_key>449293</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Longest Substring Without Repeating Characters  http://blog.csdn.net/tangximing123/article/details/38535165#</comment>
<code>public class Solution
{

public static int lengthOfLongestSubstring(String s)
{
int maxlength = 0,tmplength = 0;
int length = s.length();
String string = &quot;&quot;;
for(int i = 0; i &lt; length; i++)
{
char c = s.charAt(i);
if(string.indexOf(c) &lt; 0)
{
tmplength++;
string += c;
}
else
{
tmplength = 1;
string = String.valueOf(c);
}
if(maxlength &lt; tmplength)
maxlength = tmplength;
}
return maxlength;
}

public static void main(String[] args)
{
// TODO Auto-generated method stub
String string= &quot;bbbbbb&quot;;
System.out.println(lengthOfLongestSubstring(string));
}

}
public static int lengthOfLongestSubstring_1(String s)
{
int maxlength = 0,tmplength = 0;
int length = s.length();
String string = &quot;&quot;,maxstring = &quot;&quot;;
for(int i = 0; i &lt; length; i++)
{
char c = s.charAt(i);
int index = string.indexOf(c);
if(index &lt; 0)
{
tmplength++;
string += c;
System.out.println(string);
}
else
{
int bw = string.length() - index -1;
i = i - bw - 1;
tmplength = 0;
string = &quot;&quot;;
}
if(maxlength &lt; tmplength)
{
maxlength = tmplength;
maxstring = string;
}
}
return maxlength;
public static int lengthOfLongestSubstring(String s)
{
int start = 0;
int length = s.length();
int maxlength = 0;
int[] map = new int[256];
for(int i = 0; i &lt; length; i++)
{
char c = s.charAt(i);
if(map[c] != 1)
{
map[c] = 1;
maxlength = Math.max(maxlength, i - start + 1);
}
else
{
while(s.charAt(start) != c)
{
map[s.charAt(start)] = 0;
start++;
}
start++;
}
}
return maxlength;

}
</code>
</RECORD>
<RECORD>
<snippet_key>252941</snippet_key>
<tag>多核 无锁</tag>
<comment>来自CSDN博客：Art of Multiprocessor Programming 答案 ch5 http://blog.csdn.net/fulltopic/article/details/21901617#</comment>
<code>package jokes;

import java.util.concurrent.LinkedTransferQueue;

public class QueuePeekConsensus
{
private LinkedTransferQueue&lt;Integer&gt; q;

public QueuePeekConsensus(int n)
{
q = new LinkedTransferQueue&lt;Integer&gt;();
}

private void propose(int v)
{
q.put(v);
}

public int decide(int v)
{

propose(v);
return q.peek();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>122381</snippet_key>
<tag>设计模式 面向对象 Java模式 模板方法</tag>
<comment>来自CSDN博客：Java设计模式初识--模板方法模式  http://blog.csdn.net/ysjian_pingcx/article/details/8643816#</comment>
<code>/**
* 查看试卷的接口
*/
public void showPaper(){
question1();
question2();
question3();
}
public abstract class ExaminationPaper {

/**
* 试题一
*/
protected void question1() {
String title = &quot;1.在Java语言中，下面的几种类型哪种不能用于switch语句中的选择条件？&quot;
+ &quot;\nA.String;B.char;C.Enum;D.int;E.long&quot;;
System.out.println(title+&quot;\n答案： &quot;+answer1());
}

/**
* 试题二
*/
protected void question2() {
String title = &quot;2.下面哪个不是方法的重写必须遵循的规则？&quot;
+ &quot;\nA.访问权限必须大于或等于父类;&quot; +
&quot;B.抛出的异常比父类要少或者是父类中抛出异常的子类;\n&quot; +
&quot;C.方法名以及参数的类型，顺序和个数相同;\n&quot; +
&quot;D.在方法前必须加@Override;E.方法的返回值与父类相同或是父类的子类&quot;;
System.out.println(title+&quot;\n答案： &quot;+answer2());
}

/**
* 试题三
*/
protected void question3() {
String title = &quot;3.下面那个不是事务的特征？&quot;
+ &quot;\nA.原子性;B.一致性;C.隔离性;D.安全性;E.持久性&quot;;
System.out.println(title+&quot;\n答案： &quot;+answer3());
}

/**
* 试题一的答案
* @return
*/
protected abstract String answer1();

/**
* 试题二的答案
* @return
*/
protected abstract String answer2();

/**
* 试题三的答案
* @return
*/
protected abstract String answer3();

/**
* 查看试卷的接口
*/
public void showPaper(){
question1();
question2();
question3();
}
}
public class Ysj001Paper extends ExaminationPaper {

static{
System.out.println(&quot;姓名：Ysj001 时间：两小时&quot;);
}

@Override
protected String answer1() {
return &quot;A&quot;;
}

@Override
protected String answer2() {
return &quot;B&quot;;
}

@Override
protected String answer3() {
return &quot;C&quot;;
}
}
public class Ysj002Paper extends ExaminationPaper {

static{
System.out.println(&quot;姓名：Ysj002 时间：两小时&quot;);
}

@Override
protected String answer1() {
return &quot;E&quot;;
}

@Override
protected String answer2() {
return &quot;D&quot;;
}

@Override
protected String answer3() {
return &quot;C&quot;;
}
}
public class Ysj003Paper extends ExaminationPaper {

static{
System.out.println(&quot;姓名：Ysj003 时间：两小时&quot;);
}

@Override
protected String answer1() {
return &quot;D&quot;;
}

@Override
protected String answer2() {
return &quot;B&quot;;
}

@Override
protected String answer3() {
return &quot;C&quot;;
}
}
public class ScoreClient {

public static void main(String[] args) {

//想要看谁的试卷，就可以创建谁的试卷的对象
ExaminationPaper paper = new Ysj003Paper();
//查看试卷
paper.showPaper();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>401413</snippet_key>
<tag>java MD5加密</tag>
<comment>来自CSDN博客：/JAVA MD5/加密代码.//.  http://blog.csdn.net/weiwei5910/article/details/8976010#</comment>
<code>public class MD5 {
/* 下面这些S11-S44实际上是一个4*4的矩阵，在原始的C实现中是用#define 实现的，
这里把它们实现成为static final是表示了只读，切能在同一个进程空间内的多个
Instance间共享*/
static final int S11 = 7;
static final int S12 = 12;
static final int S13 = 17;
static final int S14 = 22;

static final int S21 = 5;
static final int S22 = 9;
static final int S23 = 14;
static final int S24 = 20;

static final int S31 = 4;
static final int S32 = 11;
static final int S33 = 16;
static final int S34 = 23;

static final int S41 = 6;
static final int S42 = 10;
static final int S43 = 15;
static final int S44 = 21;

static final byte[] PADDING = { -128, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
/* 下面的三个成员是MD5计算过程中用到的3个核心数据，在原始的C实现中
被定义到MD5_CTX结构中

*/
private long[] state = new long[4]; // state (ABCD)
private long[] count = new long[2]; // number of bits, modulo 2^64 (lsb first)
private byte[] buffer = new byte[64]; // input buffer

/* digestHexStr是MD5的唯一一个公共成员，是最新一次计算结果的
 16进制ASCII表示.
*/
public String digestHexStr;

/* digest,是最新一次计算结果的2进制内部表示，表示128bit的MD5值.
*/
private byte[] digest = new byte[16];

/*
getMD5ofStr是类MD5最主要的公共方法，入口参数是你想要进行MD5变换的字符串
返回的是变换完的结果，这个结果是从公共成员digestHexStr取得的．
*/
public String getMD5ofStr(String inbuf) {
md5Init();
md5Update(inbuf.getBytes(), inbuf.length());
md5Final();
digestHexStr = &quot;&quot;;
for (int i = 0; i &lt; 16; i++) {
digestHexStr += byteHEX(digest[i]);
}
return digestHexStr;

}
// 这是MD5这个类的标准构造函数，JavaBean要求有一个public的并且没有参数的构造函数
public MD5() {
md5Init();

return;
}
/* md5Init是一个初始化函数，初始化核心变量，装入标准的幻数 */
private void md5Init() {
count[0] = 0L;
count[1] = 0L;
///* Load magic initialization constants.

state[0] = 0x67452301L;
state[1] = 0xefcdab89L;
state[2] = 0x98badcfeL;
state[3] = 0x10325476L;

return;
}
/* F, G, H ,I 是4个基本的MD5函数，在原始的MD5的C实现中，由于它们是
简单的位运算，可能出于效率的考虑把它们实现成了宏，在java中，我们把它们
 实现成了private方法，名字保持了原来C中的。 */

private long F(long x, long y, long z) {
return (x &amp; y) | ((~x) &amp; z);

}
private long G(long x, long y, long z) {
return (x &amp; z) | (y &amp; (~z));

}
private long H(long x, long y, long z) {
return x ^ y ^ z;
}

private long I(long x, long y, long z) {
return y ^ (x | (~z));
}

/*
FF,GG,HH和II将调用F,G,H,I进行近一步变换
FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
Rotation is separate from addition to prevent recomputation.
*/

private long FF(long a, long b, long c, long d, long x, long s,
long ac) {
a += F (b, c, d) + x + ac;
a = ((int) a &lt;&lt; s) | ((int) a &gt;&gt;&gt; (32 - s));
a += b;
return a;
}

private long GG(long a, long b, long c, long d, long x, long s,
long ac) {
a += G (b, c, d) + x + ac;
a = ((int) a &lt;&lt; s) | ((int) a &gt;&gt;&gt; (32 - s));
a += b;
return a;
}
private long HH(long a, long b, long c, long d, long x, long s,
long ac) {
a += H (b, c, d) + x + ac;
a = ((int) a &lt;&lt; s) | ((int) a &gt;&gt;&gt; (32 - s));
a += b;
return a;
}
private long II(long a, long b, long c, long d, long x, long s,
long ac) {
a += I (b, c, d) + x + ac;
a = ((int) a &lt;&lt; s) | ((int) a &gt;&gt;&gt; (32 - s));
a += b;
return a;
}
/*
md5Update是MD5的主计算过程，inbuf是要变换的字节串，inputlen是长度，这个
函数由getMD5ofStr调用，调用之前需要调用md5init，因此把它设计成private的
*/
private void md5Update(byte[] inbuf, int inputLen) {

int i, index, partLen;
byte[] block = new byte[64];
index = (int)(count[0] &gt;&gt;&gt; 3) &amp; 0x3F;
// /* Update number of bits */
if ((count[0] += (inputLen &lt;&lt; 3)) &lt; (inputLen &lt;&lt; 3))
count[1]++;
count[1] += (inputLen &gt;&gt;&gt; 29);

partLen = 64 - index;

// Transform as many times as possible.
if (inputLen &gt;= partLen) {
md5Memcpy(buffer, inbuf, index, 0, partLen);
md5Transform(buffer);

for (i = partLen; i + 63 &lt; inputLen; i += 64) {

md5Memcpy(block, inbuf, 0, i, 64);
md5Transform (block);
}
index = 0;

} else

i = 0;

///* Buffer remaining input */
md5Memcpy(buffer, inbuf, index, i, inputLen - i);

}

/*
md5Final整理和填写输出结果
*/
private void md5Final () {
byte[] bits = new byte[8];
int index, padLen;

///* Save number of bits */
Encode (bits, count, 8);

///* Pad out to 56 mod 64.
index = (int)(count[0] &gt;&gt;&gt; 3) &amp; 0x3f;
padLen = (index &lt; 56) ? (56 - index) : (120 - index);
md5Update (PADDING, padLen);

///* Append length (before padding) */
md5Update(bits, 8);

///* Store state in digest */
Encode (digest, state, 16);

}

/* md5Memcpy是一个内部使用的byte数组的块拷贝函数，从input的inpos开始把len长度的
 字节拷贝到output的outpos位置开始
*/

private void md5Memcpy (byte[] output, byte[] input,
int outpos, int inpos, int len)
{
int i;

for (i = 0; i &lt; len; i++)
output[outpos + i] = input[inpos + i];
}

/*
md5Transform是MD5核心变换程序，有md5Update调用，block是分块的原始字节
*/
private void md5Transform (byte block[]) {
long a = state[0], b = state[1], c = state[2], d = state[3];
long[] x = new long[16];

Decode (x, block, 64);

/* Round 1 */
a = FF (a, b, c, d, x[0], S11, 0xd76aa478L); /* 1 */
d = FF (d, a, b, c, x[1], S12, 0xe8c7b756L); /* 2 */
c = FF (c, d, a, b, x[2], S13, 0x242070dbL); /* 3 */
b = FF (b, c, d, a, x[3], S14, 0xc1bdceeeL); /* 4 */
a = FF (a, b, c, d, x[4], S11, 0xf57c0fafL); /* 5 */
d = FF (d, a, b, c, x[5], S12, 0x4787c62aL); /* 6 */
c = FF (c, d, a, b, x[6], S13, 0xa8304613L); /* 7 */
b = FF (b, c, d, a, x[7], S14, 0xfd469501L); /* 8 */
a = FF (a, b, c, d, x[8], S11, 0x698098d8L); /* 9 */
d = FF (d, a, b, c, x[9], S12, 0x8b44f7afL); /* 10 */
c = FF (c, d, a, b, x[10], S13, 0xffff5bb1L); /* 11 */
b = FF (b, c, d, a, x[11], S14, 0x895cd7beL); /* 12 */
a = FF (a, b, c, d, x[12], S11, 0x6b901122L); /* 13 */
d = FF (d, a, b, c, x[13], S12, 0xfd987193L); /* 14 */
c = FF (c, d, a, b, x[14], S13, 0xa679438eL); /* 15 */
b = FF (b, c, d, a, x[15], S14, 0x49b40821L); /* 16 */

/* Round 2 */
a = GG (a, b, c, d, x[1], S21, 0xf61e2562L); /* 17 */
d = GG (d, a, b, c, x[6], S22, 0xc040b340L); /* 18 */
c = GG (c, d, a, b, x[11], S23, 0x265e5a51L); /* 19 */
b = GG (b, c, d, a, x[0], S24, 0xe9b6c7aaL); /* 20 */
a = GG (a, b, c, d, x[5], S21, 0xd62f105dL); /* 21 */
d = GG (d, a, b, c, x[10], S22, 0x2441453L); /* 22 */
c = GG (c, d, a, b, x[15], S23, 0xd8a1e681L); /* 23 */
b = GG (b, c, d, a, x[4], S24, 0xe7d3fbc8L); /* 24 */
a = GG (a, b, c, d, x[9], S21, 0x21e1cde6L); /* 25 */
d = GG (d, a, b, c, x[14], S22, 0xc33707d6L); /* 26 */
c = GG (c, d, a, b, x[3], S23, 0xf4d50d87L); /* 27 */
b = GG (b, c, d, a, x[8], S24, 0x455a14edL); /* 28 */
a = GG (a, b, c, d, x[13], S21, 0xa9e3e905L); /* 29 */
d = GG (d, a, b, c, x[2], S22, 0xfcefa3f8L); /* 30 */
c = GG (c, d, a, b, x[7], S23, 0x676f02d9L); /* 31 */
b = GG (b, c, d, a, x[12], S24, 0x8d2a4c8aL); /* 32 */

/* Round 3 */
a = HH (a, b, c, d, x[5], S31, 0xfffa3942L); /* 33 */
d = HH (d, a, b, c, x[8], S32, 0x8771f681L); /* 34 */
c = HH (c, d, a, b, x[11], S33, 0x6d9d6122L); /* 35 */
b = HH (b, c, d, a, x[14], S34, 0xfde5380cL); /* 36 */
a = HH (a, b, c, d, x[1], S31, 0xa4beea44L); /* 37 */
d = HH (d, a, b, c, x[4], S32, 0x4bdecfa9L); /* 38 */
c = HH (c, d, a, b, x[7], S33, 0xf6bb4b60L); /* 39 */
b = HH (b, c, d, a, x[10], S34, 0xbebfbc70L); /* 40 */
a = HH (a, b, c, d, x[13], S31, 0x289b7ec6L); /* 41 */
d = HH (d, a, b, c, x[0], S32, 0xeaa127faL); /* 42 */
c = HH (c, d, a, b, x[3], S33, 0xd4ef3085L); /* 43 */
b = HH (b, c, d, a, x[6], S34, 0x4881d05L); /* 44 */
a = HH (a, b, c, d, x[9], S31, 0xd9d4d039L); /* 45 */
d = HH (d, a, b, c, x[12], S32, 0xe6db99e5L); /* 46 */
c = HH (c, d, a, b, x[15], S33, 0x1fa27cf8L); /* 47 */
b = HH (b, c, d, a, x[2], S34, 0xc4ac5665L); /* 48 */

/* Round 4 */
a = II (a, b, c, d, x[0], S41, 0xf4292244L); /* 49 */
d = II (d, a, b, c, x[7], S42, 0x432aff97L); /* 50 */
c = II (c, d, a, b, x[14], S43, 0xab9423a7L); /* 51 */
b = II (b, c, d, a, x[5], S44, 0xfc93a039L); /* 52 */
a = II (a, b, c, d, x[12], S41, 0x655b59c3L); /* 53 */
d = II (d, a, b, c, x[3], S42, 0x8f0ccc92L); /* 54 */
c = II (c, d, a, b, x[10], S43, 0xffeff47dL); /* 55 */
b = II (b, c, d, a, x[1], S44, 0x85845dd1L); /* 56 */
a = II (a, b, c, d, x[8], S41, 0x6fa87e4fL); /* 57 */
d = II (d, a, b, c, x[15], S42, 0xfe2ce6e0L); /* 58 */
c = II (c, d, a, b, x[6], S43, 0xa3014314L); /* 59 */
b = II (b, c, d, a, x[13], S44, 0x4e0811a1L); /* 60 */
a = II (a, b, c, d, x[4], S41, 0xf7537e82L); /* 61 */
d = II (d, a, b, c, x[11], S42, 0xbd3af235L); /* 62 */
c = II (c, d, a, b, x[2], S43, 0x2ad7d2bbL); /* 63 */
b = II (b, c, d, a, x[9], S44, 0xeb86d391L); /* 64 */

state[0] += a;
state[1] += b;
state[2] += c;
state[3] += d;

}

/*Encode把long数组按顺序拆成byte数组，因为java的long类型是64bit的，
只拆低32bit，以适应原始C实现的用途
*/
private void Encode (byte[] output, long[] input, int len) {
int i, j;

for (i = 0, j = 0; j &lt; len; i++, j += 4) {
output[j] = (byte)(input[i] &amp; 0xffL);
output[j + 1] = (byte)((input[i] &gt;&gt;&gt; 8) &amp; 0xffL);
output[j + 2] = (byte)((input[i] &gt;&gt;&gt; 16) &amp; 0xffL);
output[j + 3] = (byte)((input[i] &gt;&gt;&gt; 24) &amp; 0xffL);
}
}

/*Decode把byte数组按顺序合成成long数组，因为java的long类型是64bit的，
只合成低32bit，高32bit清零，以适应原始C实现的用途
*/
private void Decode (long[] output, byte[] input, int len) {
int i, j;


for (i = 0, j = 0; j &lt; len; i++, j += 4)
output[i] = b2iu(input[j]) |
(b2iu(input[j + 1]) &lt;&lt; 8) |
(b2iu(input[j + 2]) &lt;&lt; 16) |
(b2iu(input[j + 3]) &lt;&lt; 24);

return;
}

/*
b2iu是我写的一个把byte按照不考虑正负号的原则的＂升位＂程序，因为java没有unsigned运算
*/
public static long b2iu(byte b) {
return b &lt; 0 ? b &amp; 0x7F + 128 : b;
}

/*byteHEX()，用来把一个byte类型的数转换成十六进制的ASCII表示，
 因为java中的byte的toString无法实现这一点，我们又没有C语言中的
sprintf(outbuf,&quot;%02X&quot;,ib)
*/
public static String byteHEX(byte ib) {
char[] Digit = { &apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,
&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos; };
char [] ob = new char[2];
ob[0] = Digit[(ib &gt;&gt;&gt; 4) &amp; 0X0F];
ob[1] = Digit[ib &amp; 0X0F];
String s = new String(ob);
return s;
}
public static void main(String args[]){
MD5 md5 = new MD5();
System.out.println(md5.getMD5ofStr(&quot;12345&quot;));
}
}
douban.com/note/361273726/
douban.com/note/361274342/
douban.com/note/361274367/
douban.com/note/361274381/
douban.com/note/361274491/
douban.com/note/361274514/
douban.com/note/361274615/
douban.com/note/361274651/
douban.com/note/361274683/
douban.com/note/361274739/
douban.com/note/361274787/
douban.com/note/361274810/
douban.com/note/361274826/
douban.com/note/361274929/
douban.com/note/361274985/
douban.com/note/361275125/
douban.com/note/361275160/
douban.com/note/361275181/
douban.com/note/361275228/
douban.com/note/361275259/
douban.com/note/361275290/
douban.com/note/361275346/
douban.com/note/361275370/
douban.com/note/361275394/
douban.com/note/361275489/
douban.com/note/361275532/
douban.com/note/361275549/
douban.com/note/361275568/
douban.com/note/361275593/
douban.com/note/361275628/
douban.com/note/361275668/
douban.com/note/361275695/
douban.com/note/361275716/
douban.com/note/361275849/
douban.com/note/361275853/
douban.com/note/361275881/
douban.com/note/361275928/
douban.com/note/361275954/
douban.com/note/361275982/
douban.com/note/361276017/
douban.com/note/361276177/
douban.com/note/361276269/
douban.com/note/361276288/
douban.com/note/361276318/
douban.com/note/361276350/
douban.com/note/361276398/
douban.com/note/361276421/
douban.com/note/361276442/
douban.com/note/361276462/
douban.com/note/361276491/
douban.com/note/361276690/
douban.com/note/361276716/
douban.com/note/361274320/
douban.com/note/361274358/
douban.com/note/361274395/
douban.com/note/361274428/
douban.com/note/361274434/
douban.com/note/361274447/
douban.com/note/361274546/
douban.com/note/361274551/
douban.com/note/361274575/
douban.com/note/361274584/
douban.com/note/361274637/
douban.com/note/361274666/
douban.com/note/361274710/
douban.com/note/361274753/
douban.com/note/361274771/
douban.com/note/361274873/
douban.com/note/361274912/
douban.com/note/361274971/
douban.com/note/361275007/
douban.com/note/361275032/
douban.com/note/361275065/
douban.com/note/361275080/
douban.com/note/361275101/
douban.com/note/361275157/
douban.com/note/361275230/
douban.com/note/361275269/
douban.com/note/361275313/
douban.com/note/361275331/
douban.com/note/361275361/
douban.com/note/361275387/
douban.com/note/361275427/
douban.com/note/361275434/
douban.com/note/361275459/
douban.com/note/361275586/
douban.com/note/361275613/
douban.com/note/361275645/
douban.com/note/361275677/
douban.com/note/361275703/
douban.com/note/361275743/
douban.com/note/361275752/
douban.com/note/361275766/
douban.com/note/361275773/
douban.com/note/361275908/
douban.com/note/361275940/
douban.com/note/361275969/
douban.com/note/361276009/
douban.com/note/361276025/
douban.com/note/361276058/
douban.com/note/361276085/
douban.com/note/361276118/
douban.com/note/361276131/
douban.com/note/361276309/
douban.com/note/361276342/
douban.com/note/361276387/
douban.com/note/361276459/
douban.com/note/361276470/
douban.com/note/361276519/
douban.com/note/361276526/
douban.com/note/361276536/
douban.com/note/361276545/
douban.com/note/361276623/
douban.com/note/361276643/
douban.com/note/361276663/
douban.com/note/361276707/
douban.com/note/361276730/
douban.com/note/361276746/
douban.com/note/361276762/
douban.com/note/361276791/
douban.com/note/361276802/
Â douban.com/note/361273726/
douban.com/note/361274342/
douban.com/note/361274367/
douban.com/note/361274381/
douban.com/note/361274491/
douban.com/note/361274514/
douban.com/note/361274615/
douban.com/note/361274651/
douban.com/note/361274683/
douban.com/note/361274739/
douban.com/note/361274787/
douban.com/note/361274810/
douban.com/note/361274826/
douban.com/note/361274929/
douban.com/note/361274985/
douban.com/note/361275125/
douban.com/note/361275160/
douban.com/note/361275181/
douban.com/note/361275228/
douban.com/note/361275259/
douban.com/note/361275290/
douban.com/note/361275346/
douban.com/note/361275370/
douban.com/note/361275394/
douban.com/note/361275489/
douban.com/note/361275532/
douban.com/note/361275549/
douban.com/note/361275568/
douban.com/note/361275593/
douban.com/note/361275628/
douban.com/note/361275668/
douban.com/note/361275695/
douban.com/note/361275716/
douban.com/note/361275849/
douban.com/note/361275853/
douban.com/note/361275881/
douban.com/note/361275928/
douban.com/note/361275954/
douban.com/note/361275982/
douban.com/note/361276017/
douban.com/note/361276177/
douban.com/note/361276269/
douban.com/note/361276288/
douban.com/note/361276318/
douban.com/note/361276350/
douban.com/note/361276398/
douban.com/note/361276421/
douban.com/note/361276442/
douban.com/note/361276462/
douban.com/note/361276491/
douban.com/note/361276690/
douban.com/note/361276716/
douban.com/note/361274320/
douban.com/note/361274358/
douban.com/note/361274395/
douban.com/note/361274428/
douban.com/note/361274434/
douban.com/note/361274447/
douban.com/note/361274546/
douban.com/note/361274551/
douban.com/note/361274575/
douban.com/note/361274584/
douban.com/note/361274637/
douban.com/note/361274666/
douban.com/note/361274710/
douban.com/note/361274753/
douban.com/note/361274771/
douban.com/note/361274873/
douban.com/note/361274912/
douban.com/note/361274971/
douban.com/note/361275007/
douban.com/note/361275032/
douban.com/note/361275065/
douban.com/note/361275080/
douban.com/note/361275101/
douban.com/note/361275157/
douban.com/note/361275230/
douban.com/note/361275269/
douban.com/note/361275313/
douban.com/note/361275331/
douban.com/note/361275361/
douban.com/note/361275387/
douban.com/note/361275427/
douban.com/note/361275434/
douban.com/note/361275459/
douban.com/note/361275586/
douban.com/note/361275613/
douban.com/note/361275645/
douban.com/note/361275677/
douban.com/note/361275703/
douban.com/note/361275743/
douban.com/note/361275752/
douban.com/note/361275766/
douban.com/note/361275773/
douban.com/note/361275908/
douban.com/note/361275940/
douban.com/note/361275969/
douban.com/note/361276009/
douban.com/note/361276025/
douban.com/note/361276058/
douban.com/note/361276085/
douban.com/note/361276118/
douban.com/note/361276131/
douban.com/note/361276309/
douban.com/note/361276342/
douban.com/note/361276387/
douban.com/note/361276459/
douban.com/note/361276470/
douban.com/note/361276519/
douban.com/note/361276526/
douban.com/note/361276536/
douban.com/note/361276545/
douban.com/note/361276623/
douban.com/note/361276643/
douban.com/note/361276663/
douban.com/note/361276707/
douban.com/note/361276730/
douban.com/note/361276746/
douban.com/note/361276762/
douban.com/note/361276791/
douban.com/note/361276802/
Â douban.com/note/361383311/
douban.com/note/361383331/
douban.com/note/361383359/
douban.com/note/361383383/
douban.com/note/361383408/
douban.com/note/361383444/
douban.com/note/361383492/
douban.com/note/361383511/
douban.com/note/361383568/
douban.com/note/361383664/
douban.com/note/361383677/
douban.com/note/361383697/
douban.com/note/361383700/
douban.com/note/361383715/
douban.com/note/361383723/
douban.com/note/361383758/
douban.com/note/361383765/
douban.com/note/361383790/
douban.com/note/361383805/
douban.com/note/361383814/
douban.com/note/361383823/
douban.com/note/361383838/
douban.com/note/361383843/
douban.com/note/361383871/
douban.com/note/361383924/
douban.com/note/361383941/
douban.com/note/361383963/
douban.com/note/361383987/
douban.com/note/361384011/
douban.com/note/361384021/
douban.com/note/361384043/
douban.com/note/361384067/
douban.com/note/361384087/
douban.com/note/361384218/
douban.com/note/361384239/
douban.com/note/361384263/
douban.com/note/361384286/
douban.com/note/361384299/
douban.com/note/361384312/
douban.com/note/361384336/
douban.com/note/361384384/
douban.com/note/361384424/
douban.com/note/361384441/
douban.com/note/361384457/
douban.com/note/361384475/
douban.com/note/361384504/
douban.com/note/361384559/
douban.com/note/361384564/
douban.com/note/361384589/
</code>
</RECORD>
<RECORD>
<snippet_key>318989</snippet_key>
<tag>java 递归 汉诺塔</tag>
<comment>来自CSDN博客：汉诺塔java递归解法浅析  http://blog.csdn.net/u011882512/article/details/24723245#</comment>
<code>import java.util.Scanner;

public class Main {
public static void main(String[] args) {
System.out.println(&quot;Enter disks number:&quot;);
int nDisks = new Scanner(System.in).nextInt();

doTowers(nDisks, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;);
}

public static void doTowers(int topN, char from, char inter, char to) {
if (topN == 1) {
System.out.println(&quot;Disk &quot; + topN + &quot; from &quot; + from + &quot; to &quot; + to);
} else {
doTowers(topN - 1, from, to, inter);
System.out.println(&quot;Disk &quot; + topN + &quot; from &quot; + from + &quot; to &quot; + to);
doTowers(topN - 1, inter, from, to);
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>450061</snippet_key>
<tag></tag>
<comment>来自CSDN博客：生产者消费者模式Java实现  http://blog.csdn.net/lzx1104/article/details/38554477#</comment>
<code>public class Product {
private String name;

Product() {

}

Product(String name) {
this.name = name;
}

public String getName() {
return name;
}

public void setName(String name) {
this.name = name;
}
}
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class Storage {
BlockingQueue&lt;Product&gt; queue = new LinkedBlockingQueue&lt;Product&gt;(10);

public void push(Product product) throws InterruptedException {
queue.put(product);
}

public Product pop() throws InterruptedException {
return queue.take();
}

public boolean isEmpty() {
return queue.isEmpty();
}
}
public class Producer implements Runnable {
private String producerName;
private String productName;
private int productNum;

private Storage store;

Producer(String producerName, String productName, int productNum, Storage store) {
this.producerName = producerName;
this.productName = productName;
this.productNum = productNum;
this.store = store;
}

@Override
public void run() {
for (int i = 0; i &lt; productNum; i ++) {
String pName = String.format(&quot;%s-%d-%d&quot;, productName, i, (int)(Math.random()*100));
//System.out.printf(&quot;%s is producing %s\n&quot;, producerName, pName);
try {
Product p = new Product(pName);
store.push(p);
Thread.sleep(500);
} catch (InterruptedException e) {
e.printStackTrace();
}
System.out.printf(&quot;%s produced %s\n&quot;, producerName, pName);
}
}

}
public class Consumer implements Runnable {
private String name;
private int consumerNum;
private Storage store;

Consumer(String consumer, int consumerNum, Storage store) {
this.name = consumer;
this.consumerNum = consumerNum;
this.store = store;
}

@Override
public void run() {
for (int i = 0; i &lt; this.consumerNum; i++) {
Product p = null;
try {
p = store.pop();
} catch (InterruptedException e) {
e.printStackTrace();
}

String pName = null;
if (p != null) {
pName = p.getName();
}
System.out.printf(&quot;%s consumed %s \n&quot;, name, pName);
}
}
}
public class StoreKeeper implements Runnable {
private Storage store;

StoreKeeper(Storage store) {
this.store = store;
}

@Override
public void run() {
Product p;
try {

while (!store.isEmpty()) {
p = store.pop();
System.out.println(&quot;left &quot; + p.getName());
}
} catch (InterruptedException e) {
e.printStackTrace();
}
}
}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class Sale {
public static void main(String args[]) throws InterruptedException {

System.out.println(&quot;Start Sale:&quot;);

Storage store = new Storage();

Producer p1 = new Producer(&quot;刘师傅 &quot;, &quot;烧饼&quot;, 4, store);
Producer p2 = new Producer(&quot;林师傅&quot;, &quot;米粉&quot;, 5, store);

Consumer c1 = new Consumer(&quot;张三&quot;, 2, store);
Consumer c2 = new Consumer(&quot;李四&quot;, 2, store);
Consumer c3 = new Consumer(&quot;王五&quot;, 2, store);

//ExecutorService service = Executors.newCachedThreadPool();
ExecutorService service = Executors.newFixedThreadPool(5);

service.submit(c1);
service.submit(c2);
service.submit(c3);
service.submit(p1);
service.submit(p2);

service.awaitTermination(5,TimeUnit.SECONDS);

StoreKeeper keeper = new StoreKeeper(store);
service.execute(keeper);

service.shutdown();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>139525</snippet_key>
<tag>12</tag>
<comment>来自CSDN博客：黑马程序员——面向对象之抽象类与接口  http://blog.csdn.net/u013217686/article/details/17764329#</comment>
<code>抽象类的定义与使用示例：
package com.itheima;

public class Abstract_Test {
public static void main(String[] args) {
Chinese showPerson = new Chinese();
showPerson.speek();
Foreigner elsePerson = new Foreigner();
elsePerson.speek();
}
}

abstract class Person {
public Person() {
System.out.println(&quot;人出生：哭.......&quot;);
}

public abstract void speek();
}

class Chinese extends Person {

public void speek() {

System.out.println(&quot;Chinese：国语&quot;);

}
}

class Foreigner extends Person {

public void speek() {

System.out.println(&quot;Foreigner：外语&quot;);

}
}
接口的使用示例：
package com.itheima;

public class Interface_Test {
public static void main(String[] args) {
Test_1 test_1 = new Test_1();
System.out.println(&quot;test_1.method_1(6)=&quot; + test_1.method_1(6));
System.out.println(&quot;test_1.method_2(4, 5)=&quot; + test_1.method_2(4, 5));
Test_2 test_2 = new Test_2();
System.out.println(&quot;test_2.method_1(6)=&quot; + test_2.method_1(6));
System.out.println(&quot;test_2.method_2(4, 5)=&quot; + test_2.method_2(4, 5));
System.out.println(&quot;Test_1.A=&quot; + Test_1.A + &quot;\n&quot; + &quot;Test_2.A=&quot;
+ Test_2.A);
}
}

interface Computable {
final int A = 300;

int method_1(int x);

int method_2(int x, int y);
}

class Test_1 implements Computable {

public int method_1(int x) {

return x + 6;

}

public int method_2(int x, int y) {

return x * y;
}

}

class Test_2 implements Computable {

public int method_1(int x) {

return x * 6;

}

public int method_2(int x, int y) {

return x * y * 6;
}

}
接口回调示例：
package com.itheima;

public class Interface_Test1 {

public static void main(String[] args) {
Display display;
display = new People();
display.speek();
display = new Monkey();
display.speek();
}

}

interface Display {
public void speek();
}

class People implements Display {

public void speek() {

System.out.println(&quot;人说：普通话&quot;);
}

}

class Monkey implements Display {

public void speek() {

System.out.println(&quot;猴子：胡吼&quot;);
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>450317</snippet_key>
<tag>android xml NULL service</tag>
<comment>来自CSDN博客：Android之LayoutInflater http://blog.csdn.net/linxcool/article/details/7313545#</comment>
<code>//方式一：通过传入context参数获得实例
LayoutInflater layoutInflater=LayoutInflater.from(Context context);
//方式二：通过传入系统服务参数获得实例
LayoutInflater layoutInflater=getSystemService(Context.LAYOUT_INFLATER_SERVICE);
//实例化布局
View view=layoutInflater.inflate(R.layout.ID, null);
</code>
</RECORD>
<RECORD>
<snippet_key>270853</snippet_key>
<tag></tag>
<comment>来自CSDN博客：黑马程序员_Java加强之类加载器与代理  http://blog.csdn.net/zhang446775867/article/details/22687663#</comment>
<code>class NetworkClassLoader extends ClassLoader {
String host;
int port;

public Class findClass(String name) {
byte[] b = loadClassData(name);
return defineClass(name, b, 0, b.length);
}

private byte[] loadClassData(String name) {
// load the class data from the connection
. . .
}
}
Class clazzPorxy1 = Proxy.getProxyClass(Collection.class.getClassLoader(), Collection.class);//创建代理的字节码
Constructor[] constructors = clazzPorxy1.getConstructors();//得到代理的所有构造方法
for(Constructor constructor:constructors){
String name =constructor.getName();//得到每个构造方法的名字
StringBuilder stringBuilder = new StringBuilder();
stringBuilder.append(name);//将构造方法名字存入stringBulider
Class[] clazzParams = constructor.getParameterTypes();//得到每个构造方法的参数列表，返回是一个Class数组
stringBuilder.append(&apos;(&apos;);//在参数列表前加入（
for(Class clazzParam:clazzParams){
stringBuilder.append(clazzParam.getName()).append(&apos;,&apos;); //获取每个参数的类型名
}
if(clazzParams!=null&amp;&amp;clazzParams.length!=0){//如果没有任何构造参数就会返回null。

stringBuilder.append(&apos;)&apos;);

}
stringBuilder.deleteCharAt(stringBuilder.length()-1);
System.out.println(stringBuilder.toString());
}
Method[] menthod = clazzPorxy1.getMethods();//得到代理的所有方法
for(Method constructor:menthod){
String name =constructor.getName();//得到每个方法的名字
StringBuilder stringBuilder = new StringBuilder();
stringBuilder.append(name);//将构造方法名字存入stringBulider
Class[] clazzParams = constructor.getParameterTypes();//得到每个方法的参数列表，返回是一个Class数组
stringBuilder.append(&apos;(&apos;);//在参数列表前加入（
for(Class clazzParam:clazzParams){
stringBuilder.append(clazzParam.getName()).append(&apos;,&apos;); //获取每个参数的类型名
}
if(clazzParams!=null&amp;&amp;clazzParams.length!=0){//如果没有任何构造参数就会返回null。
stringBuilder.deleteCharAt(stringBuilder.length()-1);

}
stringBuilder.append(&apos;)&apos;);
System.out.println(stringBuilder.toString());
Constructor constructor = clazzPorxy1.getConstructor( InvocationHandler.class);
Collection proxy = (Collection)constructor.newInstance(new InvocationHandler(){
ArrayList target = new ArrayList();
@Override
public Object invoke(Object proxy, Method method, Object[] args)
throws Throwable {
// TODO Auto-generated method stub
System.out.println(&quot;_________&quot;);
Object value = method.invoke(target,args);

return value;
}

});
</code>
</RECORD>
<RECORD>
<snippet_key>336389</snippet_key>
<tag></tag>
<comment>来自CSDN博客：fsdfsdf http://blog.csdn.net/zxx_happy_every_day/article/details/25413745#</comment>
<code>public String smbUploadFile() {
/**
* 1、在文件服务器共享tbsmSmb文件夹，权限为某个用户可以查看。
* 2、配置ftp.properties文件。
* 3、导入Jar包jcifs-1.3.16.jar
*/
HttpServletRequest request=ServletActionContext.getRequest();
try {
if(uploadFileName!=null&amp;&amp;!uploadFileName.equals(&quot;&quot;)){
String fileUrl=FileUploadFactory.getFileUpload().upload(upload,&quot;pic&quot;, uploadFileName);
request.setAttribute(&quot;fileUrl&quot;, fileUrl);
}

} catch (Exception e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
return SUCCESS;
}
</code>
</RECORD>
<RECORD>
<snippet_key>467461</snippet_key>
<tag>android ViewGroup 事件分发</tag>
<comment>来自CSDN博客：学习ViewGroup事件分发笔记（一）  http://blog.csdn.net/a425801998/article/details/39208593#</comment>
<code>public class MyLinearLayout extends LinearLayout {


&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;public MyLinearLayout(Context context, AttributeSet attrs) {
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;super(context, attrs);
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}


&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;@Override
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;public boolean onInterceptTouchEvent(MotionEvent ev) {
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;Log.e(&quot;MyLinearLayout&quot;, &quot;onInterceptTouchEvent&quot;);
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;return super.onInterceptTouchEvent(ev);
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}


&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;@Override
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;public boolean dispatchTouchEvent(MotionEvent ev) {
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;Log.e(&quot;MyLinearLayout&quot;, &quot;dispatchTouchEvent&quot;);
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;return super.dispatchTouchEvent(ev);
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}


&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;@Override
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;public boolean onTouchEvent(MotionEvent event) {
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;Log.e(&quot;MyLinearLayout&quot;, &quot;onTouchEvent&quot;);
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;return super.onTouchEvent(event);
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}


}
public class MyButton extends Button {

public MyButton(Context context, AttributeSet attrs) {
super(context, attrs);
}

@Override
public boolean dispatchTouchEvent(MotionEvent event) {
Log.e(&quot;MyButton&quot;,&quot;dispatchTouchEvent&quot;);
return super.dispatchTouchEvent(event);
}

@Override
public boolean onTouchEvent(MotionEvent event) {
Log.e(&quot;MyButton&quot;,&quot;onTouchEvent&quot;);
return super.onTouchEvent(event);
}

}
&lt;com.example.testtouch.view.MyLinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot;
android:id=&quot;@+id/ll_layout&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
&gt;

&lt;com.example.testtouch.view.MyButton
android:id=&quot;@+id/btn&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;Button&quot; /&gt;

&lt;/com.example.testtouch.view.MyLinearLayout&gt;
public class MainActivity extends ActionBarActivity {

private MyLinearLayout ll_layout;
private MyButton btn;

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

ll_layout = (MyLinearLayout) findViewById(R.id.ll_layout);
btn = (MyButton) findViewById(R.id.btn);

ll_layout.setOnTouchListener(new OnTouchListener() {

@Override
public boolean onTouch(View v, MotionEvent event) {
Log.e(&quot;MyLinearLayout&quot;,&quot;onTouch&quot;);
return false;
}
});

btn.setOnTouchListener(new OnTouchListener() {

@Override
public boolean onTouch(View v, MotionEvent event) {
Log.e(&quot;MyButton&quot;,&quot;onTouch&quot;);
return false;
}
});

}

}
/**
* {@inheritDoc}
*/
@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
if (mInputEventConsistencyVerifier != null) {
mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
}

boolean handled = false;
if (onFilterTouchEventForSecurity(ev)) {
final int action = ev.getAction();
final int actionMasked = action &amp; MotionEvent.ACTION_MASK;

// Handle an initial down.
if (actionMasked == MotionEvent.ACTION_DOWN) {
// Throw away all previous state when starting a new touch gesture.
// The framework may have dropped the up or cancel event for the previous gesture
// due to an app switch, ANR, or some other state change.
cancelAndClearTouchTargets(ev);
resetTouchState();
}

// Check for interception.
final boolean intercepted;
if (actionMasked == MotionEvent.ACTION_DOWN
|| mFirstTouchTarget != null) {
final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
if (!disallowIntercept) {
intercepted = onInterceptTouchEvent(ev);
ev.setAction(action); // restore action in case it was changed
} else {
intercepted = false;
}
} else {
// There are no touch targets and this action is not an initial down
// so this view group continues to intercept touches.
intercepted = true;
}

// Check for cancelation.
final boolean canceled = resetCancelNextUpFlag(this)
|| actionMasked == MotionEvent.ACTION_CANCEL;

// Update list of touch targets for pointer down, if needed.
final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;
TouchTarget newTouchTarget = null;
boolean alreadyDispatchedToNewTouchTarget = false;
if (!canceled &amp;&amp; !intercepted) {
if (actionMasked == MotionEvent.ACTION_DOWN
|| (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
|| actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
final int actionIndex = ev.getActionIndex(); // always 0 for down
final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)
: TouchTarget.ALL_POINTER_IDS;

// Clean up earlier touch targets for this pointer id in case they
// have become out of sync.
removePointersFromTouchTargets(idBitsToAssign);

final int childrenCount = mChildrenCount;
if (childrenCount != 0) {
// Find a child that can receive the event.
// Scan children from front to back.
final View[] children = mChildren;
final float x = ev.getX(actionIndex);
final float y = ev.getY(actionIndex);

final boolean customOrder = isChildrenDrawingOrderEnabled();
for (int i = childrenCount - 1; i &gt;= 0; i--) {
final int childIndex = customOrder ?
getChildDrawingOrder(childrenCount, i) : i;
final View child = children[childIndex];
if (!canViewReceivePointerEvents(child)
|| !isTransformedTouchPointInView(x, y, child, null)) {
continue;
}

newTouchTarget = getTouchTarget(child);
if (newTouchTarget != null) {
// Child is already receiving touch within its bounds.
// Give it the new pointer in addition to the ones it is handling.
newTouchTarget.pointerIdBits |= idBitsToAssign;
break;
}

resetCancelNextUpFlag(child);
if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
// Child wants to receive touch within its bounds.
mLastTouchDownTime = ev.getDownTime();
mLastTouchDownIndex = childIndex;
mLastTouchDownX = ev.getX();
mLastTouchDownY = ev.getY();
newTouchTarget = addTouchTarget(child, idBitsToAssign);
alreadyDispatchedToNewTouchTarget = true;
break;
}
}
}

if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) {
// Did not find a child to receive the event.
// Assign the pointer to the least recently added target.
newTouchTarget = mFirstTouchTarget;
while (newTouchTarget.next != null) {
newTouchTarget = newTouchTarget.next;
}
newTouchTarget.pointerIdBits |= idBitsToAssign;
}
}
}

// Dispatch to touch targets.
if (mFirstTouchTarget == null) {
// No touch targets so treat this as an ordinary view.
handled = dispatchTransformedTouchEvent(ev, canceled, null,
TouchTarget.ALL_POINTER_IDS);
} else {
// Dispatch to touch targets, excluding the new touch target if we already
// dispatched to it. Cancel touch targets if necessary.
TouchTarget predecessor = null;
TouchTarget target = mFirstTouchTarget;
while (target != null) {
final TouchTarget next = target.next;
if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {
handled = true;
} else {
final boolean cancelChild = resetCancelNextUpFlag(target.child)
|| intercepted;
if (dispatchTransformedTouchEvent(ev, cancelChild,
target.child, target.pointerIdBits)) {
handled = true;
}
if (cancelChild) {
if (predecessor == null) {
mFirstTouchTarget = next;
} else {
predecessor.next = next;
}
target.recycle();
target = next;
continue;
}
}
predecessor = target;
target = next;
}
}

// Update list of touch targets for pointer up or cancel, if needed.
if (canceled
|| actionMasked == MotionEvent.ACTION_UP
|| actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
resetTouchState();
} else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {
final int actionIndex = ev.getActionIndex();
final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);
removePointersFromTouchTargets(idBitsToRemove);
}
}

if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) {
mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
}
return handled;
}
/**
* Filter the touch event to apply security policies.
*
* @param event The motion event to be filtered.
* @return True if the event should be dispatched, false if the event should be dropped.
*
* @see #getFilterTouchesWhenObscured
*/
public boolean onFilterTouchEventForSecurity(MotionEvent event) {
//noinspection RedundantIfStatement
if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0
&amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) {
// Window is obscured, drop this touch.
return false;
}
return true;
}
/**
* Cancels and clears all touch targets.
*/
private void cancelAndClearTouchTargets(MotionEvent event) {
if (mFirstTouchTarget != null) {
boolean syntheticEvent = false;
if (event == null) {
final long now = SystemClock.uptimeMillis();
event = MotionEvent.obtain(now, now,
MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0);
event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
syntheticEvent = true;
}

for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) {
resetCancelNextUpFlag(target.child);
dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits);
}
clearTouchTargets();

if (syntheticEvent) {
event.recycle();
}
}
}
/**
* Resets all touch state in preparation for a new cycle.
*/
private void resetTouchState() {
clearTouchTargets();
resetCancelNextUpFlag(this);
mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;
}
/**
* Clears all touch targets.
*/
private void clearTouchTargets() {
TouchTarget target = mFirstTouchTarget;
if (target != null) {
do {
TouchTarget next = target.next;
target.recycle();
target = next;
} while (target != null);
mFirstTouchTarget = null;
}
}
// Check for interception.
final boolean intercepted;
if (actionMasked == MotionEvent.ACTION_DOWN
|| mFirstTouchTarget != null) {
final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
if (!disallowIntercept) {
intercepted = onInterceptTouchEvent(ev);
ev.setAction(action); // restore action in case it was changed
} else {
intercepted = false;
}
} else {
// There are no touch targets and this action is not an initial down
// so this view group continues to intercept touches.
intercepted = true;
}
/**
* Implement this method to intercept all touch screen motion events. This
* allows you to watch events as they are dispatched to your children, and
* take ownership of the current gesture at any point.
*
* &lt;p&gt;Using this function takes some care, as it has a fairly complicated
* interaction with {@link View#onTouchEvent(MotionEvent)
* View.onTouchEvent(MotionEvent)}, and using it requires implementing
* that method as well as this one in the correct way. Events will be
* received in the following order:
*
* &lt;ol&gt;
* &lt;li&gt; You will receive the down event here.
* &lt;li&gt; The down event will be handled either by a child of this view
* group, or given to your own onTouchEvent() method to handle; this means
* you should implement onTouchEvent() to return true, so you will
* continue to see the rest of the gesture (instead of looking for
* a parent view to handle it). Also, by returning true from
* onTouchEvent(), you will not receive any following
* events in onInterceptTouchEvent() and all touch processing must
* happen in onTouchEvent() like normal.
* &lt;li&gt; For as long as you return false from this function, each following
* event (up to and including the final up) will be delivered first here
* and then to the target&apos;s onTouchEvent().
* &lt;li&gt; If you return true from here, you will not receive any
* following events: the target view will receive the same event but
* with the action {@link MotionEvent#ACTION_CANCEL}, and all further
* events will be delivered to your onTouchEvent() method and no longer
* appear here.
* &lt;/ol&gt;
*
* @param ev The motion event being dispatched down the hierarchy.
* @return Return true to steal motion events from the children and have
* them dispatched to this ViewGroup through onTouchEvent().
* The current target will receive an ACTION_CANCEL event, and no further
* messages will be delivered here.
*/
public boolean onInterceptTouchEvent(MotionEvent ev) {
return false;
}
// Check for cancelation.
final boolean canceled = resetCancelNextUpFlag(this)
|| actionMasked == MotionEvent.ACTION_CANCEL;
final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;
if (actionMasked == MotionEvent.ACTION_DOWN
|| (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
|| actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
final int actionIndex = ev.getActionIndex(); // always 0 for down
final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)
: TouchTarget.ALL_POINTER_IDS;

// Clean up earlier touch targets for this pointer id in case they
// have become out of sync.
removePointersFromTouchTargets(idBitsToAssign);

final int childrenCount = mChildrenCount;
if (childrenCount != 0) {
// Find a child that can receive the event.
// Scan children from front to back.
final View[] children = mChildren;
final float x = ev.getX(actionIndex);
final float y = ev.getY(actionIndex);

final boolean customOrder = isChildrenDrawingOrderEnabled();
for (int i = childrenCount - 1; i &gt;= 0; i--) {
final int childIndex = customOrder ?
getChildDrawingOrder(childrenCount, i) : i;
final View child = children[childIndex];
if (!canViewReceivePointerEvents(child)
|| !isTransformedTouchPointInView(x, y, child, null)) {
continue;
}

newTouchTarget = getTouchTarget(child);
if (newTouchTarget != null) {
// Child is already receiving touch within its bounds.
// Give it the new pointer in addition to the ones it is handling.
newTouchTarget.pointerIdBits |= idBitsToAssign;
break;
}

resetCancelNextUpFlag(child);
if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
// Child wants to receive touch within its bounds.
mLastTouchDownTime = ev.getDownTime();
mLastTouchDownIndex = childIndex;
mLastTouchDownX = ev.getX();
mLastTouchDownY = ev.getY();
newTouchTarget = addTouchTarget(child, idBitsToAssign);
alreadyDispatchedToNewTouchTarget = true;
break;
}
}
}

if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) {
// Did not find a child to receive the event.
// Assign the pointer to the least recently added target.
newTouchTarget = mFirstTouchTarget;
while (newTouchTarget.next != null) {
newTouchTarget = newTouchTarget.next;
}
newTouchTarget.pointerIdBits |= idBitsToAssign;
}
}
// Dispatch to touch targets.
if (mFirstTouchTarget == null) {
// No touch targets so treat this as an ordinary view.
handled = dispatchTransformedTouchEvent(ev, canceled, null,
TouchTarget.ALL_POINTER_IDS);
} else {
// Dispatch to touch targets, excluding the new touch target if we already
// dispatched to it. Cancel touch targets if necessary.
TouchTarget predecessor = null;
TouchTarget target = mFirstTouchTarget;
while (target != null) {
final TouchTarget next = target.next;
if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {
handled = true;
} else {
final boolean cancelChild = resetCancelNextUpFlag(target.child)
|| intercepted;
if (dispatchTransformedTouchEvent(ev, cancelChild,
target.child, target.pointerIdBits)) {
handled = true;
}
if (cancelChild) {
if (predecessor == null) {
mFirstTouchTarget = next;
} else {
predecessor.next = next;
}
target.recycle();
target = next;
continue;
}
}
predecessor = target;
target = next;
}
}
if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {
handled = true;
}
/**
* Transforms a motion event into the coordinate space of a particular child view,
* filters out irrelevant pointer ids, and overrides its action if necessary.
* If child is null, assumes the MotionEvent will be sent to this ViewGroup instead.
*/
private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
View child, int desiredPointerIdBits) {
final boolean handled;

// Canceling motions is a special case. We don&apos;t need to perform any transformations
// or filtering. The important part is the action, not the contents.
final int oldAction = event.getAction();
if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
event.setAction(MotionEvent.ACTION_CANCEL);
if (child == null) {
handled = super.dispatchTouchEvent(event);
} else {
handled = child.dispatchTouchEvent(event);
}
event.setAction(oldAction);
return handled;
}

// Calculate the number of pointers to deliver.
final int oldPointerIdBits = event.getPointerIdBits();
final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;

// If for some reason we ended up in an inconsistent state where it looks like we
// might produce a motion event with no pointers in it, then drop the event.
if (newPointerIdBits == 0) {
return false;
}

// If the number of pointers is the same and we don&apos;t need to perform any fancy
// irreversible transformations, then we can reuse the motion event for this
// dispatch as long as we are careful to revert any changes we make.
// Otherwise we need to make a copy.
final MotionEvent transformedEvent;
if (newPointerIdBits == oldPointerIdBits) {
if (child == null || child.hasIdentityMatrix()) {
if (child == null) {
handled = super.dispatchTouchEvent(event);
} else {
final float offsetX = mScrollX - child.mLeft;
final float offsetY = mScrollY - child.mTop;
event.offsetLocation(offsetX, offsetY);

handled = child.dispatchTouchEvent(event);

event.offsetLocation(-offsetX, -offsetY);
}
return handled;
}
transformedEvent = MotionEvent.obtain(event);
} else {
transformedEvent = event.split(newPointerIdBits);
}

// Perform any necessary transformations and dispatch.
if (child == null) {
handled = super.dispatchTouchEvent(transformedEvent);
} else {
final float offsetX = mScrollX - child.mLeft;
final float offsetY = mScrollY - child.mTop;
transformedEvent.offsetLocation(offsetX, offsetY);
if (! child.hasIdentityMatrix()) {
transformedEvent.transform(child.getInverseMatrix());
}

handled = child.dispatchTouchEvent(transformedEvent);
}

// Done.
transformedEvent.recycle();
return handled;
}
public class MyLinearLayout extends LinearLayout {

public MyLinearLayout(Context context, AttributeSet attrs) {
super(context, attrs);
}

@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {
Log.e(&quot;MyLinearLayout&quot;, &quot;onInterceptTouchEvent&quot;);
return super.onInterceptTouchEvent(ev);
}

@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
Log.e(&quot;MyLinearLayout&quot;, &quot;dispatchTouchEvent&quot;);
return super.dispatchTouchEvent(ev);
}

@Override
public boolean onTouchEvent(MotionEvent event) {
Log.e(&quot;MyLinearLayout&quot;, &quot;onTouchEvent&quot;);
return super.onTouchEvent(event);
}

}
/**
* {@inheritDoc}
*/
public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {

if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) {
// We&apos;re already in this state, assume our ancestors are too
return;
}

if (disallowIntercept) {
mGroupFlags |= FLAG_DISALLOW_INTERCEPT;
} else {
mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;
}

// Pass it up to our parent
if (mParent != null) {
mParent.requestDisallowInterceptTouchEvent(disallowIntercept);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>319757</snippet_key>
<tag></tag>
<comment>来自CSDN博客：EJB AOP + Ehcache实现EJB方法缓存  http://blog.csdn.net/wwwwenhuan/article/details/24742039#</comment>
<code>public class CacheHandler {
//缓存管理器变量
private CacheManager manager;
//缓存变量
private Cache cache;

//缓存名称
private final String cacheName=&quot;EJB_METHOD_CACHE&quot;;
/********************************单例模式（饿汉式） begin***********************************************/

private static CacheHandler cacheHandler=new CacheHandler();

/**
* 私有构造函数
*/
private CacheHandler(){
System.out.println(&quot;---------------创建单例 begin--------------&quot;);
initCache();
System.out.println(&quot;---------------创建单例 end--------------&quot;);
}

public static CacheHandler getInstance(){
return cacheHandler;
}

/********************************单例模式（饿汉式） end***********************************************/


/**
* @MethodName : initCache
* @Description : 初始化缓存
*/
private void initCache(){
//1.创建cachemanager
URL url=getClass().getResource(&quot;/ehcache.xml&quot;);
manager=CacheManager.create(url);
cache=manager.getCache(cacheName);
//如果cache是空，則手動創建
// 当启动hibernate二级缓存时，cache为空
if(cache==null){
cache=new Cache(&quot;EJB_METHOD_CACHE&quot;, 10000, true, false, 600000, 300000);
manager.addCache(cache);
}
}


/**
* @MethodName : getCache
* @Description : 外部通过get方法拿到cache后，可清空cache
* @return
*/
public Cache getCache() {
return cache;
}

/**
* @MethodName : getCacheByName
* @Description : 根据缓存名称获取缓存
* @param cacheName 缓存名称
* @return 缓存名称对应的缓存对象
*/
public Cache getCacheByName(String cacheName){
return manager.getCache(cacheName);
}

/**
* @MethodName : clearCache
* @Description : 清理缓存
*/
public void clearCache(){
if(cache!=null){
cache.removeAll();
}
}

/**
* @MethodName : clearCacheByName
* @Description : 根据缓存名称删除缓存
* @param cacheName 缓存名称
*/
public void clearCacheByName(String cacheName){
getCacheByName(cacheName).removeAll();
}


/**
* @MethodName : addCache
* @Description : 用户自定义缓存
* @param cacheName 自定义缓存的名称
* @return 自定义的缓存
*/
public Cache addCache(String cacheName){
Cache customCache = manager.getCache(cacheName);
if(customCache==null){
customCache =new Cache(cacheName, 10000, false, false, 600000, 300000);
manager.addCache(customCache);
}
return customCache;
}

}
public class CacheInterceptor {
@AroundInvoke
public Object processCache(InvocationContext context) throws Exception{
String targetName = context.getTarget().getClass().getName();
String methodName = context.getMethod().getName();
Object[] arguments =context.getParameters();
Object result;

//获取缓存对象
Cache cache = CacheHandler.getInstance().getCache();

//如果方法名以find、query、或get开头则执行缓存策略
if(methodName.startsWith(&quot;find&quot;) || methodName.startsWith(&quot;get&quot;) || methodName.startsWith(&quot;query&quot;)){
String cacheKey = getCacheKey(targetName, methodName, arguments);
Element element = cache.get(cacheKey);
if (element == null) {
result = context.proceed(); // 执行目标方法，并保存目标方法执行后的返回值
element = new Element(cacheKey, (Serializable) result);
cache.put(element);
System.out.println(&quot;createCache--&gt;&quot; + cacheKey);
} else {
System.out.println(&quot;hit Cache--&gt;&quot; + cacheKey);
}
return element.getObjectValue();
}

//否则直接执行目标方法
return context.proceed();
}

/**
* @MethodName : getCacheKey
* @Description : 获得cache key的方法，cache key是Cache中一个Element的唯一标识 cache key包括
* 包名+类名+方法名+各个参数的具体指，如com.co.cache.service.UserServiceImpl.getAllUser
* @param targetName 类名
* @param methodName 方法名
* @param arguments 方法实参数组
* @return cachekey
*/
private String getCacheKey(String targetName, String methodName,
Object[] arguments) {
StringBuffer sb = new StringBuffer();
sb.append(targetName).append(&quot;.&quot;).append(methodName);
if ((arguments != null) &amp;&amp; (arguments.length != 0)) {
for (int i = 0; i &lt; arguments.length; i++) {
if(arguments[i] instanceof String[]){
String[] strArray = (String[])arguments[i];
sb.append(&quot;.&quot;);
for(String str : strArray){
sb.append(str);
}
}else{
sb.append(&quot;.&quot;).append(arguments[i]);
}

}
}

return sb.toString();
}

}
@Stateless
@Remote( IJcCommonBean.class)
@TransactionManagement(TransactionManagementType.CONTAINER)
@TransactionAttribute(TransactionAttributeType.REQUIRED)
@WebService(endpointInterface = &quot;mgr.jc.webservice.common.IJcCommonBean&quot;,serviceName = &quot;JcCommonService&quot;,targetNamespace = &quot;http://common.webservice.jc.mgr/&quot;)
@Interceptors(CacheInterceptor.class)
public class JcCommonBeanImpl extends BaseMgr implements IJcCommonBean {
//此处是EJB业务逻辑方法

}
public class CacheClearInterceptor {

@AroundInvoke
public Object clearCache(InvocationContext context) throws Exception{

//执行目标方法
Object returnObj =context.proceed();

/**************************清空本地缓存 begin**************************************/
System.out.println(&quot;清空前的缓存数：&quot;+CacheHandler.getInstance().getCache().getSize());
//清空本地缓存
CacheHandler.getInstance().clearCache();
System.out.println(&quot;清空后的缓存数：&quot;+CacheHandler.getInstance().getCache().getSize());
/**************************清空本地缓存 end**************************************/

return returnObj;
}

}
@Interceptors(CacheClearSyncInterceptor.class)
public void addAgency(Agency agency) {

commonEao.save(agency);

}
</code>
</RECORD>
<RECORD>
<snippet_key>402181</snippet_key>
<tag>来自CSDN博客：JAVA设计模式之享元模式 http://blog.csdn.net/jason0539/article/details/22908915#</tag>
<comment>派生自炸死特/blog_20140404_1_7698161</comment>
<code>package Flyweight;
public abstract class Flyweight{
ăpublic abstract void operation();
}
package Flyweight;
public class ConcreteFlyweight extends Flyweight{
private String string;
public ConcreteFlyweight(String str){
string = str;
}
public void operation()
{
System.out.println(&quot;Concrete---Flyweight : &quot; + string);
}
}
package Flyweight;
import java.util.Hashtable;
public class FlyweightFactory{
private Hashtable flyweights = new Hashtable();//----------------------------1
public FlyweightFactory(){}
public Flyweight getFlyWeight(Object obj){
Flyweight flyweight = (Flyweight) flyweights.get(obj);//----------------2
if(flyweight == null){//---------------------------------------------------3
//产生新的ConcreteFlyweight
flyweight = new ConcreteFlyweight((String)obj);
flyweights.put(obj, flyweight);//--------------------------------------5
}
return flyweight;//---------------------------------------------------------6
}
public int getFlyweightSize(){
return flyweights.size();
}
}
package Flyweight;
import java.util.Hashtable;
public class FlyweightPattern{
FlyweightFactory factory = new FlyweightFactory();
Flyweight fly1;
Flyweight fly2;
Flyweight fly3;
Flyweight fly4;
Flyweight fly5;
Flyweight fly6;
/** *//** Creates a new instance of FlyweightPattern */
public FlyweightPattern(){
fly1 = factory.getFlyWeight(&quot;Google&quot;);
fly2 = factory.getFlyWeight(&quot;Qutr&quot;);
fly3 = factory.getFlyWeight(&quot;Google&quot;);
fly4 = factory.getFlyWeight(&quot;Google&quot;);
fly5 = factory.getFlyWeight(&quot;Google&quot;);
fly6 = factory.getFlyWeight(&quot;Google&quot;);
}
public void showFlyweight(){
fly1.operation();
fly2.operation();
fly3.operation();
fly4.operation();
fly5.operation();
fly6.operation();
int objSize = factory.getFlyweightSize();
System.out.println(&quot;objSize = &quot; + objSize);
}
public static void main(String[] args){
System.out.println(&quot;The FlyWeight Pattern!&quot;);
FlyweightPattern fp = new FlyweightPattern();
fp.showFlyweight();
}
}
Concrete---Flyweight : Google
Concrete---Flyweight : Qutr
Concrete---Flyweight : Google
Concrete---Flyweight : Google
Concrete---Flyweight : Google
Concrete---Flyweight : Google
objSize = 2
String a = &quot;hello&quot;;
String b = &quot;hello&quot;;
if(a == b)
ăSystem.out.println(&quot;OK&quot;);
else
ăSystem.out.println(&quot;Error&quot;);
</code>
</RECORD>
<RECORD>
<snippet_key>189197</snippet_key>
<tag>java 设计模式 桥接模式</tag>
<comment>来自CSDN博客：设计模式之----------------桥接模式  http://blog.csdn.net/heminjia888/article/details/19239963#</comment>
<code>abstract class OperationSystemVersion
{
protected VideoFile vf;
public void setVideoFile(VideoFile vf)
{
this.vf=vf;
}
public abstract void play(String FileName);

}
class WindowsVersion extends OperationSystemVersion //拓充
{
public void play(String FileName)
{
vf.decode(&quot;Windows&quot;,FileName);
}
}
class LinuxVersion extends OperationSystemVersion //拓充
{
public void play(String FileName)
{
vf.decode(&quot;Linux&quot;,FileName);
}
}
class UnixVersion extends OperationSystemVersion //拓充
{
public void play(String FileName)
{
vf.decode(&quot;UNIX&quot;,FileName);
}
}

interface VideoFile
{
public void decode(String osType,String fileName);
}
class AVIFile implements VideoFile
{
public void decode(String osType, String fileName)
{
System.out.println(&quot;格式为AVI的视频文件&quot;+fileName+&quot;在&quot;+osType+&quot;平台中解码播放&quot;);
}
}
class MPGEFile implements VideoFile
{
public void decode(String osType, String fileName)
{
System.out.println(&quot;格式为MPGE的视频文件&quot;+fileName+&quot;在&quot;+osType+&quot;平台中解码播放&quot;);
}
}
class RMVBFile implements VideoFile
{
public void decode(String osType, String fileName)
{
System.out.println(&quot;格式为RMVB的视频文件&quot;+fileName+&quot;在&quot;+osType+&quot;平台中解码播放&quot;);
}

}
class WMVFile implements VideoFile
{
public void decode(String osType, String fileName)
{
System.out.println(&quot;格式为WMV的视频文件&quot;+fileName+&quot;在&quot;+osType+&quot;平台中解码播放&quot;);
}
}

class Client
{
public static void main(String args[])
{
VideoFile file;
OperationSystemVersion version;
file=new AVIFile();
version=new WindowsVersion();
version.setVideoFile(file);
version.play(&quot;让子弹飞&quot;);
}
}
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
String url = &quot;jdbc:mysql://127.0.0.1/test?useUnicode=true&amp;characterEncoding=utf-8&quot;;
String user = &quot;&quot;;
String psw = &quot;&quot;;
Connection con = DriverManager.getConnection(url,user,psw);
</code>
</RECORD>
<RECORD>
<snippet_key>320269</snippet_key>
<tag>java ssl</tag>
<comment>java ssl</comment>
<code>public class HttpsDownload {
public static void main(String[] args) {
// Get a SocketFactory object for creating SSL sockets
SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();
SSLSocket sslSocket = getSSLSocket(factory);

// Use the factory to create a secure socket connected to the HTTPS port of the specified web server.
SSLSession sslSession = sslSocket.getSession();

// Get the certificate presented by the web server
X509Certificate cert = getCertificate(sslSession);

// Display details about the certificate
System.out.println(sslSession.getPeerHost() + &quot; has presented a certificate belonging to:&quot;);
System.out.println(&quot;\t[&quot; + cert.getSubjectDN() + &quot;]&quot;);
System.out.println(&quot;The certificate bears the valid signature of:&quot;);
System.out.println(&quot;\t[&quot; + cert.getIssuerDN().getName() + &quot;]&quot;);

// If the user does not trust the certificate, abort
System.out.print(&quot;Do you trust this certificate (y/n)? &quot;);
System.out.flush();
BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
if (Character.toLowerCase(readLine(bufferedReader).charAt(0)) != &apos;y&apos;) {
return;
}

// Now use the secure socket just as you would use a regular socket
// First, send a regular HTTP request over the SSL socket
PrintWriter writer = new PrintWriter(getOutputStream(sslSocket));
writer.print(&quot;GET &quot; + &quot;xxx.html&quot; + &quot; HTTP/1.1\r\n\r\n&quot;);
writer.flush();

// Next, read the server&apos;s response and print it to the console
BufferedReader in = new BufferedReader(new InputStreamReader(getInputStream(sslSocket)));
String line;
while ((line = readLine(in)) != null) {
System.out.println(line);
}

// release resoures
try {
in.close();
} catch (IOException e) {
e.printStackTrace();
}
writer.close();
try {
bufferedReader.close();
} catch (IOException e) {
e.printStackTrace();
}
try {
sslSocket.close();
} catch (IOException e) {
e.printStackTrace();
}
}

private static SSLSocket getSSLSocket(SSLSocketFactory factory){
try {
return (SSLSocket) factory.createSocket(&quot;xxx.xxx.xxx.xx&quot;, 443);
} catch (IOException e) {
e.printStackTrace();
}
return null;
}

private static X509Certificate getCertificate(SSLSession sslSession){
try {
return (X509Certificate) sslSession.getPeerCertificates()[0];
} catch (SSLPeerUnverifiedException e) {
e.printStackTrace();
}
return null;
}

private static String readLine(BufferedReader bufferedReader){
try {
return bufferedReader.readLine();
} catch (IOException e) {
e.printStackTrace();
}
return null;
}

private static InputStream getInputStream(SSLSocket sslSocket){
try {
return sslSocket.getInputStream();
} catch (IOException e) {
e.printStackTrace();
}
return null;
}

private static OutputStream getOutputStream(SSLSocket sslSocket){
try {
return sslSocket.getOutputStream();
} catch (IOException e) {
e.printStackTrace();
}
return null;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>9477</snippet_key>
<tag>42</tag>
<comment>使用eclipse可视化开发环境visual class</comment>
<code>package com;

import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.awt.Menu;
import java.awt.MenuBar;
import java.awt.MenuItem;

import javax.swing.JDialog;
import javax.swing.JPanel;
import javax.swing.JFrame;
import javax.swing.JButton;
import java.awt.Dimension;
import javax.swing.JToolBar;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import java.awt.event.*;

import javax.swing.JCheckBox;
import javax.swing.JTextPane;
import java.awt.ComponentOrientation;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.CardLayout;
import java.awt.GridBagConstraints;
import java.awt.Dialog;
import javax.swing.JLabel;

public class SwingApp extends JFrame {

private static final long serialVersionUID = 1L;
private MenuBar mb = null;
private Menu m = null;
private MenuItem mtem = null;
private Menu subm = null; // @jve:decl-index=0:
private MenuItem submtem = null; // @jve:decl-index=0:
private JPanel jPanel1 = null;
private JButton jButton6 = null;
private JButton jButton2 = null;
private JButton jButton4 = null;
private JButton jButton3 = null;
private JButton jButton1 = null;
private JButton jButton5 = null;
private Dialog dialog1 = null; // @jve:decl-index=0:visual-constraint=&quot;551,70&quot;
private JLabel jLabel1 = null;
/**
* This is the default constructor
*/
public SwingApp() {
super();
initialize();
}

/**
* This method initializes this
*
* @return void
*/
private void initialize() {
this.setSize(440, 321);
this.setTitle(&quot;java界面设计&quot;);
this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
this.addWindowListener(new WindowAdapter() {
public void windowOpened(WindowEvent e){
System.out.println(&quot;open&quot;);
}
public void windowDeactivated(WindowEvent e){
System.out.println(&quot;使不活动&quot;);
}
public void windowActivated(WindowEvent e) {
System.out.println(&quot;活动中&quot;);
}
});
this.setLayout(new FlowLayout());
mb = new MenuBar();
m = new Menu(&quot;文件&quot;);
mtem = new MenuItem(&quot;退出&quot;);
subm = new Menu(&quot;子菜单&quot;);
submtem = new MenuItem(&quot;子条目&quot;);
this.setMenuBar(mb);
this.setContentPane(getJPanel1());
mb.add(m);
m.add(subm);
m.add(mtem);
subm.add(submtem);
//添加菜单栏的监听
mtem.addActionListener(new ActionListener() {

@Override
public void actionPerformed(ActionEvent e) {
// TODO Auto-generated method stub
System.out.println(&quot;退出&quot;);
getDialog1();
//System.exit(0);
}

});
}

/**
* This method initializes jPanel1
*
* @return javax.swing.JPanel
*/
private JPanel getJPanel1() {
if (jPanel1 == null) {
GridBagConstraints gridBagConstraints21 = new GridBagConstraints();
gridBagConstraints21.gridx = 15;
gridBagConstraints21.gridy = 0;
GridBagConstraints gridBagConstraints4 = new GridBagConstraints();
gridBagConstraints4.gridx = 11;
gridBagConstraints4.gridy = 0;
GridBagConstraints gridBagConstraints3 = new GridBagConstraints();
gridBagConstraints3.gridx = 12;
gridBagConstraints3.gridy = 0;
GridBagConstraints gridBagConstraints2 = new GridBagConstraints();
gridBagConstraints2.gridx = 9;
gridBagConstraints2.gridy = 0;
GridBagConstraints gridBagConstraints1 = new GridBagConstraints();
gridBagConstraints1.gridx = 0;
gridBagConstraints1.gridy = 0;
GridBagConstraints gridBagConstraints = new GridBagConstraints();
gridBagConstraints.gridx = 16;
gridBagConstraints.gridy = 0;
jPanel1 = new JPanel();
jPanel1.setLayout(new GridBagLayout());
jPanel1.setName(&quot;jPanel2&quot;);
jPanel1.add(getJButton6(), gridBagConstraints);
jPanel1.add(getJButton2(), gridBagConstraints2);
jPanel1.add(getJButton4(), gridBagConstraints3);
jPanel1.add(getJButton3(), gridBagConstraints4);
jPanel1.add(getJButton1(), gridBagConstraints1);
jPanel1.add(getJButton5(), gridBagConstraints21);
}
return jPanel1;
}

/**
* This method initializes jButton6
*
* @return javax.swing.JButton
*/
private JButton getJButton6() {
if (jButton6 == null) {
jButton6 = new JButton();
jButton6.setName(&quot;jButton6&quot;);
jButton6.setText(&quot;6&quot;);
jButton6.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
System.out.println(e.getActionCommand()); // TODO Auto-generated Event stub actionPerformed()
}
});
}
return jButton6;
}

/**
* This method initializes jButton2
*
* @return javax.swing.JButton
*/
private JButton getJButton2() {
if (jButton2 == null) {
jButton2 = new JButton();
jButton2.setName(&quot;jButton2&quot;);
jButton2.setText(&quot;2&quot;);
jButton2.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
System.out.println(e.getActionCommand()); // TODO Auto-generated Event stub actionPerformed()
}
});
}
return jButton2;
}

/**
* This method initializes jButton4
*
* @return javax.swing.JButton
*/
private JButton getJButton4() {
if (jButton4 == null) {
jButton4 = new JButton();
jButton4.setName(&quot;jButton4&quot;);
jButton4.setText(&quot;4&quot;);
jButton4.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
System.out.println(e.getActionCommand()); // TODO Auto-generated Event stub actionPerformed()
}
});
}
return jButton4;
}

/**
* This method initializes jButton3
*
* @return javax.swing.JButton
*/
private JButton getJButton3() {
if (jButton3 == null) {
jButton3 = new JButton();
jButton3.setName(&quot;jButton3&quot;);
jButton3.setText(&quot;3&quot;);
jButton3.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
System.out.println(e.getActionCommand()); // TODO Auto-generated Event stub actionPerformed()
}
});
}
return jButton3;
}

/**
* This method initializes jButton1
*
* @return javax.swing.JButton
*/
private JButton getJButton1() {
if (jButton1 == null) {
jButton1 = new JButton();
jButton1.setName(&quot;jButton1&quot;);
jButton1.setText(&quot;1&quot;);
jButton1.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
System.out.println(e.getActionCommand()); // TODO Auto-generated Event stub actionPerformed()
}
});
}
return jButton1;
}

/**
* This method initializes jButton5
*
* @return javax.swing.JButton
*/
private JButton getJButton5() {
if (jButton5 == null) {
jButton5 = new JButton();
jButton5.setName(&quot;jButton2&quot;);
jButton5.setText(&quot;5&quot;);
jButton5.addActionListener(new java.awt.event.ActionListener() {
public void actionPerformed(java.awt.event.ActionEvent e) {
System.out.println(e.getActionCommand()); // TODO Auto-generated Event stub actionPerformed()
}
});
}
return jButton5;
}

/**
* This method initializes dialog1
*
* @return java.awt.Dialog
*/
private Dialog getDialog1() {
if (dialog1 == null) {
jLabel1 = new JLabel();
jLabel1.setText(&quot;确定退出吗？&quot;);
dialog1 = new Dialog(this);
dialog1.setTitle(&quot;警告&quot;);
dialog1.setSize(new Dimension(183, 121));
dialog1.add(jLabel1, BorderLayout.NORTH);
dialog1.setVisible(true);
dialog1.setModal(true);
dialog1.addWindowListener(new WindowAdapter() {
public void windowClosed(WindowEvent e){
System.out.println(&quot;对话框关闭&quot;);
}
public void windowActivated(WindowEvent e){
System.out.println(&quot;对话框激活&quot;);
}
public void windowDeactivated(WindowEvent e){
dialog1.dispose();
}
});
}
return dialog1;
}

} // @jve:decl-index=0:visual-constraint=&quot;152,9&quot;
</code>
</RECORD>
<RECORD>
<snippet_key>451341</snippet_key>
<tag></tag>
<comment>来自CSDN博客：重构-重新组织函数 http://blog.csdn.net/soft53ears/article/details/38588393#</comment>
<code>int getRating() {
return (moreThanFive()) ? 2: 1;
}
boolean moreThanFive() {
return NUMBER &gt; 5;
}
</code>
</RECORD>
<RECORD>
<snippet_key>254989</snippet_key>
<tag></tag>
<comment>来自CSDN博客：第四周作业-键盘输入数据 和 数据类型。 http://blog.csdn.net/u013900749/article/details/22042023#</comment>
<code>import java.util.Scanner;


public class ComputeArea2
{
public static void main(String args[])
{
final double PI = 3.14159;
double area;
double radius = 0.0;
Scanner sc = new Scanner(System.in);
while (sc.hasNextDouble ()){
radius = sc.nextDouble ();
area = PI*radius*radius;
System.out.println(&quot;The area for the circle of 10 is&quot;+area);
}
sc.close();
area = PI*10*10;
System.out.println(&quot;The area for the circle of 10 is&quot; +area);
}
}

</code>
</RECORD>
<RECORD>
<snippet_key>337157</snippet_key>
<tag>484</tag>
<comment>来自CSDN博客：蓝桥杯——说好的进阶之砝码称重（贪心算法）  http://blog.csdn.net/hymanxq/article/details/25433989#</comment>
<code>public static void main(String[] args) {
// TODO Auto-generated method stub
Scanner scanner = new Scanner(System.in);
cal(Integer.parseInt(scanner.nextLine()));
}

static void cal(int n) {
int[] iarr = new int[] { 1, 3, 9, 27, 81 };

int[] tarr = new int[] { 1, 4, 13, 40, 121 };

int mark=0; //符号
int i;
while (n &gt; 0) {
for (i = 0; i &lt; tarr.length; i++) {
if (n &lt;= tarr[i]) {
break;
}
}
//想要什么，满足它即可
//满足
if(mark==0)
{
n -= iarr[i];
System.out.print(iarr[i]);//第一个肯定为+ 特殊处理
}
if(mark==1){
n -= iarr[i];
System.out.print(&quot;+&quot;+iarr[i]);
}
if(mark==-1)
{
n=-n+iarr[i];
System.out.print(&quot;-&quot;+iarr[i]);
}

//想要
//得到一个数之后，想要+ mark=1;
if(n&gt;0)
{
mark=1;
}
else if(n&lt;0) { //得到之后想要负数
n=-n;//大小取绝对值
mark=-1;//标记符号 想要- mark=-1;
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>386061</snippet_key>
<tag>466</tag>
<comment>算法 顺序操作 来自CSDN博客：算法4-9：BST顺序操作  http://blog.csdn.net/caipeichao2/article/details/29881213#</comment>
<code>public Key min() {
if(root == null) return null;

Node node = root;
while(node.left != null) {
node = node.left;
}
return node.key;
}

public Key max() {
if(root == null) return null;

Node node = root;
while(node.right != null) {
node = node.right;
}
return node.key;
}
public Key floor(Key key) {
return floor(root, key);
}

private Key floor(Node node, Key key) {
if(node == null) return null;
int compare = key.compareTo(node.key);

// 如果节点的值和key相等，则该节点就是floor值
if(compare == 0) return node.key;

// 如果key比该节点小，那么floor值一定在节点的左边。
if(compare &lt; 0) return floor(node.left, key);

// 如果key比该节点大，那么floor值一定在节点的右边。
Key k = floor(node.right, key);
if(k != null) return k;
return node.key;
}
class Node {
Key key;
Value value;
Node left;
Node right;
int count;
}
private int size(Node node) {
if(node == null) return 0;
else return node.count;
}
private Node put(Node parent, Key key, Value value) {
// 如果parent是空的，创建一个新的节点
if(parent == null) {
Node node = new Node();
node.key = key;
node.value = value;
node.count = 1;
return node;
}

// 递归插入
int compare = key.compareTo(parent.key);
if(compare &lt; 0) {
parent.left = put(parent.left, key, value); // 注意：返回值需要赋值给parent.left
} else if(compare &gt; 0) {
parent.right = put(parent.right, key,value);
} else {
parent.value = value;
}
parent.count = 1 + size(parent.left) + size(parent.right);
return parent;
}
public int rank(Key key) {
return rank(root, key);
}

private int rank(Node node, Key key) {
if(node == null) {
return 0;
}

int compare = key.compareTo(node.key);
if(compare &lt; 0) {
return rank(node.left, key);
} else if(compare &gt; 0) {
return size(node.left) + 1 + rank(node.right, key);
} else {
return size(node.left);
}
}
public Iterable&lt;Key&gt; inorder() {
Queue&lt;Key&gt; q = new LinkedList&lt;Key&gt;();
inorder(root, q);
return q;
}

private void inorder(Node node, Queue&lt;Key&gt; q) {
if(node == null) return;
inorder(node.left, q);
q.add(node.key);
inorder(node.right, q);
}
</code>
</RECORD>
<RECORD>
<snippet_key>255245</snippet_key>
<tag>466</tag>
<comment>来自CSDN博客：图算法 单源最短路径问题 无权最短路径 http://blog.csdn.net/ustc_summer/article/details/12384287#</comment>
<code>//无权最短路径问题的伪代码
void unweighted( Vertex s ){
//一个队列
Queue&lt;Vertex&gt; q = new Queue&lt;Vertex&gt;( );
//每个顶点初始距离为INFINITY
for each Vertex v
v.dist = INFINITY;
//s初始距离为0
s.dist = 0;
q.enqueue( s );

while( !q.isEmpty( ) ){
Vertex v = q.dequeue( );
//遍历v的邻接顶点
for each Vertex w adjacent to v
//如果dist是INFINITY说明没有处理过
if( w.dist == INFINITY ){
w.dist = v.dist + 1;
w.path = v;
q.enqueue( w );
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>337413</snippet_key>
<tag>charts LineChart xclcharts android图表库 线图</tag>
<comment>来自CSDN博客：XCL-Charts画线图(Line Chart) http://blog.csdn.net/xcltapestry/article/details/25471361#</comment>
<code>//线图基类
chart = new LineChart();
//图所占范围大小
chart.setChartRange(0, 0, this.mScrWidth , this.mScrHeight );

//标签1对应的数据集
LinkedList&lt;Double&gt; value1= new LinkedList&lt;Double&gt;();
value1.add((double)25);
value1.add((double)21);
value1.add((double)31);
value1.add((double)40);
value1.add((double)35);
//标签2对应的数据集
LinkedList&lt;Double&gt; value2= new LinkedList&lt;Double&gt;();
value2.add((double)30);
value2.add((double)42);
value2.add((double)50);
value2.add((double)50);
value2.add((double)40);

//将标签与对应的数据集分别绑定
LineData lineData1 = new LineData(&quot;小熊&quot;,(int)Color.rgb(234, 83, 71),value1);
LineData lineData2 = new LineData(&quot;小小熊&quot;,(int)Color.rgb(75, 166, 51),value2);

//标签集合
LinkedList&lt;String&gt; lables = new LinkedList&lt;String&gt;();
lables.add(&quot;2010&quot;);
lables.add(&quot;2011&quot;);
lables.add(&quot;2012&quot;);
lables.add(&quot;2013&quot;);
lables.add(&quot;2014&quot;);
chart.setLineLables(lables);

//设定数据源
LinkedList&lt;LineData&gt; chartData = new LinkedList&lt;LineData&gt;();
chartData.add(lineData1);
chartData.add(lineData2);
chart.setDataSource(chartData);

//图标题
chart.setTitle(&quot;线图(Line Chart)&quot;);
//图例
chart.setLegend(&quot;XCL-Charts&quot;);

//数据轴最大值
chart.setDataAxisMax(100);
//数据轴刻度间隔
chart.setDataAxisSteps(10);

//设置标签轴颜色
chart.getLablesAxisPaint().setColor((int)Color.rgb(22, 107, 164));
//设置数据轴颜色
chart.getDataAxisPaint().setColor((int)Color.rgb(252, 210, 9));

//显示分隔色
chart.isShowInnerLineInterval(false);
//设置分隔色
//chart.setInnerLineIntervalColor((int)Color.rgb(239, 239, 239));

//显示横向分隔网线
chart.isShowInnerHorizontalLine(true);
//显示竖向分隔网线
chart.isShowInnerVerticalLine(true);

//显示横向分隔网线颜色
chart.setInnerHorizontalLineStyle(1,(int)Color.rgb(218, 218, 218));
//显示竖向分隔网线颜色
chart.setInnerVerticalLineStyle(1,(int)Color.rgb(218, 218, 218));

//线条粗细
chart.setLineStyle(5);
//点上显示圆心
chart.setDotStyle(XTypes.LineDotStyle.Circle);
//点上圆心半径
chart.setLineDotRadius(8);
//点上显示标签
chart.isShowDotLabel(true);

//设置标签轴标签 偏移量,旋转角度
chart.setPaintStyle(XTypes.LineTextPaintType.LABLESAXIS_LABLES,10,-45f);
</code>
</RECORD>
<RECORD>
<snippet_key>451853</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Java中equals 和 == 的区别  http://blog.csdn.net/zhaizu/article/details/38556241#</comment>
<code>public boolean equals(Object obj) {
return (this == obj);
}
String foo = &quot;loveu&quot;;
String bar = &quot;loveu&quot;;
System.out.println(foo == bar); // 输出为 true
System.out.println(foo.equals(bar)); // 输出为 true

// String foo = new String(&quot;loveu&quot;);
// String bar = new String(&quot;loveu&quot;);
// System.out.println(foo == bar); // 输出为 false
// System.out.println(foo.equals(bar)); // 输出为 true
/* (non-Javadoc)
* @see java.lang.Object#hashCode()
*/
@Override
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((url == null) ? 0 : url.hashCode());
return result;
}


/* (non-Javadoc)
* @see java.lang.Object#equals(java.lang.Object)
*/
@Override
public boolean equals(Object obj) {
if (this == obj)
return true;
if (obj == null)
return false;
if (getClass() != obj.getClass())
return false;
VolatileTest other = (VolatileTest) obj;
if (url == null) {
if (other.url != null)
return false;
} else if (!url.equals(other.url))
return false;
return true;
}
/* (non-Javadoc)
* @see java.lang.Object#hashCode()
*/
@Override
public int hashCode() {
final int prime = 100;
int result = 1;
result = prime * result + ((url == null) ? 0 : url.hashCode());
return result;
}


/**
* 判断2条新闻是否相等
* @param o
* @return
*/
@Override
public boolean equals (Object o) {
if (o == null || (o instanceof News) == false) {
return false;
} else {
News n = (News) o;
return url.equals(n.getUrl());
}
}
/**
* Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element.
* More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this list contains
* at least one element &lt;tt&gt;e&lt;/tt&gt; such that
* &lt;tt&gt;(o==null ? e==null : o.equals(e))&lt;/tt&gt;.
*
* @param o element whose presence in this list is to be tested
* @return &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element
*/
public boolean contains(Object o) {
return indexOf(o) &gt;= 0;
}

/**
* Returns the index of the first occurrence of the specified element
* in this list, or -1 if this list does not contain the element.
* More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that
* &lt;tt&gt;(o==null ? get(i)==null : o.equals(get(i)))&lt;/tt&gt;,
* or -1 if there is no such index.
*/
public int indexOf(Object o) {
if (o == null) {
for (int i = 0; i &lt; size; i++)
if (elementData[i]==null)
return i;
} else {
for (int i = 0; i &lt; size; i++)
if (o.equals(elementData[i]))
return i;
}
return -1;
}
</code>
</RECORD>
<RECORD>
<snippet_key>402949</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：jdk7 中Collections.sort 异常  http://blog.csdn.net/fover717/article/details/33730343#</comment>
<code>java.lang.IllegalArgumentException: Comparison method violates its general contract!
at java.util.TimSort.mergeHi(TimSort.java:868)
at java.util.TimSort.mergeAt(TimSort.java:485)
at java.util.TimSort.mergeForceCollapse(TimSort.java:426)
at java.util.TimSort.sort(TimSort.java:223)
at java.util.TimSort.sort(TimSort.java:173)
at java.util.Arrays.sort(Arrays.java:659)
at java.util.Collections.sort(Collections.java:217)
Collections.sort(values, new Comparator&lt;Map.Entry&lt;String, Float&gt;&gt;() {
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;public int compare(Map.Entry&lt;String, Float&gt; o1, Map.Entry&lt;String, Float&gt; o2) {
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;return (o2.getValue() &gt; o1.getValue() ? 1 : -1);
}
});
Collections.sort(values, new Comparator&lt;Map.Entry&lt;String, Float&gt;&gt;() {
public int compare(Map.Entry&lt;String, Float&gt; o1, Map.Entry&lt;String, Float&gt; o2) {
return o2.getValue().compareTo(o1.getValue());
}
});
</code>
</RECORD>
<RECORD>
<snippet_key>337669</snippet_key>
<tag>326</tag>
<comment>来自CSDN博客：hibernate映射（二） 之Hibernate单项一对多映射  http://blog.csdn.net/renlei0109/article/details/25483361#</comment>
<code>package org.lei.model;

import java.io.Serializable;
import java.util.HashSet;
import java.util.Set;

public class Company implements Serializable{
private Integer id; //主键id属性变量
private String comName; //公司名称属性变量
private Set employees = new HashSet&lt;&gt;(); //雇员属性变量
public Company(){}
public Integer getId() {
return id;
}
public void setId(Integer id) {
this.id = id;
}
public String getComName() {
return comName;
}
public void setComName(String comName) {
this.comName = comName;
}
public Set getEmployees() {
return employees;
}
public void setEmployees(Set employees) {
this.employees = employees;
}

/**
* 注意要增加上面这两个方法
* 增加一个employee
* @param employee
*/
public void addEmployee(Employee employee){
employees.add(employee);
}

/**
* 删除一个employee
* @param employee
*/
public void removeEmployees(Employee employee){
employees.remove(employee);
}

}
package org.lei.model;

public class Employee {
private Integer id ;//主键id属性变量
private String name;//姓名属性变量
private Integer age;//年龄属性变量

public Employee(){}

public Integer getId() {
return id;
}

public void setId(Integer id) {
this.id = id;
}

public String getName() {
return name;
}

public void setName(String name) {
this.name = name;
}

public Integer getAge() {
return age;
}

public void setAge(Integer age) {
this.age = age;
}

}
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
&quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;
&lt;hibernate-mapping&gt;
&lt;class name =&quot;org.lei.model.Company&quot; table=&quot;company&quot;&gt;
&lt;id name=&quot;id&quot; type=&quot;java.lang.Integer&quot;&gt;
&lt;column name=&quot;id&quot;/&gt;
&lt;generator class=&quot;native&quot;/&gt;
&lt;/id&gt;

&lt;property name=&quot;comName&quot; type=&quot;java.lang.String&quot;&gt;
&lt;column name=&quot;com_name&quot; length=&quot;20&quot;&gt;&lt;/column&gt;
&lt;/property&gt;
&lt;set name =&quot;employees&quot; table=&quot;employee&quot; cascade=&quot;all&quot;&gt;
&lt;key column =&quot;com_id&quot;/&gt;
&lt;!-- 配置多对一关系映射 --&gt;
&lt;one-to-many class=&quot;org.lei.model.Employee&quot; /&gt;
&lt;/set&gt;
&lt;/class&gt;
&lt;/hibernate-mapping&gt;
&lt;span style=&quot;color:#ff0000;&quot;&gt;&lt;set name =&quot;employees&quot; table=&quot;employee&quot; cascade=&quot;all&quot;&gt;
&lt;key column =&quot;com_id&quot;/&gt;
&lt;!-- 配置多对一关系映射 --&gt;
&lt;one-to-many class=&quot;org.lei.model.Employee&quot; /&gt;
&lt;/set&gt;&lt;/span&gt;
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
&quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;
&lt;hibernate-mapping&gt;
&lt;class name =&quot;org.lei.model.Employee&quot; table=&quot;employee&quot;&gt;
&lt;id name=&quot;id&quot; type=&quot;java.lang.Integer&quot;&gt;
&lt;column name=&quot;id&quot;&gt;&lt;/column&gt;
&lt;generator class = &quot;native&quot;&gt;&lt;/generator&gt;
&lt;/id&gt;

&lt;property name =&quot;name&quot; type=&quot;java.lang.String&quot;&gt;
&lt;column name=&quot;name&quot; length=&quot;20&quot;&gt; &lt;/column&gt;
&lt;/property&gt;
&lt;property name=&quot;age&quot; type=&quot;java.lang.Integer&quot;&gt;
&lt;column name = &quot;age&quot; &gt;&lt;/column&gt;
&lt;/property&gt;
&lt;/class&gt;
&lt;/hibernate-mapping&gt;
package com.test;

import org.hibernate.HibernateException;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.lei.model.Company;
import org.lei.model.Employee;

public class TestOneToMany {
public static void main(String []args){
Configuration cfg = new Configuration().configure(&quot;hibernate.cfg.xml&quot;);
SessionFactory sessionFactory = cfg.buildSessionFactory();
Employee e1 = new Employee();
e1.setName(&quot;renlei1&quot;);
e1.setAge(23);

Employee e2 = new Employee();
e2.setName(&quot;zhang2&quot;);
e2.setAge(20);

Employee e3 = new Employee();
e3.setName(&quot;employee3&quot;);
e3.setAge(23);

Company com1 = new Company();
com1.setComName(&quot;com1&quot;);

Company com2 = new Company() ;
com2.setComName(&quot;com2&quot;);

com1.addEmployee(e1);
com1.addEmployee(e2);

com2.addEmployee(e3);

Integer pid;//定义主键变量
Session session = sessionFactory.openSession();
Transaction tx = null;

try {
tx = session.beginTransaction();///开启事务
pid = (Integer)session.save(com1);
session.save(com2);
tx.commit();
} catch (HibernateException e) {
e.printStackTrace();
tx.rollback();//遇异常用回滚事务
}finally{
session.close();
}
}
}
CREATE TABLE `company` (
`id` int(11) NOT NULL AUTO_INCREMENT,
`com_name` varchar(20) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
CREATE TABLE `employee` (
`id` int(11) NOT NULL AUTO_INCREMENT,
`name` varchar(20) DEFAULT NULL,
`age` int(11) DEFAULT NULL,
`com_id` int(11) DEFAULT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
</code>
</RECORD>
<RECORD>
<snippet_key>124685</snippet_key>
<tag>测试 junit</tag>
<comment>来自CSDN博客：javax.xml.parsers.DocumentBuilderFactory.setAttribute(Ljava/lang/String;Ljava/lang/Object;)V  http://blog.csdn.net/wyang0126/article/details/17506689#</comment>
<code>import static org.junit.Assert.assertEquals;

import java.util.List;

import javax.annotation.Resource;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.AbstractJUnit4SpringContextTests;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import cn.togo.bean.member.Account;
import cn.togo.service.member.AccountService;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { &quot;classpath:beans.xml&quot; })
public class TestDemo extends AbstractJUnit4SpringContextTests {

@Resource
private AccountService accountService;

@Test
public void test1() {
//
System.out.println(accountService.getAccountByUsername(&quot;test&quot;)
.getUsername());
// System.out.println(accountService.getAccountList());
assertEquals(&quot;test&quot;, accountService.getAccountByUsername(&quot;test&quot;)
.getUsername());
// System.out.println( accountService.getCount());
List&lt;Account&gt; accounts = accountService.getAllAccountList();
for (Account account : accounts) {
print_account(account);
}
}

/**
* print account
*
* @param account
*/
private void print_account(Account account) {
System.out.print(&quot;name:&quot; + account.getUsername());
System.out.print(&quot; id:&quot; + account.getId());
System.out.println();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>190221</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Quartz的任务的临时启动和暂停和恢复  http://blog.csdn.net/xpsharp/article/details/19289797#</comment>
<code>package com.gbsoft.rpt.qtz;

import java.util.Date;
import java.util.List;
import java.util.Map;

import org.quartz.JobDataMap;
import org.quartz.JobDetail;
import org.quartz.JobKey;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.SchedulerFactory;
import org.quartz.Trigger;
import org.quartz.TriggerKey;
import org.quartz.impl.StdSchedulerFactory;
import org.quartz.impl.matchers.GroupMatcher;

/**
* 一个简单的quartz任务管理器
* @author 123
*
*/
public class QuartzSchedule {
private static Scheduler scheduler=getScheduler();
/**
* 创建一个调度对象
* @return
* @throws SchedulerException
*/
private static Scheduler getScheduler() {
SchedulerFactory sf = new StdSchedulerFactory();
Scheduler scheduler=null;
try {
scheduler = sf.getScheduler();
} catch (SchedulerException e) {
e.printStackTrace();
}
return scheduler;
}
public static Scheduler getInstanceScheduler(){
return scheduler;
}

/**
* 启动一个调度对象
* @throws SchedulerException
*/
public void start() throws SchedulerException
{
scheduler.start();
}

/**
* 检查调度是否启动
* @return
* @throws SchedulerException
*/
public boolean isStarted() throws SchedulerException
{
return scheduler.isStarted();
}

/**
* 关闭调度信息
* @throws SchedulerException
*/
public void shutdown() throws SchedulerException {
scheduler.shutdown();
}
/**
* 添加调度的job信息
* @param jobdetail
* @param trigger
* @return
* @throws SchedulerException
*/
public Date scheduleJob(JobDetail jobdetail, Trigger trigger)
throws SchedulerException{
return scheduler.scheduleJob(jobdetail, trigger);
}
/**
* 添加相关的触发器
* @param trigger
* @return
* @throws SchedulerException
*/
public Date scheduleJob(Trigger trigger) throws SchedulerException{
return scheduler.scheduleJob(trigger);
}
/**
* 添加多个job任务
* @param triggersAndJobs
* @param replace
* @throws SchedulerException
*/
public void scheduleJobs(Map&lt;JobDetail, List&lt;Trigger&gt;&gt; triggersAndJobs, boolean replace) throws SchedulerException
{
scheduler.scheduleJobs(triggersAndJobs, replace);
}
/**
* 停止调度Job任务
* @param triggerkey
* @return
* @throws SchedulerException
*/
public boolean unscheduleJob(TriggerKey triggerkey)
throws SchedulerException{
return scheduler.unscheduleJob(triggerkey);
}

/**
* 停止调度多个触发器相关的job
* @param list
* @return
* @throws SchedulerException
*/
public boolean unscheduleJobs(List&lt;TriggerKey&gt; triggerKeylist) throws SchedulerException{
return scheduler.unscheduleJobs(triggerKeylist);
}
/**
* 重新恢复触发器相关的job任务
* @param triggerkey
* @param trigger
* @return
* @throws SchedulerException
*/
public Date rescheduleJob(TriggerKey triggerkey, Trigger trigger)
throws SchedulerException{
return scheduler.rescheduleJob(triggerkey, trigger);
}
/**
* 添加相关的job任务
* @param jobdetail
* @param flag
* @throws SchedulerException
*/
public void addJob(JobDetail jobdetail, boolean flag)
throws SchedulerException {
scheduler.addJob(jobdetail, flag);
}

/**
* 删除相关的job任务
* @param jobkey
* @return
* @throws SchedulerException
*/
public boolean deleteJob(JobKey jobkey) throws SchedulerException{
return scheduler.deleteJob(jobkey);
}

/**
* 删除相关的多个job任务
* @param jobKeys
* @return
* @throws SchedulerException
*/
public boolean deleteJobs(List&lt;JobKey&gt; jobKeys)
throws SchedulerException{
return scheduler.deleteJobs(jobKeys);
}
/**
*
* @param jobkey
* @throws SchedulerException
*/
public void triggerJob(JobKey jobkey) throws SchedulerException {
scheduler.triggerJob(jobkey);
}
/**
*
* @param jobkey
* @param jobdatamap
* @throws SchedulerException
*/
public void triggerJob(JobKey jobkey, JobDataMap jobdatamap)
throws SchedulerException {
scheduler.triggerJob(jobkey, jobdatamap);
}
/**
* 停止一个job任务
* @param jobkey
* @throws SchedulerException
*/
public void pauseJob(JobKey jobkey) throws SchedulerException {
scheduler.pauseJob(jobkey);
}
/**
* 停止多个job任务
* @param groupmatcher
* @throws SchedulerException
*/
public void pauseJobs(GroupMatcher&lt;JobKey&gt; groupmatcher)
throws SchedulerException {
scheduler.pauseJobs(groupmatcher);
}
/**
* 停止使用相关的触发器
* @param triggerkey
* @throws SchedulerException
*/
public void pauseTrigger(TriggerKey triggerkey)
throws SchedulerException {
scheduler.pauseTrigger(triggerkey);
}

public void pauseTriggers(GroupMatcher&lt;TriggerKey&gt; groupmatcher)
throws SchedulerException {
scheduler.pauseTriggers(groupmatcher);
}
/**
* 恢复相关的job任务
* @param jobkey
* @throws SchedulerException
*/
public void resumeJob(JobKey jobkey) throws SchedulerException {
scheduler.pauseJob(jobkey);
}

public void resumeJobs(GroupMatcher&lt;JobKey&gt; matcher)
throws SchedulerException {
scheduler.resumeJobs(matcher);
}

public void resumeTrigger(TriggerKey triggerkey)
throws SchedulerException {
scheduler.resumeTrigger(triggerkey);
}

public void resumeTriggers(GroupMatcher&lt;TriggerKey&gt; groupmatcher)
throws SchedulerException
{
scheduler.resumeTriggers(groupmatcher);
}
/**
* 暂停调度中所有的job任务
* @throws SchedulerException
*/
public void pauseAll() throws SchedulerException
{
scheduler.pauseAll();
}
/**
* 恢复调度中所有的job的任务
* @throws SchedulerException
*/
public void resumeAll() throws SchedulerException
{
scheduler.resumeAll();
}
}
package com.tempus.b2gs.scheduler;

import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.scheduling.quartz.CronTriggerBean;

public class SchedulerController implements ApplicationContextAware
{
private ApplicationContext context;
@Override
public void setApplicationContext(ApplicationContext context)
throws BeansException
{
this.context = context;
}

/**
* 方法描述: 更改任务时间
* 作 者： peng.xiao
* 日 期： 2014-2-16-下午4:56:04
* @param triggerName
* @param cronExper
* @throws Exception
* 返回类型： void
*/
public void changeTrigger(String triggerName, String cronExper) throws Exception
{
Scheduler scheduler = (Scheduler)this.context.getBean(&quot;startQuertz&quot;);
CronTriggerBean trigger = (CronTriggerBean)scheduler.getTrigger(triggerName, Scheduler.DEFAULT_GROUP);
trigger.setCronExpression(cronExper);
scheduler.rescheduleJob(triggerName, Scheduler.DEFAULT_GROUP, trigger);
}

/**
* 方法描述: 暂停任务
* 作 者： peng.xiao
* 日 期： 2014-2-16-下午4:56:16
* @param jobName
* @throws Exception
* 返回类型： void
*/
public void pauseJob(String jobName) throws Exception{
jobName = jobName.trim();
Scheduler scheduler = (Scheduler)this.context.getBean(&quot;startQuertz&quot;);
scheduler.pauseJob(jobName, Scheduler.DEFAULT_GROUP);
}

/**
* 方法描述: 恢复任务
* 作 者： peng.xiao
* 日 期： 2014-2-16-下午4:56:27
* @param jobName
* @throws SchedulerException
* 返回类型： void
*/
public void resumeJob(String jobName) throws SchedulerException{
Scheduler scheduler = (Scheduler)this.context.getBean(&quot;startQuertz&quot;);
scheduler.resumeJob(jobName, Scheduler.DEFAULT_GROUP);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>468997</snippet_key>
<tag>来自CSDN博客：Android4.4 4.2keyguard锁屏流程梳理 http://blog.csdn.net/look85/article/details/27204527#</tag>
<comment>派生自子路雨/blog_20140326_1_4925083</comment>
<code>/**
* @deprecated使用{@link android.view.WindowManager.LayoutParams#FLAG_DISMISS_KEYGUARD}
* and/or {@link android.view.WindowManager.LayoutParams#FLAG_SHOW_WHEN_LOCKED}
* 来代替; 利用该方式可以使应用达到禁用锁屏的效果而不需要额外的权限申请。this allows you to
* Enables you to lock or unlock thekeyboard. Get an instance of this class by
* calling {@link android.content.Context#getSystemService(java.lang.String)Context.getSystemService()}.
* This class is wrapped by {@link android.app.KeyguardManagerKeyguardManager}.
* @param tag A tag that informallyidentifies who you are (for debugging who
* is disabling he keyguard).
*
* @return A {@link KeyguardLock} handle to use todisable and reenable the
* keyguard.
*/
@Deprecated
public KeyguardLock newKeyguardLock(Stringtag) {
return new KeyguardLock(tag);
}
publicvoidsetCurrentOrientationLw(intnewOrientation){
synchronized (mLock){
if (newOrientation != mCurrentAppOrientation) {
mCurrentAppOrientation = newOrientation;
updateOrientationListenerLp();
}
}
}
privateintupdateSystemUiVisibilityLw() {
// If there is no window focused,there will be nobody to handle the events
// anyway, so just hang on inwhatever state we&apos;re in until things settle down.
WindowState win = mFocusedWindow != null ? mFocusedWindow :mTopFullscreenOpaqueWindowState;
if (win == null){
return 0;
}
if (win.getAttrs().type == TYPE_KEYGUARD&amp;&amp;mHideLockScreen == true) {
// We are updating at a pointwhere the keyguard has gotten
// focus, but we were last in astate where the top window is
// hiding it. This is probably because the keyguardas been
// shown while the top window wasdisplayed, so we want to ignore
// it here because this is just avery transient change and it
// will quickly lose focus once itcorrectly gets hidden.
return 0;
}

inttmpVisibility = win.getSystemUiVisibility()
&amp; ~mResettingSystemUiFlags
&amp; ~mForceClearedSystemUiFlags;
if (mForcingShowNavBar&amp;&amp;win.getSurfaceLayer()&lt;mForcingShowNavBarLayer) {
tmpVisibility&amp;= ~View.SYSTEM_UI_CLEARABLE_FLAGS;
}
finalint visibility = updateSystemBarsLw(win,mLastSystemUiFlags,tmpVisibility);
finalint diff = visibility ^ mLastSystemUiFlags;
finalbooleanneedsMenu = win.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
if (diff == 0 &amp;&amp;mLastFocusNeedsMenu == needsMenu
&amp;&amp;mFocusedApp ==win.getAppToken()) {
return 0;
}
mLastSystemUiFlags = visibility;
mLastFocusNeedsMenu = needsMenu;
mFocusedApp = win.getAppToken();
mHandler.post(new Runnable() {
@Override
publicvoid run() {
try {
IStatusBarServicestatusbar = getStatusBarService();
if (statusbar != null) {
statusbar.setSystemUiVisibility(visibility,0xffffffff);
statusbar.topAppWindowChanged(needsMenu);
}
} catch (RemoteException e) {
// re-acquire status bar servicenext time it is needed.
mStatusBarService = null;
}
}
});
return diff;
}
privatevoidhandleLongPressOnHome() {
if (mLongPressOnHomeBehavior != LONG_PRESS_HOME_NOTHING) {
mHomeConsumed = true;
performHapticFeedbackLw(null,HapticFeedbackConstants.LONG_PRESS, false);

if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI) {
toggleRecentApps();
} elseif (mLongPressOnHomeBehavior == LONG_PRESS_HOME_ASSIST){
launchAssistAction();
}
}
}
publicvoidsystemReady() {
if (!mHeadless){
mKeyguardDelegate = newKeyguardServiceDelegate(mContext, null);
mKeyguardDelegate.onSystemReady();
}
synchronized (mLock){
updateOrientationListenerLp();
mSystemReady = true;
mHandler.post(new Runnable() {
@Override
publicvoid run() {
updateSettings();
}
});
}
}
/**
*有关锁屏请求的调度者。包括锁屏状态的查询，power management事件影响锁屏是否应该被显示或者重置，特定的回调函数来
*通知windowmanager锁屏是什么时候显示，以及接受view视图传过来的消息表明已经成功完成解锁。
*请注意锁屏是在灭屏后立即被调用显示的。这样当你点亮屏幕，锁屏才能第一时间显示出来。
*例如外部事件调度锁屏视图流程：
*
*-灭屏动作-》重置锁屏并显示它为下次点亮屏幕做好准备。
*-锁屏很自然流畅的打开了-》如果他不是安全的，隐藏之。
*
*来自于锁屏视图的事件：
*-用户成功完成解锁条件-》隐藏锁屏视图，不再对输入事件进行拦截。
*请再注意：第三方应用通过条用power managment实例可以屏蔽系统的锁屏。
*
*线程和同步：
*该类是由WindowManagerPolicy创建并运行在它的线程里，锁屏UI也是这个类的构造函数里面产生。这个apis也可以被其他线程所调用。
*然而，这个类的方法手势同步的，同时任何一个锁屏视图都会发消息到handle来保证它是在锁屏UI线程里面执行的。
*/

public class KeyguardViewMediatorimplements KeyguardViewCallback,
KeyguardUpdateMonitor.InfoCallback,KeyguardUpdateMonitor.SimStateCallback {
private static final intKEYGUARD_DISPLAY_TIMEOUT_DELAY_DEFAULT = 30000;
/**
* This handler will be associated with the policy thread, which willalso
* be the UI thread of the keyguard. Since the apis of the policy, and therefore
* this class, can be called by other threads, any action that directly
* interacts with the keyguard ui should be posted to this handler,rather
* than called directly.
*/
private Handler mHandler = new Handler() {
@Override
public void handleMessage(Message msg) {
switch (msg.what) {
case TIMEOUT:
handleTimeout(msg.arg1);
return ;
case SHOW:
handleShow();
return ;
case HIDE:
handleHide();
return ;
case RESET:
handleReset();
return ;
case VERIFY_UNLOCK:
handleVerifyUnlock();
return;
case NOTIFY_SCREEN_OFF:
handleNotifyScreenOff();
return;
case NOTIFY_SCREEN_ON:
handleNotifyScreenOn((KeyguardViewManager.ShowListener)msg.obj);
return;
case WAKE_WHEN_READY:
handleWakeWhenReady(msg.arg1);
return;
case KEYGUARD_DONE:
handleKeyguardDone(msg.arg1!= 0);
return;
case KEYGUARD_DONE_DRAWING:
handleKeyguardDoneDrawing();
return;
caseKEYGUARD_DONE_AUTHENTICATING:
keyguardDone(true);
return;
case SET_HIDDEN:
handleSetHidden(msg.arg1 !=0);
break;
case KEYGUARD_TIMEOUT:
synchronized(KeyguardViewMediator.this) {
doKeyguardLocked();
}
break;
}
}
};
private void adjustStatusBarLocked() {
......//控制是否能在锁屏界面下拉状态栏。
}
}
/**
* Manages creating, showing, hiding andresetting the keyguard. Callsback
* via {@link KeyguardViewMediator.ViewMediatorCallback} to poke
* the wake lock and report that the keyguardis done, which is in turn,
* reported to this class by the current {@link KeyguardViewBase}.
*/
public class KeyguardViewManager {
private final static boolean DEBUG = KeyguardViewMediator.DEBUG;
private static String TAG = &quot;KeyguardViewManager&quot;;
public static boolean USE_UPPER_CASE = true;
public final static String IS_SWITCHING_USER = &quot;is_switching_user&quot;;

// Timeoutused for keypresses
static final int DIGIT_PRESS_WAKE_MILLIS = 5000;

private final Context mContext;
private final ViewManager mViewManager;
private final KeyguardViewMediator.ViewMediatorCallbackmViewMediatorCallback;

private WindowManager.LayoutParams mWindowLayoutParams;
private boolean mNeedsInput = false;

private ViewManagerHost mKeyguardHost;
private KeyguardHostView mKeyguardView;
public KeyguardHostView(Context context, AttributeSet attrs) {
super(context, attrs);

if (DEBUG) Log.e(TAG, &quot;KeyguardHostView()&quot;);

mLockPatternUtils = newLockPatternUtils(context);

// Note: This depends on KeyguardHostView getting reconstructed every timethe
// user switches, since mUserId will be used for the entire session.
// Once created, keyguard should *never* re-use this instance withanother user.
// In other words, mUserId should never change - hence it&apos;s marked final.
mUserId = mLockPatternUtils.getCurrentUser();

DevicePolicyManager dpm =
(DevicePolicyManager) mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
if (dpm != null) {
mDisabledFeatures =getDisabledFeatures(dpm);
mCameraDisabled =dpm.getCameraDisabled(null);
}

mSafeModeEnabled= LockPatternUtils.isSafeModeEnabled();

// These need to be created with the user context...
Context userContext = null;
try {
final String packageName = &quot;system&quot;;
userContext = mContext.createPackageContextAsUser(packageName,0,
new UserHandle(mUserId));

} catch (NameNotFoundException e) {
e.printStackTrace();
// This should never happen, but it&apos;s better to have no widgets than tocrash.
userContext = context;
}

mAppWidgetHost = new AppWidgetHost(userContext, APPWIDGET_HOST_ID, mOnClickHandler,
Looper.myLooper());

mAppWidgetManager =AppWidgetManager.getInstance(userContext);

mSecurityModel = new KeyguardSecurityModel(context);

mViewStateManager = newKeyguardViewStateManager(this);

}

@Override
protected void onFinishInflate() {
// Grab instances of and make any necessary changes to the main layouts.Create
// view state manager and wire up necessary listeners / callbacks.
View deleteDropTarget = findViewById(R.id.keyguard_widget_pager_delete_target);
mAppWidgetContainer =(KeyguardWidgetPager) findViewById(R.id.app_widget_container);
mAppWidgetContainer.setVisibility(VISIBLE);
mAppWidgetContainer.setCallbacks(mWidgetCallbacks);
mAppWidgetContainer.setDeleteDropTarget(deleteDropTarget);
mAppWidgetContainer.setMinScale(0.5f);

mSlidingChallengeLayout =(SlidingChallengeLayout) findViewById(R.id.sliding_layout);
if (mSlidingChallengeLayout != null) {
mSlidingChallengeLayout.setOnChallengeScrolledListener(mViewStateManager);
}
mAppWidgetContainer.setViewStateManager(mViewStateManager);
mAppWidgetContainer.setLockPatternUtils(mLockPatternUtils);

mMultiPaneChallengeLayout =
(MultiPaneChallengeLayout)findViewById(R.id.multi_pane_challenge);
ChallengeLayout challenge =mSlidingChallengeLayout != null ? mSlidingChallengeLayout :
mMultiPaneChallengeLayout;
challenge.setOnBouncerStateChangedListener(mViewStateManager);
mAppWidgetContainer.setBouncerAnimationDuration(challenge.getBouncerAnimationDuration());
mViewStateManager.setPagedView(mAppWidgetContainer);
mViewStateManager.setChallengeLayout(challenge);
mSecurityViewContainer = (KeyguardSecurityViewFlipper)findViewById(R.id.view_flipper);
mKeyguardSelectorView =(KeyguardSelectorView) findViewById(R.id.keyguard_selector_view);
mViewStateManager.setSecurityViewContainer(mSecurityViewContainer);

setBackButtonEnabled(false);

if (KeyguardUpdateMonitor.getInstance(mContext).hasBootCompleted()){
updateAndAddWidgets();
} else {
// We can&apos;t add widgets until after boot completes because AppWidgetHostmay try
// to contact the providers. Do itlater.
mPostBootCompletedRunnable = new Runnable() {
@Override
public void run() {
updateAndAddWidgets();
}
};
}

showPrimarySecurityScreen(false);
updateSecurityViews();
enableUserSelectorIfNecessary();
}
/**
*Watches for updates that may be interesting to the keyguard, and provides
*the up to date information as well as a registration for callbacks that care
* tobe updated.
*
*Note: under time crunch, this has been extended to include some stuff that
*doesn&apos;t really belong here. see {@link#handleBatteryUpdate} where it shutdowns
*the device, and {@link #getFailedAttempts()}, {@link #reportFailedAttempt()}
*and {@link #clearFailedAttempts()}. Maybe we should rename this &apos;KeyguardContext&apos;...
*/
public class KeyguardUpdateMonitor {
private Handler mHandler;
private ContentObserver mContentObserver;
private int mRingMode;
private int mPhoneState;
......

/**
* SIM卡状态改变捕获赋值。
* the intent and provide a {@link SimCard.State} result.
*/
private static class SimArgs {

public final IccCard.State simState;

private SimArgs(Intent intent) {
if(!TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(intent.getAction())) {
throw newIllegalArgumentException(&quot;only handles intentACTION_SIM_STATE_CHANGED&quot;);
}
String stateExtra = intent.getStringExtra(IccCard.INTENT_KEY_ICC_STATE);
if (IccCard.INTENT_VALUE_ICC_ABSENT.equals(stateExtra)) {
final String absentReason =intent
.getStringExtra(IccCard.INTENT_KEY_LOCKED_REASON);

if(IccCard.INTENT_VALUE_ABSENT_ON_PERM_DISABLED.equals(
absentReason)) {
this.simState =IccCard.State.PERM_DISABLED;
} else {
this.simState =IccCard.State.ABSENT;
}
} else if (IccCard.INTENT_VALUE_ICC_READY.equals(stateExtra)) {
this.simState =IccCard.State.READY;
} else if (IccCard.INTENT_VALUE_ICC_LOCKED.equals(stateExtra)) {
final String lockedReason =intent
.getStringExtra(IccCard.INTENT_KEY_LOCKED_REASON);
if (IccCard.INTENT_VALUE_LOCKED_ON_PIN.equals(lockedReason)){
this.simState =IccCard.State.PIN_REQUIRED;
} else if(IccCard.INTENT_VALUE_LOCKED_ON_PUK.equals(lockedReason)) {
this.simState = IccCard.State.PUK_REQUIRED;
} else {
this.simState =IccCard.State.UNKNOWN;
}
} else if (IccCard.INTENT_VALUE_LOCKED_NETWORK.equals(stateExtra)) {
this.simState =IccCard.State.NETWORK_LOCKED;
} else {
this.simState =IccCard.State.UNKNOWN;
}
}

public String toString() {
return simState.toString();
}
}

public KeyguardUpdateMonitor(Context context) {
mContext = context;

mHandler = new Handler() {
@Override
public void handleMessage(Message msg) {
switch (msg.what) {
case MSG_TIME_UPDATE:
handleTimeUpdate();
break;
case MSG_BATTERY_UPDATE:
handleBatteryUpdate(msg.arg1, msg.arg2);
break;
caseMSG_CARRIER_INFO_UPDATE:
handleCarrierInfoUpdate();
break;
case MSG_SIM_STATE_CHANGE:
handleSimStateChange((SimArgs) msg.obj);
break;
caseMSG_RINGER_MODE_CHANGED:
handleRingerModeChange(msg.arg1);
break;
caseMSG_PHONE_STATE_CHANGED:
handlePhoneStateChanged((String)msg.obj);
break;
caseMSG_CLOCK_VISIBILITY_CHANGED:
handleClockVisibilityChanged();
break;
caseMSG_DEVICE_PROVISIONED:
handleDeviceProvisioned();
break;
}
}
};
</code>
</RECORD>
<RECORD>
<snippet_key>141573</snippet_key>
<tag>设计模式 Adapter 适配器模式</tag>
<comment>来自CSDN博客：设计模式初探-适配器模式  http://blog.csdn.net/qbg19881206/article/details/17808463#</comment>
<code>/**
* 适配器模式根据适配器类和适配者类之间的关系可分为：
* 类适配器模式(继承关系)和对象适配器模式(关联关系)
* @author qbg
*/
public class AdapterPattern {

public static void main(String[] args) {
Adapter adapter = new Adapter();
adapter.request();
}
}

/**
* 客户端请求的目标接口。
* 由于java只能单根继承，所以此处必须使用接口。
*/
interface Target{
public void request();
}
/**
* 适配者类，提供具体的请求处理逻辑
*/
class Adaptee{
public void specificRequest(){
System.out.println(&quot;do something special...&quot;);
}
public void normalRequest(){
System.out.println(&quot;do something normal...&quot;);
}
}
/**
* 类适配器模式
* 优点：
* 1、由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法(覆盖适配者类方法)，使得适配器的灵活性更强。
* 缺点:
* 1、由于java不支持多重继承，所以一次最多只能适配一个适配者类，不能同时适配多个适配者；
* 2、适配者类不能为final类，final类不能继承；
* 3、由于java的单根继承使得类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。
*/
class Adapter extends Adaptee implements Target{

/**
* 将客户端的请求转发给适配者类，
* 此处请求转发功能通过类继承实现。
*/
@Override
public void request() {
this.specificRequest();
}

/**
* 可以覆盖适配者类的某些方法来增加灵活性。
*/
@Override
public void normalRequest() {
System.out.println(&quot;override adaptee&apos;s method...&quot;);
}

}
package study.patterns.adapter;
/**
* 适配器模式根据适配器类和适配者类之间的关系可分为：
* 类适配器模式(继承关系)和对象适配器模式(关联关系)
* @author qbg
*/
public class AdapterPattern {

public static void main(String[] args) {
Adapter adapter = new Adapter();
adapter.request();
}
}

/**
* 客户端请求的目标接口。
* 由于对象适配器模式采用的是关联适配者类而非继承，所以此处即可采用接口，也可采用抽象类。
*/
interface Target{
public void request();
}
/**
* 适配者类，提供具体的请求处理逻辑
*/
class Adaptee{
public void specificRequest(){
System.out.println(&quot;do something special...&quot;);
}
public void normalRequest(){
System.out.println(&quot;do something normal...&quot;);
}
}
/**
* 对象适配器模式
* 优点：
* 1、一个对象适配器可以把多个不同的适配者适配到同一个目标；
* 2、可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。
* 缺点:
* 1、与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。
* 如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，
* 将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。
*/
class Adapter implements Target{
private Adaptee adaptee = new Adaptee();

/**
* 将客户端的请求转发给适配者类，
* 此处请求转发功能通过类关联实现。
*/
@Override
public void request() {
adaptee.specificRequest();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>190733</snippet_key>
<tag></tag>
<comment>来自CSDN博客：android 动态加载控件  http://blog.csdn.net/nshzzu130/article/details/19324953#</comment>
<code>LayoutInflater viInflater=(LayoutInflater)getSystemService(LAYOUT_INFLATER_SERVICE);
ViewGroup view=(ViewGroup)viInflater.inflate(R.layout.testreceiver, null);
Button registButton=new Button(this);
registButton.setText(&quot;注册广播&quot;);
Button unregistButton=new Button(this);
unregistButton.setText(&quot;解除广播&quot;);
view.addView(registButton);
view.addView(unregistButton);

setContentView(view);
</code>
</RECORD>
<RECORD>
<snippet_key>403717</snippet_key>
<tag></tag>
<comment>来自CSDN博客：银行业务调度系统  http://blog.csdn.net/jiewin/article/details/9461381#</comment>
<code>package zxx.bank;

import java.util.ArrayList;
import java.util.List;

/**
* 号码管理器
* @author Administrator
*/
public class NumberManager {
//最后一次取到的业务号码
private int lastNumber = 0;
//业务号码队列--表示所有正在排队等待叫号的客户
private List&lt;Integer&gt; queueNumbers = new ArrayList&lt;Integer&gt;();

/*
下面这两个方法由两个线程操作，但两个线程访问的是相同的数据，所以要加同步
*/
/**
* 客户取号方法
* 思想：生成一个号码，就好比是来了一个客户，这个客户取到的号码是上一个客户取到的号码+1
* 这个客户取到号码后就开水在排队等待窗口叫号
* 程序：当调用这个取号方法时，取到的号码应该是上一个号码+1，比如上一个号码是5，那么这个号码就是6
* 把这个号码存入号码队列集合中。
* @return 返回上一个号码，也就是最后一个号码。
*/
public synchronized Integer generateNewNumber(){
//把号码存入号码队列中
queueNumbers.add(++lastNumber);
return lastNumber;
}

/**
* 窗口叫号方法
* 思想：当窗口叫号时，如果还有人在排队等候服务，那么就叫走最前面那个。
* 程序：如果号码队列中有号码，就移除第一个号码并返回这个号码。否则返回空。
* @return 返回号码队列中的第一个号码
*/
public synchronized Integer fetchNumber(){
if(queueNumbers.size()&gt;0){
return (Integer)queueNumbers.remove(0);
}else{
return null;
}
}
}
package zxx.bank;

/**
* 取号机器
* 思想：取号机器只有一个，所有程序应该用单例设计
* @author Administrator
*/
public class NumberMachine {
//普通窗口号码
private NumberManager commonManager = new NumberManager();
//快速窗口号码
private NumberManager expressManager = new NumberManager();
//VIP窗口号码
private NumberManager vipManager = new NumberManager();

//保证程序中只有一个NumberMachine的实例对象，用单例设计。就是银行里面只有一台取号机器
private NumberMachine(){}
//创建本类私有的实例对象，其他类就不能在创建。
private static NumberMachine instance = new NumberMachine();
/**
* 获取本类 NumberMachine 私有的实例对象 instance。
* @return 返回 NumberMachine 类的实例对象 instance
*/
public static NumberMachine getInstance(){
return instance;
}

/**
* 获取普通窗口号码
* @return 返回普通窗口号码给取号者
*/
public NumberManager getCommonManager() {
return commonManager;
}

/**
* 获取快速窗口号码
* @return 返回快速窗口号码给取号者
*/
public NumberManager getExpressManager() {
return expressManager;
}

/**
* 获取VIP窗口号码
* @return 返回VIP窗口号码给取号者
*/
public NumberManager getVipManager() {
return vipManager;
}
}
package zxx.bank;

/**
* 常量池
* @author Administrator
*/
public class Constants {
public static int MAX_SERVICE_TIME = 10000; //最大值：10秒
public static int MIN_SERVICE_TIME = 1000; //最小值：1秒

/* 每个普通窗口服务一个客户的平均时间为5秒，一共有4个这样的窗口，也就是说银行的所有普通窗口合起来
* 平均1.25秒内可以服务完一个普通客户，再加上快速窗口和VIP窗口也可以服务普通客户，所以，
* 1秒钟产生一个普通客户比较合理。*/
//普通客户取号间隔时间：1秒
public static int COMMON_CUSTOMER_INTERVAL_TIME = 1;
}
</code>
</RECORD>
<RECORD>
<snippet_key>453133</snippet_key>
<tag>214</tag>
<comment>来自CSDN博客：Gson介绍和使用  http://blog.csdn.net/leovnay/article/details/38662013#</comment>
<code>package json;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

public class Json_all {
/**
* Gson 谷歌的一个java 和 Json 解析器
* toJson() : Java 转换成 Json
* fromJson() : Json 转换成 Java
*/

public static void main(String[] args) {

Gson gson = new Gson();

// 基本数据转换
int[] numbers = { 1, 1, 2, 3, 5, 8, 13 };
String[] days = { &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot; };

String numbersJson = gson.toJson(numbers);
String daysJson = gson.toJson(days);

int[] fibonacci = gson.fromJson(numbersJson, int[].class);
String[] weekDays = gson.fromJson(daysJson, String[].class);

// map &lt;==&gt; json
Map&lt;String, String&gt; colours = new HashMap&lt;String, String&gt;();
colours.put(&quot;black&quot;, &quot;黑色&quot;);
colours.put(&quot;red&quot;, &quot;红色&quot;);
colours.put(&quot;blue&quot;, &quot;蓝色&quot;);

String coloursJson = gson.toJson(colours); //

Type type = new TypeToken&lt; Map&lt;String, String&gt; &gt;() {}.getType(); // 申明类型 Map&lt;String, String&gt;
Map&lt;String, String&gt; map = gson.fromJson(coloursJson, type);

// 单个对象 转换
Student stu = new Student(&quot;leovany&quot;, &quot;China&quot;, new Date(2000, 1, 1));

String stuJson = gson.toJson(stu);
Student student = gson.fromJson(stuJson, Student.class);

// 对象集合 转换
List&lt;Student&gt; students = new ArrayList&lt;Student&gt;();
Student a = new Student(&quot;Alice&quot;, &quot;Apple St&quot;, new Date(2014, 10, 1));
Student b = new Student(&quot;Bob&quot;, &quot;Banana St&quot;, null);
students.add(a);
students.add(b);

String studentsJson = gson.toJson(students);

Type type2 = new TypeToken&lt;List&lt;Student&gt;&gt;() {}.getType(); // 申明类型 List&lt;Student&gt;
List&lt;Student&gt; studentList = gson.fromJson(studentsJson, type2);
}

}
package json;

import java.util.Date;

public class Student {

private String name ;
private String address;
private Date dateOfBirth;

public Student(String name, String address, Date dateOfBirth) {
this.name = name;
this.address = address;
this.dateOfBirth = dateOfBirth;
}

public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
public String getAddress() {
return address;
}
public void setAddress(String address) {
this.address = address;
}

public Date getDateOfBirth() {
return dateOfBirth;
}

public void setDateOfBirth(Date dateOfBirth) {
this.dateOfBirth = dateOfBirth;
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>207365</snippet_key>
<tag>java 设计模式 建造者模式</tag>
<comment>来自CSDN博客：建造者模式--介绍、应用及代码  http://blog.csdn.net/lulin27860/article/details/20032891#</comment>
<code>//产品类--电脑
public class Computer {
private String name;
private String price;
private String type;
public void shwoComputer(){
System.out.println(&quot;名称：&quot;+name);
System.out.println(&quot;价格：&quot;+price);
System.out.println(&quot;类型：&quot;+type);
}
public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
public String getPrice() {
return price;
}
public void setPrice(String price) {
this.price = price;
}
public String getType() {
return type;
}
public void setType(String type) {
this.type = type;
}
}
//抽象建造者--组装并返回电脑的过程抽象
public abstract class Builder {
public abstract void setComputer(String name,String price,String type);
public abstract Computer getComputer();
}
//具体建造者--组装电脑的实体店1
public class BuilderShop1 extends Builder {

private Computer computer=new Computer();
@Override
public void setComputer(String name1, String price1, String type1) {
// TODO Auto-generated method stub
computer.setName(name1);
computer.setPrice(price1);
computer.setType(type1);
}

@Override
public Computer getComputer() {
// TODO Auto-generated method stub
return computer;
}

}
//具体建造者--组装电脑的实体店2
public class BuilderShop2 extends Builder {

private Computer computer=new Computer();
@Override
public void setComputer(String name2, String price2, String type2) {
// TODO Auto-generated method stub
computer.setName(name2);
computer.setPrice(price2);
computer.setType(type2);
}

@Override
public Computer getComputer() {
// TODO Auto-generated method stub
return computer;
}

}
//导演类--导购，又可以说是建造者的指挥者
public class Director {
private Builder builder1=new BuilderShop1();
private Builder builder2=new BuilderShop2();
public Computer getAComputer(){
builder1.setComputer(&quot;华硕&quot;, &quot;4000&quot;, &quot;台式&quot;);
return builder1.getComputer();
}

public Computer getBComputer(){
builder2.setComputer(&quot;戴尔&quot;, &quot;4000&quot;, &quot;笔记本&quot;);
return builder2.getComputer();
}
}
public class BuilderPattern {
/**
* @param args
*/
public static void main(String[] args) {
//进赛格电脑城找一导购
Director director=new Director();
//你说了一个价格，导购去两个店子给你组装了两台电脑
String price=&quot;4000&quot;;
Computer computer1=director.getAComputer();
computer1.shwoComputer();
Computer computer2=director.getBComputer();
computer2.shwoComputer();
//电脑配置你看完以后，参照你自己的价格标准最终选择一台
//至始至终，你跟导购其实都不关心电脑是如何组装的，你们只关心最后组装完成后的电脑是否符合你的要求
//剩下的事情就是你自己选择一台电脑了
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>191245</snippet_key>
<tag></tag>
<comment>来自CSDN博客：mina源码分析六（转）  http://blog.csdn.net/linyu19872008/article/details/19337503#</comment>
<code>private K key;
private V value;
private long lastAccessTime;
private final ReadWriteLock lastAccessTimeLock = new ReentrantReadWriteLock();
private final ConcurrentHashMap&lt;K, ExpiringObject&gt; delegate;//超时代理集合，保存待检查对象
private final CopyOnWriteArrayList&lt;ExpirationListener&lt;V&gt;&gt; expirationListeners;//超时监听者
private final Expirer expirer;//超时检查线程
private IoSessionAttributeMap attributes;//会话属性映射图
private WriteRequestQueue writeRequestQueue;//写请求队列
private WriteRequest currentWriteRequest;//当前写请求
public final CloseFuture close() {

synchronized (lock) {

if (isClosing()) {

return closeFuture;

} else {

closing = true;

}

}

getFilterChain().fireFilterClose();//fire出关闭事件

return closeFuture;

}



public final CloseFuture closeOnFlush() {

getWriteRequestQueue().offer(this, CLOSE_REQUEST);

getProcessor().flush(this);

return closeFuture;

}
public final CloseFuture close() {

synchronized (lock) {

if (isClosing()) {

return closeFuture;

} else {

closing = true;

}

}

getFilterChain().fireFilterClose();//fire出关闭事件

return closeFuture;

}



public final CloseFuture closeOnFlush() {

getWriteRequestQueue().offer(this, CLOSE_REQUEST);

getProcessor().flush(this);

return closeFuture;

}





private Queue&lt;ReadFuture&gt; getReadyReadFutures() {//返回可被读数据队列

Queue&lt;ReadFuture&gt; readyReadFutures =

(Queue&lt;ReadFuture&gt;) getAttribute(READY_READ_FUTURES_KEY);//从会话映射表中取出可被读数据队列

if (readyReadFutures == null) {//第一次读数据

readyReadFutures = new CircularQueue&lt;ReadFuture&gt;();//构造一个新读数据队列

Queue&lt;ReadFuture&gt; oldReadyReadFutures =

(Queue&lt;ReadFuture&gt;) setAttributeIfAbsent(

READY_READ_FUTURES_KEY, readyReadFutures);

if (oldReadyReadFutures != null) {

readyReadFutures = oldReadyReadFutures;

}

}

return readyReadFutures;

}



public final ReadFuture read() {//读数据

if (!getConfig().isUseReadOperation()) {//会话配置不允许读数据(这是默认情况)

throw new IllegalStateException(&quot;useReadOperation is not enabled.&quot;);

}

Queue&lt;ReadFuture&gt; readyReadFutures = getReadyReadFutures();//获取已经可被读数据队列

ReadFuture future;

synchronized (readyReadFutures) {//锁住读数据队列

future = readyReadFutures.poll();//取队头数据

if (future != null) {

if (future.isClosed()) {//关联的会话已经关闭了，让读者知道此情况

readyReadFutures.offer(future);

}

} else {

future = new DefaultReadFuture(this);

getWaitingReadFutures().offer(future); //将此数据插入等待被读取数据的队列，这个代码和上面的getReadyReadFutures类似，只是键值不同而已



}

}

return future;

}
public final WriteFuture write(Object message, SocketAddress remoteAddress) {

FileChannel openedFileChannel = null;

try

{

if (message instanceof IoBuffer&amp;&amp; !((IoBuffer) message).hasRemaining())

{// 空消息

throw new IllegalArgumentException(

&quot;message is empty. Forgot to call flip()?&quot;);

}

else if (message instanceof FileChannel)

{//要发送的是文件的某一区域

FileChannel fileChannel = (FileChannel) message;

message = new DefaultFileRegion(fileChannel, 0, fileChannel.size());

}

else if (message instanceof File)

{//要发送的是文件,打开文件通道

File file = (File) message;

openedFileChannel = new FileInputStream(file).getChannel();

message = new DefaultFileRegion(openedFileChannel, 0, openedFileChannel.size());

}

}

catch (IOException e)

{

ExceptionMonitor.getInstance().exceptionCaught(e);

return DefaultWriteFuture.newNotWrittenFuture(this, e);

}

WriteFuture future = new DefaultWriteFuture(this);

getFilterChain().fireFilterWrite(

new DefaultWriteRequest(message, future, remoteAddress)); //构造写请求,通过过滤器链发送出去，写请求中指明了要发送的消息，目的地址，以及返回的结果



//如果打开了一个文件通道（发送的文件的部分区域或全部），就必须在写请求完成时关闭文件通道

if (openedFileChannel != null) {

final FileChannel finalChannel = openedFileChannel;

future.addListener(new IoFutureListener&lt;WriteFuture&gt;() {

public void operationComplete(WriteFuture future) {

try {

finalChannel.close();//关闭文件通道

} catch (IOException e) {

ExceptionMonitor.getInstance().exceptionCaught(e);

}

}

});

}

return future;//写请求成功完成

}
private class CloseRequestAwareWriteRequestQueue implements WriteRequestQueue {

private final WriteRequestQueue q;//内部实际的写请求队列

public CloseRequestAwareWriteRequestQueue(WriteRequestQueue q) {

this.q = q;

}

public synchronized WriteRequest poll(IoSession session) {

WriteRequest answer = q.poll(session);

if (answer == CLOSE_REQUEST) {

AbstractIoSession.this.close();

dispose(session);

answer = null;

}

return answer;

}

public void offer(IoSession session, WriteRequest e) {

q.offer(session, e);

}

public boolean isEmpty(IoSession session) {

return q.isEmpty(session);

}

public void clear(IoSession session) {

q.clear(session);

}

public void dispose(IoSession session) {

q.dispose(session);

}

}
</code>
</RECORD>
<RECORD>
<snippet_key>469509</snippet_key>
<tag>android ScaleType SpannableStringBuild foreground</tag>
<comment>来自CSDN博客：Android开发之杂记(2) http://blog.csdn.net/MiniMicall/article/details/39314513#</comment>
<code>String param = &quot;abc&quot; ;
String text = param + &quot;dfdjkfjdkfjdfjdkf&quot; ;

SpannableStringBuilder ss = new SpannableStringBuilder(text);
ss.setSpan(new StyleSpan(Typeface.BOLD),0, param.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
ss.setSpan(new AbsoluteSizeSpan(30,true), 0, param.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
ss.setSpan(new AbsoluteSizeSpan(16,true), param.length(), text.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
textView.setText(ss);
</code>
</RECORD>
<RECORD>
<snippet_key>125965</snippet_key>
<tag>466</tag>
<comment>递归 recursion 算法 java算法 来自CSDN博客：递归  http://blog.csdn.net/zhong1113/article/details/17527387#</comment>
<code>public class RecursionDemo { //éĺ˝
public static int getsum(int a){
if (a==1)
return 1;
return a+getsum(a-1);
}
public static void main(String[] args) {
int a=getsum(5);
System.out.println(&quot;a=&quot;+a);
}
}
a=15
Exception in thread &quot;main&quot; java.lang.StackOverflowError
</code>
</RECORD>
<RECORD>
<snippet_key>469765</snippet_key>
<tag>453</tag>
<comment>来自CSDN博客：Leecode-Linked List Cycle  http://blog.csdn.net/lsp1991/article/details/39319571#</comment>
<code>Given a linked list, determine if it has a cycle in it.

Follow up:
Can you solve it without using extra space?
package Leecode;

import java.util.HashSet;
import java.util.Set;


class ListNode {
int val;
ListNode next;
ListNode(int x) {
val = x;
next = null;
}
}

/*
*
URL: https://oj.leetcode.com/problems/linked-list-cycle/
*/
public class LinkedListCycle {
//空间O(1),时间O(n^2)
public boolean hasCycle(ListNode head) {
boolean b = false;
ListNode p = head, q = head;

if (head != null) {
while (q != null &amp;&amp; q.next!=null) {
q = q.next.next;
p = p.next;

if (q == p){
b = true;
break;
}
}
}
return b;
}

//hash,空间O（n），时间O(n)
public boolean hasCycle2(ListNode head) {
boolean b =false;
Set&lt;ListNode&gt;set = new HashSet&lt;ListNode&gt;();
while(head != null){
if(set.contains(head)){
b = true;
break;
}else{
set.add(head);
head = head.next;
}
}
return b;
}
public static void main(String[] args) {

}

}
</code>
</RECORD>
<RECORD>
<snippet_key>322573</snippet_key>
<tag></tag>
<comment>来自CSDN博客：[HDOJ1042] N! [java大数]  http://blog.csdn.net/jinzhao1994/article/details/24848297#</comment>
<code>import java.math.BigInteger;
import java.util.Scanner;
public class Main {
/**
* @param args
*/
public static void main(String[] args) {
// TODO Auto-generated method stub
Scanner cin=new Scanner(System.in);
while (cin.hasNextInt()) {
BigInteger ans=BigInteger.ONE;
int n=cin.nextInt();
for (int i=2;i&lt;=n;i++) {
ans=ans.multiply(BigInteger.valueOf(i));
}
System.out.println(ans);
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>404485</snippet_key>
<tag></tag>
<comment>来自CSDN博客：切分句子（非正则） http://blog.csdn.net/nocml/article/details/18700853#</comment>
<code>/**
* @function
* @param source 待分句的句子
* @param div 分隔符
* @param include 结果中是否包含分隔符
* @return
*/
public static String[] split(String source, String div, boolean include) {

StringTokenizer tokens = new StringTokenizer(source, div, include);
String[] result = new String[tokens.countTokens()];
int i = 0;
while (tokens.hasMoreTokens()) {
result[i++] = tokens.nextToken();
}
return result;
}
</code>
</RECORD>
<RECORD>
<snippet_key>11525</snippet_key>
<tag>java</tag>
<comment>这里提供4中方法。</comment>
<code>
一、纯Java实现ICMP的ping命令
import java.io.*;
import java.net.*;
import java.nio.channels.*;
import java.util.*;
import java.util.regex.*;
public class Ping {
static int DAYTIME_PORT = 13;
static int port = DAYTIME_PORT;
static class Target {
InetSocketAddress address;
SocketChannel channel;
Exception failure;
long connectStart;
long connectFinish = 0;
boolean shown = false;
Target(String host) {
try {
address = new InetSocketAddress(InetAddress.getByName(host),
port);
} catch (IOException x) {
failure = x;
}
}
void show() {
String result;
if (connectFinish != 0)
result = Long.toString(connectFinish - connectStart) + &quot;ms&quot;;
else if (failure != null)
result = failure.toString();
else
result = &quot;Timed out&quot;;
System.out.println(address + &quot; : &quot; + result);
shown = true;
}
}
static class Printer extends Thread {
LinkedList pending = new LinkedList();
Printer() {
setName(&quot;Printer&quot;);
setDaemon(true);
}
void add(Target t) {
synchronized (pending) {
pending.add(t);
pending.notify();
}
}
public void run() {
try {
for (;;) {
Target t = null;
synchronized (pending) {
while (pending.size() == 0)
pending.wait();
t = (Target) pending.removeFirst();
}
t.show();
}
} catch (InterruptedException x) {
return;
}
}
}
static class Connector extends Thread {
Selector sel;
Printer printer;
LinkedList pending = new LinkedList();
Connector(Printer pr) throws IOException {
printer = pr;
sel = Selector.open();
setName(&quot;Connector&quot;);
}
void add(Target t) {
SocketChannel sc = null;
try {
sc = SocketChannel.open();
sc.configureBlocking(false);
boolean connected = sc.connect(t.address);
t.channel = sc;
t.connectStart = System.currentTimeMillis();
if (connected) {
t.connectFinish = t.connectStart;
sc.close();
printer.add(t);
} else {
synchronized (pending) {
pending.add(t);
}
sel.wakeup();
}
} catch (IOException x) {
if (sc != null) {
try {
sc.close();
} catch (IOException xx) {
}
}
t.failure = x;
printer.add(t);
}
}
void processPendingTargets() throws IOException {
synchronized (pending) {
while (pending.size() &gt; 0) {
Target t = (Target) pending.removeFirst();
try {
t.channel.register(sel, SelectionKey.OP_CONNECT, t);
} catch (IOException x) {
t.channel.close();
t.failure = x;
printer.add(t);
}
}
}
}
void processSelectedKeys() throws IOException {
for (Iterator i = sel.selectedKeys().iterator(); i.hasNext();) {
SelectionKey sk = (SelectionKey) i.next();
i.remove();
Target t = (Target) sk.attachment();
SocketChannel sc = (SocketChannel) sk.channel();
try {
if (sc.finishConnect()) {
sk.cancel();
t.connectFinish = System.currentTimeMillis();
sc.close();
printer.add(t);
}
} catch (IOException x) {
sc.close();
t.failure = x;
printer.add(t);
}
}
}
volatile boolean shutdown = false;
void shutdown() {
shutdown = true;
sel.wakeup();
}
public void run() {
for (;;) {
try {
int n = sel.select();
if (n &gt; 0)
processSelectedKeys();
processPendingTargets();
if (shutdown) {
sel.close();
return;
}
} catch (IOException x) {
x.printStackTrace();
}
}
}
}
public static void main(String[] args) throws InterruptedException,
IOException {
args = new String[] { &quot;8888&quot;, &quot;192.168.10.193&quot; };
if (args.length &lt; 1) {
System.err.println(&quot;Usage: java Ping [port] host...&quot;);
return;
}
int firstArg = 0;
if (Pattern.matches(&quot;[0-9]+&quot;, args[0])) {
port = Integer.parseInt(args[0]);
firstArg = 1;
}
Printer printer = new Printer();
printer.start();
Connector connector = new Connector(printer);
connector.start();
LinkedList targets = new LinkedList();
for (int i = firstArg; i &lt; args.length; i++) {
Target t = new Target(args[i]);
targets.add(t);
connector.add(t);
}
Thread.sleep(2000);
connector.shutdown();
connector.join();
for (Iterator i = targets.iterator(); i.hasNext();) {
Target t = (Target) i.next();
if (!t.shown)
t.show();
}
}
}
二、JAVA调用外部EXE实现PING功能

import java.io.*;
import java.lang.*;

public class Ping {


public Ping() {
}
public static void main(String args[])
{
if (args.length &lt; 1)
{
System.out.println(&quot;syntax Error!&quot;);
}
else
{
String line = null;
try
{
Process pro = Runtime.getRuntime().exec(&quot;ping &quot; + args[0]);
BufferedReader buf = new BufferedReader(new InputStreamReader(pro.getInputStream()));
while((line = buf.readLine()) != null)
System.out.println(line);
}
catch(Exception ex)
{
System.out.println(ex.getMessage());
}
}

}
}
三、ICMP Ping in Java(JDK 1.5 and above)
Programatically using ICMP Ping is a great way to establish that a server is up and running. Previously you couldn&apos;t do ICMP ping (what ping command does in Linux/Unix &amp; Windows) in java without using JNI or exec calls. Here is a simple and reliable method to do ICMP pings in Java without using JNI or NIO.

String host = &quot;172.16.0.2&quot;
int timeOut = 3000; // I recommend 3 seconds at least
boolean status = InetAddress.getByName(host).isReachable(timeOut)

status is true if the machine is reachable by ping; false otherwise. Best effort is made to try to reach the host, but firewalls and server configuration may block requests resulting in a unreachable status while some specific ports may be accessible. A typical implementation will use ICMP ECHO REQUESTs if the privilege can be obtained, otherwise it will try to establish a TCP connection on port 7 (Echo) of the destination host.
In Linux/Unix you may have to suid the java executable to get ICMP Ping working, ECHO REQUESTs will be fine even without suid. However on Windows you can get ICMP Ping without any issues whatsoever.
四、最简单的办法，直接调用CMD
try
{
Runtime.getRuntime().exec(&quot;cmd /c start ping 127.0.0.1&quot;);
}
catch (Exception ex)
{
System.out.println(ex.getMessage());
}
ping的过程可以显示在本地的办法
import java.io.*;
public class Ping
{
public static void main(String args[])
{
String line = null;
try
{
Process pro = Runtime.getRuntime().exec(&quot;ping 127.0.0.1 &quot;);
BufferedReader buf = new BufferedReader(new InputStreamReader(pro.getInputStream()));
while ((line = buf.readLine()) != null)
System.out.println(line);
}
catch (Exception ex)
{
System.out.println(ex.getMessage());
}
}
}
五、模拟PING
利用InetAddress的isReachable方法可以实现ping的功能，里面参数设定超时时间，返回结果表示是否连上
try {
InetAddress address = InetAddress.getByName(&quot;192.168.0.113&quot;);
System.out.println(address.isReachable(5000));
} catch (UnknownHostException e) {
e.printStackTrace();
} catch (IOException e) {
e.printStackTrace();
}
六、模拟TELNET
利用Socket的connect(SocketAddress endpoint, int timeout)方法可以实现telnet的功能，如果catch到异常说明telnet失败
try {
Socket server = new Socket();
InetSocketAddress address = new InetSocketAddress(&quot;192.168.0.113&quot;,
8080);
server.connect(address, 5000);
server.close();
} catch (UnknownHostException e){
System.out.println(&quot;telnet失败&quot;);
} catch (IOException e){
System.out.println(&quot;telnet失败&quot;);
}



实现ping命令 并且根据返回值判断是否ping通。

BufferedReader in = null;
StringBuffer sb = new StringBuffer();
try {
// 执行命令并获取输出
Process p = Runtime.getRuntime().exec(
&quot;cmd /c ping &quot; + ip+&quot; -n &quot;+pingTimes+&quot; -w &quot;+timeOut);
if (p == null) {
return false;
}
in = new BufferedReader(new InputStreamReader(p.getInputStream()));
// 逐行检测输出,计算类似=23ms TTL=62这样的字样出现的次数
int connectedCount = 0;
String line =&quot;&quot;;
while ((line=in.readLine())!= null) {
sb.append(line+&quot;\t\n&quot;);
connectedCount += getCheckResult(line);
}
p.waitFor();
if(connectedCount==0){
return false;
}
return sb.toString().indexOf(&quot;100% loss&quot;)==-1;
} catch (Exception ex) {
ex.printStackTrace();
// 出现异常则返回假
return false;
} finally {
try {
in.close();
} catch (IOException e) {
e.printStackTrace();
}
}

public static int getCheckResult(String line) {
Pattern pattern = Pattern.compile(&quot;(=\\d+ms)(\\s+)(TTL=\\d+)&quot;,
Pattern.CASE_INSENSITIVE);
Matcher matcher = pattern.matcher(line);
while (matcher.find()) {
return 1;
}
return 0;
}
</code>
</RECORD>
<RECORD>
<snippet_key>273669</snippet_key>
<tag>457</tag>
<comment>来自CSDN博客：java提高篇（二五）-----HashTable http://blog.csdn.net/chenssy/article/details/22896871#</comment>
<code>public Hashtable(int initialCapacity) {
this(initialCapacity, 0.75f);
}
</code>
</RECORD>
<RECORD>
<snippet_key>60941</snippet_key>
<tag>动画</tag>
<comment>1.设置适配器ImageAdapter时要实现BaseAdapter的四个方法。2.当每次拖动画面时，会调用getView和getItemId方法。</comment>
<code>public void onCreate(Bundle savedInstanceState)
{
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
mTextView01 = (TextView) findViewById(R.id.myTextView01);
mTextView01.setText(getString(R.string.str_txt1));
mTextView01.setTextColor(Color.BLUE);
((Gallery) findViewById(R.id.myGallery1))
.setAdapter(new ImageAdapter(this));
}

public class ImageAdapter extends BaseAdapter
{ /* 类成员 myContext为Context父类 */

private Context myContext; /* 使用android.R.drawable里的图片作为图库来源，类型为整数数组 */
private int[] myImageIds =
{
android.R.drawable.btn_minus, android.R.drawable.btn_radio,
android.R.drawable.ic_lock_idle_low_battery,
android.R.drawable.ic_menu_camera
}; /* 建构子只有一个参数，即要储存的Context */

public ImageAdapter(Context c)
{
this.myContext = c;
Log.i(TAG,&quot;c = &quot; + c.getClass());
} /* 回传所有已定义的图片总数量 */

public int getCount()
{
Log.i(TAG,&quot;1111111111111&quot;);
return this.myImageIds.length;
} /* 利用getItem方法，取得目前容器中影像的数组ID */

public Object getItem(int position)
{
Log.i(TAG,&quot;position = &quot; + position);
return position;
}

public long getItemId(int position)
{
Log.i(TAG,&quot;position2 = &quot; + position);
return position;
} /* 取得目前欲显示的影像View，传入数组ID值使之读取与成像 */

public View getView(int position, View convertView, ViewGroup parent)
{ /* 建立一个ImageView对象 */
Log.i(TAG,&quot;22222222222222&quot;);
ImageView i = new ImageView(this.myContext);
i.setImageResource(this.myImageIds[position]);
i.setScaleType(ImageView.ScaleType.FIT_XY); /* 设定这个ImageView对象的宽高，单位为dip */
i.setLayoutParams(new Gallery.LayoutParams(120, 120));
return i;
}


}
</code>
</RECORD>
<RECORD>
<snippet_key>323085</snippet_key>
<tag></tag>
<comment>来自CSDN博客：【LeetCode】Remove Element http://blog.csdn.net/Mars_NAVY/article/details/24867137#</comment>
<code>public class Solution {
public int removeElement(int[] A, int elem) {
int num=0;
int len=A.length;
for(int i=0;i&lt;len;i++){
if(A[i]!=elem)
A[num++]=A[i];
}
return num;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>142853</snippet_key>
<tag>android 单片机 蓝牙</tag>
<comment>来自CSDN博客：android开发之手机与单片机蓝牙模块通信  http://blog.csdn.net/jason0539/article/details/17880071#</comment>
<code>private void search() {
BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
if (!adapter.isEnabled()) {
adapter.enable();
}
Intent enable = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
enable.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 3600); //3600为蓝牙设备可见时间
startActivity(enable);
Intent searchIntent = new Intent(this, ComminuteActivity.class);
startActivity(searchIntent);
}
public class ComminuteActivity extends Activity {
private BluetoothReceiver receiver;
private BluetoothAdapter bluetoothAdapter;
private List&lt;String&gt; devices;
private List&lt;BluetoothDevice&gt; deviceList;
private Bluetooth client;
private final String lockName = &quot;YESYOU&quot;;
private String message = &quot;000001&quot;;
private ListView listView;

@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.search_layout);

listView = (ListView) this.findViewById(R.id.list);
deviceList = new ArrayList&lt;BluetoothDevice&gt;();
devices = new ArrayList&lt;String&gt;();
bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
bluetoothAdapter.startDiscovery();
IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);
receiver = new BluetoothReceiver();
registerReceiver(receiver, filter);

listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
@Override
public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
setContentView(R.layout.connect_layout);
BluetoothDevice device = deviceList.get(position);
client = new Bluetooth(device, handler);
try {
client.connect(message);
} catch (Exception e) {
Log.e(&quot;TAG&quot;, e.toString());
}
}
});
}

@Override
protected void onDestroy() {
unregisterReceiver(receiver);
super.onDestroy();
}

private final Handler handler = new Handler() {
@Override
public void handleMessage(Message msg) {
switch (msg.what) {
case Bluetooth.CONNECT_FAILED:
Toast.makeText(ComminuteActivity.this, &quot;连接失败&quot;, Toast.LENGTH_LONG).show();
try {
client.connect(message);
} catch (Exception e) {
Log.e(&quot;TAG&quot;, e.toString());
}
break;
case Bluetooth.CONNECT_SUCCESS:
Toast.makeText(ComminuteActivity.this, &quot;连接成功&quot;, Toast.LENGTH_LONG).show();
break;
case Bluetooth.READ_FAILED:
Toast.makeText(ComminuteActivity.this, &quot;读取失败&quot;, Toast.LENGTH_LONG).show();
break;
case Bluetooth.WRITE_FAILED:
Toast.makeText(ComminuteActivity.this, &quot;写入失败&quot;, Toast.LENGTH_LONG).show();
break;
case Bluetooth.DATA:
Toast.makeText(ComminuteActivity.this, msg.arg1 + &quot;&quot;, Toast.LENGTH_LONG).show();
break;
}
}
};

private class BluetoothReceiver extends BroadcastReceiver {
@Override
public void onReceive(Context context, Intent intent) {
String action = intent.getAction();
if (BluetoothDevice.ACTION_FOUND.equals(action)) {
BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
if (isLock(device)) {
devices.add(device.getName());
}
deviceList.add(device);
}
showDevices();
}
}

private boolean isLock(BluetoothDevice device) {
boolean isLockName = (device.getName()).equals(lockName);
boolean isSingleDevice = devices.indexOf(device.getName()) == -1;
return isLockName &amp;&amp; isSingleDevice;
}

private void showDevices() {
ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1,
devices);
listView.setAdapter(adapter);
}
}
public void connect(final String message) {
Thread thread = new Thread(new Runnable() {
public void run() {
BluetoothSocket tmp = null;
Method method;
try {
method = device.getClass().getMethod(&quot;createRfcommSocket&quot;, new Class[]{int.class});
tmp = (BluetoothSocket) method.invoke(device, 1);
} catch (Exception e) {
setState(CONNECT_FAILED);
Log.e(&quot;TAG&quot;, e.toString());
}
socket = tmp;
try {
socket.connect();
isConnect = true;
} catch (Exception e) {
setState(CONNECT_FAILED);
Log.e(&quot;TAG&quot;, e.toString());
}
if (isConnect) {
try {
OutputStream outStream = socket.getOutputStream();
outStream.write(getHexBytes(message));
} catch (IOException e) {
setState(WRITE_FAILED);
Log.e(&quot;TAG&quot;, e.toString());
}
try {
InputStream inputStream = socket.getInputStream();
int data;
while (true) {
try {
data = inputStream.read();
Message msg = handler.obtainMessage();
msg.what = DATA;
msg.arg1 = data;
handler.sendMessage(msg);
} catch (IOException e) {
setState(READ_FAILED);
Log.e(&quot;TAG&quot;, e.toString());
break;
}
}
} catch (IOException e) {
setState(WRITE_FAILED);
Log.e(&quot;TAG&quot;, e.toString());
}
}

if (socket != null) {
try {
socket.close();
} catch (IOException e) {
Log.e(&quot;TAG&quot;, e.toString());
}
}
}
}
private byte[] getHexBytes(String message) {
int len = message.length() / 2;
char[] chars = message.toCharArray();
String[] hexStr = new String[len];
byte[] bytes = new byte[len];
for (int i = 0, j = 0; j &lt; len; i += 2, j++) {
hexStr[j] = &quot;&quot; + chars[i] + chars[i + 1];
bytes[j] = (byte) Integer.parseInt(hexStr[j], 16);
}
return bytes;
}
</code>
</RECORD>
<RECORD>
<snippet_key>339461</snippet_key>
<tag>装饰者模式</tag>
<comment>来自CSDN博客：设计模式之装饰者模式  http://blog.csdn.net/chen610/article/details/25554923#</comment>
<code>public abstract class InputStream implements Closeable {}
public
class FilterInputStream extends InputStream {
/**
* The input stream to be filtered.
*/
protected volatile InputStream in;

/**
* Creates a &lt;code&gt;FilterInputStream&lt;/code&gt;
* by assigning the argument &lt;code&gt;in&lt;/code&gt;
* to the field &lt;code&gt;this.in&lt;/code&gt; so as
* to remember it for later use.
*
* @param in the underlying input stream, or &lt;code&gt;null&lt;/code&gt; if
* this instance is to be created without an underlying stream.
*/
protected FilterInputStream(InputStream in) {
this.in = in;
}
}
public
class DataInputStream extends FilterInputStream implements DataInput {

/**
* Creates a DataInputStream that uses the specified
* underlying InputStream.
*
* @param in the specified input stream
*/
public DataInputStream(InputStream in) {
super(in);
}
}
public class Decorator {
public static void main(String[] args) {
InputStream in = System.in;
InputStream ins = new DataInputStream(in);
ins = new BufferedInputStream(ins);
ins = new PushbackInputStream(ins);
ins = new LineNumberInputStream(ins);
//然后现在的这个ins就具有经过修饰的输入流中的功能了
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>192269</snippet_key>
<tag></tag>
<comment>来自CSDN博客：apktool反编译资源时出现CastException的一则解决方法  http://blog.csdn.net/lzf_china/article/details/19371425#</comment>
<code>&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;package brut.androlib.res.data.value;
public class ResStyleValue extends ResBagValue implements
ResValuesXmlSerializable {
@Override
public void serializeToResValuesXml(XmlSerializer serializer,
ResResource res) throws IOException, AndrolibException {
...
if (spec.getDefaultResource().getValue().toString()
.contains(&quot;ResStyleValue@&quot;)) {
ResStyleValue subitem = (ResStyleValue) spec.getDefaultResource().getValue();
if( subitem.mItems.length&gt;0 ) {
spec = subitem.mItems[0].m1.getReferent();
}
else{
continue;
}
}
public class ResStyleValue extends ResBagValue implements
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;ResValuesXmlSerializable {
@Override
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;public void serializeToResValuesXml(XmlSerializer serializer,
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;ResResource res) throws IOException, AndrolibException {
...
if (spec.getDefaultResource().getValue().toString()
.contains(&quot;ResStyleValue@&quot;)) {
ResStyleValue subitem = (ResStyleValue) spec.getDefaultResource().getValue();
if( subitem.mItems.length&gt;0 ) {
spec = subitem.mItems[0].m1.getReferent();
}
else{
continue;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>208901</snippet_key>
<tag>struts2</tag>
<comment>来自CSDN博客：struts2基础（续）  http://blog.csdn.net/WillCold/article/details/20068775#</comment>
<code>public class HelloWorldAction{
private String message;
....
public String execute() throws Exception{
this.message = &quot;我的第一个struts2应用&quot;;
return &quot;success&quot;;
}

public String other() throws Exception{
this.message = &quot;第二个方法&quot;;
return &quot;success&quot;;
}
&lt;package name=&quot;defaultAction&quot; namespace=&quot;/default“ extends=&quot;struts-default&quot;&gt;
        &lt;default-action-ref name=&quot;error&quot;&gt;&lt;/default-action-ref&gt;    
        &lt;action name=&quot;defaultaction“ class=&quot;org.lesson05.DefaultAction&quot;&gt;
            &lt;result name=&quot;success&quot;&gt;/defaultAction.jsp&lt;/result&gt;
        &lt;/action&gt;
        &lt;action name=&quot;error&quot;&gt;
            &lt;result&gt;/error.jsp&lt;/result&gt;
        &lt;/action&gt;
&lt;/package&gt;
&lt;package ....&gt;
&lt;global-results&gt;
&lt;result name=&quot;message&quot;&gt;/message.jsp&lt;/result&gt;
&lt;/global-results&gt;
&lt;/package&gt;
public class HelloWorldAction{
private String savePath;

public String getSavePath() {
return savePath;
}
public void setSavePath(String savePath) {
this.savePath = savePath;
}
......
}
&lt;package name=&quot;itcast&quot; namespace=&quot;/test&quot; extends=&quot;struts-default&quot;&gt;
&lt;action name=&quot;helloworld&quot; class=&quot;cn.itcast.action.HelloWorldAction&quot; &gt;
&lt;param name=&quot;savePath&quot;&gt;/images&lt;/param&gt;
&lt;result name=&quot;success&quot;&gt;/WEB-INF/page/hello.jsp&lt;/result&gt;
&lt;/action&gt;
&lt;/package&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE struts PUBLIC
&quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot;
&quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;&gt;
&lt;struts&gt;
&lt;constant name=&quot;struts.action.extension&quot; value=&quot;do&quot;/&gt;
&lt;/struts&gt;
&lt;constant name=&quot;struts.action.extension&quot; value=&quot;do,go&quot;/&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE struts PUBLIC
&quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot;
&quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;&gt;
&lt;struts&gt;
&lt;include file=&quot;struts-user.xml&quot;/&gt;
&lt;include file=&quot;struts-order.xml&quot;/&gt;
&lt;/struts&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>78085</snippet_key>
<tag>blog 设计模式 91 csdn博客</tag>
<comment>来自CSDN博客：设计模式——里氏替换原则  http://blog.csdn.net/chenchong_219/article/details/16873543#</comment>
<code>&lt;pre code_snippet_id=&quot;78085&quot; snippet_file_name=&quot;blog_20131122_1_3159936&quot; name=&quot;code&quot; class=&quot;java&quot;&gt;&lt;pre code_snippet_id=&quot;78085&quot; snippet_file_name=&quot;blog_20131122_1_3159936&quot; name=&quot;code&quot; class=&quot;java&quot;&gt;&lt;pre code_snippet_id=&quot;78085&quot; snippet_file_name=&quot;blog_20131122_1_3159936&quot;&gt;
&lt;span style=&quot;font-size: 18px; background-color: rgb(255, 255, 255);&quot;&gt;class B extends A
{
public int func1(int a, int b)
{
return a+b;
}

public int func2(int a, int b){
return func1(a,b)+100;
}
}

public class Client
{
public static void main(String[] args){
B b = new B();
System.out.println(&quot;100-50=&quot;+b.func1(100, 50));
System.out.println(&quot;100-80=&quot;+b.func1(100, 80));
System.out.println(&quot;100+20+100=&quot;+b.func2(100, 20));
}
} Â &lt;/span&gt;
&lt;span style=&quot;font-family: simsun;&quot;&gt;&lt;span style=&quot;font-size: 18px; background-color: rgb(255, 255, 255);&quot;&gt;Â &lt;/span&gt;&lt;/span&gt;
&lt;span style=&quot;font-family: &apos;Times New Roman&apos;; font-size: 18px; background-color: rgb(255, 255, 255);&quot;&gt;&lt;span style=&quot; color: rgb(0, 0, 153);&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;public class C {
public int func(int a, int b){
return a+b;
}
}
public class C1 extends C{
public int func2(int a, int b) {
return a-b;
}
}
public class Client{
public static void main(String args) {
C1 c = new C1();
System.out.println(&quot;2-1=&quot; + c.func2(2, 1));
}
}&lt;/span&gt;
&lt;span style=&quot;font-size: 18px; background-color: rgb(255, 255, 255);&quot;&gt; import java.util.HashMap;
public class Father {
public void func(HashMap m){
System.out.println(&quot;履行父类...&quot;);
}
}
import java.util.Map;
public class Son extends Father{
public void func(Map m){//方式的形参比父类的更宽松
System.out.println(&quot;履行子类...&quot;);
}
}
import java.util.HashMap;
public class Client{
public static void main(String args) {
Father f = new Son();//援用基类的处所能通明地利用其子类的工具。
HashMap h = new HashMap();
f.func(h);
}
}&lt;/span&gt;
&lt;span style=&quot;font-size: 18px; background-color: rgb(255, 255, 255);&quot;&gt; import java.util.Map;
public abstract class Father {
public abstract Map func();
}
import java.util.HashMap;
public class Son extends Father{
@Override
public HashMap func(){//方式的返回值比父类的更严酷
HashMap h = new HashMap();
h.put(&quot;h&quot;, &quot;履行子类...&quot;);
return h;
}
}
public class Client{
public static void main(String args) {
Father f = new Son();//援用基类的处所能通明地利用其子类的工具。
System.out.println(f.func());
}
}&lt;/span&gt;
class A
{
public int func1(int a, int b)
{
return a-b;
}
}

public class Client
{
public static void main(String[] args){
A a = new A();
System.out.println(&quot;100-50=&quot;+a.func1(100, 50));
System.out.println(&quot;100-80=&quot;+a.func1(100, 80));
}
}
&lt;pre code_snippet_id=&quot;78085&quot; snippet_file_name=&quot;blog_20131122_1_846055&quot; name=&quot;code&quot; class=&quot;java&quot; style=&quot;font-size: 18px;&quot;&gt;&lt;pre code_snippet_id=&quot;78085&quot; snippet_file_name=&quot;blog_20131122_1_846055&quot; name=&quot;code&quot; class=&quot;java&quot; style=&quot;line-height: 21px;&quot;&gt;&lt;pre code_snippet_id=&quot;78085&quot; snippet_file_name=&quot;blog_20131122_1_846055&quot; name=&quot;code&quot; class=&quot;java&quot;&gt;&lt;pre code_snippet_id=&quot;78085&quot; snippet_file_name=&quot;blog_20131122_1_846055&quot; name=&quot;code&quot; class=&quot;java&quot;&gt;&lt;pre code_snippet_id=&quot;78085&quot; snippet_file_name=&quot;blog_20131122_1_846055&quot;&gt;
{
public int func(int a, int b)
{
return a+b;
}
}
public class C1 extends C
{
@Override
public int func(int a, int b)Â 
{
return a-b;
}
}
public class Client
{
public static void main(String args)Â 
{
C c = new C1();
System.out.println(&quot;2+1=&quot; + c.func(2, 1));
}
}
public class C {
public int func(int a, int b){
return a+b;
}
}
public class C1 extends C{
public int func2(int a, int b) {
return a-b;
}
}
public class Client{
public static void main(String args) {
C1 c = new C1();
System.out.println(&quot;2-1=&quot; + c.func2(2, 1));
}
}
import java.util.HashMap;
public class Father {
public void func(HashMap m){
System.out.println(&quot;履行父类...&quot;);
}
}
import java.util.Map;
public class Son extends Father{
public void func(Map m){//方式的形参比父类的更宽松
System.out.println(&quot;履行子类...&quot;);
}
}
import java.util.HashMap;
public class Client{
public static void main(String args) {
Father f = new Son();//援用基类的处所能通明地利用其子类的工具。
HashMap h = new HashMap();
f.func(h);
}
}
import java.util.Map;
public abstract class Father {
public abstract Map func();
}
import java.util.HashMap;
public class Son extends Father{
@Override
public HashMap func(){//方式的返回值比父类的更严酷
HashMap h = new HashMap();
h.put(&quot;h&quot;, &quot;履行子类...&quot;);
return h;
}
}
public class Client{
public static void main(String args) {
Father f = new Son();//援用基类的处所能通明地利用其子类的工具。
System.out.println(f.func());
}
}
&lt;span style=&quot;color:#ff0000;&quot;&gt; &lt;/span&gt; public class C {
public int func(int a, int b){
return a+b;
}
}
public class C1 extends C{
@Override
public int func(int a, int b) {
return a-b;
}
}
public class Client{
public static void main(String args) {
C c = new C1();
System.out.println(&quot;2+1=&quot; + c.func(2, 1));
}
}
public class C {
public int func(int a, int b){
return a+b;
}
}
public class C1 extends C{
@Override
public int func(int a, int b) {
return a-b;
}
}
public class Client{
public static void main(String args) {
C c = new C1();
System.out.println(&quot;2+1=&quot; + c.func(2, 1));
}
}
public class C {
public int func(int a, int b){
return a+b;
}
}
public class C1 extends C{
public int func2(int a, int b) {
return a-b;
}
}
public class Client{
public static void main(String args) {
C1 c = new C1();
System.out.println(&quot;2-1=&quot; + c.func2(2, 1));
}
}
import java.util.HashMap;
public class Father {
public void func(HashMap m){
System.out.println(&quot;履行父类...&quot;);
}
}
import java.util.Map;
public class Son extends Father{
public void func(Map m){//方式的形参比父类的更宽松
System.out.println(&quot;履行子类...&quot;);
}
}
import java.util.HashMap;
public class Client{
public static void main(String args) {
Father f = new Son();//援用基类的处所能通明地利用其子类的工具。
HashMap h = new HashMap();
f.func(h);
}
}
import java.util.Map;
public abstract class Father {
public abstract Map func();
}
import java.util.HashMap;
public class Son extends Father{
@Override
public HashMap func(){//方式的返回值比父类的更严酷
HashMap h = new HashMap();
h.put(&quot;h&quot;, &quot;履行子类...&quot;);
return h;
}
}
public class Client{
public static void main(String args) {
Father f = new Son();//援用基类的处所能通明地利用其子类的工具。
System.out.println(f.func());
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>455181</snippet_key>
<tag>480</tag>
<comment>来自CSDN博客：LeetCode刷题笔录Search in Rotated Sorted Array II http://blog.csdn.net/likecool21/article/details/38716513#</comment>
<code>public class Solution {
public boolean search(int[] A, int target) {
if(A == null || A.length == 0)
return false;
int l = 0;
int r = A.length - 1;

while(l &lt;= r){
int m = (l + r) / 2;
if(A[m] == target)
return true;
//the left half is sorted
if(A[l] &lt; A[m]){
if(A[l] &lt;= target &amp;&amp; A[m] &gt; target)
r = m - 1;
else
l = m + 1;
}
//the right half is sorted
else if(A[l] &gt; A[m]){
if(A[m] &lt; target &amp;&amp; A[r] &gt;= target)
l = m + 1;
else
r = m - 1;
}
//cannot tell which half is sorted, must increment l until A[l] is not equal to A[m]
else{
l++;
}
}
return false;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>193293</snippet_key>
<tag>326,327</tag>
<comment>来自CSDN博客：java读取大文本直接插入Mysql数据库，10万条数据4秒执行完 http://blog.csdn.net/panfanglin/article/details/13006259#</comment>
<code>&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;package com.read.info;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;

public class DBconn {
int bufferSize = 20 * 1024 * 1024;//设读取文件的缓存为20MB
ArrayList&lt;String&gt; column3string = new ArrayList&lt;String&gt;();
ArrayList&lt;String&gt; column13string = new ArrayList&lt;String&gt;();

String driver = &quot;com.mysql.jdbc.Driver&quot;;
static String dbName = &quot;dyform&quot;;
static String password = &quot;root&quot;;
static String userName = &quot;root&quot;;
static String url = &quot;jdbc:mysql://localhost:3307/&quot; + dbName + &quot;?rewriteBatchedStatements=true&quot;;
static String sql = &quot;select * from workinfo&quot;;
Connection conn = null;

public static Connection getConnection() {
Connection conn = null;
try {
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
} catch (ClassNotFoundException e) {
e.printStackTrace();
}
try {
conn = DriverManager.getConnection(url, userName, password);
} catch (SQLException e) {
e.printStackTrace();
}
return conn;
}

public void readFile(String filename) throws SQLException, FileNotFoundException {
File file = new File(filename);
if (file.isFile() &amp;&amp; file.exists()) {
BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));
InputStreamReader isr = new InputStreamReader(bis);
BufferedReader br = new BufferedReader(isr, bufferSize);
int count = 0;// 计数器
String lineTXT = null;
PreparedStatement pstmt = null;
String[] temp = null;
Connection conn = getConnection();
conn.setAutoCommit(false);// 设置数据手动提交，自己管理事务
String sql = &quot;insert into workinfo(column3, column13) values (?, ?)&quot;;
pstmt = conn.prepareStatement(sql);
try {
while ((lineTXT = br.readLine()) != null) {
temp = lineTXT.split(&quot; &quot;);
pstmt.setString(1, temp[0]);
pstmt.setString(2, temp[1]);
pstmt.addBatch();// 用PreparedStatement的批量处理
if (count % 5000 == 0) {// 当增加了500个批处理的时候再提交
pstmt.executeBatch();// 执行批处理
conn.commit();
pstmt.clearBatch();
//打印插入的条数
//System.out.println(&quot;count: &quot; + count);
}
count++;
}
pstmt.executeBatch();// 执行批处理
conn.commit();
pstmt.close();
conn.close();
} catch (IOException e) {
e.printStackTrace();
}
}
}

public void show() {
System.out.println(&quot;This is string:&quot;);
for (int i = 0; i &lt; column3string.size(); i++) {
System.out.println(column3string.get(i));
}
System.out.println(&quot;This is integer:&quot;);
for (int i = 0; i &lt; column13string.size(); i++) {
System.out.println(column13string.get(i));
}
}

public static void main(String[] args) throws FileNotFoundException {
System.out.println(&quot;开始........&quot;);
DBconn test = new DBconn();
//test.show();
long timeTestStart = System.currentTimeMillis();// 记录开始时间
try {
test.readFile(&quot;D:\\ProgramFiles\\tomcat7\\webapps\\ExcelDemo1\\upload\\1_attlog.dat&quot;);
} catch (SQLException e) {
e.printStackTrace();
}
System.out.println(&quot;succeed&quot;);
long timeTestEnd = System.currentTimeMillis();// 记录结束时间
long time = timeTestEnd - timeTestStart;
long secondTime = time / 1000;
System.out.println(&quot;Time:&quot; + secondTime + &quot; seconds&quot;);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>324365</snippet_key>
<tag>327</tag>
<comment>来自CSDN博客：JAVA之IO技术File类的使用 http://blog.csdn.net/HYM1987/article/details/24914611#</comment>
<code>package ioTest.io3;
/*
* File类是对文件和文件夹的抽象。
* File类的常见方法：
* 1.创建
* createNewFile()：在指定的位置创建文件，如果该文件已经存在，则不创建，返回false。
* 和输出流对象不一样，输出流对象，只要已建立就创建，如果文件存在，则覆盖。
* mkdir():创建此抽象路径名指定的目录
* mkdir():创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。
* 2.删除
* delete()
* deleteOnExit():在程序退出时，会在退出之前删除文件。这个操作对一些应用程序创建的临时
* 文件会用上。
* 3.判断
* canExecute()
* canRead()
* canWrite()
* exists() 测试此抽象路径名表示的文件或目录是否存在。
* isDirectory()
* isFile()
* isAbsolute()
* 4.获取文件信息
* getAbsoluteFile()
* getAbsolutePath()
* getPath()
* renameTo(File dest) 重新命名此抽象路径名表示的文件。
* 以上方法都比较容易的啦，在method4中用renameTo(File dest)方法
* 演示剪切效果。
*/
import java.io.File;
import java.io.IOException;

public class FileDemo {

public static void main(String[] args) throws Exception {
//测试不同的内容调用不同的方法
//method1();
method4();
}
//创建文件
public static void method1() throws IOException, InterruptedException
{
File file=new File(&quot;file1.txt&quot;);//创建一个文件对象
sop(file.exists());//判断文件是否存在
sop(file);
file.createNewFile();//通过文件对象创建一个文件
file.deleteOnExit();
//是指在程序退出的时候删除，即使在后面代码中出现异常，没有执行delete方法，
//这句删除代码在程序退出的时候也会执行删除操作
Thread.sleep(4000);
file.delete();
}
//创建目录，并判断是否是目录，是否是文件
public static void method2()
{
File dirorFile=new File(&quot;file2.txt&quot;);
dirorFile.mkdir();
if(dirorFile.exists())
{
//注意在做以下两个判断的时候，一定要先判断文件是否存在
sop((dirorFile.isDirectory()?&quot;文件夹&quot;:&quot;不是文件夹&quot;));
sop((dirorFile.isFile()?&quot;文件&quot;:&quot;不是文件&quot;));
sop(dirorFile.isAbsolute()?&quot;绝对路径&quot;:&quot;相对路径&quot;);
}
}
//用file.renameTo()方法实现文件剪切效果
public static void method4()
{
File file1=new File(&quot;e:\\copy.txt&quot;);//e盘下已经存在的文件
File file2=new File(&quot;F:\\renameCopyToFDisk.txt&quot;);
file1.renameTo(file2);
}
public static void sop(Object obj) {
System.out.println(obj);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>455437</snippet_key>
<tag>132</tag>
<comment>来自CSDN博客：PullToRefresh使用详解（三）--实现异步加载的下拉刷新列表 http://blog.csdn.net/killcwd/article/details/26838015# 派生自harvic880925/blog_20140103_1_575704</comment>
<code>package com.example.try_simpleadapter_new;
/**
* 完成与服务器通信的下拉刷新
* @author harvic
*/
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.NameValuePair;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.protocol.HTTP;
import org.json.JSONArray;


import com.handmark.pulltorefresh.library.PullToRefreshBase;
import com.handmark.pulltorefresh.library.PullToRefreshListView;
import com.handmark.pulltorefresh.library.PullToRefreshBase.Mode;
import com.handmark.pulltorefresh.library.PullToRefreshBase.OnRefreshListener;

import android.os.AsyncTask;
import android.os.Bundle;
import android.text.format.DateUtils;
import android.util.Log;
import android.widget.ListView;
import android.app.ListActivity;

public class MainActivity extends ListActivity{

private String serverIP=&quot;http://222.195.151.19&quot;;
private List&lt;ImageAndText&gt; mData;
private PullToRefreshListView mPullRefreshListView;
ImageAndTextListAdapter adapter=null;
@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

mPullRefreshListView = (PullToRefreshListView) findViewById(R.id.pull_refresh_list);

//设定下拉监听函数
mPullRefreshListView.setOnRefreshListener(new OnRefreshListener&lt;ListView&gt;() {
@Override
public void onRefresh(PullToRefreshBase&lt;ListView&gt; refreshView) {
String label = DateUtils.formatDateTime(getApplicationContext(), System.currentTimeMillis(),
DateUtils.FORMAT_SHOW_TIME | DateUtils.FORMAT_SHOW_DATE | DateUtils.FORMAT_ABBREV_ALL);

// Update the LastUpdatedLabel
refreshView.getLoadingLayoutProxy().setLastUpdatedLabel(label);

Log.d(&quot;msg&quot;,&quot;this==&quot;+this);
// Do work to refresh the list here.
new GetDataTask().execute();

}
});

mPullRefreshListView.setMode(Mode.PULL_FROM_END);// 设置底部下拉刷新模式
//传参生成适配器
mData = getData();
ListView actualListView = mPullRefreshListView.getRefreshableView();
adapter = new ImageAndTextListAdapter(this,mData,actualListView);

// 设置适配器
actualListView.setAdapter(adapter);
}

private List&lt;ImageAndText&gt; getData() {
//创建默认的httpClient实例.
DefaultHttpClient httpclient = new DefaultHttpClient();
HttpResponse response = null;
HttpEntity entity = null;

StringBuilder builder = new StringBuilder();
JSONArray jsonArray = null;

List&lt;ImageAndText&gt; list = new ArrayList&lt;ImageAndText&gt;();

try{
// 创建httpost.访问本地服务器网址
HttpPost httpost = new HttpPost(serverIP+&quot;/try_an_server/index.php&quot;);

//构造POST方法的{name:value} 参数对
List &lt;NameValuePair&gt; vps = new ArrayList &lt;NameValuePair&gt;();
//将参数传入post方法中
vps.add(new BasicNameValuePair(&quot;action&quot;, &quot;insert&quot;));
vps.add(new BasicNameValuePair(&quot;name&quot;, &quot;进去了&quot;));

httpost.setEntity(new UrlEncodedFormEntity(vps, HTTP.UTF_8));
response = httpclient.execute(httpost); //执行

if (response.getEntity() != null) {
//如果服务器端JSON没写对，这句是会出异常，是执行不过去的
BufferedReader reader = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));
String s = reader.readLine();
for (; s != null; s = reader.readLine()) {
builder.append(s);
}
Log.i(&quot;msg&quot;,&quot;builder.toString = &quot;+ builder.toString());

jsonArray = new JSONArray(builder.toString());
for (int i = 0; i &lt; jsonArray.length(); i++) {
if(jsonArray.getJSONObject(i).getInt(&quot;id&quot;)==1){
String name=jsonArray.getJSONObject(i).getString(&quot;name&quot;);
String info=jsonArray.getJSONObject(i).getString(&quot;info&quot;);
String PicName=jsonArray.getJSONObject(i).getString(&quot;photo&quot;);
String picURL=serverIP+&quot;/try_an_server/&quot;+PicName+&quot;.jpg&quot;;

ImageAndText item=new ImageAndText(picURL,name,info);
list.add(item);
}
}
}
} catch (Exception e) {
e.printStackTrace();
} finally {
try {
if (entity != null)
{
httpclient.getConnectionManager().shutdown();//关闭连接
//这两种释放连接的方法都可以
}
} catch (Exception e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}

return list;

}



private class GetDataTask extends AsyncTask&lt;Void, Void, ImageAndText&gt; {

//后台处理部分
@Override
protected ImageAndText doInBackground(Void... params) {
// Simulates a background job.
ImageAndText item = null;
try {
item = new ImageAndText(serverIP+&quot;/try_an_server/xizang.jpg&quot;, &quot;sss&quot;, &quot;ssss&quot;);
} catch (Exception e) {
// TODO: handle exception
setTitle(&quot;map出错了&quot;);
}

return item;
}

//这里是对刷新的响应，可以利用addFirst（）和addLast()函数将新加的内容加到LISTView中
//根据AsyncTask的原理，onPostExecute里的result的值就是doInBackground()的返回值
@Override
protected void onPostExecute(ImageAndText result) {
//在头部增加新添内容

try {
mData.add(result);

//通知程序数据集已经改变，如果不做通知，那么将不会刷新mListItems的集合
adapter.notifyDataSetChanged();
adapter.loadImage();
// Call onRefreshComplete when the list has been refreshed.
mPullRefreshListView.onRefreshComplete();
} catch (Exception e) {
// TODO: handle exception
setTitle(e.getMessage());
}

super.onPostExecute(result);
}
}


}
mPullRefreshListView = (PullToRefreshListView) findViewById(R.id.pull_refresh_list);

//设定下拉监听函数
mPullRefreshListView.setOnRefreshListener(new OnRefreshListener&lt;ListView&gt;() {
@Override
public void onRefresh(PullToRefreshBase&lt;ListView&gt; refreshView) {
String label = DateUtils.formatDateTime(getApplicationContext(), System.currentTimeMillis(),
DateUtils.FORMAT_SHOW_TIME | DateUtils.FORMAT_SHOW_DATE | DateUtils.FORMAT_ABBREV_ALL);

// Update the LastUpdatedLabel
refreshView.getLoadingLayoutProxy().setLastUpdatedLabel(label);

Log.d(&quot;msg&quot;,&quot;this==&quot;+this);
// Do work to refresh the list here.
new GetDataTask().execute();

}
});
private class GetDataTask extends AsyncTask&lt;Void, Void, ImageAndText&gt; {
//后台处理部分
@Override
protected ImageAndText doInBackground(Void... params) {
// Simulates a background job.
ImageAndText item = null;
try {
item = new ImageAndText(serverIP+&quot;/try_an_server/xizang.jpg&quot;, &quot;sss&quot;, &quot;ssss&quot;);
} catch (Exception e) {
// TODO: handle exception
setTitle(&quot;map出错了&quot;);
}

return item;
}

//这里是对刷新的响应，可以利用addFirst（）和addLast()函数将新加的内容加到LISTView中
//根据AsyncTask的原理，onPostExecute里的result的值就是doInBackground()的返回值
@Override
protected void onPostExecute(ImageAndText result) {
//在头部增加新添内容

try {
mData.add(result);

//通知程序数据集已经改变，如果不做通知，那么将不会刷新mListItems的集合
adapter.notifyDataSetChanged();
adapter.loadImage();
// Call onRefreshComplete when the list has been refreshed.
mPullRefreshListView.onRefreshComplete();
} catch (Exception e) {
// TODO: handle exception
setTitle(e.getMessage());
}

super.onPostExecute(result);
}
}
mPullRefreshListView.setMode(Mode.PULL_FROM_END);// 设置底部下拉刷新模式
//传参生成适配器
mData = getData();
ListView actualListView = mPullRefreshListView.getRefreshableView();
adapter = new ImageAndTextListAdapter(this,mData,actualListView);

// 设置适配器
actualListView.setAdapter(adapter);
</code>
</RECORD>
<RECORD>
<snippet_key>390157</snippet_key>
<tag>298</tag>
<comment>来自CSDN博客：setOnFocusListener  http://blog.csdn.net/u013486906/article/details/30335553#</comment>
<code>package com.example.setonfocuschangelistener_e;

import android.os.Bundle;
import android.app.Activity;
import android.view.Menu;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnFocusChangeListener;
import android.widget.EditText;
import android.widget.TextView;

public class MainActivity extends Activity {
private EditText et=null;
private TextView tv=null;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
super.setContentView(R.layout.activity_main);
et=(EditText)super.findViewById(R.id.et1_info);
tv=(TextView)super.findViewById(R.id.tv_info);
/*et.setOnFocusChangeListener(new OnFocusChangeListener() {


public void onFocusChange(View v, boolean hasFocus) {
// TODO Auto-generated method stub
if(hasFocus) MainActivity.this.tv.setText(&quot;Focus has be located&quot;);
else MainActivity.this.tv.setText(&quot;Focus failed&quot;);
}
});*/
et.setOnClickListener(new OnClickListener() {

public void onClick(View v) {
// TODO Auto-generated method stub
et.setText(&quot;&quot;);
}
});
et.setOnFocusChangeListener(new OnFocusChangeListenerImpl());
}
private class OnFocusChangeListenerImpl implements OnFocusChangeListener{

@Override
public void onFocusChange(View v, boolean hasFocus) {
// TODO Auto-generated method stub
if(hasFocus) MainActivity.this.tv.setText(&quot;Focus locate success&quot;);
else MainActivity.this.tv.setText(&quot;Focus locate failed&quot;);
}

}

@Override
public boolean onCreateOptionsMenu(Menu menu) {
// Inflate the menu; this adds items to the action bar if it is present.
getMenuInflater().inflate(R.menu.activity_main, menu);
return true;
}

}
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:orientation=&quot;vertical&quot;
tools:context=&quot;.MainActivity&quot; &gt;


&lt;EditText
android:id=&quot;@+id/et1_info&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;Information_first&quot;
/&gt;

&lt;EditText
android:id=&quot;@+id/et2_info&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;Information_second&quot;
/&gt;

&lt;TextView
android:id=&quot;@+id/tv_info&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:layout_centerHorizontal=&quot;true&quot;
android:layout_centerVertical=&quot;true&quot;
android:text=&quot;Focuslocation&quot; /&gt;

&lt;/LinearLayout&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>471557</snippet_key>
<tag>106</tag>
<comment>BaseAdapter</comment>
<code>package com.example.listview;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.BaseAdapter;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.TextView;

public class MainActivity extends Activity {

private final String TAG = &quot;ListViewTest&quot;;
private ListView mListView;

private PackageManager mManager;

private MyAdapter mAdapter;
private List&lt;HashMap&lt;String,Object&gt;&gt;mList;

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

mManager = (PackageManager)getPackageManager();

Intent intent = new Intent(Intent.ACTION_MAIN);
intent.addCategory(Intent.CATEGORY_LAUNCHER);
List&lt;ResolveInfo&gt; apps = mManager.queryIntentActivities(intent, 0);
Log.d(TAG,&quot;app size: &quot; + apps.size());

mList = new ArrayList&lt;HashMap&lt;String,Object&gt;&gt;();
for(ResolveInfo info:apps){
HashMap&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
map.put(&quot;icon&quot;, info.loadIcon(mManager));
map.put(&quot;lable&quot;, info.loadLabel(mManager));
map.put(&quot;name&quot;, info.activityInfo.packageName);
map.put(&quot;check&quot;, false);
mList.add(map);
}

mListView = (ListView)findViewById(R.id.list);
mAdapter = new MyAdapter(this);
mListView.setAdapter(mAdapter);
mListView.setOnItemClickListener(mListener);

}

private class MyAdapter extends BaseAdapter{
private Context mContext;
public MyAdapter(Context context){
mContext = context;
}
@Override
public int getCount() {
// TODO Auto-generated method stub
return mList.size();
}
@Override
public Object getItem(int position) {
// TODO Auto-generated method stub
return mList.get(position);
}
@Override
public long getItemId(int position) {
// TODO Auto-generated method stub
return position;
}

public class MyView{

private ImageView mImage;
private TextView mLable;
private TextView mPackage;
private CheckBox mCheck;
}

@Override
public View getView(int position, View v, ViewGroup parent) {
// TODO Auto-generated method stub
MyView view = null;
HashMap&lt;String,Object&gt;map = mList.get(position);

if(v == null){
v = LayoutInflater.from(mContext).inflate(R.layout.list, null);
view = new MyView();
view.mImage = (ImageView)v.findViewById(R.id.icon);
view.mLable = (TextView)v.findViewById(R.id.lable);
view.mPackage = (TextView)v.findViewById(R.id.name);
view.mCheck = (CheckBox)v.findViewById(R.id.check);
v.setTag(view);
}else
view = (MyView)v.getTag();

view.mImage.setImageDrawable((Drawable)map.get(&quot;icon&quot;));
view.mLable.setText((String)map.get(&quot;lable&quot;));
view.mPackage.setText((String)map.get(&quot;name&quot;));
if((Boolean)map.get(&quot;check&quot;))
view.mCheck.setChecked(true);
else
view.mCheck.setChecked(false);

return v;
}

}

private OnItemClickListener mListener = new OnItemClickListener(){
@Override
public void onItemClick(AdapterView parent,View v,int position,long id){
if(((Boolean)(mList.get(position).get(&quot;check&quot;))).booleanValue() == false)
mList.get(position).put(&quot;check&quot;, true);
else
mList.get(position).put(&quot;check&quot;, false);

mAdapter.notifyDataSetChanged(); //通知数据源已更新，需要刷新ListView
Log.d(TAG,&quot;check: &quot; + position);
}
};

}
</code>
</RECORD>
<RECORD>
<snippet_key>128269</snippet_key>
<tag></tag>
<comment>来自CSDN博客：6、手机防盗--密码设置  http://blog.csdn.net/asmcvc/article/details/17557889#</comment>
<code>package com.example.mobilesafe;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.AdapterView;
import android.widget.GridView;

/**
* Created by sing on 13-12-24.
* desc:
*/
public class MainActivity extends Activity {
//activity_main中的gridview控件
private GridView gv_main;

public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

gv_main = (GridView)findViewById(R.id.gv_main);
//为gv_main对象设置适配器，该适配器为每个item填充对应的数据
gv_main.setAdapter(new MainAdapter(this));

//为gv_main设置点击item的处理事件
gv_main.setOnItemClickListener(new AdapterView.OnItemClickListener() {
/**
* item点击事件
* @param adapterView
* @param view
* @param i
* @param l
*/
@Override
public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) {
Intent intent = null;
switch (i) {
case 0: //手机防盗
intent = new Intent(MainActivity.this, LostProtectedActivity.class);
startActivity(intent);
break;
case 8: //设置中心
intent = new Intent(MainActivity.this, SettingCenterActivity.class);
startActivity(intent);
break;
}
}
});
}
}
package com.example.mobilesafe;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

import com.example.utils.util;

/**
* Created by sing on 13-12-25.
* desc:
*/
public class LostProtectedActivity extends Activity implements View.OnClickListener {

//保存配置
private SharedPreferences sp;

private AlertDialog dialog;

//第一次进入手机防盗弹出设置密码对话框的控件
private EditText et_first_dlg_pswd;
private EditText et_first_dlg_pswd_confirm;
private Button bt_first_dlg_ok;
private Button bt_first_dlg_cancel;

//非第一次进入手机防盗弹出设置密码对话框的控件
private EditText et_normal_dlg_pswd;
private Button bt_normal_dlg_ok;
private Button bt_normal_dlg_cancel;

public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_lostprotected);

sp = getSharedPreferences(&quot;config&quot;, MODE_PRIVATE);

//如果是第一次进入手机防盗则弹出设置密码对话框，否则弹出输入密码对话框
if (isFirstEntry()) {
showFirstEntryDialog();
}else {
showNormalEntryDialog();
}
}

/**
* 判断是否是第一次进入手机防盗页面，判断方法是检测有没有设置过密码
* @return
*/
private boolean isFirstEntry() {
String password = sp.getString(&quot;password&quot;, &quot;&quot;);
return password.isEmpty();
}

/**
*第一次进入手机防盗弹出设置密码对话框
*/
private void showFirstEntryDialog() {
AlertDialog.Builder builder = new AlertDialog.Builder(this);
View view = View.inflate(this, R.layout.first_entry_dialog, null);
et_first_dlg_pswd = (EditText)view.findViewById(R.id.et_first_dlg_pswd);
et_first_dlg_pswd_confirm = (EditText)view.findViewById(R.id.et_first_dlg_pswd_confirm);
bt_first_dlg_ok = (Button)view.findViewById(R.id.bt_first_dlg_ok);
bt_first_dlg_cancel = (Button)view.findViewById(R.id.bt_first_dlg_cancel);

//xml中已经设置android:onClick=&quot;onClick&quot;，这里无需再设置
//bt_first_dlg_ok.setOnClickListener(this);
//bt_first_dlg_cancel.setOnClickListener(this);

builder.setView(view);
dialog = builder.create();
dialog.show();
}

/**
*非第一次进入手机防盗弹出输入密码对话框
*/
private void showNormalEntryDialog() {
AlertDialog.Builder builder = new AlertDialog.Builder(this);
View view = View.inflate(this, R.layout.normal_entry_dialog, null);
et_normal_dlg_pswd = (EditText)view.findViewById(R.id.et_normal_dlg_pswd);
bt_normal_dlg_ok = (Button)view.findViewById(R.id.bt_normal_dlg_ok);
bt_normal_dlg_cancel = (Button)view.findViewById(R.id.bt_normal_dlg_cancel);

//xml中已经设置android:onClick=&quot;onClick&quot;，这里无需再设置
//bt_normal_dlg_ok.setOnClickListener(this);
//bt_normal_dlg_cancel.setOnClickListener(this);

builder.setView(view);
dialog = builder.create();
dialog.show();
}

@Override
public void onClick(android.view.View view) {
switch (view.getId()) {
case R.id.bt_first_dlg_cancel:
dialog.cancel();
finish();
break;
case R.id.bt_first_dlg_ok:
String pswd = et_first_dlg_pswd.getText().toString().trim();
String pswdconfirm = et_first_dlg_pswd_confirm.getText().toString().trim();

//密码不能为空
if (pswd.isEmpty() || pswdconfirm.isEmpty()) {
Toast.makeText(this, &quot;密码不能为空&quot;, 1).show();
return;
}

//判断两次密码输入是否相等
if (pswd.equals(pswdconfirm)) {
//保存密码
SharedPreferences.Editor editor = sp.edit();
editor.putString(&quot;password&quot;, util.md5String(pswd));
editor.commit();
dialog.dismiss();
//设置完毕后进入主界面，要求用户重新进入
finish();
}else {
Toast.makeText(this, &quot;两次密码不相同&quot;, 1).show();
return;
}
break;
case R.id.bt_normal_dlg_cancel:
finish();
break;
case R.id.bt_normal_dlg_ok:
String inputpswd = et_normal_dlg_pswd.getText().toString().trim();
if (inputpswd.isEmpty()) {
Toast.makeText(this, &quot;密码不能为空&quot;, 1).show();
return;
}

String savedpswd = sp.getString(&quot;password&quot;, &quot;&quot;);
if (util.md5String(inputpswd).equals(savedpswd)) {
Toast.makeText(this, &quot;密码正确进入界面&quot;, 1).show();
dialog.dismiss();
return;
}else {
Toast.makeText(this, &quot;密码不正确&quot;, 1).show();
return;
}
}
}

}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:orientation=&quot;vertical&quot; android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:gravity=&quot;center_horizontal&quot;&gt;
&lt;TextView
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;设置密码&quot;
android:id=&quot;@+id/textView&quot;
android:layout_gravity=&quot;center_horizontal&quot;
android:textSize=&quot;30sp&quot;
android:textStyle=&quot;bold&quot;
android:gravity=&quot;center_horizontal&quot; /&gt;
&lt;View
android:layout_height=&quot;1dip&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_marginTop=&quot;5dip&quot;
android:background=&quot;@drawable/devide_line&quot; /&gt;

&lt;EditText
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:id=&quot;@+id/et_first_dlg_pswd&quot;
android:hint=&quot;请输入密码&quot; /&gt;

&lt;EditText
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:id=&quot;@+id/et_first_dlg_pswd_confirm&quot;
android:layout_gravity=&quot;center_horizontal&quot;
android:hint=&quot;请再次输入密码&quot; /&gt;
&lt;View
android:layout_height=&quot;1dip&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_marginTop=&quot;5dip&quot;
android:background=&quot;@drawable/listview_devider&quot; /&gt;

&lt;LinearLayout
android:orientation=&quot;horizontal&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;&gt;

&lt;Button
android:layout_width=&quot;0dip&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;确定&quot;
android:id=&quot;@+id/bt_first_dlg_ok&quot;
android:onClick=&quot;onClick&quot;
android:layout_weight=&quot;1&quot; /&gt;

&lt;Button
android:layout_width=&quot;0dip&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;取消&quot;
android:id=&quot;@+id/bt_first_dlg_cancel&quot;
android:onClick=&quot;onClick&quot;
android:layout_weight=&quot;1&quot; /&gt;
&lt;/LinearLayout&gt;

&lt;/LinearLayout&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:orientation=&quot;vertical&quot; android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;&gt;
&lt;TextView
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;输入密码&quot;
android:id=&quot;@+id/textView&quot;
android:layout_gravity=&quot;center_horizontal&quot;
android:textSize=&quot;30sp&quot;
android:textStyle=&quot;bold&quot;
android:gravity=&quot;center_horizontal&quot; /&gt;
&lt;View
android:layout_height=&quot;1dip&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_marginTop=&quot;5dip&quot;
android:background=&quot;@drawable/devide_line&quot; /&gt;

&lt;EditText
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:id=&quot;@+id/et_normal_dlg_pswd&quot;
android:hint=&quot;请输入密码&quot; /&gt;
&lt;View
android:layout_height=&quot;1dip&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_marginTop=&quot;5dip&quot;
android:background=&quot;@drawable/listview_devider&quot; /&gt;

&lt;LinearLayout
android:orientation=&quot;horizontal&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;&gt;

&lt;Button
android:layout_width=&quot;0dip&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;确定&quot;
android:id=&quot;@+id/bt_normal_dlg_ok&quot;
android:onClick=&quot;onClick&quot;
android:layout_weight=&quot;1&quot; /&gt;

&lt;Button
android:layout_width=&quot;0dip&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;取消&quot;
android:id=&quot;@+id/bt_normal_dlg_cancel&quot;
android:onClick=&quot;onClick&quot;
android:layout_weight=&quot;1&quot; /&gt;

&lt;/LinearLayout&gt;
&lt;/LinearLayout&gt;
&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos; standalone=&apos;yes&apos; ?&gt;
&lt;map&gt;
&lt;boolean name=&quot;autoupdate&quot; value=&quot;false&quot; /&gt;
&lt;string name=&quot;password&quot;&gt;202cb962ac59075b964b07152d234b70&lt;/string&gt;
&lt;/map&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>144389</snippet_key>
<tag>java class java方法 方法传参</tag>
<comment>来自CSDN博客：关于java的方法的一点小理解 http://blog.csdn.net/qyp199312/article/details/17918397#</comment>
<code>package collection;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

public class List2Set {

public static void main(String[] args) {
List&lt;String&gt; list = new LinkedList&lt;&gt;();

/*list.add(&quot;ee&quot;);
list.add(&quot;dwa&quot;);
list.add(&quot;dwa&quot;);
list.add(&quot;sd&quot;);
list.add(&quot;vf&quot;);
list.add(&quot;3&quot;);
list.add(&quot;ee&quot;);*/
list.add(&quot;P.C32.5R袋&quot;);
list.add(&quot;P.O42.5R袋&quot;);
list.add(&quot;P.O42.5R散&quot;);
list.add(&quot;P.C32.5R袋&quot;);

stringFilter(list);
System.out.println(list);

int n = 5;
count(n);

System.out.println(n);

new List2Set().co(n);

System.out.println(n);
}

static List&lt;String&gt; stringFilter(List&lt;String&gt; list) {

Set&lt;String&gt; set = new HashSet&lt;String&gt;(list);
list = new LinkedList&lt;String&gt;(set);
System.out.println(&quot;方法体内的输出 : &quot;+list);
return list;
}

static void count(int n) {
n --;
System.out.println(&quot;方法体内的输出 : &quot;+n);
}

void co(int n) {
n --;
System.out.println(&quot;方法体内的输出 : &quot;+n);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>275461</snippet_key>
<tag>gson</tag>
<comment>来自CSDN博客：Gson的使用 http://blog.csdn.net/a965654310/article/details/22951859#</comment>
<code>生成Json字符串

Gson gson = new Gson();
List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();
for (int i = 0; i &lt; 10; i++) {
Person p = new Person();
p.setName(&quot;name&quot; + i);
p.setAge(i * 5);
persons.add(p);
}
String str = gson.toJson(persons);
</code>
</RECORD>
<RECORD>
<snippet_key>456205</snippet_key>
<tag>313</tag>
<comment>来自CSDN博客：Android中调用发送邮件 http://blog.csdn.net/u010103075/article/details/38755645#</comment>
<code>package com.home;

import android.app.Activity;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;

public class SendEmailActivity extends Activity implements OnClickListener {
private Button sendBtn;
private Button sendToManyBtn;
private Button sendAttachmentBtn;

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
sendBtn = (Button) findViewById(R.id.main_btn_send);
sendToManyBtn = (Button) findViewById(R.id.main_btn_send_many);
sendAttachmentBtn = (Button) findViewById(R.id.main_btn_send_attachment);
sendBtn.setOnClickListener(this);
sendToManyBtn.setOnClickListener(this);
sendAttachmentBtn.setOnClickListener(this);
}

@Override
public void onClick(View v) {
if (v == sendBtn) {
Intent intent = new Intent(Intent.ACTION_SENDTO);
intent.setData(Uri.parse(&quot;mailto:+297890152@qq.com&quot;));
intent.putExtra(Intent.EXTRA_SUBJECT, &quot;这是单方发送的邮件主题&quot;);
intent.putExtra(Intent.EXTRA_TEXT, &quot;这是单方发送的邮件内容&quot;);
startActivity(intent);
}
if (v == sendToManyBtn) {
Intent intent = new Intent(Intent.ACTION_SENDTO);
intent.setData(Uri.parse(&quot;mailto:297890152@qq.com&quot;));
intent.putExtra(Intent.EXTRA_EMAIL, new String[] {
&quot;313766045@qq.com&quot;, &quot;980324510@qq.com&quot; });
// 抄送
intent.putExtra(Intent.EXTRA_CC,
new String[] { &quot;981413230@qq.com&quot; });
// 密送
intent.putExtra(Intent.EXTRA_BCC,
new String[] { &quot;1316106487@qq.com&quot; });
intent.putExtra(Intent.EXTRA_SUBJECT, &quot;这是多方发送的邮件主题&quot;);
intent.putExtra(Intent.EXTRA_TEXT, &quot;这是多方发送的邮件内容&quot;);
startActivity(intent);
}
if (v == sendAttachmentBtn) {
Intent intent = new Intent(Intent.ACTION_SEND);
intent.putExtra(Intent.EXTRA_EMAIL,
new String[] { &quot;297890152@qq.com&quot; });
intent.putExtra(Intent.EXTRA_SUBJECT, &quot;这是包含附件的邮件主题&quot;);
intent.putExtra(Intent.EXTRA_TEXT, &quot;这是包含附件的邮件内容&quot;);
intent.putExtra(Intent.EXTRA_STREAM, Uri.parse(&quot;&quot;));
intent.setType(&quot;text/plain&quot;);
startActivity(intent);
}
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>340997</snippet_key>
<tag>326</tag>
<comment>来自CSDN博客：Hibernate 异常org.hibernate.LazyInitializationException: could not initialize proxy - no Session http://blog.csdn.net/sunhuwh/article/details/25627295#</comment>
<code>@WebFilter(filterName=&quot;openEntityManagerInViewFilter&quot;
,urlPatterns={&quot;/*&quot;}
,asyncSupported=true
)
public class OpenEntityManagerInViewFilter extends org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter{

}
</code>
</RECORD>
<RECORD>
<snippet_key>128781</snippet_key>
<tag>408</tag>
<comment>来自CSDN博客：黑马程序员_异常  http://blog.csdn.net/u011104495/article/details/17555877#</comment>
<code>classMyException extends Exception
{
MyException(Stringmessage)
{
super(message);
}
}
/*自定义异常。
需求：在本程序中，对于除数是-1，也视为是错误的是无法进行运算的。
那么就需要对这个问题进行自定义的描述。*/
class FuShuException extends Exception
{
FuShuException(Stringmsg)
{
super(msg);
}
}

class Demo
{
int div(inta,int b)throws FuShuException
{
if(b&lt;0)
thrownew FuShuException(&quot;除数为负数&quot;);
return a/b;
}
}
class ExceptionDemo5
{
public staticvoid main(String[] args)
{
Demo d = newDemo();

try
{
int x =d.div(4,-1);
System.out.println(&quot;x=&quot;+x);
}
catch(FuShuException e)
{
System.out.println(e.toString());
return;
//System.exit(0);//系统，退出。jvm结束。
}
finally
{
System.out.println(&quot;finally&quot;);//finally中存放的是一定会被执行的代码。
}
System.out.println(&quot;over&quot;);
}
}
/*
有一个圆形和长方形。
都可以获取面积。对于面积如果出现非法的数值，视为是获取面积出现问题。
问题通过异常来表示。
现有对这个程序进行基本设计。
*/
class NoValueException extends RuntimeException
{
NoValueException(Stringmessage)
{
super(message);
}
}
interface Shape
{
void getArea();
}
class Rec implements Shape
{
private intlen,wid;
Rec(int len ,intwid)//throws NoValueException
{
if(len&lt;=0|| wid&lt;=0)
thrownew NoValueException(&quot;出现非法值&quot;);
this.len =len;
this.wid =wid;
}
public voidgetArea()
{
System.out.println(len*wid);
}
}
class Circle implements Shape
{
private intradius;
public static finaldouble PI = 3.14;
Circle(intradius)
{
if(radius&lt;=0)
thrownew NoValueException(&quot;非法&quot;);
this.radius= radius;
}
public voidgetArea()
{
System.out.println(radius*radius*PI);
}
}
class ExceptionTest1
{
public staticvoid main(String[] args)
{

Rec r = newRec(3,4);
r.getArea();
Circle c =new Circle(-8);
System.out.println(&quot;over&quot;);
}
}
classLanPingException extends Exception
{
LanPingException(String message)
{
super(message);
}
}
classMaoYanException extends Exception
{
MaoYanException(String message)
{
super(message);
}
}
classNoPlanException extends Exception
{
NoPlanException(String msg)
{
super(msg);
}
}
classComputer
{
private int state = 3;
public void run()throwsLanPingException,MaoYanException
{
if(state==2)
throw new LanPingException(&quot;蓝屏了&quot;);
if(state==3)
throw new MaoYanException(&quot;冒烟了&quot;);
System.out.println(&quot;电脑运行&quot;);
}
public void reset()
{
state = 1;
System.out.println(&quot;电脑重启&quot;);
}
}

classTeacher
{
private String name;
private Computer cmpt;
Teacher(String name)
{
this.name = name;
cmpt = new Computer();
}
public void prelect()throws NoPlanException
{
try
{
cmpt.run();
}
catch (LanPingException e)
{
cmpt.reset();
}
catch (MaoYanException e)
{
test();
throw new NoPlanException(&quot;课时无法继续&quot;+e.getMessage());
}
System.out.println(&quot;讲课&quot;);
}
public void test()
{
System.out.println(&quot;练习&quot;);
}
}
classExceptionTest
{
public static void main(String[] args)
{
Teacher t = new Teacher(&quot;毕老师&quot;);
try
{
t.prelect();
}
catch (NoPlanException e)
{
System.out.println(e.toString());
System.out.println(&quot;换老师或者放假&quot;);
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>406533</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Search in Rotated Sorted Array II  http://blog.csdn.net/Chole1122/article/details/34800095#</comment>
<code>&lt;/pre&gt;&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;public class Solution {
public boolean search(int[] A, int target) {
if (A == null || A.length == 0) {
return false;
}
int start = 0;
int end = A.length - 1;
int mid;
boolean inLeft;
while (start + 1 &lt; end) {
mid = start + (end - start) / 2;
if (target == A[mid]) {
return true;
} else {
/**
* 当while 循环被执行时，说明至少有一边的数据是完全相等的，例如 1121111，或者211111
* 对于112111，执行完两个while循环以后，start 和 end 都指向 2
* 则跳出最外层while循环
*
* 对于211111这种，执行以后end ＝＝ mid，继续操作
* 所以两个while循环主要用来处理这种情况
* 处理完以后，就可以按照 “search in rotated sorted array ” 的方法来写
*/
while (start&lt; A.length-1 &amp;&amp; A[mid] == A[start]) {
start ++;
}
while (end &gt; 0 &amp;&amp; A[mid] == A[end]) {
end--;
} if (target &lt; A[mid]) {
if (A[mid] &gt; A[end] &amp;&amp; A[end] &gt;= target) {
start = mid + 1;
} else {
end = mid - 1;
}
} else {
if (A[mid] &lt; A[start] &amp;&amp; target &gt;= A[start]) {
end = mid - 1;
} else {
start = mid + 1;
}
}

}
}
if (target == A[start] || target == A[end]) {
return true;
}
return false;
}
}
public class Solution {
public boolean search(int[] A, int target) {
if (A == null || A.length == 0) {
return false;
}
int start = 0;
int end = A.length - 1;
int mid;
boolean inLeft;
while (start + 1 &lt; end) {
mid = start + (end - start) / 2;
if (target == A[mid]) {
return true;
} else {
if (A[mid] == A[start] &amp;&amp; A[mid] == A[end]) {
int i;
for (i = mid - 1; i &gt;= 0; i--) {
if (A[i] != A[mid]) {
end = i ;
break;
}
}
if (end != i) {
start = mid + 1;
}
} else if (A[mid] == A[start] &amp;&amp; A[mid] != A[end]){
start = mid + 1;
}else if (A[mid] != A[start] &amp;&amp; A[mid] == A[end]){
end = mid - 1;
} else {
if (target &lt; A[mid]) {
if (A[mid] &gt; A[end] &amp;&amp; A[end] &gt;= target) {
start = mid + 1;
} else {
end = mid - 1;
}
} else {
if (A[mid] &lt; A[start] &amp;&amp; target &gt;= A[start]) {
end = mid - 1;
} else {
start = mid + 1;
}
}
}
}
}
if (target == A[start] || target == A[end]) {
return true;
}
return false;
}
}
public class Solution {
public boolean search(int[] A, int target) {
int start = 0, end = A.length-1;
while(end - start &gt;= 2) {
int middle = start + (end-start)/2;
if(A[middle] == target) return true;
if(A[start] &lt; A[middle]) {
if(A[start] &lt;= target &amp;&amp; target &lt; A[middle]) end = middle-1;
else start = middle+1;
}
if(A[middle] &lt; A[end]) {
if(A[middle] &lt; target &amp;&amp; target &lt;= A[end]) start = middle+1;
else end = middle-1;
}
if(A[start] == A[middle]) start++;
if(A[middle] == A[end]) end--;
}
for(int i = start; i &lt;= end; i++) {
if(A[i] == target) return true;
}
return false;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>472069</snippet_key>
<tag>429</tag>
<comment>classloader JVM GC 来自CSDN博客：java初始化问题，其实记住三点就ok了~~~  http://blog.csdn.net/superMarss/article/details/39431663#</comment>
<code>package com.lean;

public class InitJava {

/*
* static静态变量初始化，构造函数调用(每次都执行，初始化非静态变量，方法,目的就是防止构造函数调用非静态方法属性)
* 构造函数执行，main函数执行
*
* 其实记住三点就行了~~~~搞的我都郁闷死了，给大家总结下：
* 1.先顺序加载static变量
* 2.无论何时只要执行构造函数，那么在执行构造函数方法体之前必须完成非静态变量，方法的加载(不限次数)
* 3.static执行完成后，classloader会执行main方法体，然后就正常执行呗~~~
*/
public static int k = 0;
public static InitJava t1 = new InitJava(&quot;t1&quot;);
public static InitJava t2 = new InitJava(&quot;t2&quot;);
public static int i = print(&quot;i&quot;);//
public static int n = 99;
private int a = 0;
public int j = print(&quot;j&quot;);

{
print(&quot;构造块&quot;);
}
static {
print(&quot;静态块&quot;);
}

public InitJava(String str) {
System.out.println((++k) + &quot;:&quot; + str + &quot; i=&quot; + i + &quot; n=&quot; + n);
++i;
++n;
}

public static int print(String str) {
System.out.println((++k) + &quot;:&quot; + str + &quot; i=&quot; + i + &quot; n=&quot; + n);
++n;
return ++i;
}

public static void main(String args[]) {
InitJava t = new InitJava(&quot;init&quot;);
}

}
1:j i=0 n=0
2:构造块 i=1 n=1
3:t1 i=2 n=2
4:j i=3 n=3
5:构造块 i=4 n=4
6:t2 i=5 n=5
7:i i=6 n=6
8:静态块 i=7 n=99
9:j i=8 n=100
10:构造块 i=9 n=101
11:init i=10 n=102
</code>
</RECORD>
<RECORD>
<snippet_key>210181</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Struts2之ActionContext的初始化时机错误 导致空指针  http://blog.csdn.net/z69183787/article/details/20137133#</comment>
<code>@SuppressWarnings(&quot;serial&quot;)
public abstract class AbstractParamAction extends ActionSupport{
public ActionContext actionContext = ActionContext.getContext();
public HttpServletRequest request = (HttpServletRequest) actionContext.get(ServletActionContext.HTTP_REQUEST);
public HttpServletResponse response = (HttpServletResponse) actionContext.get(ServletActionContext.HTTP_RESPONSE);

//public ServletContext application = (ServletContext)actionContext.getApplication();
public HttpSession session = request.getSession();
}
/**
*
*/
package com.wonders.stpt.marquee.action;

import org.apache.struts2.convention.annotation.Action;
import org.apache.struts2.convention.annotation.Namespace;
import org.apache.struts2.convention.annotation.ParentPackage;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Controller;

import com.wonders.stpt.innerWork.action.AbstractParamAction;
import com.wonders.stpt.marquee.service.MarqueeService;
import com.wonders.stpt.util.ActionWriter;

/**
* @ClassName: MarqueeAction
* @Description: TODO(这里用一句话描述这个类的作用)
* @author zhoushun
* @date 2014年2月28日 下午1:58:40
*
*/

@ParentPackage(&quot;struts-default&quot;)
@Namespace(value=&quot;/marquee&quot;)
@Controller(&quot;marqueeAction&quot;)
@Scope(&quot;prototype&quot;)
public class MarqueeAction extends AbstractParamAction{

/**
*
*/
private static final long serialVersionUID = 4787537184825647031L;

private ActionWriter aw = new ActionWriter(response);
private MarqueeService service;

public MarqueeService getService() {
return service;
}
@Autowired(required=false)
public void setService(@Qualifier(&quot;marqueeService&quot;)MarqueeService service) {
this.service = service;
}


@Action(value=&quot;getMarquee&quot;)
public String getMarquee(){
aw.writeJson(this.service.getMsg());
return null;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>79365</snippet_key>
<tag>java blog 类 91 csdn博客</tag>
<comment>来自CSDN博客：[Java] 抽象类 http://blog.csdn.net/robby_chan/article/details/16917055#</comment>
<code>package com.bjsxt.chap03.abstrac;

abstract class Animal {
private String name;

Animal(String name) {
this.name = name;
}

public abstract void enjoy();
}

abstract class Cat extends Animal {
private String eyesColor;

Cat(String n, String c) {
super(n);
eyesColor = c;
}
}

class Dog extends Animal {
private String furColor;

Dog(String n, String c) {
super(n);
furColor = c;
}

public void enjoy() {
System.out.println(&quot;狗叫声......&quot;);
}
}

class Bird extends Animal {
Bird() {
super(&quot;bird&quot;);
}

public void enjoy() {
System.out.println(&quot;鸟叫声......&quot;);
}
}

class Lady {
private String name;
private Animal pet;

Lady(String name, Animal pet) {
this.name = name;
this.pet = pet;
}

public void myPetEnjoy() {
pet.enjoy();
}
}

public class Test {
public static void main(String args[]) {
//Cat c = new Cat(&quot;catname&quot;, &quot;blue&quot;); error!
Dog d = new Dog(&quot;dogname&quot;, &quot;black&quot;);
Bird b = new Bird();

Lady l2 = new Lady(&quot;l2&quot;, d);
Lady l3 = new Lady(&quot;l3&quot;, b);

l2.myPetEnjoy();
l3.myPetEnjoy();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>194829</snippet_key>
<tag>java spring 定时任务 quarz</tag>
<comment>来自CSDN博客：使用quarz做具体计划时间的执行  http://blog.csdn.net/shunlongjin/article/details/19490301#</comment>
<code>@Service
public class JobService implements InitializingBean,ApplicationContextAware {
@Override
public void afterPropertiesSet() throws Exception {
init();
}
public void init(){
schedulerFactory = new StdSchedulerFactory();
try{
// 通过schedulerFactory获取一个调度器
scheduler=schedulerFactory.getScheduler();
scheduler.setJobFactory(new JobFactory() {
@Override
public Job newJob(TriggerFiredBundle triggerFiredBundle, Scheduler scheduler) throws SchedulerException {
Class jobClass = triggerFiredBundle.getJobDetail().getJobClass();
return (Job) JobService.applicationContext.getBean(jobClass);
}
});

// 启动调度
scheduler.start();
}catch (Exception e){
e.printStackTrace();
}
}
scheduler.setJobFactory(new JobFactory() {
@Override
public Job newJob(TriggerFiredBundle triggerFiredBundle, Scheduler scheduler) throws SchedulerException {
Class jobClass = triggerFiredBundle.getJobDetail().getJobClass();
return (Job) JobService.applicationContext.getBean(jobClass);
}
});
public void runJobAtTime(Date runDate,String name,String group,Map&lt;String,Object&gt; param,Class jobClass) throws SchedulerException {
JobDetail jobDetail = new JobDetailImpl(name,group,jobClass);
if(param != null){
for(String key : param.keySet()){
Object obj = param.get(key);
jobDetail.getJobDataMap().put(key,obj);
}
}
try {
SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;ss mm HH dd MM ? yyyy&quot;);
String expression=simpleDateFormat.format(runDate);
CronTrigger cronTrigger = new CronTriggerImpl(name,group,expression);
scheduler.scheduleJob(jobDetail,cronTrigger);
} catch (ParseException e) {
e.printStackTrace();
}
}
@Service
public class SendWeixinJob implements Job {
@Autowired
private MessageService messageService;
@Override
public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
JobDataMap jobDataMap = jobExecutionContext.getJobDetail().getJobDataMap();
String accountName = jobDataMap.getString(&quot;account_name&quot;);
List&lt;TuWenMsg&gt; tuWenMsgs = (List&lt;TuWenMsg&gt;) jobDataMap.get(&quot;tuwenMsgs&quot;);
String toUser = jobDataMap.getString(&quot;toUser&quot;);
int sendUser = jobDataMap.getInt(&quot;sendUser&quot;);
int sendInfoId = jobDataMap.getInt(&quot;sendInfoId&quot;);
messageService.sendMessageAsync(accountName,tuWenMsgs,toUser,sendUser,sendInfoId);

}
}
public List&lt;JobKey&gt; findAllJobs(){
List&lt;JobKey&gt; jobKeyList = new ArrayList&lt;JobKey&gt;();
try {
GroupMatcher&lt;JobKey&gt; groupMatcher = GroupMatcher.jobGroupEquals(&quot;发送微信&quot;);
Set&lt;JobKey&gt; jobKeys = scheduler.getJobKeys(groupMatcher);
for(JobKey jobKey : jobKeys){
jobKeyList.add(jobKey);
}
} catch (SchedulerException e) {
e.printStackTrace();
}
return jobKeyList;
}
public JobDetail getJobDetail(JobKey jobKey){
try {
return scheduler.getJobDetail(jobKey);
} catch (SchedulerException e) {
e.printStackTrace();
}
return null;
}
public Date getExecDate(JobKey jobKey){
try {
List&lt;CronTrigger&gt; triggers = (List&lt;CronTrigger&gt;) scheduler.getTriggersOfJob(jobKey);
if(triggers.size() != 0){
CronTrigger cronTrigger = triggers.get(0);
SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;ss mm HH dd MM ? yyyy&quot;);
return simpleDateFormat.parse(cronTrigger.getCronExpression());
}
} catch (SchedulerException e) {
e.printStackTrace();
} catch (ParseException e) {
e.printStackTrace();
}
return null;
}
public JobKey getJobKey(int sendInfoId){
return new JobKey(String.valueOf(sendInfoId),&quot;发送微信&quot;);
}
public void deleteJob(JobKey jobKey){
try {
scheduler.deleteJob(jobKey);
} catch (SchedulerException e) {
e.printStackTrace();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>275973</snippet_key>
<tag>java</tag>
<comment>来自CSDN博客：图片解析 http://blog.csdn.net/wenyan07/article/details/22963355#</comment>
<code>/**
* 测试验证码解析
* @author hanmanyi
*
*/
public class TestOCR {
/**
* @param args
* @throws IOException
*/
public static void main(String[] args) throws IOException {
String path = &quot;E:\\ZGCCZJworksp\\HMYTicket\\image\\passCode.jpg&quot;;
// String path = &quot;E:\\ZGCCZJworksp\\HMYTicket\\image\\untitled.bmp&quot;;

// for (int i = 0; i &lt; 100; i++) {
try {

filter(path);
// String valCode = new OCR().recognizeText(&quot;C:\\Program Files\\Tesseract-OCR\\&quot;,new File(path), &quot;jpg&quot;);
// String valCode = new OCR().recognizeText(&quot;C:\\Program Files\\Tesseract-OCR\\&quot;,new File(path), &quot;bmp&quot;);
// valCode = valCode.replace(&quot;\r\n\r\n&quot;, &quot;&quot;);
// System.out.println(i+&quot;|&quot;+valCode);
// } catch (IOException e) {
// e.printStackTrace();
}
catch (Exception e) {
e.printStackTrace();
}
// }
}
/**
* 过滤掉图片中的直线和孤立点
* 用被使用最多的颜色（即背景色）代替
*
*/
public static void filter(String path) {
InputStream instream;
OutputStream out;
String newpath = &quot;E:\\ZGCCZJworksp\\HMYTicket\\image\\new_passCode.jpg&quot;;
try {
BufferedImage imgOrg = ImageIO.read(new File(path));

instream = convert(imgOrg);
// instream = new FileInputStream(new File(path));
out = new FileOutputStream(new File(newpath));
int byteread = 0;
byte[] tmp = new byte[1];
while ((byteread = instream.read(tmp)) != -1) {
out.write(tmp);
}
} catch (Exception e) {
e.printStackTrace();
}
}
/**
* 用被使用最多的颜色（即背景色）代替
* @param imgOrg
*/
private static InputStream convert(BufferedImage img) {
InputStream is = null;
int width = img.getWidth();
int height = img.getHeight();
for (int j = 0; j &lt; height; j++) {
for (int i = 0; i &lt; width; i++) {
Long RGB = Long.parseLong(&quot;&quot;+img.getRGB(i, j));
Map&lt;Long, Integer&gt; map = getMaxColor(img,i,j);
Integer c = map.get(RGB);

System.out.println(RGB);
System.out.println(map);
if (c != null &amp;&amp; c &gt;1) {
img.setRGB(i, j, 0xFF0000);
}
}
}
img.flush();
ImageOutputStream imOut;
ByteArrayOutputStream bs = new ByteArrayOutputStream();
try {
imOut = ImageIO.createImageOutputStream(bs);
ImageIO.write(img, &quot;jpg&quot;,imOut);
is= new ByteArrayInputStream(bs.toByteArray());
} catch (IOException e) {
e.printStackTrace();
}



return is;
}

/**
* 周围使用最多的颜色
* @param imgOrg
*/
private static Map&lt;Long, Integer&gt; getMaxColor(BufferedImage img,int x,int y){
int width = img.getWidth();
int height = img.getHeight();
int range = 2;

Map&lt;Long, Integer&gt; map = new HashMap&lt;Long, Integer&gt;();
for (int j = y-range &lt; 0?0:y-range; j &lt; height &amp;&amp; j&lt;=y+range ; j++) {
for (int i = x-range &lt; 0?0:x-range; i &lt; width &amp;&amp; i&lt;=x+range; i++) {
long RGB = img.getRGB(i, j);
Integer c = map.get(RGB);
if (c == null) {
map.put(RGB, 1);
} else {
map.put(RGB, c + 1);
}
}
}
return map;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>407301</snippet_key>
<tag>194</tag>
<comment>来自CSDN博客：android距离感应器控制黑屏，白屏 http://blog.csdn.net/u012664191/article/details/34840029#</comment>
<code>import android.app.Activity;
import android.content.Context;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.os.Bundle;
import android.os.PowerManager;
import android.util.Log;
import android.view.Menu;
import android.view.View;

public class SensorTest extends Activity implements SensorEventListener{
public static final String TAG = &quot;SensorTest&quot;;

//调用距离传感器，控制屏幕
private SensorManager mManager;//传感器管理对象
//屏幕开关
private PowerManager localPowerManager = null;//电源管理对象
private PowerManager.WakeLock localWakeLock = null;//电源锁

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.sensor);

mManager = (SensorManager)getSystemService(Context.SENSOR_SERVICE);
//获取系统服务POWER_SERVICE，返回一个PowerManager对象
localPowerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);
//获取PowerManager.WakeLock对象,后面的参数|表示同时传入两个值,最后的是LogCat里用的Tag
localWakeLock = this.localPowerManager.newWakeLock(32, &quot;MyPower&quot;);//第一个参数为电源锁级别，第二个是日志tag
}

public void onResume(){
super.onResume();
mManager.registerListener(this, mManager.getDefaultSensor(Sensor.TYPE_PROXIMITY),// 距离感应器
SensorManager.SENSOR_DELAY_NORMAL);//注册传感器，第一个参数为距离监听器，第二个是传感器类型，第三个是延迟类型
}

public void onStop(){
super.onStop();
Log.d(TAG,&quot;on stop&quot;);
}

public void onDestroy(){
super.onDestroy();
Log.d(TAG,&quot;on destroy&quot;);
if(mManager != null){
localWakeLock.release();//释放电源锁，如果不释放finish这个acitivity后仍然会有自动锁屏的效果，不信可以试一试
mManager.unregisterListener(this);//注销传感器监听
}
}

@Override
public void onAccuracyChanged(Sensor sensor, int accuracy) {
// TODO Auto-generated method stub

}

@Override
public void onSensorChanged(SensorEvent event) {
// TODO Auto-generated method stub
float[] its = event.values;
//Log.d(TAG,&quot;its array:&quot;+its+&quot;sensor type :&quot;+event.sensor.getType()+&quot; proximity type:&quot;+Sensor.TYPE_PROXIMITY);
if (its != null &amp;&amp; event.sensor.getType() == Sensor.TYPE_PROXIMITY) {

System.out.println(&quot;its[0]:&quot; + its[0]);

//经过测试，当手贴近距离感应器的时候its[0]返回值为0.0，当手离开时返回1.0
if (its[0] == 0.0) {// 贴近手机

System.out.println(&quot;hands up&quot;);
Log.d(TAG,&quot;hands up in calling activity&quot;);
if (localWakeLock.isHeld()) {
return;
} else{

localWakeLock.acquire();// 申请设备电源锁
}
} else {// 远离手机

System.out.println(&quot;hands moved&quot;);
Log.d(TAG,&quot;hands moved in calling activity&quot;);
if (localWakeLock.isHeld()) {
return;
} else{
localWakeLock.setReferenceCounted(false);
localWakeLock.release(); // 释放设备电源锁
}
}
}
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>472837</snippet_key>
<tag>214</tag>
<comment>javascript html json entity json</comment>
<code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script src=&quot;js/jquery-1.4.2.js&quot;&gt;
&lt;/script&gt;
&lt;script src=&quot;js/json2.js&quot;&gt;
&lt;/script&gt;
&lt;script&gt;
function userinfo(username, password){
this.username = username;
this.password = password;
}

function sendAjax(){
var userinfoRef = new userinfo(&quot;中国&quot;, &quot;中国人&quot;);
var jsonString = JSON.stringify(userinfoRef);
alert(jsonString);
$.ajax({
type: &quot;POST&quot;,
url: &quot;getJSON.spring?t=&quot;+new Date().getTime(),
data: jsonString,
contentType: &quot;application/json&quot;,
dataType:&quot;json&quot;

});

}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
在服务器端取得JSON字符串并解析 &lt;input type=&quot;button&quot; onclick=&quot;javascript:sendAjax()&quot;/&gt;
&lt;/body&gt;
&lt;/html&gt;

package entity;

import java.util.List;

public class Userinfo {
private String username;
private String password;
private List listString;

public Userinfo(String username, String password) {
super();
this.username = username;
this.password = password;
}
public Userinfo() {
super();
// TODO Auto-generated constructor stub
}

public List getListString() {
return listString;
}
public void setListString(List returnList) {
this.listString = returnList;
}
public String getUsername() {
return username;
}
public void setUsername(String username) {
this.username = username;
}
public String getPassword() {
return password;
}
public void setPassword(String password) {
this.password = password;
}

}


package controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import entity.Userinfo;

/**
* 6.13 在控制层传回JSON字符串示例
* @author Administrator
*/

@Controller
public class GetJSON {

@RequestMapping(value = &quot;getJSON&quot;,produces=&quot;application/json&quot;)
public String getJSON(@RequestBody Userinfo userinfo) {

//自动转Entity
System.out.println(&quot;用户名：&quot;+userinfo.getUsername() + &quot; 用户密码： &quot;
+ userinfo.getPassword());
return &quot;index.jsp&quot;;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>210949</snippet_key>
<tag>斐波那契</tag>
<comment>来自CSDN博客：输出斐波那契数列的算法 http://blog.csdn.net/a308690341/article/details/20155897#</comment>
<code>/**
* @param i 第n个数
* @param j 第n+1个数
* @param n 输出个数
*/
public static void ff( int i,int j,int n){
int m=1;
System.out.print(i+&quot;,&quot;);
while(m++&lt;n){
System.out.print(j+&quot;,&quot;);
int k=j;
j=i+j;
i=k;
}
}
public static void main(String args[]){
ff(0,1,10);
}
</code>
</RECORD>
<RECORD>
<snippet_key>260877</snippet_key>
<tag>数据分析 关联规则</tag>
<comment>来自CSDN博客：带有时间效应的关联规则  http://blog.csdn.net/zhu_min/article/details/22320205#</comment>
<code>对于网上购物行为的关联规则如何使用，希望能有大神给些指点~~~
public void ExtractProductforUserWithTime() {
try {
BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;&quot;)));
BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;&quot;)));
DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
ArrayList&lt;String&gt; list2 = new ArrayList&lt;String&gt;();
String line = null;
String string = &quot;&quot;;
while((line = reader.readLine()) != null) {
String []ws = line.split(&quot;,&quot;);
string = ws[0]+&quot;,&quot;+ws[2];
boolean flag = true;
if(set.contains(ws[0])) {
int min = 1000,count = -1;
for(int i = 0;i &lt; list.size();i++) {
String []time = list.get(i).split(&quot;,&quot;);
if(time[0].equals(ws[0])) {
for(int j = 1;j &lt; time.length;j++) {
Date d1 = df.parse(time[j]);
Date d2 = df.parse(ws[2]);
int days = (int)Math.abs( ((d1.getTime() - d2.getTime()) / (1000 * 60 * 60 * 24)));
if(days &lt;=7 &amp;&amp;days &gt;=0) {
if(days&lt;=min) {
min = days;
flag = false;
}
else
continue;
}
if(days &gt;7) {
flag = true;
min = 1000;
break;
}
}
}
else
break;
if(!flag)
count = i;
}
if(count == -1) {
list.add(string);
list2.add(ws[1]);
}
else {
list2.set(count, list2.get(count)+&quot;,&quot;+ws[1]);
list.set(count, list.get(count) + &quot;,&quot; + ws[2]);
}
}
else {
for(int i = 0;i &lt; list.size();i++) {
if(!list2.get(i).equals(&quot;&quot;)) {
writer.write(list.get(i)+&quot;\t&quot; + list2.get(i)+&quot;\n&quot;);
writer.flush();
}
}
list.clear();
list2.clear();
set.add(ws[0]);
list.add(string);
list2.add(ws[1]);
}
}
for(int i = 0;i &lt; list.size();i++) {
if(!list2.get(i).equals(&quot;&quot;)) {
writer.write(list.get(i)+&quot;\t&quot; + list2.get(i)+&quot;\n&quot;);
writer.flush();
}
}
writer.close();
}catch (IOException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} catch (ParseException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>391949</snippet_key>
<tag></tag>
<comment>来自CSDN博客：设计模式——装饰模式  http://blog.csdn.net/xiaobaismiley/article/details/30600257#</comment>
<code>package dai;

public abstract class Bird {
//表示能飞多远
public abstract int fly();
}
package dai;

/**
* @author Roger
* 具体组件
*/
public class Sparrow extends Bird{

@Override
public int fly() {
// TODO Auto-generated method stub
return 100;
}

}
package dai;

public class Decorator extends Bird{

@Override
public int fly() {
// TODO Auto-generated method stub
return 100;
}

}
package dai;


public class SparrowDecorator extends Decorator{
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;Bird sparrow;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;public SparrowDecorator(Bird sparrow) {
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;super(sparrow);
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;this.sparrow = sparrow;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}


&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;@Override
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;public int fly() {
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;// TODO Auto-generated method stub
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;return this.sparrow.fly()+eleFLY();   //在装饰类中加上了新的特性
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;private int eleFLY(){
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;return 50;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}
}
package dai;


public class Client {


&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;/**
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt; * @param args
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt; */
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;public static void main(String[] args) {
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;// TODO Auto-generated method stub
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;//未添加装饰
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;Bird sparrow = new Sparrow();
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;System.out.println(sparrow.fly());
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;//一类装饰是一个类，如果需要添加装饰，只要将需要添加装饰的对象传入，传入的对象已经加过装饰
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;//添加了装饰
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;Bird sparrowDecorator = new SparrowDecorator(sparrow);
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;System.out.println(sparrowDecorator.fly());
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;//继续添加装饰
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;Bird sparrowDecorator2 = new SparrowDecorator(sparrowDecorator);
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;System.out.println(sparrowDecorator2.fly());
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}


}
</code>
</RECORD>
<RECORD>
<snippet_key>457485</snippet_key>
<tag>java</tag>
<comment>来自CSDN博客：第一篇 http://blog.csdn.net/chenkaiadd/article/details/10952751#</comment>
<code>List list = new ArrayList();
list.add(&quot;ok1&quot;);
list.add(&quot;ok2&quot;);
list.add(1, &quot;ok3&quot;);
list.add(2, &quot;ok4&quot;);
ModelAndView mv =new ModelAndView(&quot;success&quot;,&quot;li&quot;,list);
</code>
</RECORD>
<RECORD>
<snippet_key>326669</snippet_key>
<tag>457</tag>
<comment>来自CSDN博客：HashMap--面试必问的集合类  http://blog.csdn.net/zhangming1013/article/details/25003371#</comment>
<code>&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;HashMap&lt;String , Double&gt; map = new HashMap&lt;String , Double&gt;();
map.put(&quot;语文&quot; , 80.0);
map.put(&quot;数学&quot; , 89.0);
map.put(&quot;英语&quot; , 78.2);
public V put(K key, V value)
{
// 如果 key 为 null，调用 putForNullKey 方法进行处理
if (key == null)
return putForNullKey(value);
// 根据 key 的 keyCode 计算 Hash 值
int hash = hash(key.hashCode());
// 搜索指定 hash 值在对应 table 中的索引
int i = indexFor(hash, table.length);
// 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素
for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next)
{
Object k;
// 找到指定 key 与需要放入的 key 相等（hash 值相同
// 通过 equals 比较放回 true）
if (e.hash == hash &amp;&amp; ((k = e.key) == key
|| key.equals(k)))
{
V oldValue = e.value;
e.value = value;
e.recordAccess(this);
return oldValue;
}
}
// 如果 i 索引处的 Entry 为 null，表明此处还没有 Entry
modCount++;
// 将 key、value 添加到 i 索引处
addEntry(hash, key, value, i);
return null;
}
HashMap&lt;String , Double&gt; map = new HashMap&lt;String , Double&gt;();
map.put(&quot;语文&quot; , 80.0);
map.put(&quot;数学&quot; , 89.0);
map.put(&quot;英语&quot; , 78.2);
</code>
</RECORD>
<RECORD>
<snippet_key>457741</snippet_key>
<tag>来自CSDN博客：获取android手机内部存储空间和外部存储空间的参数 &amp;&amp; 如何决定一个apk的安装位置 http://blog.csdn.net/zhandoushi1982/article/details/8560233#</tag>
<comment>派生自DBOY/blog_20140227_1_207337</comment>
<code>import android.os.Environment;
import android.os.StatFs;
import java.io.File;
public long getAvailableInternalMemorySize(){
File path = Environment.getDataDirectory();
StatFs stat = new StatFs(path.getPath());
long blockSize = stat.getBlockSize();
long availableBlocks = stat.getAvailableBlocks();
return availableBlocks*blockSize;
}

public long getTotalInternalMemorySize(){
File path = Environment.getDataDirectory();
StatFs stat = new StatFs(path.getPath());
long blockSize = stat.getBlockSize();
long totalBlocks = stat.getBlockCount();
return totalBlocks*blockSize;
}

public boolean externalMemoryAvailable(){
return Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED);
}

public long getAvailableExternalMemorySize(){
if(externalMemoryAvailable()){
File path = Environment.getExternalStorageDirectory();
StatFs stat = new StatFs(path.getPath());
long blockSize = stat.getBlockSize();
long availableBlocks = stat.getAvailableBlocks();
return availableBlocks*blockSize;
}
else{
return -1;
}
}

public long getTotalExternalMemorySize(){
if(externalMemoryAvailable()){
File path = Environment.getExternalStorageDirectory();
StatFs stat = new StatFs(path.getPath());
long blockSize = stat.getBlockSize();
long totalBlocks = stat.getBlockCount();
return totalBlocks*blockSize;
}
else{
return -1;
}
}
Log.i(&quot;zhangcheng&quot;,&quot;内部可用存储空间是：&quot;+Long.toString(getAvailableInternalMemorySize()/(1024*1024)));
Log.i(&quot;zhangcheng&quot;,&quot;内部总共存储空间是：&quot;+Long.toString(getTotalInternalMemorySize()/(1024*1024)));

Log.i(&quot;zhangcheng&quot;,&quot;外部可用存储空间是：&quot;+Long.toString(getAvailableExternalMemorySize()/(1024*1024)));
Log.i(&quot;zhangcheng&quot;,&quot;外部总共存储空间是：&quot;+Long.toString(getTotalExternalMemorySize()/(1024*1024)));
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>64781</snippet_key>
<tag>327</tag>
<comment>jxl  比对文件相同列 提取自定义列 导入excel 做整合用  另加运行时间  毫秒 转天:时:分:秒</comment>
<code>import jxl.Cell;
import jxl.CellType;
import jxl.Sheet;
import jxl.Workbook;
import jxl.write.Label;

import java.io.File;

/**
* Created with IntelliJ IDEA.
* User: Ro0tSh3ll
* Date: 13-9-27
* Time: 上午11:11
* To change this template use File | Settings | File Templates.
*/
public class excelContrast {
/**
* excel对比导入工具
* @param args
*/
public static void main(String[] args) {
Long startTime = System.currentTimeMillis();
String duibi1=&quot;E:/excel/sk_czy.xls&quot;;
int duibilie1=1;
String duibi2=&quot;E:/excel/yzds_towangf_20130925(3)(1).xls&quot;;
int duibilie2=10;
int tiqulie=1;
String shuchu=&quot;E:/excel/SK_CZY_UID.xls&quot;;
int charulie=2;



dryh(duibi1, duibi2, shuchu, duibilie1, duibilie2, charulie,tiqulie);
Long endTime = System.currentTimeMillis();

System.out.println(format(endTime-startTime));
}

/**
*
* @param duibi1 对比文件1 d
* @param duibi2 对比文件2 d
* @param shuchu 输出文件 d
* @param duibilie1 输入要对比文件1的列 d
* @param duibilie2 输入要对比文件2的列 s
* @param charulie 对比输出文件的输出到列 d
* @param tiqulie 提取文件列输出到charulie d
* @return
*/
public static String dryh(String duibi1, String duibi2, String shuchu, int duibilie1, int duibilie2, int charulie,int tiqulie){
try {
Workbook book = Workbook.getWorkbook(new File(duibi1));
// 获得第一个工作表对象
Sheet sheet = book.getSheet(0);
// 得到第一列第一行的单元格
int columnum = sheet.getColumns();// 得到列数
int rownum = sheet.getRows();// 得到行数
// System.out.println(columnum);
// System.out.println(rownum);
for (int i = 1; i &lt; rownum; i++)// 循环进行读写
{
Cell cell1 = sheet.getCell(duibilie1, i);
String result = cell1.getContents();
// System.out.println(&quot;列名&gt;&gt;&gt;&gt;duibi1&gt;&gt;&gt;&gt;&gt;&quot;+result);
String pd = duqu(result.trim(),duibi2,duibilie2,tiqulie);
if (pd != null) {
Workbook rw = Workbook.getWorkbook(new File(shuchu));

//创建可写入的Excel工作薄对象
jxl.write.WritableWorkbook wwb = Workbook.createWorkbook(new File(shuchu), rw);

//读取第一张工作表
jxl.write.WritableSheet ws = wwb.getSheet(0);

//获得第一个单元格对象
jxl.write.WritableCell wc = ws.getWritableCell(charulie, i);
// System.out.println(&quot;判断返回值&quot;+pd);
//判断单元格的类型, 做出相应的转化

System.out.println(wc.getType());
if (wc.getType() == CellType.LABEL) {
Label l = (Label) wc;
l.setString(pd);
System.out.println(&quot;成功&quot;);
} else if(wc.getType() == CellType.EMPTY){
Label label=new Label(charulie, i,pd);
ws.addCell(label);
System.out.println(&quot;成功&quot;);
} else{
System.out.println(&quot;失败&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+wc.getType());
}

//写入Excel对象
wwb.write();

//关闭可写入的Excel对象
wwb.close();

//关闭只读的Excel对象
rw.close();

System.out.println(pd);
}
// System.out.print(result);
// System.out.print(&quot;\t&quot;);
// System.out.println();
}
book.close();
} catch (Exception e) {
System.out.println(e);
}
return null;
}

public static String duqu(String zhi,String duibi2,int duibilie2,int tiqulie) {
String bl = null;
try {

Workbook book = Workbook.getWorkbook(new File(duibi2));
// 获得第一个工作表对象
Sheet sheet = book.getSheet(0);
// 得到第一列第一行的单元格
int columnum = sheet.getColumns();// 得到列数
int rownum = sheet.getRows();// 得到行数
// System.out.println(columnum);
// System.out.println(rownum);
for (int i = 1; i &lt; rownum; i++)// 循环进行读写
{
Cell cell1 = sheet.getCell(duibilie2, i);
String result = cell1.getContents();
// if (zhi.trim()==result.trim()){
// System.out.println(zhi+&quot;===============&quot;+result);
// }

// System.out.print(zhi==result+zhi+result);
// System.out.println(&quot;result&quot;+result+&quot;zhi:&quot;+zhi+&quot;结果:&quot;+zhi.equals(result));
if (zhi.equals(result.replace(&quot;\&quot;&quot;,&quot;&quot;).trim())) {
Cell cell2 = sheet.getCell(tiqulie, i);
bl = cell2.getContents();
return bl;
}
// System.out.print(result);
// System.out.print(&quot;\t&quot;);
// System.out.println();
}

book.close();

} catch (Exception e) {
System.out.println(e);
}
return bl;
}

public static String format(long ms) {//将毫秒数换算成x天x时x分x秒x毫秒
int ss = 1000;
int mi = ss * 60;
int hh = mi * 60;
int dd = hh * 24;
long day = ms / dd;
long hour = (ms - day * dd) / hh;
long minute = (ms - day * dd - hour * hh) / mi;
long second = (ms - day * dd - hour * hh - minute * mi) / ss;
long milliSecond = ms - day * dd - hour * hh - minute * mi - second * ss;
String strDay = day &lt; 10 ? &quot;0&quot; + day : &quot;&quot; + day;
String strHour = hour &lt; 10 ? &quot;0&quot; + hour : &quot;&quot; + hour;
String strMinute = minute &lt; 10 ? &quot;0&quot; + minute : &quot;&quot; + minute;
String strSecond = second &lt; 10 ? &quot;0&quot; + second : &quot;&quot; + second;
String strMilliSecond = milliSecond &lt; 10 ? &quot;0&quot; + milliSecond : &quot;&quot; + milliSecond;
strMilliSecond = milliSecond &lt; 100 ? &quot;0&quot; + strMilliSecond : &quot;&quot; + strMilliSecond;
// return strDay + &quot; &quot; + strHour + &quot;:&quot; + strMinute + &quot;:&quot; + strSecond + &quot; &quot; + strMilliSecond;
return strDay + &quot; &quot; + strHour + &quot;:&quot; + strMinute + &quot;:&quot; + strSecond + &quot; &quot; + strMilliSecond;
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>80389</snippet_key>
<tag>LIBGDX blog 91 csdn博客</tag>
<comment>来自CSDN博客：Libgdx专题系列：对象篇 纹理的旋转，放缩，位移  http://blog.csdn.net/wu928320442/article/details/16900125#</comment>
<code>public class FirstGame implements ApplicationListener
{

private Pixmap mPixmap;
private Texture mTexture;
private TextureRegion mTextureRegion;
private SpriteBatch mSpriteBatch;
private OrthographicCamera mCamera;

private float mScaleX;
private float mScaleY;
private float mRotation;
private float mTransfer;
private float timer;

@Override
public void create()
{
mPixmap = new Pixmap(Gdx.files.internal(&quot;gremlins.png&quot;));
mTexture = new Texture(mPixmap);
mTextureRegion = new TextureRegion(mTexture, 0, 0, 30, 30);
mSpriteBatch = new SpriteBatch();
// 镜头需要设定宽高和镜头中间位置
mCamera = new OrthographicCamera(800, 480);
mCamera.position.set(800 / 2, 480 / 2, 0);

mScaleX = 1;
mScaleY = 1;
mRotation = 0;
mTransfer = 0;
}

@Override
public void resize(int width, int height)
{
// 确保AndroidManifest.xml里面的Activity配置为横屏
// 宽和高才是横屏的值的返回，默认为竖屏的值
}

@Override
public void render()
{
// 镜头的更新与设置矩阵到SpriteBatch
mCamera.update();
mSpriteBatch.setProjectionMatrix(mCamera.combined);

timer += Gdx.graphics.getDeltaTime();
// 1.移动
if (timer &lt; 3)
{
//每秒移动50像素
mTransfer += 50 * Gdx.graphics.getDeltaTime();
}
// 2.放缩
else if (timer &gt; 3 &amp;&amp; timer &lt; 6)
{
mTransfer=0;
//每秒xy方向上放大1倍
mScaleX += 1 * Gdx.graphics.getDeltaTime();
mScaleY += 1 * Gdx.graphics.getDeltaTime();
}
// 3.翻转
else if (timer &gt; 6 &amp;&amp; timer &lt; 9)
{
mTransfer=0;
mScaleX=1;
mScaleY=1;
//每秒旋转90度
mRotation += 90 * Gdx.graphics.getDeltaTime();
}
else
{
timer = 0;
mTransfer = 0;
mScaleX = 1;
mScaleY = 1;
mRotation=0;
}
Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);

mSpriteBatch.begin();
//这里的15,15是放缩旋转的中心点， 他是根据纹理区域左下角来计算的
//30,30是要要放缩到的大小，这里和剪切区域大小一致
mSpriteBatch.draw(mTextureRegion, 400 + mTransfer, 240, 15, 15, 30, 30,
mScaleX, mScaleY, mRotation);
mSpriteBatch.end();
}

@Override
public void pause()
{
// TODO Auto-generated method stub

}

@Override
public void resume()
{
// TODO Auto-generated method stub

}

@Override
public void dispose()
{
// 所有实现Disposable接口的都需要释放资源
mPixmap.dispose();
mTexture.dispose();
mSpriteBatch.dispose();
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>145925</snippet_key>
<tag>63</tag>
<comment>来自CSDN博客：十、Spring  AOP注解实现  http://blog.csdn.net/kuailefangyuan/article/details/17959839#</comment>
<code>package org.meify.bean;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

/**
* 作者类
* 使用Component约定实现零配置
* @description
* @version 1.0
* @author meify 2014-1-2 下午2:47:14
*/
//指定bean的作用域
@Scope(&quot;prototype&quot;)
//给AuthorBean指定实例名为author
@Component(&quot;author&quot;)
public class AuthorBean {

private String id;
private String name;
private int age;
private String address;

public AuthorBean() {
super();
}

public AuthorBean(String id, String name, int age, String address) {
this.id = id;
this.name = name;
this.age = age;
this.address = address;
}

public String getId() {
return id;
}

public void setId(String id) {
this.id = id;
}

public String getName() {
return name;
}

public void setName(String name) {
this.name = name;
}

public int getAge() {
return age;
}

public void setAge(int age) {
this.age = age;
}

public String getAddress() {
return address;
}

public void setAddress(String address) {
this.address = address;
}

public String toString() {
return &quot;作者编号：&quot; + id + &quot;；作者姓名：&quot; + name + &quot;;作者年龄：&quot; + age + &quot;；作者住址：&quot; + address;
}

//在容器对bean的依赖关系注入完成后回调该方法
@PostConstruct
public void init() {
System.out.println(&quot;正在初始化AuthorBean。。。。&quot;);
}

//在容器销毁该bean之前回调该方法
@PreDestroy
public void close() {
System.out.println(&quot;正在执行销毁AuthorBean。。。&quot;);
}


public String write(){
System.out.println(&quot;作家正在写作。。。。&quot;);
return &quot;完成初稿啦。。。&quot;;
}

public void throwException(){
//1、这里抛出一个异常，但是自己处理了，所以异常增强处理不会再去处理该异常
try {
throw new Exception(&quot;不好好写作。。。&quot;);
} catch (Exception e) {
// TODO Auto-generated catch block
System.out.println(&quot;写作出现异常啦。。。&quot;);
}
//2、故意引发一个异常且不做处理,这时异常增强处理就会去处理该异常
System.out.println(5/0);
}


public void insert(String name,String text){
System.out.println(&quot;指行insert方法&quot;);
System.out.println(name+&quot;正在执行插入操作。。。。&quot;);
System.out.println(&quot;插入的内容为&quot;+text);
}


}
package org.meify.advice;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

/**
* 编写一个切面Bean
* 注意：声明bean为切面bean后，Spring将不会将它作为组件bean来处理，
* 因此，负责自动增强的后处理bean将略过切面bean，不会对它进行任何处理
* @description
* @version 1.0
* @author meify 2014-1-6 下午5:24:56
*/
@Aspect
public class MyAspect {


/**
* 指定执行AuthorBean的toString()方法之前执行增强处理
* @version 1.0
* @description
* @author meify 2014-1-7 上午10:12:35
*/
@Before(&quot;execution(* org.meify.bean.AuthorBean.toString())&quot;)
public void beforeAdvice(){
System.out.println(&quot;before-----处理&quot;);
System.out.println(&quot;作家正在酝酿初稿中。。。。&quot;);
}


/**
* AfterRunning增强处理
* @version 1.0
* @description
* @author meify 2014-1-7 上午10:12:05
*/
@AfterReturning(returning=&quot;result&quot;,pointcut=&quot;execution(* org.meify.bean.AuthorBean.write()))&quot;)
public void afterRunningAdvice(Object result){
System.out.println(&quot;after-------处理&quot;);
System.out.println(&quot;获取的参数为====&quot;+result.toString());
}

/**
* Throwable 增强处理
* 注意异常会继续传播到上一级调用者，最后传播到jvm，导致程序中止
* @param ex
* @version 1.0
* @description
* @author meify 2014-1-7 上午10:20:34
*/
@AfterThrowing(throwing=&quot;ex&quot;,pointcut=&quot;execution(* org.meify.bean.AuthorBean.throwException()))&quot;)
public void catchException(Throwable ex){
System.out.println(&quot;抛出异常后的增强处理&quot;);
System.out.println(&quot;处理捕获到目标方法中抛出的异常为==&quot;+ex);
}

/**
* round增强处理
* @version 1.0
* @description
* @author meify 2014-1-7 上午10:29:06
* @throws Throwable
*/
@Around(&quot;execution(* org.meify.bean.AuthorBean.insert(*,*)))&quot;)
public void roundAdvice(ProceedingJoinPoint joinpoint) throws Throwable{
System.out.println(&quot;执行insert()方法之前增强处理。。。。&quot;);
//在目标方法执行之前获取目标方法的参数
Object[] objs=joinpoint.getArgs();
System.out.println(&quot;获取的目标方法的参数为&quot;);
for( int i=0;i&lt;objs.length;i++){
System.out.println(objs[i]);
}

joinpoint.proceed(); //procced()方法——调用目标方法
/* //获取当前Aop框架为目标对象生成的代理对象
System.out.println(joinpoint.getThis());*/
System.out.println(&quot;执行insert()方法之后增强处理。。。。&quot;);
}




}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context-3.0.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx-3.0.xsd&quot;&gt;

&lt;!-- 配置包扫描器 :自动扫描包以及其自包下的所有bean类--&gt;
&lt;context:component-scan base-package=&quot;org.meify.bean,org.meify.advice&quot;&gt;
&lt;!-- 使用正则表达式来限制或者排除某些bean --&gt;
&lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.aspectj.lang.annotation.Aspect&quot;&gt;&lt;/context:include-filter&gt;
&lt;!-- &lt;context:include-filter type=&quot;regex&quot; expression=&quot;.*Bean&quot;&gt;&lt;/context:include-filter&gt;
&lt;context:exclude-filter type=&quot;regex&quot; expression=&quot;.*Event&quot;&gt;&lt;/context:exclude-filter&gt; --&gt;
&lt;/context:component-scan&gt;

&lt;!-- 开启@AspectJ支持 --&gt;
&lt;aop:aspectj-autoproxy/&gt;




&lt;/beans&gt;
package org.meify.test;

import java.sql.SQLException;

import org.meify.bean.AuthorBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
* 测试AOP编程
* @description
* @version 1.0
* @author meify 2014-1-3 下午2:15:20
*/
public class Test01 {
public static void main(String[] args) throws SQLException {
ApplicationContext ctx=new ClassPathXmlApplicationContext(&quot;spring-config.xml&quot;);
System.out.println(ctx);

AuthorBean author=ctx.getBean(&quot;author&quot;,AuthorBean.class);
System.out.println(author);

author.write();

author.insert(&quot;梅方元&quot;,&quot;今天是个好日子，好日子啊好日子。。。。&quot;);

author.throwException();
}
}
org.springframework.context.support.ClassPathXmlApplicationContext@df503: startup date [Tue Jan 07 10:53:06 CST 2014]; root of context hierarchy
正在初始化AuthorBean。。。。
before-----处理
作家正在酝酿初稿中。。。。
作者编号：null；作者姓名：null;作者年龄：0；作者住址：null
作家正在写作。。。。
after-------处理
获取的参数为====完成初稿啦。。。
执行insert()方法之前增强处理。。。。
获取的目标方法的参数为
梅方元
今天是个好日子，好日子啊好日子。。。。
指行insert方法
梅方元正在执行插入操作。。。。
插入的内容为今天是个好日子，好日子啊好日子。。。。
执行insert()方法之后增强处理。。。。
写作出现异常啦。。。
抛出异常后的增强处理
处理捕获到目标方法中抛出的异常为==java.lang.ArithmeticException: / by zero
Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero
at org.meify.bean.AuthorBean.throwException(AuthorBean.java:101)
at org.meify.bean.AuthorBean$$FastClassByCGLIB$$b3f9f1e5.invoke(&lt;generated&gt;)
at net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:149)
at org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invokeJoinpoint(Cglib2AopProxy.java:692)
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:150)
at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:55)
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:89)
at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
at org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.intercept(Cglib2AopProxy.java:625)
at org.meify.bean.AuthorBean$$EnhancerByCGLIB$$902d5169.throwException(&lt;generated&gt;)
at org.meify.test.Test01.main(Test01.java:27)
</code>
</RECORD>
<RECORD>
<snippet_key>261389</snippet_key>
<tag>javascript browser chrome function stylesheet</tag>
<comment>来自CSDN博客：high一下 http://blog.csdn.net/u012859193/article/details/22190245#</comment>
<code>&lt;a title=&quot;把这个链接拖到你的Chrome收藏夹工具栏中&quot; href=&apos;javascript:(function() {
function c() {
var e = document.createElement(&quot;link&quot;);
e.setAttribute(&quot;type&quot;, &quot;text/css&quot;);
e.setAttribute(&quot;rel&quot;, &quot;stylesheet&quot;);
e.setAttribute(&quot;href&quot;, f);
e.setAttribute(&quot;class&quot;, l);
document.body.appendChild(e)
}

function h() {
var e = document.getElementsByClassName(l);
for (var t = 0; t &lt; e.length; t++) {
document.body.removeChild(e[t])
}
}

function p() {
var e = document.createElement(&quot;div&quot;);
e.setAttribute(&quot;class&quot;, a);
document.body.appendChild(e);
setTimeout(function() {
document.body.removeChild(e)
}, 100)
}

function d(e) {
return {
height : e.offsetHeight,
width : e.offsetWidth
}
}

function v(i) {
var s = d(i);
return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r
}

function m(e) {
var t = e;
var n = 0;
while (!!t) {
n += t.offsetTop;
t = t.offsetParent
}
return n
}

function g() {
var e = document.documentElement;
if (!!window.innerWidth) {
return window.innerHeight
} else if (e &amp;&amp; !isNaN(e.clientHeight)) {
return e.clientHeight
}
return 0
}

function y() {
if (window.pageYOffset) {
return window.pageYOffset
}
return Math.max(document.documentElement.scrollTop, document.body.scrollTop)
}

function E(e) {
var t = m(e);
return t &gt;= w &amp;&amp; t &lt;= b + w
}

function S() {
var e = document.createElement(&quot;audio&quot;);
e.setAttribute(&quot;class&quot;, l);
e.src = i;
e.loop = false;
e.addEventListener(&quot;canplay&quot;, function() {
setTimeout(function() {
x(k)
}, 500);
setTimeout(function() {
N();
p();
for (var e = 0; e &lt; O.length; e++) {
T(O[e])
}
}, 15500)
}, true);
e.addEventListener(&quot;ended&quot;, function() {
N();
h()
}, true);
e.innerHTML = &quot; &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;&quot;;
document.body.appendChild(e);
e.play()
}

function x(e) {
e.className += &quot; &quot; + s + &quot; &quot; + o
}

function T(e) {
e.className += &quot; &quot; + s + &quot; &quot; + u[Math.floor(Math.random() * u.length)]
}

function N() {
var e = document.getElementsByClassName(s);
var t = new RegExp(&quot;\\b&quot; + s + &quot;\\b&quot;);
for (var n = 0; n &lt; e.length; ) {
e[n].className = e[n].className.replace(t, &quot;&quot;)
}
}

var e = 30;
var t = 30;
var n = 350;
var r = 350;
var i = &quot;//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3&quot;;
var s = &quot;mw-harlem_shake_me&quot;;
var o = &quot;im_first&quot;;
var u = [&quot;im_drunk&quot;, &quot;im_baked&quot;, &quot;im_trippin&quot;, &quot;im_blown&quot;];
var a = &quot;mw-strobe_light&quot;;
var f = &quot;//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css&quot;;
var l = &quot;mw_added_css&quot;;
var b = g();
var w = y();
var C = document.getElementsByTagName(&quot;*&quot;);
var k = null;
for (var L = 0; L &lt; C.length; L++) {
var A = C[L];
if (v(A)) {
if (E(A)) {
k = A;
break
}
}
}
if (A === null) {
console.warn(&quot;Could not find a node of the right size. Please try a different page.&quot;);
return
}
c();
S();
var O = [];
for (var L = 0; L &lt; C.length; L++) {
var A = C[L];
if (v(A)) {
O.push(A)
}
}
})() &apos;&gt;High一下!&lt;/a&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>326925</snippet_key>
<tag>63</tag>
<comment>annotation</comment>
<code>package cn.lmj.annotation;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.reflect.Field;

public class Person
{
//通过注解注入对象
@Inject(name=&quot;cn.lmj.annotation.Book&quot;)
private Book book;

public Book getBook()
{
return this.book;
}

public static void main(String[] args)
{
//对象由工厂产生
Person p = Factory.getBean(Person.class);
System.out.println(p.getBook());
}
}

class Book
{

}

@Retention(RetentionPolicy.RUNTIME)
@interface Inject
{
String name();
}

//工厂对象
class Factory
{
//产生对象
public static &lt;T&gt; T getBean(Class&lt;?&gt; clazz)
{
try
{
Object obj = clazz.newInstance();
Field[] fields = obj.getClass().getDeclaredFields();
for(int i = 0;fields!=null &amp;&amp; i&lt;fields.length;i++)
{
Field f = fields[i];
f.setAccessible(true);
Inject inject = f.getAnnotation(Inject.class);
if(inject != null)
{
String classname = inject.name();
Object o = Class.forName(classname).newInstance();
f.set(obj, o);
}
}

return (T) obj;
}
catch (Exception e)
{
e.printStackTrace();
throw new RuntimeException(e);
}

}
}
</code>
</RECORD>
<RECORD>
<snippet_key>408069</snippet_key>
<tag></tag>
<comment>来自CSDN博客：java并发编程-Executor框架  http://blog.csdn.net/petib_wangwei/article/details/35235345#</comment>
<code>Executor executor = Executors.newFixedThreadPool(10);
Runnable task = new Runnable() {
@Override
public void run() {
System.out.println(&quot;task over&quot;);
}
};
executor.execute(task);

executor = Executors.newScheduledThreadPool(10);
ScheduledExecutorService scheduler = (ScheduledExecutorService) executor;
scheduler.scheduleAtFixedRate(task, 10, 10, TimeUnit.SECONDS);
ExecutorService executorService = (ExecutorService) executor;
while (!executorService.isShutdown()) {
try {
executorService.execute(task);
} catch (RejectedExecutionException ignored) {

}
}
executorService.shutdown();
Callable&lt;Integer&gt; func = new Callable&lt;Integer&gt;(){
public Integer call() throws Exception {
System.out.println(&quot;inside callable&quot;);
Thread.sleep(1000);
return new Integer(8);
}
};
FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(func);
Thread newThread = new Thread(futureTask);
newThread.start();

try {
System.out.println(&quot;blocking here&quot;);
Integer result = futureTask.get();
System.out.println(result);
} catch (InterruptedException ignored) {
} catch (ExecutionException ignored) {
}
package executorservice;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;

public class ConcurrentCalculator {

private ExecutorService exec;
private int cpuCoreNumber;
private List&lt;Future&lt;Long&gt;&gt; tasks = new ArrayList&lt;Future&lt;Long&gt;&gt;();

// 内部类
class SumCalculator implements Callable&lt;Long&gt; {
private int[] numbers;
private int start;
private int end;

public SumCalculator(final int[] numbers, int start, int end) {
this.numbers = numbers;
this.start = start;
this.end = end;
}

public Long call() throws Exception {
Long sum = 0l;
for (int i = start; i &lt; end; i++) {
sum += numbers[i];
}
return sum;
}
}

public ConcurrentCalculator() {
cpuCoreNumber = Runtime.getRuntime().availableProcessors();
exec = Executors.newFixedThreadPool(cpuCoreNumber);
}

public Long sum(final int[] numbers) {
// 根据CPU核心个数拆分任务，创建FutureTask并提交到Executor
for (int i = 0; i &lt; cpuCoreNumber; i++) {
int increment = numbers.length / cpuCoreNumber + 1;
int start = increment * i;
int end = increment * i + increment;
if (end &gt; numbers.length)
end = numbers.length;
SumCalculator subCalc = new SumCalculator(numbers, start, end);
FutureTask&lt;Long&gt; task = new FutureTask&lt;Long&gt;(subCalc);
tasks.add(task);
if (!exec.isShutdown()) {
exec.submit(task);
}
}
return getResult();
}

/**
* 迭代每个只任务，获得部分和，相加返回
*
* @return
*/
public Long getResult() {
Long result = 0l;
for (Future&lt;Long&gt; task : tasks) {
try {
// 如果计算未完成则阻塞
Long subSum = task.get();
result += subSum;
} catch (InterruptedException e) {
e.printStackTrace();
} catch (ExecutionException e) {
e.printStackTrace();
}
}
return result;
}

public void close() {
exec.shutdown();
}
}
int[] numbers = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 10, 11 };
ConcurrentCalculator calc = new ConcurrentCalculator();
Long sum = calc.sum(numbers);
System.out.println(sum);
calc.close();
public class ConcurrentCalculator2 {

private ExecutorService exec;
private CompletionService&lt;Long&gt; completionService;


private int cpuCoreNumber;

// 内部类
class SumCalculator implements Callable&lt;Long&gt; {
......
}

public ConcurrentCalculator2() {
cpuCoreNumber = Runtime.getRuntime().availableProcessors();
exec = Executors.newFixedThreadPool(cpuCoreNumber);
completionService = new ExecutorCompletionService&lt;Long&gt;(exec);


}

public Long sum(final int[] numbers) {
// 根据CPU核心个数拆分任务，创建FutureTask并提交到Executor
for (int i = 0; i &lt; cpuCoreNumber; i++) {
int increment = numbers.length / cpuCoreNumber + 1;
int start = increment * i;
int end = increment * i + increment;
if (end &gt; numbers.length)
end = numbers.length;
SumCalculator subCalc = new SumCalculator(numbers, start, end);
if (!exec.isShutdown()) {
completionService.submit(subCalc);


}

}
return getResult();
}

/**
* 迭代每个只任务，获得部分和，相加返回
*
* @return
*/
public Long getResult() {
Long result = 0l;
for (int i = 0; i &lt; cpuCoreNumber; i++) {
try {
Long subSum = completionService.take().get();
result += subSum;
} catch (InterruptedException e) {
e.printStackTrace();
} catch (ExecutionException e) {
e.printStackTrace();
}
}
return result;
}

public void close() {
exec.shutdown();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>261645</snippet_key>
<tag>android ListView属性 ListView背景 ListView颜色</tag>
<comment>来自CSDN博客：Android ListView重要美化属性  http://blog.csdn.net/cs_li1126/article/details/22384143#</comment>
<code>android:fadingEdge=&quot;none&quot;
android:cacheColorHint=“#00000000”
android:listSelector=&quot;#00000000&quot;
android:scrollbars=&quot;none&quot; ä¸ setVerticalScrollBarEnabled(true);
</code>
</RECORD>
<RECORD>
<snippet_key>211717</snippet_key>
<tag>stringbuilder string stringbuffer</tag>
<comment>来自CSDN博客：String StringBuffer 和StringBuilder区别  http://blog.csdn.net/Caesardadi/article/details/11903067#</comment>
<code>stringBuilder.append(&quot;-&quot; + newMonth);
stringBuilder.append(&quot;-&quot;).append(newMonth);
</code>
</RECORD>
<RECORD>
<snippet_key>196365</snippet_key>
<tag>327</tag>
<comment>来自CSDN博客：java中的IO流。  http://blog.csdn.net/javawebxy/article/details/12997301#</comment>
<code>import java.io.*;
class hello{
public static void main(String[] args) {
File file=new File(&quot;D:\\hello.txt&quot;);
try{
file.方法名();
//file.createNewFile 创建一个新文件
//file.delete 删除一个文件
}catch (Exception e) {
e.printStackTrace();
}
}
}
/**
* 在d盘创建一个名字为hell的文件夹
* */
import java.io.*;
class hello{
public static void main(String[] args) {
String fileName=&quot;D:&quot;+File.separator+&quot;hello&quot;;
File f=new File(fileName);
f.mkdir();
}
}
/**
* 使用list列出指定目录的全部文件
* */
import java.io.*;
class hello{
public static void main(String[] args) {
String fileName=&quot;D:&quot;+File.separator;
File f=new File(fileName);
String[] str=f.list();//返回String数组是文件名的集合,如360Downloads，360，Program。
//File[] str = f.listFiles() 返回File类型的数组集合，得到具体的地址，如D:\360Downloads，D:\360，D:\Program等等
for(String str:fileNameList){
            System.out.println(str);
        }
}
}
package com.xy.study.io.fileStream;

import java.io.File;

/**
* description:递归方法列出一个目录中的所有内容
* @author 许阳
*/
public class listAllFileOfPath {

public File print(File file){
if(file!=null){
File[] files = file.listFiles();
for(File file1: files){
if(file1.isDirectory()){
print(file1);
}else{
System.out.println(file1);
}
}
}
return null;
}
public static void main(String [] args){
String filePath = &quot;D:/&quot;;
File file = new File(filePath);
new listAllFileOfPath().print(file);
}
}
public class outputStringToFile {
public static void main(String [] args){
String filePath = &quot;d:&quot;+ File.separator+&quot;test.txt&quot;;
File file = new File(filePath);
try{
OutputStream outputStream = new FileOutputStream(file);//FileOutputStream(file,true) 向文件追加内容。
//FileOutStream是OutputStream接口的一个具体实现，具体可看最上面的示意图。
String str = &quot;Hello World，Hello Java！&quot;;//String str = &quot;\r\n&quot;是换行的意思
byte[] bytes = str.getBytes();
outputStream.write(bytes);
outputStream.close();
}catch (Exception e){
e.printStackTrace();
}
}
}
public class inputStringFromFile {
public static void main(String [] args){
String path = &quot;d:&quot;+ File.separator+&quot;test.txt&quot;;
File file = new File(path);
try {
InputStream inputStream = new FileInputStream(file);
byte[] bytes = new byte[1024];//byte[] b=new byte[(int)file.length()];指定一次性读取所有内容。避免设定的大小或者太小。
int len;
if((len=inputStream.read(bytes))!=-1){//查看文件是否读到了末尾，若是，返回-1
System.out.println(&quot;读取的长度为&quot;+len);
System.out.print(new String(bytes,0,len));
}else{
inputStream.close();
}
} catch (Exception e) {
e.printStackTrace();
}
}
}
public class writeStringToFile {
public static void main(String [] args) {
String filePath = &quot;d:&quot;+File.separator+&quot;test.txt&quot;;
File file = new File(filePath);
try {
Writer writer = new FileWriter(file);//Writer out =new FileWriter(f,true);向文件中追加内容。
String str = &quot;雄关漫道真如铁，而今迈步从头越。&quot;;
writer.write(str);
writer.close();
} catch (IOException e) {
e.printStackTrace();
}
}
}
public class readStringFromFile {
public static void main(String [] args) {
String filePath = &quot;d:&quot;+ File.separator+&quot;test.txt&quot;;
File file = new File(filePath);
try {
Reader reader = new FileReader(file);
char[] chars = new char[100];
int len;
if((len = reader.read(chars))!=-1){
System.out.println(&quot;读取的长度为&quot;+len);
System.out.print(new String(chars,0,len));
}
reader.close();
} catch (IOException e) {
e.printStackTrace();
}
}
}
public class fileOutputStreamToOutputStreamWriter {
public static void main(String [] args){
File file = new File(&quot;d:&quot;+File.separator+&quot;test.txt&quot;);
try {
Writer writer = new OutputStreamWriter(new FileOutputStream(file));
writer.write(&quot;hello&quot;);
writer.close();
} catch (Exception e) {
e.printStackTrace();
}
}
}
public class fileInputStreamToInputStreamReader {
public static void main(String[] args){
String filePath = &quot;d:&quot;+ File.separator+&quot;test.txt&quot;;
try {
Reader reader = new InputStreamReader(new FileInputStream(filePath));
char[] chars = new char[1024];
int len;
if((len=reader.read(chars))!=-1){
System.out.println(new String(chars,0,len));
}
} catch (Exception e) {
e.printStackTrace();
}
}
}
//使用内存流将字符串读入转换成小写字母然后输出
public class byteArrayChangeString {
public static void main(String [] args){
String str = &quot;XUYANG&quot;;
ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
ByteArrayInputStream inputStream = new ByteArrayInputStream(str.getBytes());
int len ;
while((len=inputStream.read())!=-1){
char ch = (char)len;
outputStream.write(Character.toLowerCase(ch));
}
String outStr = outputStream.toString();
try {
inputStream.close();
outputStream.close();
} catch (IOException e) {
e.printStackTrace();
}
System.out.println(outStr);
}
}
public class MessageSend implements Runnable{
private PipedOutputStream outputStream = null;

public MessageSend(){
outputStream = new PipedOutputStream();
}

public PipedOutputStream getOutputStream(){
return this.outputStream;
}

@Override
public void run() {
String message = &quot;Hello World,Hello Java!&quot;;
byte[] bytes = message.getBytes();
try {
outputStream.write(bytes);
} catch (IOException e) {
e.printStackTrace();
}
try {
outputStream.close();
} catch (IOException e) {
e.printStackTrace();
}
}
}
public class MessageReceive implements Runnable {
private PipedInputStream inputStream = null;

public MessageReceive(){
inputStream = new PipedInputStream();
}

public PipedInputStream getInputStream(){
return this.inputStream;
}
@Override
public void run() {
byte[] bytes = new byte[1000];
int len;
try {
if((len = inputStream.read(bytes))!=-1){
System.out.println(&quot;接收的内容为&quot;+new String(bytes,0,len));
}
} catch (IOException e) {
e.printStackTrace();
}
try {
inputStream.close();
} catch (IOException e) {
e.printStackTrace();
}
}
}
public class PipedStreamSocket {
public static void main(String [] args){
MessageSend messageSend = new MessageSend();
MessageReceive messageReceive = new MessageReceive();
//连接管道
try {
messageSend.getOutputStream().connect(messageReceive.getInputStream());
} catch (IOException e) {
e.printStackTrace();
}
new Thread(messageSend).start();
new Thread(messageReceive).start();
}
}
public class PrintStringToFile{
public static void main(String [] args) throws Exception{
PrintStream printStream = new PrintStream(new FileOutputStream(new File(&quot;d:&quot;+File.separator+&quot;test.txt&quot;)));
String str = &quot;雄关漫道真如铁，而今迈步从头越！&quot;;
//byte[] bytes = str.getBytes(); 不能转化成字节打印，否则是乱码。
printStream.println(str);
printStream.close();
}
}
public class PrintStringRedirect {
public static void main(String[] args) throws Exception{
System.out.println(&quot;这些在控制台可以看到&quot;);
OutputStream outputStream = new FileOutputStream(new File(&quot;D:&quot;+File.separator+&quot;test.txt&quot;));
System.setOut(new PrintStream(outputStream));
System.out.println(&quot;这些在文件中才能看到&quot;);
}
}
public class myException extends Exception {
public myException(int i){
super(&quot;您输入的数为&quot;+i);
}
}
public class PrintErrorRedirect {
public static void main(String [] args) throws Exception{
System.err.println(&quot;这些在控制台可以看到&quot;);
PrintStream printStream = new PrintStream(new FileOutputStream(new File(&quot;d:&quot;+File.separator+&quot;test.txt&quot;)));
System.setErr(printStream);
int i = 10;
if(i&gt;0){
throw new MyException(i);
}
}
}
//从文件读取内容而不从键盘录入
public class SystemInRedirect {
public static void main(String[] args) throws Exception{
File file = new File(&quot;d:&quot;+File.separator+&quot;test.txt&quot;);
System.setIn(new FileInputStream(file));
byte[] bytes = new byte[1024];
int len;
if((len=System.in.read(bytes))!=-1){
System.out.println(new String(bytes,0,len));
}
}
}
public class BufferedReaderInputSystemIn {
public static void main(String [] args) throws Exception{
File file = new File(&quot;d:&quot;+File.separator+&quot;test.txt&quot;);
BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
String str = null;
System.out.println(&quot;请输入内容：&quot;);
System.setOut(new PrintStream(new FileOutputStream(file)));
str = bufferedReader.readLine();
System.out.println(str);
}
}
public class ScannerReadSystemIn {
public static void main(String [] args){
Scanner scanner = new Scanner(System.in);
System.out.println(&quot;请输入：&quot;);
String a = scanner.next();
//int a = scanner.nextInt();整数型
//long a = scanner.nextLong();长整型
System.out.println(a);
}
}
public class DataOutputStreamWriteStringToFile {
public static void main(String[] args) throws Exception{
File file = new File(&quot;d:&quot;+File.separator+&quot;test.txt&quot;);
DataOutputStream outputStream = new DataOutputStream(new FileOutputStream(file));
DataInputStream inputStream = new DataInputStream(new FileInputStream(file));
char[] chars = {&apos;A&apos;,&apos;B&apos;,&apos;C&apos;};
for(char temp:chars){
outputStream.writeChar(temp);
}
char[] ch = new char[10];
int count= 0 ;
char temp;
while((temp = inputStream.readChar()) != &apos;C&apos;){
ch[count++] = temp;
}
System.out.println(ch);
}
}
public class SequenceFile {
public static void main(String [] args) throws Exception{
File file1 = new File(&quot;d:&quot;+File.separator+&quot;test.txt&quot;);
File file2 = new File(&quot;d:&quot;+File.separator+&quot;hello.txt&quot;);
File file3 = new File(&quot;d:&quot;+File.separator+&quot;xuyang.txt&quot;);
InputStream input1 = new FileInputStream(file1);
InputStream input2 = new FileInputStream(file2);
OutputStream output = new FileOutputStream(file3);
//合并流
SequenceInputStream sequenceInputStream = new SequenceInputStream(input1,input2);//合并在一起读出来，根据参数顺序读取
int len = 0 ;
while((len = sequenceInputStream.read())!=-1){
output.write(len);
}
input1.close();
input2.close();
}
}
public class zipOutputStreamFile {
public static void main(String [] args) throws Exception{
File file = new File(&quot;d:&quot;+File.separator+&quot;test.txt&quot;);
File zipFile = new File(&quot;d:&quot;+File.separator+&quot;test.zip&quot;);
ZipOutputStream zipOut = new ZipOutputStream(new FileOutputStream(zipFile));
InputStream inputStream = new FileInputStream(file);
//开始写入新的 ZIP 文件条目并将流定位到条目数据的开始处。
zipOut.putNextEntry(new ZipEntry(file.getName()));
//添加注释
zipOut.setComment(&quot;test&quot;);
 int len ;
while((len=inputStream.read())!=-1){
zipOut.write(len);
}
inputStream.close();
zipOut.close();
}
}
public class ZipOutputStreamManyFile {
public static void main(String [] args) throws Exception{
File file = new File(&quot;d:&quot;+File.separator+&quot;123&quot;);
File zipFile = new File(&quot;d:&quot;+File.separator+&quot;123.zip&quot;);
ZipOutputStream zipOut = new ZipOutputStream(new FileOutputStream(zipFile));
zipOut.setComment(&quot;测试！&quot;);
InputStream inputStream = null;
if(file.isDirectory()){
File[] files = file.listFiles();
for(File file1:files){
inputStream = new FileInputStream(file1);
zipOut.putNextEntry(new ZipEntry(file1.getName()));
int len;
while((len=inputStream.read())!=-1){
zipOut.write(len);
}
inputStream.close();
}
}
zipOut.close();
}
}
public class UnZipInputStreamFile {
public static void main(String [] args) throws Exception{
File file = new File(&quot;d:&quot;+File.separator+&quot;test.zip&quot;);
File unFile = new File(&quot;d:&quot;+File.separator+&quot;test.txt&quot;);
//说明是个压缩文件
ZipFile zipFile = new ZipFile(file);
//打印要压缩文件的名字
System.out.println(zipFile.getName());
InputStream input = zipFile.getInputStream(zipFile.getEntry(&quot;test.txt&quot;));//指定要压缩包内的文件名
OutputStream output = new FileOutputStream(unFile);
int len;
while((len=input.read())!=-1){
output.write(len);
}
output.close();
input.close();
}
}
public class UnZipInputStreamManyFile {
public static void main(String [] args) throws Exception{
File file = new File(&quot;d:&quot;+File.separator+&quot;123.zip&quot;);
File outFile = null;
//指定是一个zip文件
ZipFile zipFile = new ZipFile(file);
ZipInputStream zipInput = new ZipInputStream(new FileInputStream(file));
ZipEntry entry = null;
InputStream inputStream = null;
OutputStream outputStream = null;
while ((entry = zipInput.getNextEntry())!=null){
outFile = new File(&quot;d:&quot;+File.separator+ entry.getName());
if(!outFile.getParentFile().exists()){
outFile.getParentFile().mkdir();
}
if(!outFile.exists()){
outFile.createNewFile();
}
inputStream = zipFile.getInputStream(entry);
outputStream = new FileOutputStream(outFile);
int temp ;
if((temp = inputStream.read())!=-1){
outputStream.write(temp);
}
inputStream.close();
outputStream.close();
}
}
}
public class pushBackInputSteamTest {
public static void main(String [] args) throws Exception{
String str = &quot;Hello,Java!&quot;;
PushbackInputStream push = null;
ByteArrayInputStream byteArray = new ByteArrayInputStream(str.getBytes());
push = new PushbackInputStream(byteArray);
int temp = 0;
while((temp = push.read())!=-1){
if(temp==&apos;,&apos;){
push.unread(temp);
temp=push.read();
System.out.print(&quot;(回退&quot;+(char)temp +&quot;)&quot;);
}else{
System.out.print((char)temp);
}
}
}
}
//打印出来为Hello(回退,)Java!
public class ErrorEncoding {
public static void main(String [] args) throws Exception{
String str = &quot;上帝请保佑许阳&quot;;
//System.getProperty(&quot;file.encoding&quot;)获取本地编码
 byte[] bytes = str.getBytes(&quot;ISO8859-1&quot;);
OutputStream out = new FileOutputStream(new File(&quot;d:&quot;+File.separator+&quot;test.txt&quot;));
out.write(bytes);
out.close();
}
}
//乱码是由于编码不一致造成的
public class Persion implements Serializable {
private String name ;
private int age;

public Persion (){

}
public Persion (String name, int age) {
this.name = name;
this.age = age;
}

@Override
public String toString() {
return &quot;姓名：&quot;+name+&quot;,年龄：&quot;+age;
}
}
public class objectOutputStreamDemo {
public static void main(String[] args) throws IOException {
File file = new File(&quot;d:&quot; + File.separator + &quot;test.txt&quot;);
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(
file));
oos.writeObject(new Person(&quot;许阳&quot;,22));
oos.close();
}
}
public class ObjectInputStreamDemo{
public static void main(String[] args) throws Exception{
File file = new File(&quot;d:&quot; + File.separator + &quot;test.txt&quot;);
ObjectInputStream input = new ObjectInputStream(new FileInputStream(
file));
Object obj = input.readObject();
input.close();
System.out.println(obj);
}
}
public class ExternalizableDemo{
public static void main(String[] args) throws Exception{
ser(); // 序列化
dser(); // 反序列话
}

public static void ser() throws Exception{
File file = new File(&quot;d:&quot; + File.separator + &quot;test.txt&quot;);
ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(
file));
out.writeObject(new Person(&quot;许阳&quot;, 23));
out.close();
}

public static void dser() throws Exception{
File file = new File(&quot;d:&quot; + File.separator + &quot;test.txt&quot;);
ObjectInputStream input = new ObjectInputStream(new FileInputStream(
file));
Object obj = input.readObject();
input.close();
System.out.println(obj);
}
}

class Person implements Externalizable{
public Person(){

}

public Person(String name, int age){
this.name = name;
this.age = age;
}

@Override
public String toString(){
return &quot;姓名：&quot; + name + &quot; 年龄：&quot; + age;
}

// 复写这个方法，根据需要可以保存的属性或者具体内容，在序列化的时候使用
@Override
public void writeExternal(ObjectOutput out) throws IOException{
out.writeObject(this.name);
out.writeInt(age);
}

// 复写这个方法，根据需要读取内容 反序列话的时候需要
@Override
public void readExternal(ObjectInput in) throws IOException,
ClassNotFoundException{
this.name = (String) in.readObject();
this.age = in.readInt();
}

   //private transient String name; 加了transient属性代表此属性对应的数据显示为null
private String name;
private int age;
}
</code>
</RECORD>
<RECORD>
<snippet_key>277253</snippet_key>
<tag>java 算法 ACM 多项式求和</tag>
<comment>来自CSDN博客：[hdu 2011] 多项式求和  http://blog.csdn.net/u011506951/article/details/23019007#</comment>
<code>import java.text.DecimalFormat;
import java.util.Scanner;

public class Main {
public static void main(String[] args) {
DecimalFormat df = new DecimalFormat(&quot;0.00&quot;);
Scanner scanner = new Scanner(System.in);

int m = scanner.nextInt();
while (m-- != 0) {
int n = scanner.nextInt();

float sum = 0;
for (int i = 1; i &lt;= n; i++) {
sum += Math.pow(-1, i + 1) * (1.0 / i);
}
System.out.println(df.format(sum));
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>261901</snippet_key>
<tag>205</tag>
<comment>来自CSDN博客：JAVA注解简单例子  http://blog.csdn.net/ilwzxy/article/details/22398015#</comment>
<code>import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.Method;


/**
* Project Name:Anno
* File Name:Anno.java
* Package Name:
* Date:2014-3-28下午1:57:42
*
*/


/**
* ClassName:Anno
* Function: 注解简单例子.
* Date: 2014-3-28 下午1:57:42
* @author Administrator
*/
@Target(value = ElementType.METHOD)
@Retention(value = RetentionPolicy.RUNTIME)
@interface CanRun {
}
class AnnotationRunner {
public void method1(){
System.out.println(&quot;method1&quot;);
}
@CanRun
public void method2(){
System.out.println(&quot;method2&quot;);
}
@CanRun
public void method3(){
System.out.println(&quot;method3&quot;);
}
public void method4(){
System.out.println(&quot;method4&quot;);
}
public void method5(){
System.out.println(&quot;method5&quot;);
}
}
public class Anno {
public static void main(String[] args){
AnnotationRunner runner = new AnnotationRunner();
Method[] methods = runner.getClass().getMethods();
for(Method method : methods){
CanRun annos = method.getAnnotation(CanRun.class);
if(annos != null){
try{
method.invoke(runner);
}catch(Exception e){
e.printStackTrace();
}
}
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>342789</snippet_key>
<tag>ejb Ejb实例分析</tag>
<comment>来自CSDN博客：Ejb in action（四）——购物车实例演示有状态会话Bean  http://blog.csdn.net/liu765023051/article/details/25621469#</comment>
<code>package com.ejb.remote;
import java.util.List;
public interface IStatefulSessionBean {
public void put(String bookName);
public List&lt;String&gt; list();
}
package com.ejb.remote.impl;
import java.util.ArrayList;
import java.util.List;
import javax.ejb.Remote;
import javax.ejb.Stateful;
import com.ejb.remote.IStatefulSessionBean;
@Remote
@Stateful
public class StatefulSessionBeanImpl implements IStatefulSessionBean {
private List&lt;String&gt; bookList;
public StatefulSessionBeanImpl() {
bookList = new ArrayList&lt;String&gt;();
}
@Override
public void put(String bookName) {
bookList.add(bookName);
}
@Override
public List&lt;String&gt; list() {
return bookList;
}
}
&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;
pageEncoding=&quot;utf-8&quot;%&gt;
&lt;%@page import=&quot;javax.naming.NamingException&quot;%&gt;
&lt;%@page import=&quot;javax.naming.InitialContext&quot;%&gt;
&lt;%@page import=&quot;java.util.Properties&quot;%&gt;
&lt;%@page import=&quot;com.ejb.remote.IStatefulSessionBean&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=ISO-8859-1&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;%
try {
IStatefulSessionBean statefulBean = null;
//如果是
if (session.getAttribute(&quot;statefulBean&quot;) == null) {
//配置属性，他们是创建InitialContext的实例条件
Properties props = new Properties();
//JDNI工厂
props.setProperty(&quot;java.naming.factory.initial&quot;,&quot;org.jnp.interfaces.NamingContextFactory&quot;);
//JNDI查找包
props.setProperty(&quot;java.naming.factory.url.pkgs&quot;,&quot;org.jboss.naming&quot;);
//JNDI服务地址
props.setProperty(&quot;java.naming.provider.url&quot;,&quot;localhost:1099&quot;);
InitialContext ctx = new InitialContext(props);
statefulBean = (IStatefulSessionBean) ctx.lookup(&quot;StatefulSessionBeanImpl/remote&quot;);
session.setAttribute(&quot;statefulBean&quot;, statefulBean);
} else {
statefulBean = (IStatefulSessionBean) session.getAttribute(&quot;statefulBean&quot;);
}
String name = request.getParameter(&quot;name&quot;);
if (name != null) {
name = new String(name.getBytes(&quot;ISO8859_1&quot;), &quot;utf-8&quot;);
statefulBean.put(name);
}
out.println(&quot;您已购买：&quot;+statefulBean.list());

} catch (NamingException e) {
e.printStackTrace();
}
%&gt;
&lt;table border=&quot;1&quot;&gt;
&lt;tr&gt;
&lt;td&gt;书名&lt;/td&gt;
&lt;td&gt;购买&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;西游记&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;sessionbean4.jsp?name=西游记&quot;&gt;购买&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;水浒传&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;sessionbean4.jsp?name=水浒传&quot;&gt;购买&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;红楼梦&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;sessionbean4.jsp?name=红楼梦&quot;&gt;购买&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;三国演义&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;sessionbean4.jsp?name=三国演义&quot;&gt;购买&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>458509</snippet_key>
<tag>442</tag>
<comment>来自CSDN博客：数据结构之二叉树创建与遍历 http://blog.csdn.net/lantiancaiyun/article/details/38776911#</comment>
<code>package com.zhiru;

import java.util.Stack;

public class BinaryTree1 {

private Stack&lt;TreeNode&gt; s;
private TreeNode root;// 根节点

public BinaryTree1() {
root = null;
}

public BinaryTree1(char[] x, char[] y) {
root = createBinTree(x, y, x.length);
}

public BinaryTree1(char ref) {
root = null;
}

public TreeNode getRoot() {
return root;
}

/*
* 结点类 成员变量：结点中数据data,左孩子lChild,右孩子结点rChild.
*/
class TreeNode {
private char data;
private TreeNode lChild;
private TreeNode rChild;

public TreeNode(char d) {
data = d;
lChild = null;
rChild = null;
}

public TreeNode(char d, TreeNode l, TreeNode r) {
data = d;
lChild = l;
rChild = r;
}
}

/*
* 计算以r为根的树的结点个数.
*/
public int size(TreeNode r) {
if (r == null)
return 0;
else
return 1 + size(r.lChild) + size(r.rChild);
}

/*
* 计算以r为根的二叉树的深度.
*/
public int height(TreeNode r) {
if (r == null)
return 0;
else {
int ls = height(r.lChild);
int rs = height(r.rChild);
return ls &lt; rs ? rs + 1 : ls + 1;
}
}

/*
* 判断两颗二叉树是否相同
*/
public boolean isEquals(TreeNode a, TreeNode b) {
if (a == null &amp;&amp; b == null)
return true;
if (a != null &amp;&amp; b != null &amp;&amp; a.data == b.data
&amp;&amp; isEquals(a.lChild, b.lChild) &amp;&amp; isEquals(a.rChild, b.rChild))
return true;
else
return false;
}

// 前序遍历：根左右
public void preOrder(TreeNode r) {
if (r != null) {
System.out.print(r.data + &quot; &quot;);
preOrder(r.lChild);
preOrder(r.rChild);
}

}

/*
* 中序遍历:左根右
*/
public void inOrder(TreeNode r) {
if (r != null) {
inOrder(r.lChild);
System.out.print(r.data + &quot; &quot;);
inOrder(r.rChild);
}
}

/*
* 后序遍历:左右根
*/
public void afterOrder(TreeNode r) {
if (r != null) {
afterOrder(r.lChild);
afterOrder(r.rChild);
System.out.print(r.data + &quot; &quot;);
}
}

// 前序遍历的非递归实现要用到栈
/*
* 实现原理就是：先访问当前根节点，然后判断当前结点的右结点是否为空 不为空压栈，为空在判断左子树是否为空，不为空将当前结点改变为它的左子树结点
* 为空弹出栈中和它相邻的右结点。 要点就是要在栈中留下回退的结点，而前序遍历是按照“根左右”的顺序遍历的， 所以回退的结点就是右结点
*/
public void preOrderNonRecursion() {
s = new Stack&lt;TreeNode&gt;();
TreeNode p = root;
s.push(null);
while (p != null) {
System.out.print(p.data + &quot; &quot;);// 访问根结点
if (p.rChild != null)
s.push(p.rChild);// 将右子树结点预留栈中
if (p.lChild != null)
p = p.lChild;// 进左子树.
else
p = s.pop();
// System.out.print(s.pop()+&quot; &quot;);
}
s = null;
}

/*
* 中序遍历非递归实现
*/
public void inOrderNonRecursion() {
/*
* 一颗二叉子树遍历完毕的标志是它的右孩子为空
*/
s = new Stack&lt;TreeNode&gt;();
TreeNode p = root;
do {
// 压入栈中的是左结点以及该左结点的第一个右孩子，
// 如果这个右孩子还有右孩子，那它将被弹出,将它的右孩子压入栈中.
while (p != null) {
s.push(p);
p = p.lChild;
}
if (!s.empty()) {
p = s.pop();
System.out.print(p.data + &quot; &quot;);
p = p.rChild;
}
} while (p != null || !s.empty());// 当没有左子树且栈为空【没有右孩子】结束
s = null;
}

/*
* 由前序序列和中序序列构造二叉树. x为前序序列， y为中序序列
*/
public char[] getChar(char[] m, int start) {
if (m.length &lt; 1) {
return null;
} else {
if (start &gt;= 1 &amp;&amp; start &lt; m.length) {
int j = start;
char[] x = new char[m.length - start];
for (int i = 0; i &lt; x.length; i++) {
x[i] = m[j++];
}
return x;
}
}
return null;
}

public TreeNode createBinTree(char[] x, char[] y, int len) {
if (x != null &amp;&amp; y != null) {
int n;
if ((n = len) == 0)
return null;
int k = 0;
while (x[0] != y[k])
k++;// 在中序序列中寻找根节点.
TreeNode t = new TreeNode(x[0]);// 创建根节点
t.lChild = createBinTree(getChar(x, 1), y, k);// 构造左子树
t.rChild = createBinTree(getChar(x, k + 1), getChar(y, k + 1), n
- k - 1);// 构造右子树
return t;
}
return null;
}

public static void main(String[] args) {
// TODO Auto-generated method stub

char[] a = { &apos;A&apos;, &apos;B&apos;, &apos;H&apos;, &apos;F&apos;, &apos;D&apos;, &apos;E&apos;, &apos;C&apos;, &apos;K&apos;, &apos;G&apos; };
char[] b = { &apos;H&apos;, &apos;B&apos;, &apos;D&apos;, &apos;F&apos;, &apos;A&apos;, &apos;E&apos;, &apos;K&apos;, &apos;C&apos;, &apos;G&apos; };
BinaryTree1 bt = new BinaryTree1(a, b);
// char[]x=getChar(a,1);
// for(int i=0;i&lt;x.length;i++){
// Print.print(&quot; &quot;);
// }
Print.print(&quot;二叉树节点个数&quot; + bt.size(bt.getRoot()));
Print.print(&quot;二叉树的深度:&quot; + bt.height(bt.getRoot()));
Print.print(&quot;前序遍历:&quot;);
bt.preOrder(bt.getRoot());
System.out.println();
Print.print(&quot;中序遍历:&quot;);
bt.inOrder(bt.getRoot());
System.out.println();
Print.print(&quot;后序遍历:&quot;);
bt.afterOrder(bt.getRoot());
System.out.println();
Print.print(&quot;前序遍历[非递归]:&quot;);
bt.preOrderNonRecursion();
Print.print(&quot;中序遍历非递归\n&quot;);
bt.inOrderNonRecursion();
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>277509</snippet_key>
<tag>5</tag>
<comment>来自CSDN博客：黑马程序员--4、面向对象 http://blog.csdn.net/tiuwing/article/details/22981595#</comment>
<code>/**
制作文档
@author wing
@version v1.1
*/
public class TestDoc{
/**
空参数构造函数
*/
TestDoc(){}
/**
获取一个整型数组中的最大值。
@param a 接受一个int类型的数组
@return 返回该数组的最大值
*/
public int getMax(int[] a){
return 1;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>262158</snippet_key>
<tag>326</tag>
<comment>来自CSDN博客：读取和保存arff文件 http://blog.csdn.net/donger_soft/article/details/22408849#</comment>
<code>package com.weka.test;

import java.io.File;
import java.io.IOException;

import weka.core.Attribute;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.converters.ArffLoader;
import weka.core.converters.ArffSaver;
import weka.core.converters.Saver;

public class Test {
public static void filter(String loadPath, String savePath) throws IOException {
ArffLoader loader = new ArffLoader();
loader.setFile(new File(loadPath));
Instances structure = loader.getStructure();
Attribute attrClass = structure.attribute(&quot;class&quot;);
Attribute attrPredictedclass = structure.attribute(&quot;predictedclass&quot;);

ArffSaver saver = new ArffSaver();
saver.setFile(new File(savePath));
saver.setRetrieval(Saver.INCREMENTAL);
saver.setStructure(structure);

Instance inst;
while( (inst = loader.getNextInstance(structure)) != null ) {
double a = inst.value(attrClass);
double b = inst.value(attrPredictedclass);
if(a != b) {
saver.writeIncremental(inst);
}
}

saver.writeIncremental(null);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>408837</snippet_key>
<tag>42</tag>
<comment>来自CSDN博客：Eclipse自动补全增强，自动补全弹出时TAB、空格键功能修改 http://blog.csdn.net/yinhangfeng/article/details/35309193#</comment>
<code>public boolean verifyKey(VerifyEvent e) {
if (!Helper.okToUse(fProposalShell))
return true;

char key= e.character;
if (key == 0) {
int newSelection= fProposalTable.getSelectionIndex();
int visibleRows= (fProposalTable.getSize().y / fProposalTable.getItemHeight()) - 1;
int itemCount= fProposalTable.getItemCount();
switch (e.keyCode) {

case SWT.ARROW_LEFT :
case SWT.ARROW_RIGHT :
filterProposals();
return true;

case SWT.ARROW_UP :
newSelection -= 1;
if (newSelection &lt; 0)
newSelection= itemCount - 1;
break;

case SWT.ARROW_DOWN :
newSelection += 1;
if (newSelection &gt; itemCount - 1)
newSelection= 0;
break;

case SWT.PAGE_DOWN :
newSelection += visibleRows;
if (newSelection &gt;= itemCount)
newSelection= itemCount - 1;
break;

case SWT.PAGE_UP :
newSelection -= visibleRows;
if (newSelection &lt; 0)
newSelection= 0;
break;

case SWT.HOME :
newSelection= 0;
break;

case SWT.END :
newSelection= itemCount - 1;
break;

default :
if (e.keyCode != SWT.CAPS_LOCK &amp;&amp; e.keyCode != SWT.MOD1 &amp;&amp; e.keyCode != SWT.MOD2 &amp;&amp; e.keyCode != SWT.MOD3 &amp;&amp; e.keyCode != SWT.MOD4)
hide();
return true;
}

selectProposal(newSelection, (e.stateMask &amp; SWT.CTRL) != 0);

e.doit= false;
return false;

} else if(key == &apos;\t&apos;) {
//修改使按TAB时具有与ARROW_DOWN相同的效果
int newSelection = fProposalTable.getSelectionIndex() + 1;
if (newSelection &gt; fProposalTable.getItemCount() - 1)
newSelection = 0;
selectProposal(newSelection, (e.stateMask &amp; SWT.CTRL) != 0);
e.doit= false;
return false;
}

// key != 0
switch (key) {
case 0x1B: // Esc
e.doit= false;
hide();
break;

case &apos;\n&apos;: // Ctrl-Enter on w2k
case &apos;\r&apos;: // Enter
e.doit= false;
insertSelectedProposalWithMask(e.stateMask);
break;

// TAB已经具有ARROW_DOWN功能 1347行
// case &apos;\t&apos;:
// e.doit= false;
// fProposalShell.setFocus();
// return false;

default:
ICompletionProposal p= getSelectedProposal();
if (p instanceof ICompletionProposalExtension) {
ICompletionProposalExtension t= (ICompletionProposalExtension) p;
char[] triggers= t.getTriggerCharacters();
//if (contains(triggers, key)) { 修改阻止 = 空格 . 与 ; 的代码上屏
if (key != &apos;=&apos; &amp;&amp; key != 0x20 &amp;&amp; key != &apos;.&apos; &amp;&amp; key != &apos;;&apos;
&amp;&amp; contains(triggers, key)) {
e.doit= false;
hide();
insertProposal(p, key, e.stateMask, fContentAssistSubjectControlAdapter.getSelectedRange().x);
}
}
}

return true;
}
</code>
</RECORD>
<RECORD>
<snippet_key>459022</snippet_key>
<tag>453</tag>
<comment>Given a singly linked list L: L0→L1→…→Ln-1→Ln,reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</comment>
<code>/**
* Definition for singly-linked list.
* class ListNode {
* int val;
* ListNode next;
* ListNode(int x) {
* val = x;
* next = null;
* }
* }
*/
public class Solution {
public void reorderList(ListNode head) {
Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;();
ListNode tail = head;
while(tail != null){
stack.push(tail);
tail = tail.next;
}
int length = stack.size();
//judge length is even or odd in order to calculate how many ListNodes
//will be poped
length = (length % 2) == 0 ? (length/2 - 1) : length/2;
for(int i = 0; i &lt; length; i++){
ListNode listNode = stack.pop();
//must make current point of element on the top of stack empty
//in order to prevent dead loop
stack.peek().next = null;
//insert the poped element behind head
listNode.next = head.next;
head.next = listNode;
head = head.next.next;
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>328206</snippet_key>
<tag></tag>
<comment>来自CSDN博客：static在java中的作用 http://blog.csdn.net/eleven521/article/details/25062413#</comment>
<code>&lt;span style=&quot;font-family: Helvetica, Tahoma, Arial, sans-serif;font-size:12px; line-height: 19px;&quot;&gt;说明static&lt;span style=&quot;font-family: Helvetica, Tahoma, Arial, sans-serif;font-size:12px; line-height: 19px;&quot;&gt;变量只是接受了最后一次的初始化，多个实例共享一个&lt;span style=&quot;font-family: Helvetica, Tahoma, Arial, sans-serif;font-size:12px; line-height: 19px;&quot;&gt;静态的变量的问题&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>393742</snippet_key>
<tag>android</tag>
<comment>来自CSDN博客：Android 图片缩放  http://blog.csdn.net/SSWDG123456/article/details/31033361#</comment>
<code>&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt; mBitmap = BitmapFactory.decodeStream(in);&lt;/span&gt;
int width = mBitmap.getWidth();
int height = mBitmap.getHeight();
Matrix matrix = new Matrix();
matrix.postScale(3, 2);
Log.i(TAG, &quot;width is &quot;+width+&quot;;height is &quot;+height);
mBitmap = Bitmap.createBitmap(mBitmap,0,0,width,height ,matrix,true);
// mDrawable = Drawable.createFromStream(in, &quot;pic.png&quot;);
width = mBitmap.getWidth();
height = mBitmap.getHeight();
Log.i(TAG, &quot;width is &quot;+width+&quot;;height is &quot;+height);
</code>
</RECORD>
<RECORD>
<snippet_key>343813</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Adroid 下菜单的使用  http://blog.csdn.net/Alger_magic/article/details/25747921#</comment>
<code>@Override
publicboolean onCreateOptionsMenu(Menu menu) {
// 调用父类方法来加入系统菜单
// 虽然目前android还没有系统菜单，但是为了兼容到以后的版本，最好加上
super.onCreateOptionsMenu(menu);

// 添加菜单项（多种方式）
// 1.直接指定标题
menu.add(&quot;菜单项1&quot;);
// 2.通过资源指定标题
menu.add(R.string.menuitem2);
// 3.显示指定菜单项的组号、ID、排序号、标题
menu.add(
1, //组号
Menu.FIRST, //唯一的ID号
Menu.FIRST, //排序号
&quot;菜单项3&quot;); //标题

// 如果希望显示菜单，请返回true
returntrue;
}
/*
@Override
publicboolean onCreateOptionsMenu(Menu menu) {
super.onCreateOptionsMenu(menu);
// 添加4个菜单项，分成2组
int group1 =1;
int gourp2 =2;
menu.add(group1, 1, 1, &quot;item 1&quot;);
menu.add(group1, 2, 2, &quot;item 2&quot;);
menu.add(gourp2, 3, 3, &quot;item 3&quot;);
menu.add(gourp2, 4, 4, &quot;item 4&quot;);
// 显示菜单
menu.removeGroup(group1); //删除一组菜单
menu.setGroupVisible(gourp2, visible); //设置一组菜单是否可见
menu.setGroupEnabled(gourp2, enabled); //设置一组菜单是否可点
menu.setGroupCheckable(gourp2, checkable, exclusive); //设置一组菜单的勾选情况


returntrue;
}*/


&lt;span style=&quot;color:#000066;&quot;&gt;
&lt;/span&gt;
@Override
public void onCreateContextMenu(ContextMenu menu, View v,
ContextMenuInfo menuInfo) {
// TODO Auto-generated method stub

menu.add(&quot;HI&quot;);
menu.add(&quot;china&quot;);

//子菜单
SubMenu file = menu.addSubMenu(&quot;english&quot;);
SubMenu file2 = menu.addSubMenu(1,111,1,&quot;math&quot;);

file.add(1, 11, 1, &quot;nimei&quot;);
file.add(1, 22, 2, &quot;lilei&quot;);
file.add(1, 33, 3, &quot;hanmeimei&quot;);



super.onCreateContextMenu(menu, v, menuInfo);
}
@Override
publicboolean onCreateOptionsMenu(Menu menu) {
int base = Menu.FIRST;
// 一个menu可以包括多个子菜单
SubMenu subMenu = menu.addSubMenu(base, base+1, Menu.NONE, &quot;系统设置&quot;);
// 子菜单可以包括多个菜单项
MenuItem menuitem1 = subMenu.add(base, base+1, base+1, &quot;显示设置&quot;);
subMenu.add(base, base+2, base+2, &quot;网络设置&quot;);
subMenu.add(base, base+3, base+3, &quot;高级设置&quot;);
subMenu.add(base, base+4, base+4, &quot;安全设置&quot;);

// 子菜单项不支持显示图标，这样做是没意义的，尽管不会报错！
menuitem1.setIcon(R.drawable.displaysettings);

//但是子菜单本身是支持图标的
subMenu.setIcon(R.drawable.settings);

// 显示菜单请返回true
returntrue;
}
&lt;h2&gt;
&lt;/h2&gt;
@Override
publicboolean onOptionsItemSelected(MenuItem item) {
switch (item.getItemId()) {
//响应每个菜单项(通过菜单项的ID)，父菜单项和子菜单项的消息处理也是通过id号来区分
case1:
// do something here
break;
case2:
// do something here
break;
case3:
// do something here
break;
case4:
// do something here
break;
default:
//对没有处理的事件，交给父类来处理
returnsuper.onOptionsItemSelected(item);
}
//返回true表示处理完菜单项的事件，不需要将该事件继续传播下去了
return true;
}
@Override
public boolean onContextItemSelected(MenuItem item) {
// TODO Auto-generated method stub

switch (item.getItemId()) { //通过id区分点击事件，父菜单项和子菜单项都可以处理
case 11:
new AlertDialog.Builder(this).setTitle(&quot;11&quot;).setMessage(&quot;11 hope&quot;)
.setPositiveButton(&quot;确定&quot;, null).show();
break;


case 22:
new AlertDialog.Builder(this).setTitle(&quot;22&quot;).setMessage(&quot;22 hope&quot;)//子菜单项
.setPositiveButton(&quot;确定&quot;, null).show();
break;


case 111:
new AlertDialog.Builder(this).setTitle(&quot;111&quot;).setMessage(&quot;22 hope&quot;) //父菜单项
.setPositiveButton(&quot;确定&quot;, null).show();
break;


default:
break;
}
return super.onContextItemSelected(item);
}


&lt;span style=&quot;color:#330099;&quot;&gt;
&lt;/span&gt;
//第一步：创建监听器类
class MyMenuItemClickListener implements OnMenuItemClickListener {
@Override
publicboolean onMenuItemClick(MenuItem item) {
// do something here...
return true; //finish handling
}
}


//第二步：为菜单项注册监听器
menuItem.setOnMenuItemClickListener(new MyMenuItemClickListener());
</code>
</RECORD>
<RECORD>
<snippet_key>197390</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：分治法 Divide and Conquer - Closest Pair of Points 找最近点对  http://blog.csdn.net/hellobinfeng/article/details/19585795#</comment>
<code>package CloestPairOfPoints;

import java.util.Arrays;
import java.util.Comparator;

/**
* Divide and Conquer to get the cloest pair of points
*
* O(nlogn) time complexity
*
*/
public class CloestPairOfPoints {

public static void main(String[] args) {

Point[] points = new Point[6];

points[0] = new Point(2, 3);
points[1] = new Point(12, 30);
points[2] = new Point(40, 50);
points[3] = new Point(5, 1);
points[4] = new Point(12, 10);
points[5] = new Point(3, 4);

double minDist = closest(points);
System.out.println(minDist);
double minDistBruteForce = bruteForce(points);
System.out.println(minDistBruteForce);

}

// A utility function to find the distance between two points
private static double dist(Point p1, Point p2) {
return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)
* (p1.y - p2.y));
}

// A Brute Force method to return the smallest distance between two points
// in P[] of size n
public static double bruteForce(Point[] P) {
double min = Double.MAX_VALUE;
int n = P.length;
for (int i = 0; i &lt; n; i++) {
for (int j = i + 1; j &lt; n; j++) {
min = Math.min(min, dist(P[i], P[j]));
}
}
return min;
}

// The main functin that finds the smallest distance
// This method mainly uses closestUtil()
public static double closest(Point[] P) {
System.out.println(&quot;Before soring:&quot;);
System.out.println(Arrays.toString(P));
Arrays.sort(P, new Comparator&lt;Point&gt;() {
@Override
public int compare(Point p1, Point p2) {
return p1.x - p2.x;
}
});
System.out.println(&quot;After sorting in x axis:&quot;);
System.out.println(Arrays.toString(P));

return closestUtil(P, 0, P.length - 1);
}

// A recursive function to find the smallest distance. The array P contains
// all points sorted according to x coordinate
private static double closestUtil(Point[] P, int begin, int end) {
int n = end - begin + 1;
if (n &lt;= 3) { // If there are 2 or 3 points, then use brute force
return bruteForce(P);
}

int mid = n / 2; // Find the middle point
Point midPoint = P[mid];

// Consider the vertical line passing through the middle point
// calculate the smallest distance dl on left of middle point and
// dr on right side
double left = closestUtil(P, begin, mid);
double right = closestUtil(P, mid, end);

// Find the smaller of two distances
double distMin = Math.min(left, right);
Point[] strip = new Point[n];
int stripLen = 0;

// Build an array strip[] that contains points close (closer than d)
// to the line passing through the middle point
for (int i = 0; i &lt; n; i++) {
if (Math.abs(P[i].x - midPoint.x) &lt; distMin) {
strip[stripLen] = P[i];
stripLen++;
}
}

// Find the closest points in strip. Return the minimum of d and closest
// distance is strip[]
return Math.min(distMin, stripCloest(strip, stripLen, distMin));
}

// A utility function to find the distance beween the closest points of
// strip of given size. All points in strip[] are sorted accordint to
// y coordinate. They all have an upper bound on minimum distance as d.
// Note that this method seems to be a O(n^2) method, but it&apos;s a O(n)
// method as the inner loop runs at most 6 times
private static double stripCloest(Point[] strip, int stripLen,
double distMin) {

Arrays.sort(strip, 0, stripLen, new Comparator&lt;Point&gt;() {
@Override
public int compare(Point p1, Point p2) {
return p1.y - p2.y;
}
});

System.out.println(&quot;After sorting in y axis for strip:&quot;);
System.out.println(Arrays.toString(strip));
double min = distMin;

// O(C*n) time complexity, not O(n^2)
// Pick all points one by one and try the next points till the difference
// between y coordinates is smaller than d.
// This is a proven fact that this loop runs at most 6 times
for (int i=0; i&lt;stripLen; i++) {
for(int j=i+1; j&lt;stripLen &amp;&amp; (strip[j].y - strip[i].y &lt; min); j++) {
min = Math.min(min, dist(strip[i], strip[j]));
}
}

return min;
}


static class Point {
int x, y;

public Point(int x, int y) {
this.x = x;
this.y = y;
}

@Override
public String toString() {
return &quot;[x=&quot; + x + &quot;, y=&quot; + y + &quot;]&quot;;
}
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>16389</snippet_key>
<tag>184</tag>
<comment>SimpleDateFormat不是线程安全的，如果多线程访问同一个SimpleDateFormat对象就会出错。我曾经写过一个多线程导数据的程序，结果下单时间比支付时间还晚，后来才发现是这个问题。</comment>
<code>import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
/**
* 线程安全的SimpleDateFormat帮助类&lt;br/&gt;
* 创建SimpleDateFormat对象成本较高，但是SimpleDateFormat又不是线程安全的，因此使用ThreadLocal模式&lt;br/&gt;
*
* @author xujsh(xjs250@163.com)
*
* */
public class DateFormatUtil {

public static final String PATTERN10 = &quot;yyyy-MM-dd&quot;;
public static final String PATTERN19 = &quot;yyyy-MM-dd HH:mm:ss&quot;;

private static final ThreadLocal&lt;Map&lt;String,SimpleDateFormat&gt;&gt; DATE_FORMAT_HOLDER = new ThreadLocal&lt;Map&lt;String,SimpleDateFormat&gt;&gt;(){
@Override
protected Map&lt;String, SimpleDateFormat&gt; initialValue() {
Map&lt;String, SimpleDateFormat&gt; map = new HashMap&lt;String, SimpleDateFormat&gt;();
map.put(PATTERN10, new SimpleDateFormat(PATTERN10));
map.put(PATTERN19, new SimpleDateFormat(PATTERN19));
return map;
}
};
private DateFormatUtil(){
//私有的构造函数
}
/**
* 获取符合pattern格式的SimpleDateFormat对象&lt;br/&gt;
* 如果pattern格式的SimpleDateFormat对象不存在，会创建并缓存之&lt;br/&gt;
*
* @param pattern
* @return
* */
public static SimpleDateFormat getDateFormat(String pattern){
Map&lt;String, SimpleDateFormat&gt; map = DATE_FORMAT_HOLDER.get();
SimpleDateFormat sdf = map.get(pattern);
if(sdf == null){
sdf = new SimpleDateFormat(pattern);
map.put(pattern, sdf);
}
return sdf;
}
/**
* 获取yyyy-MM-dd格式的SimpleDateFormat对象
*
* @return
* */
public static SimpleDateFormat getDateFormat10(){
return getDateFormat(PATTERN10);
}
/**
* 获取yyyy-MM-dd HH:mm:ss格式的SimpleDateFormat对象
*
* @return
* */
public static SimpleDateFormat getDateFormat19(){
return getDateFormat(PATTERN19);
}
/**
* 把日期格式化成yyyy-MM-dd字符串
*
* @param date
* @return
* */
public static String format10(Date date){
if(date == null){
return &quot;&quot;;
}
return getDateFormat10().format(date);
}
/**
* 把日期格式化成yyyy-MM-dd HH:mm:ss字符串
*
* @param date
* @return
* */
public static String format19(Date date){
if(date == null){
return &quot;&quot;;
}
return getDateFormat19().format(date);
}
/**
* 把yyyy-MM-dd格式的字符串转化成日期
*
* @param datestr
* @return
* */
public static Date parse10(String datestr){
if(datestr == null || datestr.length()!=10){
return null;
}
try{
return getDateFormat10().parse(datestr);
}catch(Exception e){
return null;
}
}
/**
* 把yyyy-MM-dd HH:mm:ss格式的字符串转化成日期
*
* @param datestr
* @return
* */
public static Date parse19(String datestr){
if(datestr == null || datestr.length() != 19){
return null;
}
try{
return getDateFormat19().parse(datestr);
}catch(Exception e){
return null;
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>328718</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：黑马程序员——多线程  http://blog.csdn.net/luo_yawa/article/details/25052905#</comment>
<code>public class Test extends Thread {
public void run() {
//要多线程执行的代码
}
}
//调用时直接new该对象调用start（）方法实现多线程；
public static void main(String[] args) {
new Mythread().start();
}
class Mythread implements Runnable{
//实现Runna接口复写run()方法实现多线程
public void run() {
//多线程执行的代码
}

}
//调用时将对象传入Thread（）方法实现多线程
public static void main(String[] args) {
new Thread(new Mythread()).start();
}
public class hello extends Thread {
private String name;
public hello() {

}

public hello(String name) {
this.name = name;
}

public void run() {
for (int i = 0; i &lt; 5; i++) {
System.out.println(name + &quot;运行 &quot; + i);
}
}

public static void main(String[] args) {
hello h1 = new hello(&quot;线程A&quot;);
Thread demo = new Thread(h1);
hello h2 = new hello(&quot;线程Ｂ&quot;);
Thread demo1 = new Thread(h2);
demo.start();
demo1.start();
}
}
public class Test22 implements Runnable {
private static int num = 20;

public void run() {
this.show();
}
private synchronized void show() {
do {
// synchronized (mutex) { 也可以在此用同步代码块实现
if (num &gt; 0) {
System.err.println(Thread.currentThread().getName()
+ &quot;------------|&quot; + num);
num--;
}
// }
} while (true);
}

}
public static void main(String[] args) {
Test22 test22 = new Test22();
new Thread(test22).start();
new Thread(test22).start();
new Thread(test22).start();
new Thread(test22).start();

}
public class Res {
private String name;
private int count = 1;
private boolean flag = false;
private Lock lock = new ReentrantLock(); //新建一个Lock 替代了 synchronized
private Condition condition_set = lock.newCondition(); //新建一个Condition 替代了 Object 监视器方法的使用
private Condition condition_out = lock.newCondition(); //新建一个Condition 替代了 Object 监视器方法的使用

public void set(String name) {
lock.lock(); //获取锁
try {
while(flag)
condition_set.await(); //线程等待 会抛出异常
this.name = name + &quot;-----------&quot; + count++;
System.out.println(Thread.currentThread().getName() + &quot;|生产者|&quot;
+ this.name);
flag = true;
condition_out.signal(); //唤醒等待的消费者线程

} catch (InterruptedException e) {
e.printStackTrace();
} finally {
lock.unlock(); //finall代码必须执行，所以在这里释放锁
}

}

public void out() {
lock.lock();

try {
while(!flag)
condition_out.await();
System.out.println(Thread.currentThread().getName() + &quot;|消费者|&quot;
+ this.name);
flag = false;
condition_set.signalAll(); //唤醒等待的消费者线程
} catch (InterruptedException e) {
e.printStackTrace();
} finally {
lock.unlock();
}

}
}
public class Shengcan implements Runnable {

private Res res;
public Shengcan(Res res) {
this.res = res;
}
public void run() {
while (true) {
res.set(&quot;ĺĺ&quot;);
}
}

}
public class Xiaofei implements Runnable {
private Res res;

public Xiaofei(Res res) {
this.res = res;
}

public void run() {
while (true) {
res.out();
}

}

}
public class Test {
public static void main(String[] args) {
Res res = new Res();
Shengcan shengcan = new Shengcan(res);
Xiaofei xiaofei = new Xiaofei(res);

new Thread(shengcan).start();
new Thread(xiaofei).start();
new Thread(shengcan).start();
new Thread(xiaofei).start();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>394254</snippet_key>
<tag></tag>
<comment>来自CSDN博客：集合重新hashcode（）和equals（)方法  http://blog.csdn.net/m529031854/article/details/31361373#</comment>
<code>2. 关于 Object 类的 equals 方法的特点
a) 自反性：x.equals(x)应该返回 true
b) 对称性：x.equals(y)为 true，那么 y.equals(x)也为 true。
c) 传递性：x.equals(y)为 true 并且 y.equals(z)为 true，那么 x.equals(z)也应该为 true。
d) 一致性：x.equals(y)的第一次调用为 true，那么 x.equals(y)的第二次、第三次、第 n
次调用也应该为 true，前提条件是在比较之间没有修改 x 也没有修改 y。
e) 对于非空引用 x，x.equals(null)返回 false。
3. 关于 Object 类的 hashCode()方法的特点：
a) 在 Java 应用的一次执行过程当中，对于同一个对象的 hashCode 方法的多次调用，
他们应该返回同样的值（前提是该对象的信息没有发生变化）。
b) 对于两个对象来说，如果使用equals方法比较返回true，那么这两个对象的hashCode
值一定是相同的。
c) 对于两个对象来说，如果使用equals方法比较返回false，那么这两个对象的hashCode
值不要求一定不同（可以相同，可以不同），但是如果不同则可以提高应用的性能。
d) 对于Object类来说，不同的Object对象的hashCode值是不同的（Object类的hashCode
值表示的是对象的地址）。
4. 当使用 HashSet 时，hashCode()方法就会得到调用，判断已经存储在集合中的对象的
hash code 值是否与增加的对象的 hash code 值一致；如果不一致，直接加进去；如
果一致，再进行 equals 方法的比较，equals 方法如果返回 true，表示对象已经加进
去了，就不会再增加新的对象，否则加进去。
5. 如果我们重写 equals 方法，那么也要重写 hashCode 方法，反之亦然。
&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;package com.zhujl.set;

import java.util.HashSet;
import java.util.Set;

public class SetDemo1 {
public static void main(String[] args) {
Set set = new HashSet();
// set.add(new String(&quot;zhangsan&quot;));
// set.add(new String(&quot;lisi&quot;));
// set.add(new String(&quot;zhangsan&quot;));
// Person p1 = new Person(&quot;zhangsan&quot;);
// set.add(p1);
// set.add(p1);
//
Person p1 = new Person(&quot;A&quot;);
Person p2 = new Person(&quot;A&quot;);
set.add(p1);
set.add(p2);
System.out.println(p1.hashCode()==p2.hashCode());
}
}
class Person{
String name;
public Person(String name){
this.name=name;
}
public int hashCode(){
return this.name.hashCode();
}
public boolean equals(Object o){
if(this==o){
return true;
}
if(o!=null || o instanceof Person){
Person p = (Person)o;
if(name.equals(p.name)){
return true;
}
}
return false;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>66830</snippet_key>
<tag>类</tag>
<comment>基本类型与包装类</comment>
<code>public class PrimitiveTypeDemo {
public static void main(String[] args) {

/**
* Float和Double的最小值和最大值都是以科学记数法的形式输出的。
* 结尾的“E+数字”表示E之前的数字要乘以10的多少次方。
* 比如3.14E3就是3.14×1000=3140，3.14E-3就是3.14/1000=0.00314
*/

// byte
System.out.println(&quot;基本类型：byte 二进制位数：&quot; + Byte.SIZE);
System.out.println(&quot;包装类：java.lang.Byte&quot;);
System.out.println(&quot;最小值：Byte.MIN_VALUE=&quot; + Byte.MIN_VALUE);
System.out.println(&quot;最大值：Byte.MAX_VALUE=&quot; + Byte.MAX_VALUE);
System.out.println();

// short
System.out.println(&quot;基本类型：short 二进制位数：&quot; + Short.SIZE);
System.out.println(&quot;包装类：java.lang.Short&quot;);
System.out.println(&quot;最小值：Short.MIN_VALUE=&quot; + Short.MIN_VALUE);
System.out.println(&quot;最大值：Short.MAX_VALUE=&quot; + Short.MAX_VALUE);
System.out.println();

// int
System.out.println(&quot;基本类型：int 二进制位数：&quot; + Integer.SIZE);
System.out.println(&quot;包装类：java.lang.Integer&quot;);
System.out.println(&quot;最小值：Integer.MIN_VALUE=&quot; + Integer.MIN_VALUE);
System.out.println(&quot;最大值：Integer.MAX_VALUE=&quot; + Integer.MAX_VALUE);
System.out.println();

// long
System.out.println(&quot;基本类型：long 二进制位数：&quot; + Long.SIZE);
System.out.println(&quot;包装类：java.lang.Long&quot;);
System.out.println(&quot;最小值：Long.MIN_VALUE=&quot; + Long.MIN_VALUE);
System.out.println(&quot;最大值：Long.MAX_VALUE=&quot; + Long.MAX_VALUE);
System.out.println();

// float
System.out.println(&quot;基本类型：float 二进制位数：&quot; + Float.SIZE);
System.out.println(&quot;包装类：java.lang.Float&quot;);
System.out.println(&quot;最小值：Float.MIN_VALUE=&quot; + Float.MIN_VALUE);
System.out.println(&quot;最大值：Float.MAX_VALUE=&quot; + Float.MAX_VALUE);
System.out.println();

// double
System.out.println(&quot;基本类型：double 二进制位数：&quot; + Double.SIZE);
System.out.println(&quot;包装类：java.lang.Double&quot;);
System.out.println(&quot;最小值：Double.MIN_VALUE=&quot; + Double.MIN_VALUE);
System.out.println(&quot;最大值：Double.MAX_VALUE=&quot; + Double.MAX_VALUE);
System.out.println();

// char
System.out.println(&quot;基本类型：char 二进制位数：&quot; + Character.SIZE);
System.out.println(&quot;包装类：java.lang.Character&quot;);
// 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台
System.out.println(&quot;最小值：Character.MIN_VALUE=&quot;
+ (int) Character.MIN_VALUE);
// 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台
System.out.println(&quot;最大值：Character.MAX_VALUE=&quot;
+ (int) Character.MAX_VALUE);

}
}
</code>
</RECORD>
<RECORD>
<snippet_key>344325</snippet_key>
<tag>Broadcast Receiver</tag>
<comment>来自CSDN博客：Broadcast Receiver  http://blog.csdn.net/ican87/article/details/24411495#</comment>
<code>public class MyBroadcastReceiver extendsBroadcastReceiver {

String SMS_RECEIVED = &quot;android.provider.Telephony.SMS_RECEIVED&quot;;

@Override
public void onReceive(Context context, Intent intent) {

if (intent.getAction().equals(SMS_RECEIVED)) {

// 接收短信后相关处理；

}
}
}
private BroadcastReceivermyBroadcastReceiver = new BroadcastReceiver() {

@Override

public void onReceive(Context context, Intent intent) {

// 相关处理

}

};
IntentFilter intentFilter = newIntentFilter(&quot;android.provider.Telephony.SMS_RECEIVED&quot;);

registerReceiver(myBroadcastReceiver,intentFilter);
</code>
</RECORD>
<RECORD>
<snippet_key>197902</snippet_key>
<tag></tag>
<comment>来自CSDN博客：关于异常捕获后程序的去向  http://blog.csdn.net/zhaohefeijava/article/details/19615145#</comment>
<code>public class ExceptionTest {

/**
* @author zhao33699
*/
// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓********在捕获chufa3的异常后，chufa3终止，继续向下执行chufa1和chufa2↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
public static void main(String[] args) {
// TODO Auto-generated method stub
try {
chufa3();
} catch (Exception e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
chufa1();
chufa2();
}

// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓********该方法，在内部抛出捕获异常后，该循环继续↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
public static void chufa1() {
for (int i = 0; i &lt; 10; i++) {
try {
System.out.println(100 / i);
} catch (Exception e) {
System.out.println(e.getMessage());
}
}
System.out.println(&quot;chufa1程序运行完毕&quot;);
}

// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑

// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓********该方法，在内部抛出捕获异常后，该循环终止↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
public static void chufa2() {
try {
for (int i = 0; i &lt; 10; i++) {
System.out.println(100 / i);
}
} catch (Exception e) {
System.out.println(e.getMessage());
}
System.out.println(&quot;chufa2程序运行完毕&quot;);
}

// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑

// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓********该方法，在外部抛出捕获异常后，该方法终止↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
public static void chufa3() throws Exception {

for (int i = 0; i &lt; 10; i++) {
System.out.println(100 / i);
}

System.out.println(&quot;chufa3程序运行完毕&quot;);
}
// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑
}
</code>
</RECORD>
<RECORD>
<snippet_key>475397</snippet_key>
<tag>fontfont省市县三级联动fontfont fontfont的Android开发之实现三级联动效果fontfont fontfontXmlPullParser高级应用fontfont</tag>
<comment>来自CSDN博客：Android开发之解析XML并实现三级联动效果 http://blog.csdn.net/fengyuzhengfan/article/details/39560427#</comment>
<code>包com.jph.px;

进口的java.io.InputStream;
进口的java.util.List;
进口的java.util.Map;
进口com.jph.sevice.PullProvince;
进口android.os.Bundle;
进口android.os.Handler;
进口android.os.Message;
进口android.app.Activity;
进口android.view.View;
进口android.widget.AdapterView;
进口android.widget.AdapterView.OnItemSelectedListener;
进口android.widget.ArrayAdapter;
进口android.widget.Spinner;
进口android.widget.Toast;
/ **
*省，市，区三级联动
* @作者JPH
*日期：2014年9月25日
* /
公共类MainActivity活动{
私人微调省，市，区;
私人地图&lt;字符串，地图&lt;字符串，列表&lt;字符串&gt;&gt;&gt;数据= NULL;
/ **当前的选择的省份** /
私人字符串currentProvince;
/ **当前的选择的城市** /
私人字符串currentCity;
私人PullProvince pullProvince;
// / **当前的选择的区** /
//私人字符串currentArea;
私人处理程序mHandler =新的处理程序（）{
@SuppressWarnings（“选中”）
@Override
公共无效的handleMessage（消息MSG）{
// TODO自动生成方法存根
开关（msg.what）{
案例PullProvince.PARSESUCCWSS：//数据解析完毕，加载数据
数据=（地图&lt;字符串，地图&lt;字符串，列表&lt;字符串&gt;&gt;&gt;）msg.obj;
initData（）;
打破;
默认情况下：
打破;
}
super.handleMessage（MSG）;
}
};
@Override
保护无效的onCreate（捆绑savedInstanceState）{
super.onCreate（savedInstanceState）;
的setContentView（R.layout.activity_main）;
省=（微调）findViewById（R.id.province）;
城市=（微调）findViewById（R.id.city）;
面积=（微调）findViewById（R.id.area）;
pullProvince =新PullProvince（mHandler）;
的InputStream inStream中= this.getClass（）。使用getClassLoader（）。
的getResourceAsStream（“province_city.xml”）;
pullProvince.getProvinces（inStream中）;
}
/ **
*初始化数据
* /
私人无效initData（）{
如果（数据！= NULL）{
String []的arrStrings = data.keySet（）的toArray（新的String [0]）;
System.out.println（arrStrings）;
//将省份信息填充到全省微调
province.setAdapter（新ArrayAdapter &lt;字符串&gt;（这一点，
android.R.layout.simple_list_item_multiple_choice，arrStrings））;
currentProvince = getCurrentProvince（）;
bindCityAdapter（currentProvince）;
currentCity = getCurrentCity（）;
bindAreaAdapter（currentCity）;
setOnItemSelectedListener（）;
}
}
私人无效bindAreaAdapter（弦乐currentCity）{
// TODO自动生成方法存根
//根据当前显示的城市将对应的区填充到区域微调
area.setAdapter（新ArrayAdapter &lt;字符串&gt;（这一点，
android.R.layout.simple_list_item_multiple_choice，
data.get（currentProvince）获得（currentCity）））;
}
私人无效bindCityAdapter（弦乐currentProvince）{
// TODO自动生成方法存根
//根据当前显示的省份将对应的城市填充到城市微调
city​​.setAdapter（新ArrayAdapter &lt;字符串&gt;（这一点，
android.R.layout.simple_list_item_multiple_choice数据。
得到（currentProvince）.keySet（）的toArray（新的String [0]）））;
}
/ **
*为微调设置监听器
* /
私人无效setOnItemSelectedListener（）{
// TODO自动生成方法存根
province.setOnItemSelectedListener（新OnItemSelectedListener（）{
@Override
公共无效onItemSelected（适配器视图&lt;？&gt;为arg0，查看ARG1，
INT ARG2，长ARG3）{
// TODO自动生成方法存根
currentProvince = getCurrentProvince（）;
bindCityAdapter（currentProvince）;
}

@Override
公共无效onNothingSelected（适配器视图&lt;？&gt;为arg0）{
// TODO自动生成方法存根

}
}）;
city​​.setOnItemSelectedListener（新OnItemSelectedListener（）{
@Override
公共无效onItemSelected（适配器视图&lt;？&gt;为arg0，查看ARG1，
INT ARG2，长ARG3）{
// TODO自动生成方法存根
currentCity = getCurrentCity（）;
bindAreaAdapter（currentCity）;
}

@Override
公共无效onNothingSelected（适配器视图&lt;？&gt;为arg0）{
// TODO自动生成方法存根

}
}）;
area.setOnItemSelectedListener（新OnItemSelectedListener（）{
@Override
公共无效onItemSelected（适配器视图&lt;？&gt;为arg0，查看ARG1，
INT ARG2，长ARG3）{
// TODO自动生成方法存根
Toast.makeText（MainActivity.this，area.getSelectedItem（）。的toString（），
Toast.LENGTH_SHORT）。显示（）;
}

@Override
公共无效onNothingSelected（适配器视图&lt;？&gt;为arg0）{
// TODO自动生成方法存根

}
}）;
}

/ **获取当前选择的省份
*返回字符串：当前选择的省份
* /
私人字符串getCurrentProvince（）{
// TODO自动生成方法存根
返回province.getSelectedItem（）的toString（）;
}
/ **获取当前选择的城市
*返回字符串：当前选择的城市
* /
私人字符串getCurrentCity（）{
// TODO自动生成方法存根
返回city.getSelectedItem（）的toString（）;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>82437</snippet_key>
<tag>453</tag>
<comment>来自CSDN博客：JavaSE 拾遗(8)——JavaSE 集合框架  http://blog.csdn.net/zhaoyw2008/article/details/9002460#</comment>
<code>/**
* 需求：创建一个队列和堆栈的类
*/
package cn.itcast.others;

import java.util.LinkedList;

/**
* @class: HeapStackDemo
* @package: cn.itcast.others
* @description: TODO
* @author： vivianZhao
* @date: 2013-7-17 下午3:13:27
* @version: 1.0
*/
public class HeapStackDemo {

/**
* @method: main
* @description: TODO
* @param args
* @return: void
* @author： vivianZhao
* @date: 2013-7-17 下午3:13:27
* @version: 1.0
*/
public static void main(String[] args) {
// TODO Auto-generated method stub
Stack&lt;String&gt; stack = new Stack&lt;String&gt;();
stack.push(&quot;1&quot;);
stack.push(&quot;2&quot;);
stack.push(&quot;3&quot;);
System.out.println(stack.pull());
System.out.println(stack.pull());
System.out.println(stack.pull());

System.out.println(&quot;-----------------------&quot;);

Queue&lt;String&gt; queue = new Queue&lt;String&gt;();
queue.push(&quot;1&quot;);
queue.push(&quot;2&quot;);
queue.push(&quot;3&quot;);
System.out.println(queue.pull());
System.out.println(queue.pull());
System.out.println(queue.pull());
}

}

class Stack&lt;T&gt; {
private LinkedList&lt;T&gt; linkedList = new LinkedList&lt;T&gt;();

public void push(T element) {
linkedList.push(element);
}

public T pull() {
return linkedList.pollFirst();
}

}

class Queue&lt;T&gt;{
private LinkedList&lt;T&gt; linkedList = new LinkedList&lt;T&gt;();

public void push(T element) {
linkedList.push(element);
}

public T pull() {
return linkedList.pollLast();
}
}
/**
需求:演示 HashSet 中保存自定义对象集合

思路:
1.添加 Person 的对象到 HashSet 对象中
2.添加重复元素试试看，
3.定义 HashSet 对象中 Person 元素名字和年龄相同的元素就为相同元素
4.打印出 HashSet 对象中的元素

步骤:

总结：
1.Set 集合中，不能保存重复的元素，不同的存储结构对于元素是否相同的判断方法不同
2.HashSet 对象中元素相同的定义依赖于元素的 hashCode 和 equals 方法
3.HashSet 中，判断 hash 值是否相同底层实现可以用二叉树结构实现
*/
import java.util.*;

class HashSetDemo
{
public static void main(String[] args)
{
HashSet personHashSet = new HashSet();

personHashSet.add(new Person(&quot;zhangsan&quot;,12));
personHashSet.add(new Person(&quot;lisi&quot;,13));
personHashSet.add(new Person(&quot;wangwu&quot;,14));
personHashSet.add(new Person(&quot;zhaoliu&quot;,15));
personHashSet.add(new Person(&quot;zhaoliu&quot;,15));

Iterator iterator = personHashSet.iterator();

while(iterator.hasNext())
{
Person person = (Person)iterator.next();
printObject(person);
}


}

static void printObject(Object o)
{
System.out.println(o);
}
}

class Person
{
private String name;
private int age;

Person(String name, int age)
{
this.name = name;
this.age = age;
}

public String getName()
{
return name;
}

public int getAge()
{
return age;
}

public int hashCode()
{
System.out.println(name + &quot;: hashCode&quot;);
return name.hashCode() + age*21;
}

public boolean equals(Object o)
{
if(o instanceof Person)
{
Person person = (Person)o;
System.out.println(name + &quot;: equals :&quot; + person.getName());
if(name.equals(person.getName()) &amp;&amp; age == person.getAge())
{
return true;
}
}

return false;
}

public String toString()
{
return name + &quot;:&quot; + age;
}
}
/**
需求:演示 TreeSet 中保存自定义对象

思路:
1.往 TreeSet 集合中存储自定义对象学生，按照学生的年龄进行排序
2.打印 TreeSet 集合中的元素

步骤:

总结：
Set:无序，不可以有重复元素
|--HashSet：底层数据结构是 hash 表，线程非同步
保证元素唯一性的原理：依赖元素的 hashCode 方法和 equals 方法返回的值

|--TreeSet：可以对 Set 集合中的元素进行自定义的排序。
底层数据结构是二叉树
保证元素唯一性的依据之一：元素的 compareTo 方法

TreeSet 排序的第一种方式：让元素自身具备比较性，元素需要实现 Comparable 接口
TreeSet 排序的第二种方式：传一个 Comparator 实例给 TreeSet，让容器自身具备比较性

就好像一个班上的人可以自动按身高排序，这个可以算作他们自身具备的比较性，也可以
给老师一个直尺，老师量过每个人的升高后，老师来给这些人排序。

Comparator 和 Comparable 接口使得 TreeSet 集合具有了极好的扩展性。
*/
import java.util.*;

class TreeSetDemo
{
public static void main(String[] args)
{
//TreeSet studentTreeSet = new TreeSet(); // 使用自身比较性排序
TreeSet studentTreeSet = new TreeSet(new StudentComparator()); //使用比较器排序

studentTreeSet.add(new Student(&quot;zhangsan&quot;, 22));
studentTreeSet.add(new Student(&quot;lisi&quot;, 17));
studentTreeSet.add(new Student(&quot;wangwu&quot;, 18));
studentTreeSet.add(new Student(&quot;zhaoliu&quot;, 18));

Iterator studentIterator = studentTreeSet.iterator();

while(studentIterator.hasNext())
{
Student student = (Student)studentIterator.next();
System.out.println(student);
}
}
}

class Student implements Comparable
{
private String name;
private int age;

Student(String name, int age)
{
this.name = name;
this.age = age;
}

public String getName()
{
return name;
}

public int getAge()
{
return age;
}

public int compareTo(Object o)
{
if(o instanceof Student)
{
Student student = (Student)o;
System.out.println(toString() + &quot;...compareTo:...&quot; + student.toString());
if(age == student.getAge())
{
return name.compareTo(student.getName());
}
else
{
return ((Integer)age).compareTo(student.getAge());
}
}
return -1;
}

public String toString()
{
return name + &quot;:&quot; + age;
}
}

class StudentComparator implements Comparator
{
public int compare(Object object1, Object object2)
{
Student stu1 = (Student)object1;
Student stu2 = (Student)object2;

int num = stu1.getName().compareTo(stu2.getName());

if(num == 0)
{
return ((Integer)stu1.getAge()).compareTo((Integer)stu2.getAge());
}
return num;
}
}
/**
需求:演示泛型类的定义和使用

思路:定义一个工具类主要功能是可以保存某个对象实例到成员变量中，还支持
把该对象实例取出来，但是为了能操作多种数据类型的对象，该引用数据类型延
迟到在类使用的时候才确定，而类的使用有两种，一种是使用类定义变量、创建
对象，一种是 extends 该类

步骤:

总结：
1.泛型类就是具有泛型声明的类，也就是泛型定义在类上

2.什么时候定义泛型类：在定义一个类的时候，当类中要操作的引用类型数据在
类定义的时候数据类型不能确定(比如想要支持多种数据类型)，而在类使用的
时候可以确定，早期使用 Object 来实现，现在定义泛型类来实现。
*/
class GenericClassDemo
{
public static void main(String[] args)
{
Utils&lt;Worker&gt; util = new Utils&lt;Worker&gt;();

util.setObject(new Worker());
//util.setObject(new Student()); // 编译时就会发现问题
Worker worker = util.getObject();
}
}

class Utils&lt;T&gt;
{
private T object;

public void setObject(T object)
{
this.object = object;
}

public T getObject()
{
return object;
}
}

class Worker
{
}

class Student
{
}
/**
需求:一个钉子厂，钉子厂可以生产钉子和对外打广告，钉子的原料可
以有3种，铁、铝、铜，生产的时候用一种就行，一个钉子厂在实例化
的时候，才定下来这个钉子厂只能用那一种原料生产。

思路:

步骤:
*/
class NailFactoryDemo
{
public static void main(String[] args)
{
NailFactory&lt;Aluminum&gt; aluminumNailFactory = new NailFactory&lt;Aluminum&gt;();

aluminumNailFactory.advertise();
//aluminumNailFactory.makeNail(new Copper());
aluminumNailFactory.makeNail(new Aluminum());
}
}

class NailFactory&lt;T&gt;
{
public void advertise()
{
System.out.println(&quot;我们厂是世界上最好的钉子厂&quot;);
}

public void makeNail(T material)
{
if(material instanceof Aluminum || material instanceof Copper
|| material instanceof Ferrum)
{
System.out.println(&quot;生产出1吨 &quot; + material + &quot; 钉子&quot;);
}
else
{
return;
}

}
}

/*
class NailFactory
{
public void advertise()
{
System.out.println(&quot;我们厂是世界上最好的钉子厂&quot;);
}

public void makeNail(Object material)
{
if(material instanceof Aluminum || material instanceof Copper
|| material instanceof Ferrum)
{
System.out.println(&quot;生产出1吨 &quot; + material + &quot; 钉子&quot;);
}
else
{
return;
}
}
}
//*/

class Aluminum
{
public String toString()
{
return &quot;铝&quot;;
}
}

class Copper
{
public String toString()
{
return &quot;铜&quot;;
}
}

class Ferrum
{
public String toString()
{
return &quot;铁&quot;;
}
}

class Gold
{
public String toString()
{
return &quot;金&quot;;
}
}
/**
需求:演示泛型方法、静态方法泛型

思路:定义一个工具类，可以打印对象，但是为了能打印所有对象打印的对
象的类型延迟到方法调用的时候才能确定。

步骤:

总结：
1.为了让不同方法可以操作不同引用类型，而且类型还要延迟到使用方法的
时候才能确定，那么泛型可以定义在方法上。
2.在调用泛型方法的时候，不用像使用泛型类一样指定类型，而是根据方法
的参数列表和返回值来确定泛型的类型，泛型方法相当于，方法参数的类型
或者方法返回值类型延迟到方法实际调用的时候才确定，并且不用显式指定
，泛型类型会根据返回值类型和参数类型默认进行类型匹配。
3.泛型类中的泛型类型作用于整个对象生存期，而泛型方法中的泛型类型只
作用于方法的某一次执行期间，和方法的局部变量类似。
4.静态方法不可以访问类上定义的泛型，如果静态方法操作的引用数据类型
不确定可以将泛型定义在方法上。
*/
class GenericMethodDemo
{
public static void main(String[] args)
{
Utils util = new Utils();

util.show(&quot;泛型&quot;);
util.show(new Integer(15));
util.print(new Integer(15));
}
}

class Utils
{
public &lt;T&gt; void show(T t)
{
System.out.println(&quot;show&quot; + t);
}

public &lt;T&gt; void print(T t)
{
System.out.println(&quot;print&quot; + t);
}

public static &lt;T&gt; void out(T t)
{
System.out.println(&quot;out&quot; + t);
}
}
/**
需求:演示泛型接口

思路:假设一个妻子在做饭的方法中使用过的原材料一生中都是固定的，并
且在该妻子创建的时候才确定原材料的类型。

步骤:

总结：
1.接口的泛型是延迟接口中使用的引用类型到实现接口或者使用接口
定义变量的时候才确定，如果实现接口的类还不能确定该引用类型，可以
继续定义泛型类，延迟到类创建对象的时候才确定该类型。所以延迟也是
可以传递的。
2.如果泛型类在使用的时候，如果指定泛型的类型，在使用该对象调用类
的函数的时候，才会提示类型不安全。
3.泛型在指定类型的时候，看起来有点重复，因为类上要指定，函数上还
要传对应的参数，如果有类的依赖关系，依赖的类在使用过的时候还要指
定，也就是在每一个使用泛型类的地方都要指定。
4.泛型增加了安全性，但是也增加了表达上的冗余。
*/
class GenericInterfaceDemo
{
public static void main(String[] args)
{
//Family family = new Family(new XiaoFang&lt;String&gt;()); //会报操作不安全
Family&lt;String&gt; family = new Family&lt;String&gt;(new XiaoFang&lt;String&gt;());
family.cook(&quot;米&quot;);
}
}


interface Wife&lt;T&gt;
{
void cook(T material);
}

/*
class Family
{
Wife wife;

Family(Wife wife)
{
this.wife = wife;
}

public void cook(Object material)
{
wife.cook(material);
}
}
//*/

class Family&lt;T&gt;
{
Wife&lt;T&gt; wife;

Family(Wife&lt;T&gt; wife)
{
this.wife = wife;
}

public void cook(T material)
{
wife.cook(material);
}
}

class XiaoFang&lt;T&gt; implements Wife&lt;T&gt;
{
public void cook(T material)
{
System.out.println(&quot;XiaoFang cooking by &quot; + material);
}
}
/**
需求:演示泛型限定

思路:
1.演示 Comparator 接口中泛型限定的作用
2.定义一个 Person 类和它的两个子类 Student、Worker
3.在两个 TreeSet 集合中分别保存 Student 和 Worker 对象
4.Person Student Worker 对象排序的定义都相同
5.Comparator 接口的是实现类中泛型分别用 Person Student Worker
6.比较三个 Comparator 实现类的优劣

步骤:

总结：
因为 TreeSet 构造函数的泛型限定 new TreeSet&lt;E&gt;(Comparator&lt;? super E&gt; c)
所以可以只定义 PersonComparator 比较器
new TreeSet&lt;Student&gt;(new PersonComparator())
new TreeSet&lt;Worker&gt;(new PersonComparator())
这样就提高了代码的复用性，减少了代码重复
printCollection(Collection&lt;? extends Person&gt; e) 方法也是相同的道理
*/
import java.util.*;

class GenericLimitDemo
{
public static void main(String[] args)
{
TreeSet&lt;Student&gt; studentTreeSet = new TreeSet&lt;Student&gt;(new PersonComparator());

studentTreeSet.add(new Student(&quot;aaa11&quot;));
studentTreeSet.add(new Student(&quot;aaa13&quot;));
studentTreeSet.add(new Student(&quot;aaa12&quot;));
studentTreeSet.add(new Student(&quot;aaa14&quot;));

TreeSet&lt;Worker&gt; workerTreeSet = new TreeSet&lt;Worker&gt;(new PersonComparator());

workerTreeSet.add(new Worker(&quot;aaa--11&quot;));
workerTreeSet.add(new Worker(&quot;aaa--14&quot;));
workerTreeSet.add(new Worker(&quot;aaa--12&quot;));
workerTreeSet.add(new Worker(&quot;aaa--13&quot;));

prinPersontCollection(studentTreeSet);
prinPersontCollection(workerTreeSet);

}

static void printPersonCollection(Collection&lt;? extends Person&gt; e)
{
Iterator&lt;? extends Person&gt; iterator = e.iterator();
while(iterator.hasNext())
{
Person person = iterator.next();
System.out.println(person.getName());
}
}
}

class Person
{
private String name;

Person(String name)
{
this.name = name;
}

public String getName()
{
return name;
}
}

class Student extends Person
{
Student(String name)
{
super(name);
}
}

class Worker extends Person
{
Worker(String name)
{
super(name);
}
}

class PersonComparator implements Comparator&lt;Person&gt;
{
public int compare(Person person1, Person person2)
{
return person2.getName().compareTo(person1.getName());
}
}
import java.util.*;
class MapDemo
{
public static void main(String[] args)
{
//建立Map集合
Map&lt;String,String&gt; map=new HashMap&lt;String,String&gt;();
////添加元素,添加元素，如果出现添加时，相同的键。那么后添加的值会覆盖原有键对应值。
map.put(&quot;01&quot;,&quot;zhangsan1&quot;);
map.put(&quot;02&quot;,&quot;zhangsan2&quot;);
map.put(&quot;03&quot;,&quot;zhangsan3&quot;);
map.put(&quot;04&quot;,&quot;zhangsan4&quot;);

sop(map.containsKey(&quot;02&quot;));//判断键是否存在
sop(map.get(&quot;01&quot;));//可以通过get方法的返回值来判断一个键是否存在。通过返回null来判断。
sop(map);
Collection&lt;String&gt; coll=map.values();//用values获取map集合中所有的值.
sop(coll);
}
public static void sop(Object obj)//为了打印方便建立一个函数
{
System.out.println(obj);
}
}
import java.util.*;
class MapDemo2
{
public static void main(String[] args)
{
Map&lt;String,String&gt; map=new HashMap&lt;String,String&gt;();

map.put(&quot;01&quot;,&quot;zhansan01&quot;);
map.put(&quot;02&quot;,&quot;zhansan02&quot;);
map.put(&quot;03&quot;,&quot;zhansan03&quot;);
map.put(&quot;04&quot;,&quot;zhansan04&quot;);

Set&lt;String&gt; s=map.keySet();//先获取map集合的所有键的Set集合,keySet();
System.out.println(map);//有了Set集合。就可以获取其迭代器。

for(Iterator&lt;String&gt; it=s.iterator(); it.hasNext();)
{
String key=it.next();
//有了键可以通过map集合的get方法获取其对应的值。
String value=map.get(key);
System.out.println(key+&quot;...&quot;+value);
}
}
}
interface Map&lt;K, V&gt;
{
public static interface Entry&lt;K, V&gt;
{
public abstract K getKey();
public abstract V getValue();
...
}
...
}
/**
1.描述学生.
2.定义map容器.将学生作为键.住址作为值,存入.
3.获取map集合中的元素
*/
import java.util.*;

class MapDemo3
{
public static void main(String[] args)
{
Map&lt;Integer,String&gt; map=new HashMap&lt;Integer,String&gt;();

map.put(01,&quot;java01&quot;);
map.put(02,&quot;java02&quot;);
map.put(03,&quot;java03&quot;);
map.put(04,&quot;java04&quot;);

//将Map集合中的映射关系取出。存入到Set集合中。
Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entrySet=map.entrySet();

for(Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it=entrySet.iterator();it.hasNext();)
{
Map.Entry&lt;Integer,String&gt; me=it.next();
Integer key=me.getKey();
String value=me.getValue();
System.out.println(key+&quot;....&quot;+value);
}
}
}
import java.util.*;

class Student implements Comparable&lt;Student&gt;// 为了以后方便可能存进去TreeSet集合中去实现Comparable.将学生具备比较性
{
private String name;
private int age;

Student(String name, int age)// 将学生name和age初始化
{
this.name = name;
this.age = age;
}

public int compareTo(Student s)// 覆盖Comparable中的compareTo方法.来比较,先比较age在比较name.
{
int num = new Integer(this.age).compareTo(new Integer(s.age));// Integer是因为age是基本数据类型不具备比较.要转成Integer来实现compareTo方法
if (num == 0)
return this.name.compareTo(s.name);// name是字符串本身就比较比较性.直接使用compareTo方法就哦了
return num;
}

public int hashCode()// 复写hashCode.来让存进去的学生保证唯一.为什么要覆盖因为默认比较是比较hash值.和内容是否一样.因为存的是hash值所以每次建立对象的时候都不一样
// 所以要复写hashCode,来比较年龄和姓名是否是相同.这样就能保证学生的唯一性了.
{
return name.hashCode() + age * 34;
}

public boolean equals(Object obj)// 如果年龄相同的话在比较年龄.
{
if (!(obj instanceof Student))// 如果穿进去不的不是学生类.抛异常
throw new ClassCastException(&quot;类型不匹配&quot;);
Student s = (Student) obj;
return this.name.equals(s.name) &amp;&amp; this.age == s.age;
}

public String getName() {
return name;
}

public int getInt() {
return age;
}

public String toString() {
return name + &quot;..&quot; + age;
}
}

class MapTest {
public static void main(String[] args) {
HashMap&lt;Student, String&gt; hm = new HashMap&lt;Student, String&gt;();// 穿件Map集合中的
// HashMap集合

hm.put(new Student(&quot;zhangsan01&quot;, 21), &quot;beijing&quot;);// 往里面添加键值对.将学生作为键.住址作为值
hm.put(new Student(&quot;zhangsan02&quot;, 22), &quot;tianjing&quot;);
hm.put(new Student(&quot;zhangsan03&quot;, 23), &quot;sahgnhan&quot;);
hm.put(new Student(&quot;zhangsan01&quot;, 23), &quot;sahgnhan&quot;);

// 第一种去取出方式
Set&lt;Student&gt; s = hm.keySet();
for (Iterator&lt;Student&gt; it = s.iterator(); it.hasNext();) {
Student key = it.next();
String value = hm.get(key);
System.out.println(key + &quot;....&quot; + value);
}
// 第二种取出方式
System.out
.println(&quot;-----------------------------------------------------&quot;);
Set&lt;Map.Entry&lt;Student, String&gt;&gt; entrySet = hm.entrySet();
for (Iterator&lt;Map.Entry&lt;Student, String&gt;&gt; it = entrySet.iterator(); it
.hasNext();) {
Map.Entry&lt;Student, String&gt; me = it.next();
Student key1 = me.getKey();
String value1 = me.getValue();
System.out.println(key1 + &quot;...&quot; + value1);
}
}
}
Collection.sort(list);//对list集合进行排序
int index =Collection.binarySearch(list,&quot;aaa&quot;);//查找&quot;aaa&quot;所在位置.返回插入点-1
Collection.sort(list,new 比较器Comparator);//对list集合进行长度排序
int index =Collection.binarySearch(list,&quot;aaa&quot;new 比较器Comparator);//查找&quot;aaa&quot;所在位置.(按长度来了)返回插入点-1
</code>
</RECORD>
<RECORD>
<snippet_key>213509</snippet_key>
<tag>326</tag>
<comment>来自CSDN博客：Hibernate中对象的状态  http://blog.csdn.net/u011417072/article/details/20291573#</comment>
<code>/**
* 对象的状态
*
* @author Administrator
*
*/
public class StateTest {
private static SessionFactory sessionFactory;
static {
Configuration configuration = new Configuration();
configuration.configure();
sessionFactory = configuration.buildSessionFactory();
}

@Test
public void testUpdatePerson() {
Session session = sessionFactory.openSession();
Transaction transaction = session.beginTransaction();
Person person = (Person) session.get(Person.class, 2L);
person.setPname(&quot;aaa&quot;);
session.update(person);//本来就是持久化状态 所以这行代码也没用
transaction.commit();
session.close();
}

/**
* 该程序发出了 Hibernate: select max(pid) from person
* 这条sql语句是在session.save(person);发出的
* Hibernate: insert into hibernate0909.person (pname, psex, pid) values (?, ?, ?)
* 是在transaction.commit();发出的 两条sql语句
*/
@Test
public void testSavePerson() {
Session session = sessionFactory.openSession();
Transaction transaction = session.beginTransaction();
Person person = new Person();
person.setPname(&quot;abc&quot;);
person.setPsex(&quot;asdf&quot;);
session.close();
session.save(person);
transaction.commit();

}

@Test
public void testSaveOrUpdate() {
Session session = sessionFactory.openSession();
Transaction transaction = session.beginTransaction();
Person person = new Person();// 临时状态
person.setPname(&quot;abc&quot;);// 临时状态
person.setPsex(&quot;asdf&quot;);// 临时状态
// session.save(person);//临时状态转化成持久化状态
person.setPname(&quot;aaaa&quot;);// 持久化状态
session.save(person);// 无用，因为已经是持久化状态
transaction.commit();// 同步到数据库中
session.close();// 托管状态
}

@Test
public void testUpdatePerson2() {
Session session = sessionFactory.openSession();
Transaction transaction = session.beginTransaction();
Person person = (Person) session.get(Person.class, 2L);
person.setPname(&quot;aaa&quot;);
/**
* 在执行session.update的时候， hibernate内部会为person对象去对照内存快照（副本），如果属性发生改变才要执行
* update语句，如果没有改变，则不发出update语句
*/
session.update(person);
transaction.commit();// 并没有发出update语句
session.close();
}

/**
* 如果执行session.save方法，hibernate内部会检查主键是否存在，如果存在，则不管
* 如果执行session.update方法，看属性是否发生变化，如果发生变化，则执行update语句，如果没有发生改变，则不执行
* 在hibernate内部，是通过标识符来判断一个对象在数据库中是否有值
*/
@Test
public void testUpdate3() {
Session session = sessionFactory.openSession();
Transaction transaction = session.beginTransaction();
Person person = new Person();
person.setPid(2L);
session.update(person);
transaction.commit();
session.close();
}

@Test
public void testSavePerson3() {
Session session = sessionFactory.openSession();
Transaction transaction = session.beginTransaction();
Person person = new Person();// 临时状态
person.setPname(&quot;abc&quot;);
person.setPsex(&quot;asdf&quot;);
session.save(person);// 持久化状态
transaction.commit();
session.close();// 当session关闭以后，事务环境不存在了
session = sessionFactory.openSession();// 打开了一个新的session,这个时候的session并没有保存person对象
Transaction transaction2 = session.beginTransaction();
session.update(person);// person中的id已经有值了
transaction2.commit();
session.close();
}

@Test
public void testaa() {
Session session = sessionFactory.openSession();
Transaction transaction = session.beginTransaction();
Person per = new Person();
//Person per = (Person)session.get(Person.class, 1L);
per.setPid(1L);
per.setPsex(&quot;男&quot;);
per.setPname(&quot;Steven&quot;);
session.update(per);
session.getTransaction().commit();
// 数据库中id、name、sex全都一样，为什么还执行update语句？
session.close();

}
}
public class StateExam {
private static SessionFactory sessionFactory;
static {
Configuration configuration = new Configuration();
configuration.configure();
sessionFactory = configuration.buildSessionFactory();
}
/**
* 利用session.createQuery(&quot;from Person&quot;).list方法把person表的所有的数据全部提取出来
然后遍历list,把person中的属性做一些改变，最后提交事务，关闭session.
*/
@Test
public void testEx01(){
Session session = sessionFactory.openSession();
Transaction transaction = session.beginTransaction();
List&lt;Person&gt; personList = session.createQuery(&quot;from Person&quot;).list();
for(Person person:personList){
person.setPname(&quot;干露露&quot;);//person已经是持久化对象的状态
}
transaction.commit();
session.close();
}
/**
* 新创建一个person对象，执行save方法，再关闭session,
再重新打开一个session,让person对象的属性值发生改变，把改变后的结果同步到数据库中
*/
@Test
public void testEx02(){
Session session = sessionFactory.openSession();
Transaction transaction = session.beginTransaction();
Person person = new Person();
person.setPname(&quot;干露露的妈&quot;);
person.setPsex(&quot;腰&quot;);
session.save(person);
transaction.commit();
session.close();
session = sessionFactory.openSession();
transaction = session.beginTransaction();
person.setPsex(&quot;老妖&quot;);
session.update(person);
transaction.commit();
session.close();
}
@Test
public void test1(){
Session session=sessionFactory.openSession();
Transaction transaction=session.beginTransaction();
List&lt;Person&gt; persons=session.createQuery(&quot;from Person&quot;).list();
for (Person person : persons) {
person.setPname(&quot;你妹&quot;);
}
transaction.commit();
session.close();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>213765</snippet_key>
<tag>android viewpager Scroller</tag>
<comment>来自CSDN博客：ViewPager切换滑动速度修改  http://blog.csdn.net/liyuxp/article/details/20303021#</comment>
<code>public class FixedSpeedScroller extends Scroller {
private int mDuration = 1500;

public FixedSpeedScroller(Context context) {
super(context);
}

public FixedSpeedScroller(Context context, Interpolator interpolator) {
super(context, interpolator);
}

@Override
public void startScroll(int startX, int startY, int dx, int dy, int duration) {
// Ignore received duration, use fixed one instead
super.startScroll(startX, startY, dx, dy, mDuration);
}

@Override
public void startScroll(int startX, int startY, int dx, int dy) {
// Ignore received duration, use fixed one instead
super.startScroll(startX, startY, dx, dy, mDuration);
}

public void setmDuration(int time) {
mDuration = time;
}

public int getmDuration() {
return mDuration;
}
}
try {
Field field = ViewPager.class.getDeclaredField(&quot;mScroller&quot;);
field.setAccessible(true);
FixedSpeedScroller scroller = new FixedSpeedScroller(mViewPager.getContext(),
new AccelerateInterpolator());
field.set(mViewPager, scroller);
scroller.setmDuration(2000);
} catch (Exception e) {
LogUtils.e(TAG, &quot;&quot;, e);
}
</code>
</RECORD>
<RECORD>
<snippet_key>460302</snippet_key>
<tag>java 初学者 java编程思想练习题</tag>
<comment>来自CSDN博客：java编程思想（第四版）第二章练习题-9  http://blog.csdn.net/xiao1ni1zi/article/details/38895213#</comment>
<code>&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;&lt;span style=&quot;font-size:18px;&quot;&gt;public class Test9 {
static Integer i = new Integer(10);
static int a = new Integer(20);
public static void main(String args[]){
System.out.println(&quot;i = &quot;+i);
System.out.println(&quot;a = &quot;+a);
}
}&lt;/span&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>1806</snippet_key>
<tag></tag>
<comment>     *    ***   *****  ******* ******************** *********  *******   *****    ***     *</comment>
<code>package zaifu.com ;

public class MultiplyLoop3 {
public static void main ( String [ ] args ) {
MultiplyLoop3 multiplyLoop3 = new MultiplyLoop3 ( ) ;
multiplyLoop3.print ( 11 ) ;
}

public void print ( int n ) {
int temp = 0 ;
for ( int i = 0 ; i &lt; n ; i ++ ) {
for ( int j = 0 ; j &lt; Math.abs ( n / 2 - i ) ; j ++ ) {
System.out.print ( &quot; &quot; ) ;
}
if ( i &lt;= n / 2 ) {
temp = i ;
}
else {
temp = n - i - 1 ;
}
for ( int k = 0 ; k &lt; ( 2 * temp + 1 ) ; k ++ ) {
System.out.print ( &quot;*&quot; ) ;
}
System.out.println ( ) ;
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>344837</snippet_key>
<tag>java swing 鼠标 mxgraph 鼠标滚动事件</tag>
<comment>来自CSDN博客：解决swt桥连awt后鼠标滚轮事件(MouseEvent)无法接收的问题。 http://blog.csdn.net/mixiao25184/article/details/25802979#</comment>
<code>//AWT和SWT框架联系在一起的桥梁
final Composite container = new Composite(parent ,SWT.EMBEDDED);
Frame frame = SWT_AWT.new_Frame(container);
java.awt.event.MouseMotionListener mlAwt = new MouseMotionListener() {
@Override
public void mouseMoved(MouseEvent e) {
container.getDisplay().asyncExec(new Runnable() {
@Override
public void run() {
container.forceFocus();
}
});
}
@Override
public void mouseDragged(MouseEvent e) {
}
};
container.addMouseWheelListener(new MouseWheelListener() {
@Override
public void mouseScrolled(final org.eclipse.swt.events.MouseEvent event) {
// BPMClient.moseWheelListener(event.count);
EventQueue.invokeLater(new Runnable() {
public void run() {
System.out.println(&quot;滚动事件传递滚动值，
这里根据event.count值判断是上下滚动&quot;);
}
});

}
});



// 给相应的面板传递该事件,提醒AWT鼠标监听器添加到所有被添加进了AWT框架的孩子

bpmPanel.graphComponent.getGraphControl().addMouseMotionListener(mlAwt);
</code>
</RECORD>
<RECORD>
<snippet_key>475909</snippet_key>
<tag>来自CSDN博客：Android开发之获取手机SIM卡信息 http://blog.csdn.net/fengyuzhengfan/article/details/38036903#</tag>
<comment>派生自CrazyCodeBoy/blog_20140722_1_7465442</comment>
<code>package com.jph.telephonystatus;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import android.os.Bundle;
import android.app.Activity;
import android.content.Context;
import android.telephony.TelephonyManager;
import android.widget.ListView;
import android.widget.SimpleAdapter;
/**
* Describe:&lt;/br&gt;
* 获取Sim卡信息
* 本实例通过TelephonyManager类的对象的getXxx()
* 方法获取手机Sim卡信息。
* @author jph
* Date:2014.07.22
* */
public class TelephonyStatus extends Activity {
ListView listShow;
//创建一个tManager类的实例
TelephonyManager tManager;
//声明一个表示Sim卡状态名的数组
String []statusName=new String[]{};
//声明一个表示Sim卡状态值得集合
ArrayList&lt;String&gt;statusValue=new ArrayList&lt;String&gt;();
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
listShow=(ListView)findViewById(R.id.listShow);
//获取系统的tManager对象
tManager=(TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);
//获取表示各种状态名的数组
statusName=getResources().getStringArray(R.array.statusName);
//获取表示sim卡状态的的数组
String simStatus[]=getResources().getStringArray(R.array.simStatus);
//获取表示手机类型的数组
String phoneType[]=getResources().getStringArray(R.array.phoneType);
//获取设备编号
statusValue.add(tManager.getDeviceId());
//获取设备类型
statusValue.add(phoneType[tManager.getPhoneType()]);
//获取软件版本
statusValue.add(tManager.getDeviceSoftwareVersion()==null?&quot;未知&quot;
:tManager.getDeviceSoftwareVersion());
//获取设备当前位置
statusValue.add(tManager.getCellLocation()==null? &quot;未知&quot;
:tManager.getCellLocation().toString());
//获取设备呼叫状态
switch (tManager.getCallState()) {
case TelephonyManager.CALL_STATE_IDLE:
statusValue.add(&quot;空闲&quot;);
break;
case TelephonyManager.CALL_STATE_OFFHOOK:
statusValue.add(&quot;正在通话&quot;);
break;
case TelephonyManager.CALL_STATE_RINGING:
statusValue.add(&quot;等待接听&quot;);
break;
default:
break;
}
//获取电话号码
statusValue.add(tManager.getLine1Number());
//获取运营商的国家代码
statusValue.add(tManager.getNetworkCountryIso());
//获取运营商的名称
statusValue.add(tManager.getNetworkOperatorName());
//获取网络类型
statusValue.add(getNetworkType(tManager.getNetworkType()));
//获取SPN
statusValue.add(tManager.getSimOperatorName().equals(&quot;&quot;)?&quot;未知&quot;
:tManager.getSimOperatorName());
//获取SIM卡的序列号
statusValue.add(tManager.getSimSerialNumber());
//获取SIM卡状态
statusValue.add(simStatus[tManager.getSimState()]);
List&lt;Map&lt;String, Object&gt;&gt; listItems=new ArrayList&lt;Map&lt;String,Object&gt;&gt;();
// 遍历statusValues集合，将statusNames、statusValues
// 的数据封装到List&lt;Map&lt;String , String&gt;&gt;集合中
for (int i = 0; i &lt; statusName.length; i++) {
Map&lt;String, Object&gt;listItem=new HashMap&lt;String, Object&gt;();
listItem.put(&quot;name&quot;,statusName[i]);
listItem.put(&quot;value&quot;,statusValue.get(i));
listItems.add(listItem);
}
SimpleAdapter adapter=new SimpleAdapter(this, listItems, R.layout.line,
new String[]{&quot;name&quot;,&quot;value&quot;},new int[]{R.id.txtName,R.id.txtValue});
//为listShow设置Adapter
listShow.setAdapter(adapter);
}
//获取手机网络类型
private String getNetworkType(int networkType) {
// TODO Auto-generated method stub
switch (networkType) {
case TelephonyManager.NETWORK_TYPE_1xRTT:
return &quot;1xRTT&quot;;
case TelephonyManager.NETWORK_TYPE_CDMA:
return &quot;CDMA&quot;;
case TelephonyManager.NETWORK_TYPE_EDGE:
return &quot;EDGE&quot;;
case TelephonyManager.NETWORK_TYPE_EHRPD:
return &quot;EHRPD&quot;;
case TelephonyManager.NETWORK_TYPE_EVDO_0:
return &quot;EVDO_0&quot;;
case TelephonyManager.NETWORK_TYPE_EVDO_A:
return &quot;EVDO_A&quot;;
case TelephonyManager.NETWORK_TYPE_EVDO_B:
return &quot;EVDO_B&quot;;
case TelephonyManager.NETWORK_TYPE_GPRS:
return &quot;GPRS&quot;;
case TelephonyManager.NETWORK_TYPE_HSDPA:
return &quot;HSDPA&quot;;
case TelephonyManager.NETWORK_TYPE_HSPA:
return &quot;HSPA&quot;;
case TelephonyManager.NETWORK_TYPE_HSPAP:
return &quot;HSPAP&quot;;
case TelephonyManager.NETWORK_TYPE_HSUPA:
return &quot;HSUPA&quot;;
case TelephonyManager.NETWORK_TYPE_IDEN:
return &quot;IDEN&quot;;
case TelephonyManager.NETWORK_TYPE_LTE:
return &quot;LTE&quot;;
case TelephonyManager.NETWORK_TYPE_UMTS:
return &quot;UMTS&quot;;
case TelephonyManager.NETWORK_TYPE_UNKNOWN:
return &quot;UNKNOWN&quot;;
default:
return &quot;UNKNOWN&quot;;
}
}
}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
&lt;!-- 声明一个名为statusName的数组 --&gt;
&lt;string-array name=&quot;statusName&quot;&gt;
&lt;item&gt;设备编号&lt;/item&gt;
&lt;item&gt;手机制式&lt;/item&gt;
&lt;item&gt;软件版本&lt;/item&gt;
&lt;item&gt;设备当前位置&lt;/item&gt;
&lt;item&gt;设备呼叫状态&lt;/item&gt;
&lt;item&gt;电话号码&lt;/item&gt;
&lt;item&gt;运营商的国家代码&lt;/item&gt;
&lt;item&gt;运营商的名称&lt;/item&gt;
&lt;item&gt;网络类型&lt;/item&gt;
&lt;item&gt;SPN&lt;/item&gt;
&lt;item&gt;SIM卡的序列号&lt;/item&gt;
&lt;item&gt;SIM卡状态&lt;/item&gt;
&lt;/string-array&gt;
&lt;!-- 声明一个名为phoneType的数组 --&gt;
&lt;string-array name=&quot;phoneType&quot;&gt;
&lt;item&gt;未知&lt;/item&gt;
&lt;item&gt;GSM&lt;/item&gt;
&lt;item&gt;CDMA&lt;/item&gt;
&lt;/string-array&gt;
&lt;!-- 声明一个名为simSatus的数组 --&gt;
&lt;string-array name=&quot;simStatus&quot;&gt;
&lt;item&gt;状态未知&lt;/item&gt;
&lt;item&gt;无SIM卡&lt;/item&gt;
&lt;item&gt;被PIN加锁&lt;/item&gt;
&lt;item&gt;被PUK加锁&lt;/item&gt;
&lt;item&gt;被NetWork PIN加锁&lt;/item&gt;
&lt;item&gt;已准备好&lt;/item&gt;
&lt;/string-array&gt;
&lt;/resources&gt;
&lt;!-- 添加访问手机位置的权限 --&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt;
&lt;!-- 添加访问手机状态的权限 --&gt;
&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>82949</snippet_key>
<tag>来自CSDN博客：JSTL与EL表达式 http://blog.csdn.net/sunhuimingzxc/article/details/16891863#</tag>
<comment>派生自sunhuimingzxc/blog_20131122_1_3845520</comment>
<code>public void doGet(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {

request.setAttribute(&quot;hello&quot;, &quot;Hello World!!!&quot;);

Group group = new Group();
group.setGroupName(&quot;三年二班&quot;);
User user = new User();
user.setPassword(&quot;abc&quot;);
user.setUserName(&quot;sunhuimig&quot;);
user.setGroup(group);
request.setAttribute(&quot;user&quot;, user);

String[] obj = new String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;};
request.setAttribute(&quot;obj&quot;, obj);

Map map = new HashMap();
map.put(&quot;k&quot;, &quot;key&quot;);
map.put(&quot;y&quot;, &quot;yes&quot;);

List&lt;User&gt; list = new ArrayList&lt;User&gt;();
list.add(user);

request.setAttribute(&quot;map&quot;, map);
request.setAttribute(&quot;list&quot;, list);

request.getRequestDispatcher(&quot;/WEB-INF/test/el.jsp&quot;).forward(request, response);
}
&lt;li&gt;字符：&lt;/li&gt;
${hello }&lt;br&gt;

&lt;li&gt;对象：&lt;/li&gt;
用户名：${user.userName }&lt;br&gt;
密码：${user.password }&lt;br&gt;
组名：${user.group.groupName }&lt;br&gt;

&lt;li&gt;数组：&lt;/li&gt;
${obj[0] }&lt;br&gt;

&lt;li&gt;MAP：&lt;/li&gt;
${map.k }&lt;br&gt;

&lt;li&gt;list中的对象&lt;/li&gt;
${list[0].userName }&lt;br&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>410629</snippet_key>
<tag>478</tag>
<comment>来自CSDN博客：java 冒泡排序 http://blog.csdn.net/yx13649017813/article/details/35801489#</comment>
<code>/**
* @Title: mpSort
* @Description: 冒泡排序(规则: 内层循环-i-1)
*/
public static void mpSort(){
System.out.println(&quot;请输入你要输入的数据个数: &quot;);
Scanner sc = new Scanner(System.in);
int count = sc.nextInt();
int[] arr = new int[count];
for (int i = 0; i &lt; arr.length; i++) {
System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个数: &quot;);
arr[i] = sc.nextInt();
}
System.out.println(&quot;排序后的数据是: &quot;);
for (int i = 0; i &lt; arr.length; i++) {
System.out.print(arr[i]);
if (i &lt; arr.length - 1) {
System.out.print(&quot; , &quot;);
}
}
for (int i = 0; i &lt; arr.length; i++) {
for (int j = 0; j &lt; arr.length-i-1; j++) {
if (arr[j] &gt; arr[j+1]) {
int temp = arr[j];
arr[j] = arr[j+1];
arr[j+1] = temp;
}
}
}
System.out.println(&quot;\n排序后的数据是: &quot;);
for (int i = 0; i &lt; arr.length; i++) {
System.out.print(arr[i]);
if (i &lt; arr.length - 1) {
System.out.print(&quot; , &quot;);
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>395278</snippet_key>
<tag>判断网络是否畅通</tag>
<comment>来自CSDN博客：判断网络是否畅通，否则设置网络连接  http://blog.csdn.net/u011402761/article/details/31529127#</comment>
<code>public class NetworkDetector {

public static boolean detect(Activity act) {

ConnectivityManager manager = (ConnectivityManager) act
.getApplicationContext().getSystemService(
Context.CONNECTIVITY_SERVICE);

TelephonyManager mTelephony = (TelephonyManager) act
.getSystemService(act.TELEPHONY_SERVICE);

// 检查网络连接，如果无网络可用，就不需要进行连网操作等
NetworkInfo info = manager.getActiveNetworkInfo();

if (info == null || !manager.getBackgroundDataSetting()) {
return false;
}

// 判断网络连接类型，只有在3G或wifi里进行一些数据更新。
int netType = info.getType();
int netSubtype = info.getSubtype();

if (netType == ConnectivityManager.TYPE_WIFI) {
return info.isConnected();
} else if (netType == ConnectivityManager.TYPE_MOBILE
&amp;&amp; netSubtype == TelephonyManager.NETWORK_TYPE_UMTS
&amp;&amp; !mTelephony.isNetworkRoaming()) {
return info.isConnected();
} else {
return false;
}

}

public static void setNetworkMethod(final Activity activty) {
// 提示对话框
AlertDialog.Builder builder = new Builder(activty);
builder.setTitle(&quot;网络设置提示&quot;)
.setMessage(&quot;网络连接不可用,是否进行设置?&quot;)
.setPositiveButton(&quot;设置&quot;, new DialogInterface.OnClickListener() {

@Override
public void onClick(DialogInterface dialog, int which) {
// TODO Auto-generated method stub
Intent intent = null;
// 判断手机系统的版本 即API大于10 就是3.0或以上版本
if (android.os.Build.VERSION.SDK_INT &gt; 10) {
intent = new Intent(
android.provider.Settings.ACTION_WIRELESS_SETTINGS);
} else {
intent = new Intent();
ComponentName component = new ComponentName(
&quot;com.android.settings&quot;,
&quot;com.android.settings.WirelessSettings&quot;);
intent.setComponent(component);
intent.setAction(&quot;android.intent.action.VIEW&quot;);
}
activty.startActivity(intent);
}
})
.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() {

@Override
public void onClick(DialogInterface dialog, int which) {
dialog.dismiss();
}
}).show();
}

}
&lt;/pre&gt;&lt;pre code_snippet_id=&quot;395278&quot; snippet_file_name=&quot;blog_20140616_3_2782453&quot; name=&quot;code&quot; class=&quot;java&quot;&gt;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
boolean networkState = NetworkDetector.detect(MainActivity.this);
if (!networkState) {


NetworkDetector.setNetworkMethod(this);


} else {
Toast.makeText(MainActivity.this, &quot;网络畅通！&quot;, Toast.LENGTH_SHORT)
.show();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>461070</snippet_key>
<tag>327</tag>
<comment>来自CSDN博客：Servlet实现Session  http://blog.csdn.net/u010870518/article/details/38945211#</comment>
<code>//登陆界面
package com.tsinghua;

import javax.servlet.http.*;

import java.io.*;

public class Login extends HttpServlet{

public void doGet(HttpServletRequest req,HttpServletResponse res){

//业务逻辑
try{
//解决中文乱码
res.setContentType(&quot;text/html;charset=gbk&quot;);

PrintWriter pw = res.getWriter();
//返回登陆界面
pw.println(&quot;&lt;html&gt;&quot;);
pw.println(&quot;&lt;body&gt;&quot;);

pw.println(&quot;&lt;h1&gt;用户登录&lt;/h1&gt;&quot;);
pw.println(&quot;&lt;form action=logincl method=post&gt;&quot;); //action的是servlet的url
pw.println(&quot;用户名：&lt;input type=text name=username&gt;&lt;br/&gt;&quot;);
pw.println(&quot;密码：&lt;input type=password name=passwd&gt;&lt;br/&gt;&quot;);
pw.println(&quot;&lt;input type=submit value=loing&gt;&lt;br/&gt;&quot;);
pw.println(&quot;&lt;input type=hidden name=sex value=男&gt;&lt;br/&gt;&quot;); //hidden类型在页面中不显示
pw.println(&quot;&lt;/form&gt;&quot;);

pw.println(&quot;&lt;/body&gt;&quot;);
pw.println(&quot;&lt;/html&gt;&quot;);

}
catch(Exception ex){
ex.printStackTrace();
}
}

public void doPost(HttpServletRequest req,HttpServletResponse res){
this.doGet(req,res);
}
}
//登陆界面
package com.tsinghua;

import javax.servlet.http.*;

import java.io.*;

public class Logincl extends HttpServlet{

public void doGet(HttpServletRequest req,HttpServletResponse res){

//业务逻辑
try{
//解决中文乱码
//res.setContentType(&quot;text/html;charset=gbk&quot;);
//PrintWriter pw = res.getWriter();

//接受用户名和密码
String u = req.getParameter(&quot;username&quot;);
String p = req.getParameter(&quot;passwd&quot;);
//验证
if(u.equals(&quot;sp&quot;) &amp;&amp; p.equals(&quot;123&quot;))
{
//将验证成功的信息，写入到session中去
//1.得到session
HttpSession hs = req.getSession(true);
//修改session的存在时间
hs.setMaxInactiveInterval(20000);// 以秒算的
hs.setAttribute(&quot;pass&quot;,&quot;ok&quot;); //设置到session中去

//合法的情况 跳转到Welcome
res.sendRedirect(&quot;welcome?uname=&quot;+u+&quot;&amp;upass=&quot;+p);//这里跳转的仍是servlet的url
}
else
{
//不合法的情况
//跳转
res.sendRedirect(&quot;login&quot;);//跳转的是要到servlet的url
}

}
catch(Exception ex){
ex.printStackTrace();
}
}

public void doPost(HttpServletRequest req,HttpServletResponse res){
this.doGet(req,res);
}
}
//登陆界面
package com.tsinghua;

import javax.servlet.http.*;

import java.io.*;

public class Welcome extends HttpServlet{

public void doGet(HttpServletRequest req,HttpServletResponse res){

//得到session
HttpSession hs = req.getSession(true);
String val = (String)hs.getAttribute(&quot;pass&quot;);
//判断
if(val == null)
{
try{
//非法登陆
res.sendRedirect(&quot;login&quot;);
}catch(Exception ex){
ex.printStackTrace();
}

}

//得到Logincl传递的 用户名
String u=req.getParameter(&quot;uname&quot;);
//得到密码
String p= req.getParameter(&quot;upass&quot;);
String sex= req.getParameter(&quot;sex&quot;);
println(sex);
//业务逻辑

try{
//解决中文乱码
res.setContentType(&quot;text/html;charset=gbk&quot;);

PrintWriter pw = res.getWriter();

pw.println(&quot;hello welcome！&quot;+u+p);

}
catch(Exception ex){
ex.printStackTrace();
}
}

public void doPost(HttpServletRequest req,HttpServletResponse res){
this.doGet(req,res);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>133646</snippet_key>
<tag></tag>
<comment>来自CSDN博客：3.android 读取文件中的数据 http://blog.csdn.net/u011206291/article/details/17660597#</comment>
<code>package com.wjl.bc;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;

import org.apache.http.util.EncodingUtils;

import android.R.string;
import android.app.Activity;
import android.os.Bundle;
import android.widget.TextView;

public class FileManage2Activity extends Activity {
/** Called when the activity is first created. */

private TextView mytextView;
@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);

mytextView=(TextView)findViewById(R.id.myTextView);

// this.fileFromRaw();
// fileFromAsset();

// fileFromSdcard();
String fileName=&quot;Test.txt&quot;;
String message=&quot;abcderty&quot;;
writeFileData(fileName, message);



}


//从 resource中的raw 文件夹中获取文件病毒去数据（资源文件只能度不能写）
public void fileFromRaw()
{
String res=&quot;&quot;;
try {
InputStream in=getResources().openRawResource(R.raw.abc);
int length=in.available();
byte[] buffer=new byte[length];
in.read(buffer);
res=EncodingUtils.getString(buffer, &quot;UTF-8&quot;);
// res=EncodingUtils.getString(buffer, &quot;BIG5&quot;);
// res=EncodingUtils.getString(buffer, &quot;UNICODE&quot;);
in.close();
mytextView.setText(res);
} catch (Exception e) {
// TODO: handle exception
e.printStackTrace();
}
}

/**
* 从asset中获取文件并读出数据（资源文件只能读不能写）
*/
public void fileFromAsset()
{
String fileName=&quot;abc.txt&quot;;
String res=&quot;&quot;;
try {
InputStream in=getResources().getAssets().open(fileName);
int length=in.available();
byte[] buffer=new byte[length];
in.read(buffer);
res=EncodingUtils.getString(buffer, &quot;UTF-8&quot;);
in.close();
mytextView.setText(res);
} catch (Exception e) {
// TODO: handle exception
e.printStackTrace();
}
}

/**
* 从sdcard 中去读文件，首先要把文件通过 adb.exe push d:\abc.txt\sdcard
*
*/

public void fileFromSdcard()
{
String fileName=&quot;/sdcard/abc.txt&quot;;
String res=&quot;&quot;;
try {
FileInputStream fin=new FileInputStream(fileName);
int length=fin.available();
byte[] buffer=new byte[length];
fin.read(buffer);
res=EncodingUtils.getString(buffer, &quot;UTF-8&quot;);
fin.close();
mytextView.setText(res);
} catch (Exception e) {
// TODO: handle exception
e.printStackTrace();
}
}

public void writeFileData(String fileName, String message)
{
try {
FileOutputStream fout=openFileOutput(fileName, MODE_PRIVATE);
byte[] bytes=message.getBytes();
fout.write(bytes);
fout.close();
} catch (Exception e) {
// TODO: handle exception
e.printStackTrace();
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>330254</snippet_key>
<tag></tag>
<comment>来自CSDN博客：【LeetCode】Evaluate Reverse Polish Notation  http://blog.csdn.net/u013027996/article/details/25151249#</comment>
<code>public class Solution {
public int evalRPN(String[] tokens) {
Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
int len = tokens.length;
for(int i = 0; i &lt; len; i++){
if(isDigit(tokens[i])){
stack.push(Integer.parseInt(tokens[i]));
}else{
int num2 = stack.pop();
int num1 = stack.pop();
int num = 0;
if(tokens[i].equals(&quot;+&quot;)){
num = num1 + num2;
}else if(tokens[i].equals(&quot;-&quot;)){
num = num1 - num2;
}else if(tokens[i].equals(&quot;*&quot;)){
num = num1 * num2;
}else{
num = num1 / num2;
}
stack.push(num);
}
}
return stack.peek();
}
private boolean isDigit(String token){
if(token.equals(&quot;+&quot;) || token.equals(&quot;-&quot;)
|| token.equals(&quot;*&quot;) || token.equals(&quot;/&quot;)){
return false;
}
return true;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>395790</snippet_key>
<tag>319</tag>
<comment>来自CSDN博客：startActivityForResult用法详解  http://blog.csdn.net/ee3a1111/article/details/31754527#</comment>
<code>package com.ljq.activitys;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;

public class MainActivity extends Activity {
private final static String TAG=&quot;MainActivity&quot;;

@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);

Button btnOpen=(Button)this.findViewById(R.id.btnOpen);
btnOpen.setOnClickListener(new View.OnClickListener(){
public void onClick(View v) {
//得到新打开Activity关闭后返回的数据
//第二个参数为请求码，可以根据业务需求自己编号
startActivityForResult(new Intent(MainActivity.this, OtherActivity.class), 1);
}
});
}

/**
* 为了得到传回的数据，必须在前面的Activity中（指MainActivity类）重写onActivityResult方法
*
* requestCode 请求码，即调用startActivityForResult()传递过去的值
* resultCode 结果码，结果码用于标识返回数据来自哪个新Activity
*/
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
String result = data.getExtras().getString(&quot;result&quot;);//得到新Activity 关闭后返回的数据
Log.i(TAG, result);
}
}
package com.ljq.activitys;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;

public class OtherActivity extends Activity {

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.other);

Button btnClose=(Button)findViewById(R.id.btnClose);
btnClose.setOnClickListener(new View.OnClickListener(){
public void onClick(View v) {
//数据是使用Intent返回
Intent intent = new Intent();
//把返回数据存入Intent
intent.putExtra(&quot;result&quot;, &quot;My name is linjiqin&quot;);
//设置返回数据
OtherActivity.this.setResult(RESULT_OK, intent);
//关闭Activity
OtherActivity.this.finish();
}
});

}

}
@Override public void onCreate(Bundle savedInstanceState) {
....
button1.setOnClickListener(new View.OnClickListener(){
public void onClick(View v) {
startActivityForResult (new Intent(MainActivity.this, NewActivity.class), 1);
}
});
button2.setOnClickListener(new View.OnClickListener(){
public void onClick(View v) {
startActivityForResult (new Intent(MainActivity.this, NewActivity.class), 2);
}
});

@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) {
switch(requestCode){
case 1:
//来自按钮1的请求，作相应业务处理
case 2:
//来自按钮2的请求，作相应业务处理
}
}
}
public class ResultActivity extends Activity {
.....
ResultActivity.this.setResult(1, intent);
ResultActivity.this.finish();
}
public class NewActivity extends Activity {
......
NewActivity.this.setResult(2, intent);
NewActivity.this.finish();
}
public class MainActivity extends Activity { // 在该Activity会打开ResultActivity和NewActivity
@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) {
switch(resultCode){
case 1:
// ResultActivity的返回数据
case 2:
// NewActivity的返回数据
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>461326</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Servlet生成动态验证码  http://blog.csdn.net/a137151062/article/details/38959043#</comment>
<code>package com.lhg.codeservlet;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Random;

import javax.imageio.ImageIO;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ValidateCodeServlet extends HttpServlet {

@Override
protected void doPost(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {

//禁止页面缓存
response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;);
response.setHeader(&quot;Cache-control&quot;, &quot;No-cache&quot;);
//设置过期的时间
response.setDateHeader(&quot;Expires&quot;, 0);
response.setContentType(&quot;image/jpeg&quot;); //设置响应正文的MIME类型为图片
int width =60, height =20;
/*创建一个位于缓存的图像，宽度为60，高度为20*/
BufferedImage image =new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
Graphics g =image.getGraphics(); //获取用于处理图形上下文的对象，相当于画笔
Random random =new Random(); //创建生成随机数的对象
g.setColor(getRandomColor(200,250)); //设置画像的背景色
g.fillRect(0, 0, width, height); //画一个矩形，坐标(0,0)，宽度为60，高度为20
g.setFont(new Font(&quot;Times New Roman&quot;,Font.PLAIN,18)); //设定字体格式
g.setColor(getRandomColor(160, 200));
for(int i = 0;i&lt;100;i++){ //产生100条随机干扰线
int x = random.nextInt(width);
int y = random.nextInt(height);
int x1 = random.nextInt(12);
int y1 = random.nextInt(12);
g.drawLine(x, y, x+x1, y+y1); //在图形的坐标之间画干扰线
}
String strCode =&quot;&quot;;
for(int i =0; i&lt;4; i++){
String strNumber =String.valueOf(random.nextInt(10)); //设置每次随机的数0~10
strCode =strCode +strNumber; //拼接生成的验证码
//设置字体的颜色
g.setColor(new Color(15+random.nextInt(120),15+random.nextInt(120),15+random.nextInt(120)));

g.drawString(strNumber, 13 * i+6, 16); //将验证码一次画到图像上，坐标（x=13*i +6,y =16）
}
request.getSession().setAttribute(&quot;Code&quot;, strCode); //验证码放到session中
g.dispose();
ImageIO.write(image,&quot;JPEG&quot;, response.getOutputStream()); //输出JEPG格式的图像
response.getOutputStream().flush(); //刷新输出流
response.getOutputStream().close(); //关闭输出流

}
/**
* 随机获取颜色
* @param fc
* @param bc
* @return
*/
public Color getRandomColor(int fc,int bc){
Random random = new Random();
Color randomColor =null;
if(fc&gt;255){
fc=255;
}
if(bc&gt;255){
bc=255;
}
//设置0~255之间的随机颜色值
int r=fc +random.nextInt(bc - fc);
int g=fc +random.nextInt(bc - fc);
int b=fc +random.nextInt(bc - fc);
randomColor = new Color(r,g,b);
return randomColor; //返回具有指定的RGB颜色
}

@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {
doPost(request, response);
}
}
&lt;span style=&quot;font-size:18px;&quot;&gt; //禁止页面缓存
response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;);
response.setHeader(&quot;Cache-control&quot;, &quot;No-cache&quot;);
//设置过期的时间
response.setDateHeader(&quot;Expires&quot;, 0);&lt;/span&gt;
&lt;form action=&quot;index.jsp&quot; method=&quot;post&quot;&gt;
用户名：   &lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;br&gt;
验证码：    &lt;img name=&quot;img1&quot; src =&quot;validatecode&quot;&gt;&lt;br&gt;
输入验证码：&lt;input type=&quot;text&quot; name=&quot;code&quot;/&gt;&lt;br&gt;
&lt;input type=&quot;submit&quot; value=&quot;刷新&quot;&gt;
&lt;/form&gt;
&lt;servlet&gt;
&lt;servlet-name&gt;ValidateCodeServlet&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.lhg.codeservlet.ValidateCodeServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
&lt;servlet-name&gt;ValidateCodeServlet&lt;/servlet-name&gt;
&lt;url-pattern&gt;/validatecode&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>2830</snippet_key>
<tag></tag>
<comment> ERROR/AndroidRuntime(262): java.lang.IllegalStateException: get field slot from row 1 col -1 failed</comment>
<code>04-19 05:02:51.065: WARN/dalvikvm(262): threadid=3: thread exiting with uncaught exception (group=0x4001b188)
04-19 05:02:51.073: ERROR/AndroidRuntime(262): Uncaught handler: thread main exiting due to uncaught exception
04-19 05:02:51.112: ERROR/AndroidRuntime(262): java.lang.IllegalStateException: get field slot from row 1 col -1 failed
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at android.database.CursorWindow.getLong_native(Native Method)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at android.database.CursorWindow.getInt(CursorWindow.java:434)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at android.database.AbstractWindowedCursor.getInt(AbstractWindowedCursor.java:93)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at lnu.edu.Cxuanzeti$3.onClick(Cxuanzeti.java:243)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at android.view.View.performClick(View.java:2364)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at android.view.View.onTouchEvent(View.java:4179)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at android.widget.TextView.onTouchEvent(TextView.java:6541)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at android.view.View.dispatchTouchEvent(View.java:3709)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:884)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:884)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:884)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:884)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at com.android.internal.policy.impl.PhoneWindow$DecorView.superDispatchTouchEvent(PhoneWindow.java:1659)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at com.android.internal.policy.impl.PhoneWindow.superDispatchTouchEvent(PhoneWindow.java:1107)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at android.app.Activity.dispatchTouchEvent(Activity.java:2061)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at com.android.internal.policy.impl.PhoneWindow$DecorView.dispatchTouchEvent(PhoneWindow.java:1643)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at android.view.ViewRoot.handleMessage(ViewRoot.java:1691)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at android.os.Handler.dispatchMessage(Handler.java:99)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at android.os.Looper.loop(Looper.java:123)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at android.app.ActivityThread.main(ActivityThread.java:4363)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at java.lang.reflect.Method.invokeNative(Native Method)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at java.lang.reflect.Method.invoke(Method.java:521)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:860)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:618)
04-19 05:02:51.112: ERROR/AndroidRuntime(262): at dalvik.system.NativeStart.main(Native Method)

代码如下：
b15.setOnClickListener(new Button.OnClickListener(){//下一题
public void onClick(View v)
{
//System.out.println(&quot;CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC&quot;);
if(cur.moveToNext())
{
if(cur!=null)
{
if(!cur.isAfterLast())
{
id=cur.getInt(cur.getColumnIndex(&quot;Table_Id&quot;));
string_q=cur.getString(cur.getColumnIndex(&quot;Table_Qustion&quot;));
string_a=cur.getString(cur.getColumnIndex(&quot;Table_A&quot;));
string_b=cur.getString(cur.getColumnIndex(&quot;Table_B&quot;));
string_c=cur.getString(cur.getColumnIndex(&quot;Table_C&quot;));
string_d=cur.getString(cur.getColumnIndex(&quot;Table_D&quot;));
string_answer=cur.getString(cur.getColumnIndex(&quot;Table_Answer&quot;));
dificultynum = cur.getInt(cur.getColumnIndex(&quot;Table_Dificulty&quot;));
str=string_q+&apos;n&apos;+string_a+&apos;n&apos;+string_b+&apos;n&apos;+string_c+&apos;n&apos;+string_d;
numofrate++;
textview8.setText(str);
}
}
}
if(cur==null)
{
textview8.setText(numofrate+&quot;道题难为度等级&quot;+dificultyrate+&quot;的题中你答对了&quot;+numberoftrue+&quot;道&quot;);
}
}

});

为什么不能往下读取了？
</code>
</RECORD>
<RECORD>
<snippet_key>214789</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Java 并发编程中使用 ReentrantLock 替代 synchronized 关键字原语  http://blog.csdn.net/linux_Mary_me/article/details/20374741#</comment>
<code>public final ReentrantLock lock = new ReentrantLock();
......
try {
lock.lock();
// 进入同步内容
....
} finally {
lock.unlock(); // 必须在 finally 块中解锁，否则一旦出现异常，执行不到解锁，则一直锁住了。
}
public class Buffer {
private Object lock;

public Buffer() {
lock = this;
}

public void write() {
synchronized (lock) {
long startTime = System.currentTimeMillis();
System.out.println(&quot;开始往这个buff写入数据…&quot;);
for (;;) { // 模拟要处理很长时间
if (System.currentTimeMillis() &gt; Integer.MAX_VALUE) {
break;
}
}
System.out.println(&quot;终于写完了&quot;);
}
}

public void read() {
synchronized (lock) {
System.out.println(&quot;从这个buff读数据&quot;);
}
}
}
public class Writer extends Thread {
private Buffer buff;

public Writer(Buffer buff) {
this.buff = buff;
}

@Override
public void run() {
buff.write();
}
}

public class Reader extends Thread {
private Buffer buff;

public Reader(Buffer buff) {
this.buff = buff;
}

@Override
public void run() {
buff.read(); // 这里估计会一直阻塞
System.out.println(&quot;读结束&quot;);
}
}
public class Test {
public static void main(String[] args) {
Buffer buff = new Buffer();

final Writer writer = new Writer(buff);
final Reader reader = new Reader(buff);

writer.start();
reader.start();

new Thread(new Runnable() {
@Override
public void run() {
long start = System.currentTimeMillis();
for (;;) {
// 等5秒钟去中断读
if (System.currentTimeMillis() - start &gt; 5000) {
System.out.println(&quot;不等了，尝试中断&quot;);
reader.interrupt();
break;
}
}
}
}).start();
}
}
import java.util.concurrent.locks.ReentrantLock;
public class BufferInterruptibly {
private ReentrantLock lock = new ReentrantLock();

public void write() {
lock.lock();
try {
long startTime = System.currentTimeMillis();
System.out.println(&quot;开始往这个buff写入数据…&quot;);
for (;;) { // 模拟要处理很长时间
if (System.currentTimeMillis() - startTime &gt; Integer.MAX_VALUE) {
break;
}
}
System.out.println(&quot;终于写完了&quot;);
} finally {
lock.unlock();
}
}

public void read() throws InterruptedException {
lock.lockInterruptibly();// 注意这里，可以响应中断
try {
System.out.println(&quot;从这个buff读数据&quot;);
} finally {
lock.unlock();
}
}
}
public class Reader extends Thread {
private BufferInterruptibly buff;

public Reader(BufferInterruptibly buff) {
this.buff = buff;
}

@Override
public void run() {
try {
buff.read();//可以收到中断的异常，从而有效退出
} catch (InterruptedException e) {
System.out.println(&quot;我不读了&quot;);
}

System.out.println(&quot;读结束&quot;);
}
}

/**
* Writer倒不用怎么改动
*/
public class Writer extends Thread {
private BufferInterruptibly buff;
public Writer(BufferInterruptibly buff) {
this.buff = buff;
}

@Override
public void run() {
buff.write();
}
}

public class Test {
public static void main(String[] args) {
BufferInterruptibly buff = new BufferInterruptibly();

final Writer writer = new Writer(buff);
final Reader reader = new Reader(buff);

writer.start();
reader.start();

new Thread(new Runnable() {
@Override
public void run() {
long start = System.currentTimeMillis();
for (;;) {
if (System.currentTimeMillis() - start &gt; 5000) {
System.out.println(&quot;不等了，尝试中断&quot;);
reader.interrupt();
break;
}
}
}
}).start();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>330510</snippet_key>
<tag>helloworld struts2 简单例子</tag>
<comment>来自CSDN博客：重温struts2之第一个struts2程序helloworld  http://blog.csdn.net/a1969212650/article/details/25141415#</comment>
<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee
http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
version=&quot;3.1&quot;
metadata-complete=&quot;true&quot;&gt;

&lt;filter&gt;
&lt;filter-name&gt;struts2&lt;/filter-name&gt;
&lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
&lt;filter-name&gt;struts2&lt;/filter-name&gt;
&lt;url-parttern&gt;/*&lt;/url-parttern&gt;
&lt;/filter-mapping&gt;




&lt;welcome-file-list&gt;
&lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
&lt;/welcome-file-list&gt;
&lt;/web-app&gt;
&lt;%@page language=&quot;java&quot; contentType=&quot;text/html; charset=gbk&quot;%&gt;
&lt;!DOCTYPE unspecified PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;登录页面&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;center&gt;
&lt;form action=&quot;login.action&quot; method=&quot;post&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p&gt;用户名：&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;p&gt;密码：&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;input type=&quot;text&quot; name=&quot;password&quot; /&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/form&gt;
&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
public class LoginAction {

private String username;
private String password;

public String execute(){
if(&quot;a&quot;.equals(this.getUsername())&amp;&amp;&quot;a&quot;.equals(this.getPassword()))
return &quot;success&quot;;
return &quot;error&quot;;
}

public String getUsername() {
return username;
}
public void setUsername(String username) {
this.username = username;
}
public String getPassword() {
return password;
}
public void setPassword(String password) {
this.password = password;
}



}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE struts PUBLIC
&quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;
&quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;

&lt;struts&gt;

&lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;false&quot; /&gt;
&lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot; /&gt;

&lt;package name=&quot;default&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt;

&lt;default-action-ref name=&quot;index&quot; /&gt;

&lt;global-results&gt;
&lt;result name=&quot;error&quot;&gt;/error.jsp&lt;/result&gt;
&lt;/global-results&gt;

&lt;global-exception-mappings&gt;
&lt;exception-mapping exception=&quot;java.lang.Exception&quot; result=&quot;error&quot;/&gt;
&lt;/global-exception-mappings&gt;

&lt;action name=&quot;index&quot;&gt;
&lt;result type=&quot;redirectAction&quot;&gt;
&lt;param name=&quot;actionName&quot;&gt;HelloWorld&lt;/param&gt;
&lt;param name=&quot;namespace&quot;&gt;/example&lt;/param&gt;
&lt;/result&gt;
&lt;/action&gt;

&lt;action name=&quot;login&quot; class=&quot;ch1.helloworld.LoginAction&quot;&gt;
&lt;result name=&quot;success&quot;&gt;/helloworld/welcome.jsp&lt;/result&gt;
&lt;result name=&quot;error&quot;&gt;/helloworld/login.jsp&lt;/result&gt;
&lt;/action&gt;
&lt;/package&gt;

&lt;/struts&gt;
&lt;%@page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; %&gt;
&lt;html&gt;
&lt;body&gt;
helloworld
&lt;/body&gt;
&lt;/html&gt;
import com.opensymphony.xwork2.ActionContext;

public class GetBooksAction {
private String[] books;


public String[] getBooks() {
return books;
}


public void setBooks(String[] books) {
this.books = books;
}


public String execute(){

String user = (String)ActionContext.getContext().getSession().get(&quot;username&quot;);

if(user!= null &amp;&amp; &quot;a&quot;.equals(user)){
this.setBooks(new BookDao().getBooks());
return &quot;success&quot;;
}
return &quot;login&quot;;
}

}
&lt;action name=&quot;getbooks&quot; class=&quot;ch1.helloworld.GetBooksAction&quot;&gt;
&lt;result name=&quot;success&quot;&gt;/helloworld/showbooks.jsp&lt;/result&gt;
&lt;result name=&quot;login&quot;&gt;/helloworld/login.jsp&lt;/result&gt;
&lt;/action&gt;
public class BookDao {

public String[] getBooks(){
return new String[]{&quot;java&quot;,&quot;c++&quot;,&quot;c&quot;};
}

}
&lt;%@page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; %&gt;
&lt;%@page import=&quot;java.util.*,com.opensymphony.xwork2.util.*&quot; %&gt;
&lt;html&gt;
&lt;body&gt;
&lt;table&gt;
&lt;%
ValueStack vs = (ValueStack)request.getAttribute(&quot;struts.valueStack&quot;);
String[] books = (String[])vs.findValue(&quot;books&quot;);
for(String book:books){
%&gt;
&lt;tr&gt;
&lt;td&gt;&lt;%= book %&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;%} %&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;%@page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; %&gt;
&lt;%@taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;
&lt;html&gt;
&lt;body&gt;
&lt;table border=&quot;1&quot;&gt;
&lt;s:iterator value=&quot;books&quot; status=&quot;index&quot;&gt;
&lt;s:if test=&quot;index.odd==true&quot;&gt;
&lt;tr style=&quot;background-color:#00dd00&quot;&gt;
&lt;td&gt;&lt;s:property/&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/s:if&gt;
&lt;s:else&gt;
&lt;tr style=&quot;background-color:#00ddee&quot;&gt;
&lt;td&gt;&lt;s:property/&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/s:else&gt;
&lt;/s:iterator&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;filter&gt;
&lt;filter-name&gt;struts2&lt;/filter-name&gt;
&lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt;
&lt;init-param&gt;
&lt;param-name&gt;config&lt;/param-name&gt;
&lt;param-value&gt;aconfig.xml,bconfig.xml&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;init-param&gt;
&lt;param-name&gt;actionPackages&lt;/param-name&gt;
&lt;param-value&gt;a.b.c,a.b.d&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;/filter&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>396046</snippet_key>
<tag>leetcode</tag>
<comment>来自CSDN博客：leetcde: Rotate Image http://blog.csdn.net/mmlfs/article/details/31768701#</comment>
<code>public class Solution {
public void rotate(int[][] matrix) {
int n = matrix.length;
if(n==0)
{
return ;
}
for(int i=0;i&lt;n;i++ )
{
for(int j=0;j&lt;n-i;j++ )
{
int tmp = matrix[i][j];
matrix[i][j] = matrix[n-1-j][n-1-i];
matrix[n-1-j][n-1-i] = tmp;
}
}
for(int i=0;i&lt;n/2;i++ )
{
for(int j=0;j&lt;n;j++ )
{
int tmp = matrix[i][j];
matrix[i][j] = matrix[n-1-i][j];
matrix[n-1-i][j] = tmp;
}
}
return ;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>461582</snippet_key>
<tag></tag>
<comment>来自CSDN博客：CSDN英雄会——一份“奇妙”的银行流水 http://blog.csdn.net/godbreak/article/details/38962499#</comment>
<code>import java.util.Scanner;

public class Main {

/**
* @param args
*/
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

FinalItem[] list = new FinalItem[25];
Boolean hasUnknown;
Integer id;
Double a, b, d;

Boolean[] known = new Boolean[25];
int size = 0;

while (sc.hasNextLine()) {
String line = sc.nextLine();
String[] record = line.split(&quot;;&quot;);
hasUnknown = false;
id = Integer.parseInt(record[0]);
if (!record[1].equals(&quot;?&quot;)) {
a = Double.parseDouble(record[1]);
} else {
a = null;
}
if (!record[2].equals(&quot;?&quot;)) {
b = Double.parseDouble(record[2]);
} else {
b = null;
}
if (!record[3].equals(&quot;?&quot;)) {
d = Double.parseDouble(record[3]);
} else {
d = null;
}
if (a != null &amp;&amp; a != 0d &amp;&amp; b == null) {
b = 0d;
} else if (b != null &amp;&amp; b != 0d &amp;&amp; a == null) {
a = 0d;
}
hasUnknown = a == null || b == null || d == null;
known[size] = !hasUnknown;
list[size] = new FinalItem(hasUnknown, id, a, b ,d);
++size;
}
Boolean allDone = false;
while (!allDone) {
allDone = true;
if (size &gt; 1 &amp;&amp; known[0] &amp;&amp; !known[1]) {
if (!list[1].fixFromAbove(list[0])) {
allDone = false;
} else {
known[1] = true;
}
}
if (size &gt; 1 &amp;&amp; known[size - 1] &amp;&amp; !known[size - 2]) {
if (!list[size - 2].fixFromBellow(list[size - 1])) {
allDone = false;
} else {
known[size - 2] = true;
}
}
for (int i = 1; i &lt; size - 1; ++i) {
if (known[i] &amp;&amp; (!known[i - 1] || !known[i + 1])) {
if (known[i] &amp;&amp; !known[i + 1]) {
for (int j = i; j &lt; size - 1; ++j) {
if (known[j + 1])
continue;
if (!list[j + 1].fixFromAbove(list[j])) {
allDone = false;
break;
} else {
known[j + 1] = true;
}
}
}
if (known[i] &amp;&amp; !known[i - 1]) {
for (int j = i; j &gt; 0; --j) {
if (known[j - 1])
continue;
if (!list[j - 1].fixFromBellow(list[j])) {
allDone = false;
break;
} else {
known[j - 1] = true;
}
}
}
}
}
}
for (int i = 0; i &lt; size; ++i) {
System.out.printf(&quot;%d;%.2f;%.2f;%.2f\n&quot;, list[i].id, list[i].a, list[i].b, list[i].d);
}
sc.close();
return;
}

}

class FinalItem {
Boolean hasUnknown = false;

Integer id = 0;

Double a = null;
Double b = null;
Double c = null;
Double d = null;

FinalItem(Boolean hasUnknown, Integer id, Double a, Double b, Double d) {
this.hasUnknown = hasUnknown;
this.id = id;
this.a = a;
this.b = b;
this.d = d;
if (!this.hasUnknown)
this.c = this.b + this.d - this.a;
}

Boolean fixFromAbove(FinalItem ft) {
Double c = ft.d;
if (c == null)
return false;
this.c = c;
if (this.hasUnknown) {
if (this.a == null &amp;&amp; this.b != null &amp;&amp; this.d != null) {
this.a = this.b + this.d - this.c;
this.hasUnknown = false;
} else if (this.b == null &amp;&amp; this.a != null &amp;&amp; this.d != null) {
this.b = this.c + this.a - this.d;
this.hasUnknown = false;
} else if (this.d == null &amp;&amp; this.a != null &amp;&amp; this.b != null) {
this.d = this.c + this.a - this.b;
this.hasUnknown = false;
}
if (this.d != null) {
Double diff = this.c - this.d;
if (diff &gt; 0) {
this.b = diff;
this.a = 0d;
} else {
this.a = -diff;
this.b = 0d;
}
this.hasUnknown = false;
}
return !this.hasUnknown;
} else
return !this.hasUnknown;
}

Boolean fixFromBellow(FinalItem ft) {
Double d = ft.c;
if (d == null)
return false;
if (this.hasUnknown) {
this.d = d;
if (this.a != null &amp;&amp; this.b != null) {
if (this.c == null) {
this.c = this.b + this.d - this.a;
}
this.hasUnknown = false;
}
if (this.c != null) {
Double diff = this.c - this.d;
if (diff &gt; 0) {
this.b = diff;
this.a = 0d;
} else {
this.a = -diff;
this.b = 0d;
}
this.hasUnknown = false;
}
return !this.hasUnknown;
} else
return !this.hasUnknown;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>215045</snippet_key>
<tag>214</tag>
<comment>json 来自CSDN博客：从数据库读取数据存放在List&lt;T&gt;中，在jsp中将其取出来。（使用JSON）  http://blog.csdn.net/u012560410/article/details/20384113#</comment>
<code>@RequestMapping(&quot;&quot;)
public String index(HttpServletRequest request) {
List&lt;Widget&gt; widgets = widgetManager.getAll();
request.setAttribute(&quot;widgets&quot;, widgets);
String jsonWidget = jsonArray.toString();
request.setAttribute(&quot;jsonWidget&quot;, jsonWidget);
return getFileBasePath() + &quot;uiIndex&quot;;
}
&lt;script&gt;
var json = &apos;${jsonWidget}&apos;;
var jsonObj = eval(&quot;(&quot; + json + &quot;)&quot;);
for (var k in jsonObj) {
alert(&quot;第&quot; + k + &quot;条记录 , 名称 : &quot; + jsonObj[k].name);
alert(&quot;第&quot; + k + &quot;条记录 , 编辑URL : &quot; + jsonObj[k].editUrl);
alert(&quot;第&quot; + k + &quot;条记录 , 链接URL : &quot; + jsonObj[k].linkUrl);
}
&lt;/script&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>411653</snippet_key>
<tag>spring date 类型转换</tag>
<comment>来自CSDN博客：SpringMVC 映射Date类型时的问题，及解决 http://blog.csdn.net/caohuilei/article/details/35996935#</comment>
<code>@InitBinder
protected void initBinder(HttpServletRequest request,
ServletRequestDataBinder binder) throws Exception {
DateFormat fmt = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
CustomDateEditor dateEditor = new CustomDateEditor(fmt, true);
binder.registerCustomEditor(Date.class, dateEditor);
super.initBinder(request, binder);
}
</code>
</RECORD>
<RECORD>
<snippet_key>265230</snippet_key>
<tag></tag>
<comment>来自CSDN博客：读Tomcat源码确定加载web.xml中节点元素的顺序 http://blog.csdn.net/insistGoGo/article/details/22598001#</comment>
<code>/**
* Start this component and implement the requirements
* of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.
*
* @exception LifecycleException if this component detects a fatal error
* that prevents this component from being used
*/
@Override
protectedsynchronized void startInternal() throwsLifecycleException {
//设置webappLoader 代码省略

// Standard container startup 代码省略

try{

// Set up the context init params 初始化context-param节点数据
mergeParameters();


// Configure and call application event listeners
//配置和调用listeners 也就是说开始监听
if(ok) {
if(!listenerStart()) {
log.error(&quot;Error listenerStart&quot;);
ok = false;
}
}

// Configure and call application filters
//配置和调用filters filters开始起作用
if(ok) {
if(!filterStart()) {
log.error(&quot;Error filterStart&quot;);
ok = false;
}
}

// Load and initialize all &quot;load on startup&quot; servlets
//加载和初始化配置在load on startup的servlets
if(ok) {
loadOnStartup(findChildren());
}

// Start ContainerBackgroundProcessor thread
super.threadStart();
}finally{
// Unbinding thread
unbindThread(oldCCL);
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>331022</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Service-boundService绑定服务(3)  http://blog.csdn.net/qq285016127/article/details/25171043#</comment>
<code>/**
* @author Lean
*
*/
public class LeanService extends Service {

private LocalBinder mBinder=new LocalBinder();

class LocalBinder extends Binder{
//获取本服务对象并调用其方法
public Service getService(){
return LeanService.this;
}

public String calledRemoteMethod(String str){
return &quot;you called remote method args=&quot;+str;
}

}

@Override
public IBinder onBind(Intent arg0) {
return mBinder;
}

//同样 耗时操作也会促使界面卡屏
public void countNum(){
for (int i = 0; i &lt; 20; i++) {
try {
Thread.sleep(1000l);
Log.v(&quot;log&quot;,&quot;countNum : &quot;+i);
} catch (InterruptedException e) {
e.printStackTrace();
}
}
}

@Override
public boolean onUnbind(Intent intent) {
Log.v(&quot;log&quot;,&quot;onUnbind&quot;);
return super.onUnbind(intent);
}

}
&lt;service android:name=&quot;org.lean.LeanService&quot;/&gt;
/**
* @author Administrator
*
*/
public class MainActivity extends Activity {

private ServiceConnection mConnection;

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
initUI();

mConnection=new ServiceConnection() {

&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;//只有在service因异常而断开连接的时候，这个方法才会用到
@Override
public void onServiceDisconnected(ComponentName name) {
Log.v(&quot;log&quot;,&quot;onServiceDisconnected&quot;+name.getClassName());
}

//数据连接成功，通过IBinder的stub程序获取远程指针并调用相应内存的方法
@Override
public void onServiceConnected(ComponentName name, IBinder service) {
// String result=((LocalBinder)service).calledRemoteMethod(&quot;Lean&quot;);
// Log.v(&quot;log&quot;,result);
// ((LeanService)((LocalBinder)service).getService()).countNum();
}
};
}

private void initUI() {
findViewById(R.id.boundService).setOnClickListener(new OnClickListener() {
@Override
public void onClick(View v) {
Intent intent=new Intent(MainActivity.this,LeanService.class);
bindService(intent, mConnection,Service.BIND_AUTO_CREATE);
}
});
findViewById(R.id.unboundService).setOnClickListener(new OnClickListener() {
@Override
public void onClick(View v) {
unbindService(mConnection);
}
});
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>411909</snippet_key>
<tag>319</tag>
<comment>来自CSDN博客：远程进程调用  http://blog.csdn.net/jonemill/article/details/36012489#</comment>
<code>package cn.itcast.remoteservice;

interface IService {
void callMethodInService();
}
package cn.itcast.remoteservice;

import android.app.IntentService;
import android.app.Service;
import android.content.Intent;
import android.os.IBinder;
import android.os.RemoteException;
import android.test.IsolatedContext;

public class RemoteService extends Service {

@Override
public IBinder onBind(Intent intent) {

return new MyBinder();
}


private class MyBinder extends IService.Stub{

@Override
public void callMethodInService() throws RemoteException {
sayHelloInService();

}

}

/**
* 服务里面的一个方法
*/
public void sayHelloInService(){
System.out.println(&quot;hello in service&quot;);
}

@Override
public void onCreate() {
System.out.println(&quot;remote service oncreate&quot;);
super.onCreate();
}

}
package cn.itcast.remoteservice;

interface IService {
void callMethodInService();
}
package cn.itcast.callremote;

import cn.itcast.remoteservice.IService;
import android.app.Activity;
import android.content.ComponentName;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.IBinder;
import android.os.RemoteException;
import android.view.View;

public class DemoActivity extends Activity {
IService iService;
@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
Intent intent = new Intent();
//远程service的action.
intent.setAction(&quot;cn.itcast.remoteservice&quot;);
bindService(intent, new MyConn(), BIND_AUTO_CREATE);
}


public void click(View view){
try {
// 调用了远程服务的方法
iService.callMethodInService();
} catch (RemoteException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}

private class MyConn implements ServiceConnection{

@Override
public void onServiceConnected(ComponentName name, IBinder service) {
iService = IService.Stub.asInterface(service);

}

@Override
public void onServiceDisconnected(ComponentName name) {
// TODO Auto-generated method stub

}

}
}
</code>
</RECORD>
<RECORD>
<snippet_key>477445</snippet_key>
<tag></tag>
<comment>来自CSDN博客：&lt;Java语言&gt;值传递与引用 http://blog.csdn.net/Ashelyhss/article/details/39668477#</comment>
<code>public class FartherJava {
public class SubJava{
private String subit = null;
public void SubJava(){
subit = &quot;subJava&quot;;
System.out.println(&quot;SubJava:subit=&quot;+subit);
}
public void subChange(){
subit = &quot;subChange&quot;;
}
public void subPrint(){
System.out.println(&quot;subPrint subit=&quot;+subit);
}
}

private int g_int = 0;
private short [] buffer = {1,2};

public FartherJava() {
g_int = 0;
int i = 1;
String j=&quot;fartherJava&quot;;

System.out.println(&quot;FartherJava i=&quot;+i);
fartherChange(i);
System.out.println(&quot;FartherChange i=&quot;+i);
System.out.println(&quot;FartherJava j=&quot;+j);
fartherChange(j);
System.out.println(&quot;FartherChange j=&quot;+j);
changeStructData();
System.out.println(&quot;changeStructData g_int=&quot;+g_int);
System.out.println(&quot;changeStructData buffer[0]=&quot;+buffer[0]);
SubJava sjJava = new SubJava();
changeSubJava(sjJava);
sjJava.subPrint();
}

public void changeSubJava(SubJava sjava)
{
sjava.subPrint();
sjava.subChange();
}

public void fartherChange(String j){
j = &quot;fartherChange&quot;;
}

public void fartherChange(int i){
i = 2;
}

public void changeStructData(){
System.out.println(&quot;FartherData g_int=&quot;+g_int);
g_int = 1;
System.out.println(&quot;FartherData buffer[0]=&quot;+buffer[0]);
buffer[0] = 3;
}

public static void main(String args[]) {
FartherJava m = new FartherJava();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>281093</snippet_key>
<tag>482</tag>
<comment>dfs 来自CSDN博客：第五周作业——有向图强连通分量的编程实现 http://blog.csdn.net/gdouchufu/article/details/23192181#</comment>
<code>public static void main(String[] args) {
try(Scanner scanner = new Scanner
(GraphDAG.class.getClassLoader().getResourceAsStream(&quot;tinyDG.txt&quot;));){

//第一行的数字是顶点的数目
int v = scanner.nextInt();
//第二行的数字是边的数目
int e = scanner.nextInt();
//构造该图的反向图
GraphReverse graphReverse = new GraphReverse(v, e);

//读取每条边对应的两个顶点,将边添加到反向图的邻接表里
for (int i = 0; i &lt; e; i++) {
int v1 = scanner.nextInt();
int v2 = scanner.nextInt();
graphReverse.addEdgeReverse(v2, v1);
}

//对反向图进行DFS
GraphSCC graphSCC = new GraphSCC(graphReverse.getAdjacencyListReverse());
graphSCC.dfs();

//反向图的强连通分量集合
List&lt;GraphNode[]&gt; cc = graphSCC.getSCC();
int count = cc.size();
System.err.println(&quot;********** 共有&quot;+count+&quot;个连通分量,分别为: ********** &quot;);

//遍历强连通分量,输出SCC的post值逆序和每个顶点信息
for(int i=count-1; i&gt;=0; i--){
GraphNode[] c = cc.get(i);
System.err.println(&quot;第&quot;+(count-i)+&quot;个连通分量:&quot;);

//存储该SCC的post值
int [] postDESC = new int[c.length];

int index = 0;
for(GraphNode node : c){
System.err.println(node.getInfo());
postDESC[index++] = node.getPost();
}
//对post值冒泡排序
postDESC = BubbleSort.sort(postDESC);

System.err.print(&quot;反向图中顶点post的逆序表示: &quot;);
for(int j=postDESC.length-1; j&gt;=0; j--){
for(GraphNode node : c){
if(node.getPost() == postDESC[j]){
int name = node.getName();
System.err.print(name+&quot; &quot;);
}
continue;
}
}
System.err.println(&quot;\n&quot;);
}

}
}
</code>
</RECORD>
<RECORD>
<snippet_key>346629</snippet_key>
<tag></tag>
<comment>来自CSDN博客：2002-View-Animation-interpolator http://blog.csdn.net/zhi07/article/details/25881925#</comment>
<code>/*
* Copyright (C) 2009 The Android Open Source Project
*
* Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package com.example.android.apis.view;

// Need the following import to get access to the app resources, since this
// class is in a sub-package.
import com.example.android.apis.R;

import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.view.animation.AnimationUtils;
import android.view.animation.Animation;
import android.view.animation.TranslateAnimation;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Spinner;

public class Animation3 extends Activity implements AdapterView.OnItemSelectedListener {
private static final String[] INTERPOLATORS = {
&quot;Accelerate&quot;, &quot;Decelerate&quot;, &quot;Accelerate/Decelerate&quot;,
&quot;Anticipate&quot;, &quot;Overshoot&quot;, &quot;Anticipate/Overshoot&quot;,
&quot;Bounce&quot;
};

@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.animation_3);

Spinner s = (Spinner) findViewById(R.id.spinner);
ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this,
android.R.layout.simple_spinner_item, INTERPOLATORS);
adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
s.setAdapter(adapter);
s.setOnItemSelectedListener(this);
}

public void onItemSelected(AdapterView parent, View v, int position, long id) {
final View target = findViewById(R.id.target);
final View targetParent = (View) target.getParent();

Animation a = new TranslateAnimation(0.0f,
targetParent.getWidth() - target.getWidth() - targetParent.getPaddingLeft() -
targetParent.getPaddingRight(), 0.0f, 0.0f);
a.setDuration(1000);
a.setStartOffset(300);
a.setRepeatMode(Animation.RESTART);
a.setRepeatCount(Animation.INFINITE);

switch (position) {
case 0:
//加速
a.setInterpolator(AnimationUtils.loadInterpolator(this,
android.R.anim.accelerate_interpolator));
break;
case 1:
//减速
a.setInterpolator(AnimationUtils.loadInterpolator(this,
android.R.anim.decelerate_interpolator));
break;
case 2:
//先加速后减速
a.setInterpolator(AnimationUtils.loadInterpolator(this,
android.R.anim.accelerate_decelerate_interpolator));
break;
case 3:
//先向前缩然后运行
a.setInterpolator(AnimationUtils.loadInterpolator(this,
android.R.anim.anticipate_interpolator));
break;
case 4:
//运行超出然后弹回
a.setInterpolator(AnimationUtils.loadInterpolator(this,
android.R.anim.overshoot_interpolator));
break;
case 5:
//先向前缩然后运行 运行超出然后弹回
a.setInterpolator(AnimationUtils.loadInterpolator(this,
android.R.anim.anticipate_overshoot_interpolator));
break;
case 6:
//运行之后弹几次
a.setInterpolator(AnimationUtils.loadInterpolator(this,
android.R.anim.bounce_interpolator));
break;
}

target.startAnimation(a);
}

public void onNothingSelected(AdapterView parent) {
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>331278</snippet_key>
<tag>java 优化 线性规划 修正单纯形法</tag>
<comment>来自CSDN博客：修正单纯形法·优化算法实现·Java http://blog.csdn.net/zstu_wangrui/article/details/25187567#</comment>
<code>public class LPSimplexM {

private static final double inf = 1e9;

private int n; // 约束个数
private double[][] A; // 输入函数参数
private double[] b; // 约束值
private double[] c; // 目标函数系数
private double Z; // 目标值
private void InitF() { // 初始化 First
/* problem 1.
* max Z = 5*x1 + 4*x2; min Z = -5*x1 - 4*x2;
* x1 + 3*x2 &lt;= 90; x1 + 3*x2 + x3 = 90;
* 2*x1 + x2 &lt;= 80; =&gt; 2*x1 + x2 + x4 = 80;
* x1 + x2 &lt;= 45; x1 + x2 + x5 = 45;
* xi &gt;= 0
*/
/* problem 2.
* min Z = -7*x1 - 12*x2;
* 9*x1 + 4*x2 + x3 = 360;
* 4*x1 + 5*x2 +x4 = 200;
* 3*x1 + 10*x2 + x5 = 300;
* xi &gt;= 0
*/
n = 3;
A = new double[n+1][n+1];
b = new double[n+1];
// c = new double[n&lt;&lt;1];
Z = inf;
// 约束初始条件
A[1][1] = 1; A[1][2] = 3;
A[2][1] = 2; A[2][2] = 1;
A[3][1] = 1; A[3][2] = 1;
// 条件值
// problem 1.
// b[1] = 90;
// b[2] = 80;
// b[3] = 45;
// problem 2.
b[1] = 360;
b[2] = 200;
b[3] = 300;
// for(int i = 1; i &lt;= n; i++)System.out.println(&quot;b[&quot; + i + &quot;] = &quot; + b[i]);
// 目标函数系数
// c[1] = -5; c[2] = -4;
}

int m;
private double[][] p;
private double[][] e, oe;
private double[][] E, oE;
private double[] X;
private boolean[] G;
private int[] S;
private void InitS() {
m = 2;
p = new double[n+1][n+m+1];
e = new double[n+1][n+1];
oe = new double[n+1][n+1];
E = new double[n+1][n+1];
oE = new double[n+1][n+1];
X = new double[n+1];
G = new boolean[n+m+1];
S = new int[n+1];

c = new double[n+m+1];
// problem 1.
// c[1] = -5; c[2] = -4; c[3] = 0; c[4] = 0; c[5] = 0;
// problem 2.
c[1] = -7; c[2] = -12; c[3] = 0; c[4] = 0; c[5] = 0;
// problem 1.
// p[1][1] = 1; p[1][2] = 3; p[1][3] = 1; p[1][4] = 0; p[1][5] = 0;
// p[2][1] = 2; p[2][2] = 1; p[2][3] = 0; p[2][4] = 1; p[2][5] = 0;
// p[3][1] = 1; p[3][2] = 1; p[3][3] = 0; p[3][4] = 0; p[3][5] = 1;
// problem 2.
p[1][1] = 9; p[1][2] = 4; p[1][3] = 1; p[1][4] = 0; p[1][5] = 0;
p[2][1] = 4; p[2][2] = 5; p[2][3] = 0; p[2][4] = 1; p[2][5] = 0;
p[3][1] = 3; p[3][2] = 10; p[3][3] = 0; p[3][4] = 0; p[3][5] = 1;

for(int i = 1; i &lt;= n; i++)
for(int j = 1; j &lt;= n; j++)
if(i == j)E[i][j] = oE[i][j] = 1;
else E[i][j] = oE[i][j] = 0;

for(int i = 1; i &lt;= n; i++)
X[i] = b[i];

G[1] = false; G[2] = false; G[3] = true; G[4] = true; G[5] = true;

S[1] = 3; S[2] = 4; S[3] = 5;
}


public LPSimplexM() {
InitF();
InitS();
AlgorithmProcess();
solve();
}

private void AlgorithmProcess() {
double[] coE = new double[n+1]; // c * E^-1
double[] r = new double [n+m+1]; // c - c * E^-1 * p
double[] oEp = new double[n+1]; // E^-1 * p;
boolean flag = false;
while(true) {
// x = E^-1 * b
for(int i = 1; i &lt;= n; i++){
X[i] = 0;
for(int j = 1; j &lt;= n; j++)
X[i] += oE[i][j]*b[j];
}
// c * E^-1
for(int i = 1; i &lt;= n; i++){
coE[i] = 0;
for(int j = 1; j &lt;= n; j++)
coE[i] += c[S[j]]*oE[j][i];
}
// r = c - c * E^-1 * p =&gt; min r&apos; id -&gt; k
int k = -1;
flag = false;
for(int i = 1; i &lt;= n+m; i++)if(!G[i]){
double ans = 0;
for(int j = 1; j &lt;= n; j++)
ans += coE[j]*p[j][i];
r[i] = c[i] - ans;
if(!flag &amp;&amp; r[i] &lt; 0){
k = i;
flag = true;
}else if(flag &amp;&amp; r[i] &lt; r[k]){
k = i;
}
}
if(k == -1)return ; // solution output 1（X, S 为最优解）
// E^-1 * p; =&gt; min theta&gt;0&apos; id -&gt; s
int s = -1;
flag = false;
for(int i = 1; i &lt;= n; i++){
oEp[i] = 0;
for(int j = 1; j &lt;= n; j++){
oEp[i] += oE[i][j]*p[j][k];
}
if(oEp[i] &gt; 0){
if(!flag){
s = i;
flag = true;
}else if(flag &amp;&amp; X[i]/oEp[i] &lt; X[s]/oEp[s]){
s = i;
}
}
}
if(!flag)return ; // no solution 1（无允许解）
if(s == -1)return ; // no solution 2（该问题有无解集）
// p[s] = p[k], 形成新的矢量基 E
G[S[s]] = false; G[k] = true;
S[s] = k;
// System.out.println(&quot;k = &quot; + k + &quot;; s = &quot; + s);
for(int i = 1; i &lt;= n; i++){
p[i][k] = -1.0*oEp[i]/oEp[s];
if(i == s)
p[i][k] = 1/oEp[s];
}
for(int i = 1; i &lt;= n; i++){
int id = S[i];
for(int j = 1; j &lt;= n; j++){
if(i == s){
e[j][i] = p[j][k];
}else{
if(j == i){
e[j][i] = 1;
}else{
e[j][i] = 0;
}
}
}
}
// for(int i = 1; i &lt;= n; i++){
// for(int j = 1; j &lt;= n; j++){
// System.out.print(oE[i][j] + &quot; &quot;);
// }System.out.println();
// }System.out.println(&quot;{oE}&quot;);
// for(int i = 1; i &lt;= n; i++){
// for(int j = 1; j &lt;= n; j++){
// System.out.print(e[i][j] + &quot; &quot;);
// }System.out.println();
// }System.out.println(&quot;{e}&quot;);
for(int i = 1; i &lt;= n; i++){
for(int j = 1; j &lt;= n; j++){
oe[i][j] = 0;
for(int t = 1; t &lt;= n; t++){
oe[i][j] += e[i][t]*oE[t][j];
}
}
}
for(int i = 1; i &lt;= n; i++){
for(int j = 1; j &lt;= n; j++){
oE[i][j] = oe[i][j];
//System.out.print(oE[i][j] + &quot; &quot;);
}//System.out.println();
}//System.out.println();
}
}
// 最优解输出
private void solve() {
Z = 0;
for(int i = 1; i &lt;= n; i++){
int id = S[i];
Z += c[id]*X[i];
System.out.println(id + &quot; : &quot; + X[i] + &quot; * &quot; + -c[id]);
}
System.out.println(&quot;Z = &quot; + -Z);
}

public static void main(String[] args) {
new LPSimplexM();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>150277</snippet_key>
<tag>10</tag>
<comment>来自CSDN博客：【Java重构系列】重构31式之封装集合  http://blog.csdn.net/LoveLion/article/details/17970147#</comment>
<code>package sunny.refactoring.one.before;

import java.util.Collection;
import java.util.ArrayList;

//订单类
class Order {
private double orderTotal; //订单总金额
private Collection&lt;OrderItem&gt; orderItems; //集合对象，存储一个订单中的所有订单项

public Order() {
this.orderItems = new ArrayList&lt;OrderItem&gt;();
}

//返回订单项集合
public Collection&lt;OrderItem&gt; getOrderItems() {
return this.orderItems;
}

//返回订单总金额
public double getOrderTotal() {
return this.orderTotal;
}

//增加订单项，同时增加订单总金额
public void addOrderItem(OrderItem orderItem) {
this.orderTotal += orderItem.getTotalPrice();
orderItems.add(orderItem);
}

//删除订单项，同时减少订单总金额
public void removeOrderItem(OrderItem orderItem) {
this.orderTotal -= orderItem.getTotalPrice();
orderItems.remove(orderItem);
}
}

//订单项类，省略了很多属性
class OrderItem {
private double totalPrice; //订单项商品总价格

public OrderItem() {
}

public OrderItem(double totalPrice) {
this.totalPrice = totalPrice;
}

public void setTotalPrice(double totalPrice) {
this.totalPrice = totalPrice;
}

public double getTotalPrice() {
return this.totalPrice;
}
}

class Client {
public static void main(String args[]) {
OrderItem orderItem1 = new OrderItem(116.00);
OrderItem orderItem2 = new OrderItem(234.00);
OrderItem orderItem3 = new OrderItem(58.00);

Order order = new Order();
order.addOrderItem(orderItem1);
order.addOrderItem(orderItem2);
order.addOrderItem(orderItem3);

//获取订单类中的订单项集合
Collection&lt;OrderItem&gt; orderItems = order.getOrderItems();

System.out.print(&quot;订单中各订单项的价格分别为：&quot;);
for (Object obj : orderItems) {
System.out.print(((OrderItem)obj).getTotalPrice() + &quot;,&quot;);
}
System.out.println(&quot;订单总金额为&quot; + order.getOrderTotal());

//通过订单项集合对象的add()方法增加新订单
orderItems.add(new OrderItem(100.00));

System.out.print(&quot;订单中各订单项的价格分别为：&quot;);
for (Object obj : orderItems) {
System.out.print(((OrderItem)obj).getTotalPrice() + &quot;,&quot;);
}
System.out.println(&quot;增加新项后订单总金额为&quot; + order.getOrderTotal());
}
}
package sunny.refactoring.one.after;
……
class Order {
……
//将getOrderItems()的返回类型改为Iterable
public Iterable&lt;OrderItem&gt; getOrderItems() {
return this.orderItems;
}
……
}

class OrderItem {
……
}

class Client {
public static void main(String args[]) {
OrderItem orderItem1 = new OrderItem(116.00);
OrderItem orderItem2 = new OrderItem(234.00);
OrderItem orderItem3 = new OrderItem(58.00);

Order order = new Order();
order.addOrderItem(orderItem1);
order.addOrderItem(orderItem2);
order.addOrderItem(orderItem3);

//获取Iterable&lt;OrderItem&gt;类型的订单项集合对象
Iterable&lt;OrderItem&gt; orderItems = order.getOrderItems();

Iterator&lt;OrderItem&gt; iterator = orderItems.iterator();
System.out.print(&quot;订单中各订单项的价格分别为：&quot;);
while(iterator.hasNext()) {
System.out.print(((OrderItem)iterator.next()).getTotalPrice() + &quot;,&quot;);
}
System.out.println(&quot;订单总金额为&quot; + order.getOrderTotal());

//无法访问Order中的集合，Iterable没有提供add()方法，只能通过Order的addOrderItem()方法增加新元素
order.addOrderItem(new OrderItem(100.00));

Iterator&lt;OrderItem&gt; iteratorNew = orderItems.iterator();
System.out.print(&quot;订单中各订单项的价格分别为：&quot;);
while(iteratorNew.hasNext()) {
System.out.print(((OrderItem)iteratorNew.next()).getTotalPrice() + &quot;,&quot;);
}
System.out.println(&quot;增加新项后订单总金额为&quot; + order.getOrderTotal());
}
}
package sunny.refactoring.one.after;
……
import java.util.Iterator;
……
class Order {
……
//返回遍历orderItems对象的迭代器
public Iterator&lt;OrderItem&gt; getOrderItemsIterator() {
return orderItems.iterator();
}
……
}

class OrderItem {
……
}

class Client {
public static void main(String args[]) {
OrderItem orderItem1 = new OrderItem(116.00);
OrderItem orderItem2 = new OrderItem(234.00);
OrderItem orderItem3 = new OrderItem(58.00);

Order order = new Order();
order.addOrderItem(orderItem1);
order.addOrderItem(orderItem2);
order.addOrderItem(orderItem3);

//获取遍历订单项集合对象的迭代器
Iterator&lt;OrderItem&gt; iterator = order.getOrderItemsIterator();
System.out.print(&quot;订单中各订单项的价格分别为：&quot;);
while(iterator.hasNext()) {
System.out.print(((OrderItem)iterator.next()).getTotalPrice() + &quot;,&quot;);
}
System.out.println(&quot;订单总金额为&quot; + order.getOrderTotal());

//无法访问Order中的集合，只能通过Order的addOrderItem()方法增加新元素
order.addOrderItem(new OrderItem(100.00));

Iterator&lt;OrderItem&gt; iteratorNew = order.getOrderItemsIterator();
System.out.print(&quot;订单中各订单项的价格分别为：&quot;);
while(iteratorNew.hasNext()) {
System.out.print(((OrderItem)iteratorNew.next()).getTotalPrice() + &quot;,&quot;);
}
System.out.println(&quot;订单总金额为&quot; + order.getOrderTotal());
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>215813</snippet_key>
<tag>android 自定义控件 动画 反射 播放gif图片</tag>
<comment>来自CSDN博客：android中播放gif动画之二  http://blog.csdn.net/u010142437/article/details/20407281#</comment>
<code>package com.home.gifview;

import java.io.InputStream;
import java.lang.reflect.Field;
import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Movie;
import android.os.SystemClock;
import android.util.AttributeSet;
import android.util.TypedValue;
import android.widget.ImageView;

public class GifView extends ImageView {

private Movie movie;
private long movieStart;
private int imageWidth;
private int imageHeight;

public GifView(Context context) {
super(context);
}

public GifView(Context context, AttributeSet attrs) {
this(context, attrs, 0);
}

public GifView(Context context, AttributeSet attrs, int defStyle) {
super(context, attrs, defStyle);
TypedArray a = context.obtainStyledAttributes(attrs,
R.styleable.GifView);
int resourceId = getResourceId(a, context, attrs);
if (resourceId != 0) {
InputStream is = getResources().openRawResource(resourceId);
movie = Movie.decodeStream(is);
if (movie != null) {
Bitmap bitmap = BitmapFactory.decodeStream(is);
imageWidth = bitmap.getWidth();
imageHeight = bitmap.getHeight();
bitmap.recycle();
}
}
}

@Override
protected void onDraw(Canvas canvas) {
if (movie == null) {
// 普通图片则直接调用父类的onDraw()方法
super.onDraw(canvas);
} else {
playGif(canvas);
invalidate();
}
}

@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
super.onMeasure(widthMeasureSpec, heightMeasureSpec);
if (movie != null) {
// 如果是gif图片则定制GifView的大小
setMeasuredDimension(imageWidth, imageHeight);
}
}

/**
* 播放gif动画
*
* @param canvas
* @return
*/
private boolean playGif(Canvas canvas) {
long now = SystemClock.uptimeMillis();
if (movieStart == 0) {
movieStart = now;
}
int duration = movie.duration();
if (duration == 0) {
duration = 1000;
}
int relTime = (int) ((now - movieStart) % duration);
movie.setTime(relTime);
movie.draw(canvas, 0, 0);
if ((now - movieStart) &gt;= duration) {
movieStart = 0;
return true;
}
return false;
}

/**
* 使用反射，获取到src指定图片资源所对应的id。
*
* @param a
* @param context
* @param attrs
* @return
*/
private int getResourceId(TypedArray a, Context context, AttributeSet attrs) {
try {
Field field = TypedArray.class.getDeclaredField(&quot;mValue&quot;);
field.setAccessible(true);
TypedValue typedValueObject = (TypedValue) field.get(a);
return typedValueObject.resourceId;
} catch (Exception e) {
e.printStackTrace();
} finally {
if (a != null) {
a.recycle();
}
}
return 0;
}
}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;

&lt;declare-styleable name=&quot;GifView&quot;&gt;&lt;/declare-styleable&gt;

&lt;/resources&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot; &gt;

&lt;com.home.gifview.GifView
android:id=&quot;@+id/main_gifView&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:layout_centerInParent=&quot;true&quot;
android:src=&quot;@drawable/loading&quot; /&gt;

&lt;/RelativeLayout&gt;
android:hardwareAccelerated=&quot;false&quot;
</code>
</RECORD>
<RECORD>
<snippet_key>281349</snippet_key>
<tag></tag>
<comment>来自CSDN博客：JAVA学习脚印 1:开篇——初识java语言及开发环境  http://blog.csdn.net/ziyuanxiazai123/article/details/23136787#</comment>
<code>package com.learningjava;
/**
* the first example to show hello world
* @version 1.1 2013-08-05
* @author wangdq
*/
public class HelloWorld {
public static void main(String args[]) {
System.out.println(&quot;Hello, World!&quot;);//Observe the tradition
}
}
package com.learningjava;
import java.util.Date;
/**
* a simple program to show time
* @author wangdq
*/
public class ShowTime {
public static void main(String[] args) {
Date date = new Date();
System.out.println(&quot;Time now is: &quot;+date);//show the current time
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>200462</snippet_key>
<tag>327</tag>
<comment>来自CSDN博客：列出指定目录下的文件（Java 目录和文件操作） http://blog.csdn.net/themagickeyjianan/article/details/9368637#</comment>
<code>import java.io.File;
import java.io.FilenameFilter;
public class ListFileUtil
{

//过滤文件
static class MyFilenameFilter implements FilenameFilter
{
private String surfix = &quot;&quot;;
public MyFilenameFilter(String surfix)
{
this.surfix=surfix;
}
@Override
public boolean accept(File dir, String name)
{
// TODO Auto-generated method stub
if(new File(dir,name).isFile())
return name.endsWith(surfix);
return false;
}
}

// 列出所有文件夹包含的子目录的文件路径
public static void listAllFiles(String dirName)
{
if(!dirName.endsWith(File.separator))
dirName+=File.separator;
File dirFile = new File(dirName);
if(!dirFile.exists())
{
System.out.println(&quot;List失败！找不到目录：&quot;+dirName);
return;
}
File[] files = dirFile.listFiles();
for(int i=0;i&lt;files.length;i++)
if(files[i].isFile())
{
System.out.println(files[i].getAbsolutePath()+&quot; 是文件&quot;);
}
else if(files[i].isDirectory())
{
System.out.println(files[i].getAbsolutePath()+&quot; 是目录&quot;);
ListFileUtil.listAllFiles(files[i].getAbsolutePath());
}
}

//列出目录中用过滤器过滤后的文件
public static void listFilesByFilenameFilter(FilenameFilter filter,String dirName)
{
if(!dirName.endsWith(File.separator))
dirName+=File.separator;
File dirFile = new File(dirName);
if(!dirFile.exists()||(!dirFile.isDirectory()))
{
System.out.println(&quot;List失败！找不到目录：&quot;+dirName);
return;
}

File[] files = dirFile.listFiles(filter); //以指定的过滤器过滤文件
for(int i=0;i&lt;files.length;i++)
if(files[i].isFile())
{
System.out.println(files[i].getAbsolutePath()+&quot; 是文件&quot;);
}
else if(files[i].isDirectory())
{
System.out.println(files[i].getAbsolutePath()+&quot; 是目录&quot;);
ListFileUtil.listAllFiles(files[i].getAbsolutePath());
}
}

public static void main(String[] args)
{
String dir = &quot;D:/360&quot;;
System.out.println(dir+&quot;目录下的内容：&quot;);
ListFileUtil.listAllFiles(dir);

System.out.println();
System.out.println(&quot;经过过滤器过滤后的文件：&quot;);
FilenameFilter myFilenameFilter = new ListFileUtil.MyFilenameFilter(&quot;.txt&quot;);
ListFileUtil.listFilesByFilenameFilter(myFilenameFilter, dir);

}
}
</code>
</RECORD>
<RECORD>
<snippet_key>346885</snippet_key>
<tag>326</tag>
<comment>来自CSDN博客：JDBC的封装  http://blog.csdn.net/lhaiq/article/details/25887681#</comment>
<code>Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
ResultSet rs = null;
try {
rs = DataAccess.select(sql, parameters);//
ResultSetMetaData rsmd = rs.getMetaData();
int cols = rsmd.getColumnCount();
// 获取每一个字段名
List&lt;String&gt; colNames = new ArrayList&lt;String&gt;();// 保存所有的字段
for (int i = 0; i &lt; cols; i++) {
String colName = rsmd.getColumnName(i + 1);
colNames.add(colName);
}
// 获取数据
while (rs.next()) {
for (String nm : colNames) {// 遍历一行中的所列
Object val = rs.getObject(nm);
map.put(nm, val);
}
}

} catch (SQLException e) {
e.printStackTrace();
} finally {
JdbcUtils.closeResultSet(rs);
}

return map;
}
/**
*将查询结果自动包装为一个对象
* @param &lt;T&gt;
* @param sql
* @param parameters
* @param clazz
* @return
*/
@SuppressWarnings(&quot;unchecked&quot;)
public static &lt;T&gt; T selectForObject(String sql, Object[] parameters,
Class&lt;T&gt; clazz) throws NoSuchMethodException {
ResultSet rs = null;
try {
rs = DataAccess.select(sql, parameters);
return JdbcUtils.createBean(rs, clazz);
} catch (SQLException e) {
e.printStackTrace();
} finally {
JdbcUtils.closeResultSet(rs);
}
return null;

}

/**
* 将查询的数据放到List Map中
* 每一行是一个Map，然后放入List中
* @param sql
* @param parameters
* @return
*/
public static List&lt;Map&lt;String, Object&gt;&gt; selectForListMaps(String sql,
Object[] parameters) {
// 封装数据用
List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();// 声明返回的对象


ResultSet rs = null;
try {
rs = DataAccess.select(sql, parameters);
ResultSetMetaData rsmd = rs.getMetaData();
int cols = rsmd.getColumnCount();
// 获取每一个字段名
List&lt;String&gt; colNames = new ArrayList&lt;String&gt;();// 保存所有的字段
for (int i = 0; i &lt; cols; i++) {
String colName = rsmd.getColumnName(i + 1);
colNames.add(colName);
}
// 获取数据
while (rs.next()) {
// 一行数据
Map&lt;String, Object&gt; mm = new LinkedHashMap&lt;String, Object&gt;();
for (String nm : colNames) {// 遍历一行中的所列
Object val = rs.getObject(nm);
mm.put(nm, val);
}
// 将这个map放到list
list.add(mm);
}

} catch (SQLException e) {
e.printStackTrace();
} finally {
JdbcUtils.closeResultSet(rs);
}

return list;

}
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.math.BigDecimal;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;

import org.apache.commons.beanutils.BeanUtils;

public abstract class JdbcUtils {


public static final int TYPE_UNKNOWN = Integer.MIN_VALUE;


public static void closeConnection(Connection con) {
if (con != null) {
try {
con.close();
} catch (SQLException ex) {
ex.printStackTrace();
} catch (Throwable ex) {
}
}
}


public static void closeStatement(Statement stmt) {
if (stmt != null) {
try {
stmt.close();
} catch (SQLException ex) {
ex.printStackTrace();
} catch (Throwable ex) {

}
}
}


public static void closeResultSet(ResultSet rs) {
if (rs != null) {
try {
rs.close();
} catch (SQLException ex) {
ex.printStackTrace();
} catch (Throwable ex) {
}
}
}

public static Object getResultSetValue(ResultSet rs, String fieldName, Class requiredType) throws SQLException {

Object value = null;

if (String.class.equals(requiredType)) {
value = rs.getString(fieldName);
} else if (boolean.class.equals(requiredType) || Boolean.class.equals(requiredType)) {
value = rs.getBoolean(fieldName);
} else if (byte.class.equals(requiredType) || Byte.class.equals(requiredType)) {
value = rs.getByte(fieldName);
} else if (short.class.equals(requiredType) || Short.class.equals(requiredType)) {
value = rs.getShort(fieldName);
} else if (int.class.equals(requiredType) || Integer.class.equals(requiredType)) {
value = rs.getInt(fieldName);
} else if (long.class.equals(requiredType) || Long.class.equals(requiredType)) {
value = rs.getLong(fieldName);
} else if (float.class.equals(requiredType) || Float.class.equals(requiredType)) {
value = rs.getFloat(fieldName);
} else if (double.class.equals(requiredType) || Double.class.equals(requiredType)
|| Number.class.equals(requiredType)) {
value = rs.getDouble(fieldName);
} else if (byte[].class.equals(requiredType)) {
value = rs.getBytes(fieldName);
} else if (java.sql.Date.class.equals(requiredType) || java.util.Date.class.equals(requiredType)) {
value = new Date(rs.getDate(fieldName).getTime());
} else if (java.sql.Time.class.equals(requiredType)) {
value = rs.getTime(fieldName);
} else if (java.sql.Timestamp.class.equals(requiredType)) {
value = rs.getTimestamp(fieldName);
} else if (BigDecimal.class.equals(requiredType)) {
value = rs.getBigDecimal(fieldName);
} else if (Blob.class.equals(requiredType)) {
value = rs.getBlob(fieldName);
} else if (Clob.class.equals(requiredType)) {
value = rs.getClob(fieldName);
} else {
}
return value;
}

public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {
String name = resultSetMetaData.getColumnLabel(columnIndex);
if (name == null || name.length() &lt; 1) {
name = resultSetMetaData.getColumnName(columnIndex);
}
return name;
}

public static &lt;T&gt; T createBean(ResultSet rs, Class&lt;T&gt; clazz) {
T t = null;
Field[] fields = clazz.getDeclaredFields();
try {
// 获取数据
if (rs.next()) {
t = (T) clazz.newInstance();
for (Field field : fields) {
String fieldName = field.getName();
Class&lt;? extends Object&gt; fieldType = field.getType();
Object value = JdbcUtils.getResultSetValue(rs, fieldName, fieldType);
if (null != value) {
BeanUtils.setProperty(t, fieldName, value);
}
}
}
if (rs.next()) {
throw new RuntimeException(&quot;查询结果集不止一条数据，请确认SQL语句是否正确&quot;);
}
return t;
} catch (SQLException e) {
e.printStackTrace();
} catch (InstantiationException e) {
e.printStackTrace();
} catch (IllegalAccessException e) {
e.printStackTrace();
} catch (InvocationTargetException e) {
e.printStackTrace();
}
return null;
}

public static &lt;T&gt; List&lt;T&gt; createListBean(ResultSet rs, Class&lt;T&gt; clazz) {
T t = null;
Field[] fields = clazz.getDeclaredFields();
List&lt;T&gt; tList = new ArrayList&lt;T&gt;();
try {
// 获取数据
while (rs.next()) {
t = (T) clazz.newInstance();
for (Field field : fields) {
String fieldName = field.getName();
Class&lt;?&gt; fieldType = field.getType();
Object value = JdbcUtils.getResultSetValue(rs, fieldName, fieldType);
if (null != value) {
BeanUtils.setProperty(t, fieldName, value);
}
}
tList.add(t);
}
return tList;
} catch (SQLException e) {
e.printStackTrace();
} catch (InstantiationException e) {
e.printStackTrace();
} catch (IllegalAccessException e) {
e.printStackTrace();
} catch (InvocationTargetException e) {
e.printStackTrace();
}
return Collections.EMPTY_LIST;
}

}
/**
* 将结果集自动包装为一个List&lt;T&gt;
* @param &lt;T&gt;
* @param sql
* @param parameters
* @param clazz
* @return
*/
@SuppressWarnings(&quot;unchecked&quot;)
public static &lt;T&gt; List&lt;T&gt; selectForList(String sql, Object[] parameters,
Class&lt;T&gt; clazz) {
ResultSet rs = null;
try {
rs = DataAccess.select(sql, parameters);
return JdbcUtils.createListBean(rs, clazz);
} catch (SQLException e) {
e.printStackTrace();
} finally {
JdbcUtils.closeResultSet(rs);
}
return null;


}
public static Map&lt;String, Object&gt; queryForMap(String sql, Object[] parameters) {
Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
ResultSet rs = null;
try {
rs = DataAccess.select(sql, parameters);//
ResultSetMetaData rsmd = rs.getMetaData();
int cols = rsmd.getColumnCount();
// 获取每一个字段名
List&lt;String&gt; colNames = new ArrayList&lt;String&gt;();// 保存所有的字段
for (int i = 0; i &lt; cols; i++) {
String colName = rsmd.getColumnName(i + 1);
colNames.add(colName);
}
// 获取数据
while (rs.next()) {
for (String nm : colNames) {// 遍历一行中的所列
Object val = rs.getObject(nm);
map.put(nm, val);
}
}

} catch (SQLException e) {
e.printStackTrace();
} finally {
JdbcUtils.closeResultSet(rs);
}

return map;
}
</code>
</RECORD>
<RECORD>
<snippet_key>412421</snippet_key>
<tag>webservice jax-ws mtom</tag>
<comment>来自CSDN博客：JAX-WS - 二进制处理之MTOM(文件上传)  http://blog.csdn.net/u013379717/article/details/34904849#</comment>
<code>import javax.jws.WebService;

@WebService
public interface UploadService {

public void upload(byte[] file);

}
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import javax.jws.WebService;
import com.xilen.jws.UploadService;

@WebService(endpointInterface=&quot;com.xilen.jws.UploadService&quot;, serviceName=&quot;UploadServiceImplService&quot;)
public class UploadServiceImpl implements UploadService{

@Override
public void upload(byte[] file) {
try {
/**
* 将字节数组输出到文件
*/
FileOutputStream fos = new FileOutputStream(new File(&quot;test.png&quot;));
fos.write(file);
fos.close();
} catch (IOException e) {
e.printStackTrace();
}
}
}
public class WsStart {
public static void main(String[] args) {
String address = &quot;http://127.0.0.1:8888/upload&quot;;
Endpoint.publish(address, new UploadServiceImpl());
}
}
import java.io.File;
import java.io.IOException;
import javax.xml.ws.soap.MTOMFeature;
import org.apache.commons.io.FileUtils;
import com.xilen.jws.impl.UploadService;
import com.xilen.jws.impl.UploadServiceImplService;

public class ClientMain {

public static void main(String[] args) {
try {
UploadServiceImplService usis = new UploadServiceImplService();

UploadService service = usis.getUploadServiceImplPort();

service.upload(FileUtils.readFileToByteArray(new File(&quot;G:/xl.png&quot;)));

} catch (IOException e) {
e.printStackTrace();
}
}
}
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import javax.jws.WebService;
import javax.xml.ws.soap.MTOM;
import com.xilen.jws.UploadService;

/**
* 实现类注解MTOM
*/
@WebService(endpointInterface=&quot;com.xilen.jws.UploadService&quot;, serviceName=&quot;UploadServiceImplService&quot;)
@MTOM
public class UploadServiceImpl implements UploadService{

@Override
public void upload(byte[] file) {
try {
/**
* 将字节数组输出到文件
*/
FileOutputStream fos = new FileOutputStream(new File(&quot;test.png&quot;));
fos.write(file);
fos.close();
} catch (IOException e) {
e.printStackTrace();
}
}
}
import java.io.File;
import java.io.IOException;
import javax.xml.ws.soap.MTOMFeature;
import org.apache.commons.io.FileUtils;
import com.xilen.jws.impl.UploadService;
import com.xilen.jws.impl.UploadServiceImplService;

public class ClientMain {

public static void main(String[] args) {
try {
UploadServiceImplService usis = new UploadServiceImplService();

/**
* 获取远程服务代理时传入MTOMFeature实例
*/
UploadService service = usis.getUploadServiceImplPort(new MTOMFeature());

service.upload(FileUtils.readFileToByteArray(new File(&quot;g:/xl.png&quot;)));

} catch (IOException e) {
e.printStackTrace();
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>150533</snippet_key>
<tag>泛型 知识点 边界</tag>
<comment>来自CSDN博客：泛型的边界  http://blog.csdn.net/y172158950/article/details/18044165#</comment>
<code>import java.util.ArrayList;

public class TypeTest {

public static void main(String[] args) {
//泛型中的类型String,Integer在
Class&lt;?&gt; c1 = new ArrayList&lt;String&gt;().getClass();
Class&lt;?&gt; c2 = new ArrayList&lt;Integer&gt;().getClass();
System.out.println(c1 == c2); //true
}

}
//output
true
import java.lang.reflect.Array;
import java.util.Arrays;

@SuppressWarnings(&quot;hiding&quot;)
public class ArrayMaker&lt;T&gt; {

private Class&lt;T&gt; kind;

public ArrayMaker(Class&lt;T&gt; kind) {
this.kind = kind;
}

@SuppressWarnings(&quot;unchecked&quot;)
T[] create(int size) {
//此处Array.newInstance()方法返回的是Object,必须转型；说明期望的泛型没有起任何作用
return (T[]) Array.newInstance(kind, size);
}

@SuppressWarnings(&quot;unchecked&quot;)
T[] create(T t, int size) throws InstantiationException, IllegalAccessException {
//此处Array.newInstance()方法返回的是Object,必须转型；说明期望的泛型没有起任何作用
T[] ts = (T[]) Array.newInstance(kind, size);
//注意：此处仍能保证放入T[]的类型为T
for(int i=0; i&lt;ts.length; i++) {
ts[i] = t;
// ts[i] = new Object(); //Type mismatch: cannot convert from Object to T
}
return ts;
}

public static void main(String[] args) throws Exception {
ArrayMaker&lt;String&gt; StrsMaker = new ArrayMaker&lt;String&gt;(String.class);
String[] strsArray = StrsMaker.create(10);
String[] strsArray2 = StrsMaker.create(&quot;AA&quot;, 10);
System.out.println(Arrays.toString(strsArray));
System.out.println(Arrays.toString(strsArray2));

}
}
//output
[null, null, null, null, null, null, null, null, null, null]
[AA, AA, AA, AA, AA, AA, AA, AA, AA, AA]
</code>
</RECORD>
<RECORD>
<snippet_key>281605</snippet_key>
<tag></tag>
<comment>来自CSDN博客：【顺时针打印矩阵】  http://blog.csdn.net/jingtianxiaozhi01/article/details/23204291#</comment>
<code>package com.itheima.test9;

public class Test9 {

public static void main(String[] args) {
int[][] a=myMethod(5);
for(int i=0;i&lt;a.length;i++){
for(int j=0;j&lt;a.length;j++){
switch ((a[i][j]+&quot;&quot;).length()) {
case 1:
System.out.print(a[i][j]+&quot; &quot;);
break;
case 2:
System.out.print(a[i][j]+&quot; &quot;);
break;
case 3:
System.out.print(a[i][j]+&quot; &quot;);
break;

}
}
System.out.println();
}
}
public static int[][] myMethod(int n){
//初始化用来存放n阶矩阵的数组
int[][] a=new int[n][n];
//定义计数器从1开始
int num=1;

//这个m是第几个圈的意思
mark: for(int m=0;m&lt;(n+1)/2;m++){

//从左往右打印最上面一排
for(int i=m;i&lt;=n-1-m;i++){
a[m][i]=num++;
if(num==n*n+1)
break mark;
}

//从上往下打印最右边一排去掉最上面一个和最下面一个
for(int j=1+m;j&lt;=n-2-m;j++){
a[j][n-1-m]=num++;
}

//右往左打印最下面一排
for(int k=n-1-m;k&gt;=m;k--){
a[n-1-m][k]=num++;
}

//从下往上打印最左边一排，去掉最下面一个和最上面一个
for(int l=n-2-m;l&gt;=1+m;l--){
a[l][m]=num++;
}
}

return a;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>397326</snippet_key>
<tag></tag>
<comment>来自CSDN博客：【黑马程序员】交通灯管理系统  http://blog.csdn.net/tnt2011cpp/article/details/32108437#</comment>
<code>enum Lamp{
S2N(&quot;N2S&quot;,false,&quot;S2W&quot;),S2W(&quot;N2E&quot;,false,&quot;W2E&quot;),S2E(&quot;N2W&quot;,true,&quot;S2E&quot;),
W2E(&quot;E2W&quot;,false,&quot;W2N&quot;),W2N(&quot;E2S&quot;,false,&quot;S2N&quot;),W2S(&quot;E2N&quot;,true,&quot;W2S&quot;),
N2S(null,false,null),N2E(null,false,null),N2W(null,false,null),
E2W(null,false,null),E2S(null,false,null),E2N(null,false,null);
private String opposite;
private boolean lighted;
private String next;
private Lamp(String opposite,Boolean lighted,String next){
this.opposite=opposite;
this.lighted=lighted;
this.next=next;
}

public void light(){
this.lighted=true;
if(opposite!=null){
Lamp LampOpposite=Lamp.valueOf(opposite);
LampOpposite.light();

}
System.out.println(name()+&quot;lamp is green,下面总共应该6个方向能看到车辆穿过！&quot;);

}
public Lamp blackOut(){
this.lighted=false;
if(opposite!=null){
Lamp lampOpposite=Lamp.valueOf(opposite);
lampOpposite.blackOut();
}
Lamp nextLamp=null;
if(next!=null){
nextLamp=Lamp.valueOf(next);
System.out.println(&quot;绿灯从&quot;+name()+&quot;-------&gt;切换为&quot;+nextLamp.name());
nextLamp.light();

}
return nextLamp;
}
public boolean isLighted(){
return this.lighted;
}
}
package com.isoftsone.interview;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;


public class LampController {
private static LampController instance=new LampController();
public static LampController getInstance(){
return instance;
}
private Lamp currentLamp=null;
public LampController(){
currentLamp=Lamp.S2N;
}
public void start(){
currentLamp.light();
Executors.newScheduledThreadPool(1).scheduleAtFixedRate(
new Runnable() {

@Override
public void run() {
// TODO 自动生成的方法存根
currentLamp=currentLamp.blackOut();
}
},10,10,TimeUnit.SECONDS);
}

}
package com.isoftsone.interview;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
public class Road {
private List&lt;String&gt; vechicles=new ArrayList&lt;String&gt;();
private String name=null;
public Road(String name){
this.name=name;
ExecutorService pool=Executors.newSingleThreadExecutor();
pool.execute(new Runnable() {
@Override
public void run() {
// TODO 自动生成的方法存根
for(int i=1;i&lt;1000;i++){
try {
Thread.sleep((new Random().nextInt(10)+1)*1000);
} catch (InterruptedException e) {
// TODO 自动生成的 catch 块
e.printStackTrace();
}
vechicles.add(Road.this.name+&quot;_&quot;+i);
}
}
});
ScheduledExecutorService timer= Executors.newScheduledThreadPool(1);
timer.scheduleAtFixedRate(
new Runnable() {
@Override
public void run() {
// TODO 自动生成的方法存根
if(vechicles.size()&gt;0){
boolean lighted=Lamp.valueOf(Road.this.name).isLighted();
if(lighted){
System.out.println(vechicles.remove(0)+&quot; is traversing ! &quot;);
}
}
}
},1,1,TimeUnit.SECONDS);

}

package com.isoftsone.interview;

import javax.swing.text.StyledEditorKit.ForegroundAction;

public class TransportLamp {
public static String[] RoadLine={&quot;S2N&quot;,&quot;S2W&quot;,&quot;S2E&quot;,&quot;N2S&quot;,&quot;N2W&quot;,&quot;N2E&quot;,&quot;W2E&quot;,&quot;W2N&quot;,&quot;W2S&quot;,&quot;E2W&quot;,&quot;E2N&quot;,&quot;E2S&quot;};
public static void main(String[] args) {
// TODO 自动生成的方法存根
new LampController().start();
for(int i=0;i&lt;12;i++){
new Road(RoadLine[i]);
}

}

}
</code>
</RECORD>
<RECORD>
<snippet_key>478213</snippet_key>
<tag></tag>
<comment>来自CSDN博客：装饰模式（Decorator）  http://blog.csdn.net/qilixiang012/article/details/39700177#</comment>
<code>/**
* 在内存中模拟数据库，准备点测试数据，好计算奖金
*/
public class TempDB {
private TempDB(){
}
/**
* 记录每个人的月度销售额，只用了人员，月份没有用
*/
public static Map&lt;String,Double&gt; mapMonthSaleMoney =
new HashMap&lt;String,Double&gt;();
static{
//填充测试数据
mapMonthSaleMoney.put(&quot;张三&quot;,10000.0);
mapMonthSaleMoney.put(&quot;李四&quot;,20000.0);
mapMonthSaleMoney.put(&quot;王五&quot;,30000.0);
}
}
/**
* 计算奖金的对象
*/
public class Prize {
/**
* 计算某人在某段时间内的奖金，有些参数在演示中并不会使用，
* 但是在实际业务实现上是会用的，为了表示这是个具体的业务方法，
* 因此这些参数被保留了
* @param user 被计算奖金的人员
* @param begin 计算奖金的开始时间
* @param end 计算奖金的结束时间
* @return 某人在某段时间内的奖金
*/
public double calcPrize(String user,Date begin,Date end){
double prize = 0.0;
//计算当月业务奖金，所有人都会计算
prize = this.monthPrize(user, begin, end);
//计算累计奖金
prize += this.sumPrize(user, begin, end);

//需要判断该人员是普通人员还是业务经理，团队奖金只有业务经理才有
if(this.isManager(user)){
prize += this.groupPrize(user, begin, end);
}
return prize;
}

/**
* 计算某人的当月业务奖金，参数重复，就不再注释了
*/
private double monthPrize(String user, Date begin, Date end) {
//计算当月业务奖金,按照人员去获取当月的业务额，然后再乘以3%
double prize = TempDB.mapMonthSaleMoney.get(user) * 0.03;
System.out.println(user+&quot;当月业务奖金&quot;+prize);
return prize;
}

/**
* 计算某人的累计奖金，参数重复，就不再注释了
*/
public double sumPrize(String user, Date begin, Date end) {
//计算累计奖金,其实应该按照人员去获取累计的业务额，然后再乘以0.1%
//简单演示一下，假定大家的累计业务额都是1000000元
double prize = 1000000 * 0.001;
System.out.println(user+&quot;累计奖金&quot;+prize);
return prize;
}

/**
* 判断人员是普通人员还是业务经理
* @param user 被判断的人员
* @return true表示是业务经理,false表示是普通人员
*/
private boolean isManager(String user){
//应该从数据库中获取人员对应的职务
//为了演示，简单点判断，只有王五是经理
if(&quot;王五&quot;.equals(user)){
return true;
}
return false;
}
/**
* 计算当月团队业务奖，参数重复，就不再注释了
*/
public double groupPrize(String user, Date begin, Date end) {
//计算当月团队业务奖金，先计算出团队总的业务额，然后再乘以1%，
//假设都是一个团队的
double group = 0.0;
for(double d : TempDB.mapMonthSaleMoney.values()){
group += d;
}
double prize = group * 0.01;
System.out.println(user+&quot;当月团队业务奖金&quot;+prize);
return prize;
}
}
public class Client {
public static void main(String[] args) {
//先创建计算奖金的对象
Prize p = new Prize();

//日期对象都没有用上，所以传null就可以了
double zs = p.calcPrize(&quot;张三&quot;,null,null);
System.out.println(&quot;==========张三应得奖金：&quot;+zs);
double ls = p.calcPrize(&quot;李四&quot;,null,null);
System.out.println(&quot;==========李四应得奖金：&quot;+ls);
double ww = p.calcPrize(&quot;王五&quot;,null,null);
System.out.println(&quot;==========王经理应得奖金：&quot;+ww);
}
}
张三当月业务奖金300.0
张三累计奖金1000.0
==========张三应得奖金：1300.0
李四当月业务奖金600.0
李四累计奖金1000.0
==========李四应得奖金：1600.0
王五当月业务奖金900.0
王五累计奖金1000.0
王五当月团队业务奖金600.0
==========王经理应得奖金：2500.0
/**
* 组件对象的接口，可以给这些对象动态的添加职责
*/
public abstract class Component {
/**
* 示例方法
*/
public abstract void operation();
}
/**
* 具体实现组件对象接口的对象
*/
public class ConcreteComponent extends Component {
public void operation() {
//相应的功能处理
}
}
/**
* 装饰器接口，维持一个指向组件对象的接口对象，并定义一个与组件接口一致的接口
*/
public abstract class Decorator extends Component {
/**
* 持有组件对象
*/
protected Component component;
/**
* 构造方法，传入组件对象
* @param component 组件对象
*/
public Decorator(Component component) {
this.component = component;
}
public void operation() {
//转发请求给组件对象，可以在转发前后执行一些附加动作
component.operation();
}
}
/**
* 装饰器的具体实现对象，向组件对象添加职责
*/
public class ConcreteDecoratorA extends Decorator {
public ConcreteDecoratorA(Component component) {
super(component);
}
/**
* 添加的状态
*/
private String addedState;
public String getAddedState() {
return addedState;
}
public void setAddedState(String addedState) {
this.addedState = addedState;
}
public void operation() {
//调用父类的方法，可以在调用前后执行一些附加动作
//在这里进行处理的时候，可以使用添加的状态
super.operation();
}
}
/**
* 装饰器的具体实现对象，向组件对象添加职责
*/
public class ConcreteDecoratorB extends Decorator {
public ConcreteDecoratorB(Component component) {
super(component);
}
/**
* 需要添加的职责
*/
private void addedBehavior() {
//需要添加的职责实现
}
public void operation() {
//调用父类的方法，可以在调用前后执行一些附加动作
super.operation();
addedBehavior();
}
}
/**
* 计算奖金的组件接口
*/
public abstract class Component {
/**
* 计算某人在某段时间内的奖金，有些参数在演示中并不会使用，
* 但是在实际业务实现上是会用的，为了表示这是个具体的业务方法，
* 因此这些参数被保留了
* @param user 被计算奖金的人员
* @param begin 计算奖金的开始时间
* @param end 计算奖金的结束时间
* @return 某人在某段时间内的奖金
*/
public abstract double calcPrize(String user
,Date begin,Date end);
}
/**
* 基本的实现计算奖金的类，也是被装饰器装饰的对象
*/
public class ConcreteComponent extends Component{
public double calcPrize(String user, Date begin, Date end) {
//只是一个默认的实现，默认没有奖金
return 0;
}
}
/**
* 装饰器的接口，需要跟被装饰的对象实现同样的接口
*/
public abstract class Decorator extends Component{
/**
* 持有被装饰的组件对象
*/
protected Component c;
/**
* 通过构造方法传入被装饰的对象
* @param c被装饰的对象
*/
public Decorator(Component c){
this.c = c;
}
public double calcPrize(String user, Date begin, Date end) {
//转调组件对象的方法
return c.calcPrize(user, begin, end);
}
}
/**
* 装饰器对象，计算当月业务奖金
*/
public class MonthPrizeDecorator extends Decorator{
public MonthPrizeDecorator(Component c){
super(c);
}
public double calcPrize(String user, Date begin, Date end) {
//1：先获取前面运算出来的奖金
double money = super.calcPrize(user, begin, end);
//2：然后计算当月业务奖金,按人员和时间去获取当月业务额，然后再乘以3%
double prize = TempDB.mapMonthSaleMoney.get(user) * 0.03;
System.out.println(user+&quot;当月业务奖金&quot;+prize);
return money + prize;
}
}
/**
* 装饰器对象，计算累计奖金
*/
public class SumPrizeDecorator extends Decorator{
public SumPrizeDecorator(Component c){
super(c);
}
public double calcPrize(String user, Date begin, Date end) {
//1：先获取前面运算出来的奖金
double money = super.calcPrize(user, begin, end);
//2：然后计算累计奖金,其实应按人员去获取累计的业务额，然后再乘以0.1%
//简单演示一下，假定大家的累计业务额都是1000000元
double prize = 1000000 * 0.001;
System.out.println(user+&quot;累计奖金&quot;+prize);
return money + prize;
}
}
/**
* 装饰器对象，计算当月团队业务奖金
*/
public class GroupPrizeDecorator extends Decorator{
public GroupPrizeDecorator(Component c){
super(c);
}
public double calcPrize(String user, Date begin, Date end) {
//1：先获取前面运算出来的奖金
double money = super.calcPrize(user, begin, end);
//2：然后计算当月团队业务奖金，先计算出团队总的业务额，然后再乘以1%
//假设都是一个团队的
double group = 0.0;
for(double d : TempDB.mapMonthSaleMoney.values()){
group += d;
}
double prize = group * 0.01;
System.out.println(user+&quot;当月团队业务奖金&quot;+prize);
return money + prize;
}
}
/**
* 使用装饰模式的客户端
*/
public class Client {
public static void main(String[] args) {
//先创建计算基本奖金的类，这也是被装饰的对象
Component c1 = new ConcreteComponent();

//然后对计算的基本奖金进行装饰，这里要组合各个装饰
//说明，各个装饰者之间最好是不要有先后顺序的限制，
//也就是先装饰谁和后装饰谁都应该是一样的

//先组合普通业务人员的奖金计算
Decorator d1 = new MonthPrizeDecorator(c1);
Decorator d2 = new SumPrizeDecorator(d1);

//注意：这里只需使用最后组合好的对象调用业务方法即可，会依次调用回去
//日期对象都没有用上，所以传null就可以了
double zs = d2.calcPrize(&quot;张三&quot;,null,null);
System.out.println(&quot;==========张三应得奖金：&quot;+zs);
double ls = d2.calcPrize(&quot;李四&quot;,null,null);
System.out.println(&quot;==========李四应得奖金：&quot;+ls);

//如果是业务经理，还需要一个计算团队的奖金计算
Decorator d3 = new GroupPrizeDecorator(d2);
double ww = d3.calcPrize(&quot;王五&quot;,null,null);
System.out.println(&quot;==========王经理应得奖金：&quot;+ww);
}
}
张三当月业务奖金300.0
张三累计奖金1000.0
==========张三应得奖金：1300.0
李四当月业务奖金600.0
李四累计奖金1000.0
==========李四应得奖金：1600.0
王五当月业务奖金900.0
王五累计奖金1000.0
王五当月团队业务奖金600.0
==========王经理应得奖金：2500.0
public class A {
public void a1(){
System.out.println(&quot;now in A.a1&quot;);
}
}
public class C1 extends A{
public void c11(){
System.out.println(&quot;now in C1.c11&quot;);
}
}
public class C2 {
/**
* 创建A对象的实例
*/
private A a = new A();

public void a1(){
//转调A对象的功能
a.a1();
}
public void c11(){
System.out.println(&quot;now in C2.c11&quot;);
}
}
public class B {
public void b1(){
System.out.println(&quot;now in B.b1&quot;);
}
}
public class C3 {
private A a = new A();
private B b = new B();

public void a1(){
//转调A对象的功能
a.a1();
}
public void b1(){
//转调B对象的功能
b.b1();
}
public void c11(){
System.out.println(&quot;now in C3.c11&quot;);
}
}
public class C4 {
//示例直接在属性上创建需要组合的对象
private A a = new A();

//示例通过外部传入需要组合的对象
private B b = null;
public void setB(B b){
this.b = b;
}
public void a1(){
//转调A对象的功能
a.a1();
}
public void b1(){
//转调B对象的功能
b.b1();
}
public void c11(){
System.out.println(&quot;now in C4.c11&quot;);
}
}
public class IOTest {
public static void main(String[] args)throws Exception {
//流式读取文件
DataInputStream din = null;
try{
din = new DataInputStream(
new BufferedInputStream(
new FileInputStream(&quot;IOTest.txt&quot;)
)
);
//然后就可以获取文件内容了
byte bs []= new byte[din.available()];
din.read(bs);
String content = new String(bs);
System.out.println(&quot;文件内容====&quot;+content);
}finally{
din.close();
}
}
}
/**
* 实现简单的加密
*/
public class EncryptOutputStream extends OutputStream{
//持有被装饰的对象
private OutputStream os = null;
public EncryptOutputStream(OutputStream os){
this.os = os;
}
public void write(int a) throws IOException {
//先统一向后移动两位
a = a+2;
//97是小写的a的码值
if(a &gt;= (97+26)){
//如果大于，表示已经是y或者z了，减去26就回到a或者b了
a = a-26;
}
this.os.write(a);
}
}
public class Client {
public static void main(String[] args) throws Exception {
//流式输出文件
DataOutputStream dout = new DataOutputStream(
new BufferedOutputStream(
//这是我们加的装饰器
new EncryptOutputStream(
new FileOutputStream(&quot;MyEncrypt.txt&quot;))));
//然后就可以输出内容了
dout.write(&quot;abcdxyz&quot;.getBytes());
dout.close();
}
}
cdefzab
public class Client {
public static void main(String[] args) throws Exception {
//流式输出文件
DataOutputStream dout = new DataOutputStream(
//换了个位置
new EncryptOutputStream (
new BufferedOutputStream(
new FileOutputStream(&quot;MyEncrypt.txt&quot;))));
dout.write(&quot;abcdxyz&quot;.getBytes());
dout.close();
}
}
public class EncryptOutputStream2 extends FilterOutputStream{
private OutputStream os = null;
public EncryptOutputStream2(OutputStream os){
//调用父类的构造方法
super(os);
}
public void write(int a) throws IOException {
//先统一向后移动两位
a = a+2;
//97是小写的a的码值
if(a &gt;= (97+26)){
//如果大于，表示已经是y或者z了，减去26就回到a或者b了
a = a-26;
}
//调用父类的方法
super.write(a);
}
}
/**
* 商品销售管理的业务接口
*/
public interface GoodsSaleEbi {
/**
* 保存销售信息，本来销售数据应该是多条，太麻烦了，为了演示，简单点
* @param user 操作人员
* @param customer 客户
* @param saleModel 销售数据
* @return 是否保存成功
*/
public boolean sale(String user,String customer,
SaleModel saleModel);
}
/**
* 封装销售单的数据，简单的示意一些
*/
public class SaleModel {
/**
* 销售的商品
*/
private String goods;
/**
* 销售的数量
*/
private int saleNum;
public String getGoods() {
return goods;
}
public void setGoods(String goods) {
this.goods = goods;
}
public int getSaleNum() {
return saleNum;
}
public void setSaleNum(int saleNum) {
this.saleNum = saleNum;
}
public String toString(){
return &quot;商品名称=&quot;+goods+&quot;,购买数量=&quot;+saleNum;
}
}
public class GoodsSaleEbo implements GoodsSaleEbi{
public boolean sale(String user,String customer,
SaleModel saleModel) {
System.out.println(user+&quot;保存了&quot;
+customer+&quot;购买 &quot;+saleModel+&quot; 的销售数据&quot;);
return true;
}
}
/**
* 装饰器的接口，需要跟被装饰的对象实现同样的接口
*/
public abstract class Decorator implements GoodsSaleEbi{
/**
* 持有被装饰的组件对象
*/
protected GoodsSaleEbi ebi;
/**
* 通过构造方法传入被装饰的对象
* @param ebi被装饰的对象
*/
public Decorator(GoodsSaleEbi ebi){
this.ebi = ebi;
}
}
/**
* 实现权限控制
*/
public class CheckDecorator extends Decorator{
public CheckDecorator(GoodsSaleEbi ebi){
super(ebi);
}
public boolean sale(String user,String customer
, SaleModel saleModel) {
//简单点，只让张三执行这个功能
if(!&quot;张三&quot;.equals(user)){
System.out.println(&quot;对不起&quot;+user
+&quot;，你没有保存销售单的权限&quot;);
//就不再调用被装饰对象的功能了
return false;
}else{
return this.ebi.sale(user,customer,saleModel);
}
}
}
/**
* 实现日志记录
*/
public class LogDecorator extends Decorator{
public LogDecorator(GoodsSaleEbi ebi){
super(ebi);
}
public boolean sale(String user,String customer,
SaleModel saleModel) {
//执行业务功能
boolean f = this.ebi.sale(user, customer, saleModel);

//在执行业务功能过后，记录日志
DateFormat df =
new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
System.out.println(&quot;日志记录：&quot;+user+&quot;于&quot;+
df.format(new Date())+&quot;时保存了一条销售记录，客户是&quot;
+customer+&quot;,购买记录是&quot;+saleModel);
return f;
}
}
public class Client {
public static void main(String[] args) {
//得到业务接口，组合装饰器
GoodsSaleEbi ebi = new CheckDecorator(
new LogDecorator(
new GoodsSaleEbo()));
//准备测试数据
SaleModel saleModel = new SaleModel();
saleModel.setGoods(&quot;Moto手机&quot;);
saleModel.setSaleNum(2);
//调用业务功能
ebi.sale(&quot;张三&quot;,&quot;张三丰&quot;, saleModel);
ebi.sale(&quot;李四&quot;,&quot;张三丰&quot;, saleModel);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>463118</snippet_key>
<tag>来自CSDN博客：java中单例模式 http://blog.csdn.net/ruanjian11110/article/details/38641615#</tag>
<comment>派生自炸死特/blog_20140416_1_3007966</comment>
<code>public class Singleton {
private static Singleton uniqueInstance = null;

private Singleton() {
// Exists only to defeat instantiation.
}

public static Singleton getInstance() {
if (uniqueInstance == null) {
uniqueInstance = new Singleton();
}
return uniqueInstance;
}
// Other methods...
}
package jason.single;

public class TestStream {
String name = null;

public String getName() {
return name;
}

public void setName(String name) {
this.name = name;
}

private TestStream() {
}

private static TestStream ts1 = null;

public static TestStream getTest() {
if (ts1 == null) {
ts1 = new TestStream();
}
return ts1;
}

public void printInfo() {
System.out.println(&quot;the name is &quot; + name);
}

}
package jason.single;

public class TMain {
public static void main(String[] args){
TestStream ts1 = TestStream.getTest();
ts1.setName(&quot;jason&quot;);
TestStream ts2 = TestStream.getTest();
ts2.setName(&quot;0539&quot;);

ts1.printInfo();
ts2.printInfo();

if(ts1 == ts2){
System.out.println(&quot;创建的是同一个实例&quot;);
}else{
System.out.println(&quot;创建的不是同一个实例&quot;);
}
}
}
//饿汉式单例类.在类初始化时，已经自行实例化
public class Singleton1 {
//私有的默认构造子
private Singleton1() {}
//已经自行实例化
private static final Singleton1 single = new Singleton1();
//静态工厂方法
public static Singleton1 getInstance() {
return single;
}
}
//懒汉式单例类.在第一次调用的时候实例化
public class Singleton2 {
//私有的默认构造子
private Singleton2() {}
//注意，这里没有final
private static Singleton2 single=null;
//静态工厂方法
public synchronized static Singleton2 getInstance() {
if (single == null) {
single = new Singleton2();
}
return single;
}
}
import java.util.HashMap;
import java.util.Map;
//登记式单例类.
//类似Spring里面的方法，将类名注册，下次从里面直接获取。
public class Singleton3 {
private static Map&lt;String,Singleton3&gt; map = new HashMap&lt;String,Singleton3&gt;();
static{
Singleton3 single = new Singleton3();
map.put(single.getClass().getName(), single);
}
//保护的默认构造子
protected Singleton3(){}
//静态工厂方法,返还此类惟一的实例
public static Singleton3 getInstance(String name) {
if(name == null) {
name = Singleton3.class.getName();
System.out.println(&quot;name == null&quot;+&quot;---&gt;name=&quot;+name);
}
if(map.get(name) == null) {
try {
map.put(name, (Singleton3) Class.forName(name).newInstance());
} catch (InstantiationException e) {
e.printStackTrace();
} catch (IllegalAccessException e) {
e.printStackTrace();
} catch (ClassNotFoundException e) {
e.printStackTrace();
}
}
return map.get(name);
}
//一个示意性的商业方法
public String about() {
return &quot;Hello, I am RegSingleton.&quot;;
}
public static void main(String[] args) {
Singleton3 single3 = Singleton3.getInstance(null);
System.out.println(single3.about());
}
}
&lt;pre class=&quot;java&quot; name=&quot;code&quot;&gt;Java Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例在。 使用Singleton的好处还在于可以节省内存，因为它限制了实例的个数，有利于Java垃圾回（garbage collection）。
&lt;pre class=&quot;java&quot; name=&quot;code&quot;&gt;01.public class Singleton {
02. private static Singleton uniqueInstance = null;
03.
04. private Singleton() {
05. // Exists only to defeat instantiation.
06. }
07.
08. public static Singleton getInstance() {
09. if (uniqueInstance == null) {
10. uniqueInstance = new Singleton();
11. }
12. return uniqueInstance;
13. }
14. // Other methods...
15.}
</code>
</RECORD>
<RECORD>
<snippet_key>135694</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Reverse Integer http://blog.csdn.net/u013325815/article/details/17708951#</comment>
<code>public class Solution {
public int reverse(int x) {
int sign = (x&lt;0?-1:1);

x = Math.abs(x);
Stack&lt;Integer&gt; mystack = new Stack&lt;Integer&gt;();
while(x&gt;0){
int last = x%10;
x = x/10;
mystack.push(last);
}

//reverse construct;
int result =0 ; int i = 0;
while(!mystack.empty()){
int first = mystack.pop();
result += first*Math.pow(10,i);
i++;
}
return sign*result;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>347397</snippet_key>
<tag>eclipse 代码 Sublime Text 多行编辑 批量删除行号</tag>
<comment>来自CSDN博客：如何删除多行首字母，Sublime Text2多行编辑运用  http://blog.csdn.net/u010983881/article/details/25898989#</comment>
<code>&lt;strong&gt;&lt;span style=&quot;font-size:14px;&quot;&gt;一、问题描述：&lt;/span&gt;&lt;/strong&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;&lt;/span&gt;&lt;span style=&quot;font-size:14px&quot;&gt;问答区有个问题是这样问的&lt;span style=&quot;background-color:rgb(255,255,255)&quot;&gt;：&lt;a target=_blank target=&quot;_blank&quot; href=&quot;http://ask.csdn.net/questions/29687&quot;&gt;&lt;span style=&quot;font-family:Helvetica,Tahoma,Arial,sans-serif; color:#0066cc&quot;&gt;&lt;span style=&quot;line-height:16px&quot;&gt;如何在eclipse中删除多行首字母&lt;/span&gt;&lt;/span&gt;？&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size:14px&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;&lt;/span&gt;题主的问题是代码中每行都有序号，这些序号一行一行地删太麻烦，如何进行批量删除？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;white-space:pre&quot;&gt;&lt;/span&gt;   &lt;span style=&quot;font-size:14px&quot;&gt;我们在进行代码重用的时候时常会出现行号同时被复制的情况，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size:14px&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;&lt;/span&gt;比如下面的这点代码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre code_snippet_id=&quot;347397&quot; snippet_file_name=&quot;blog_20140515_2_7338663&quot; name=&quot;code&quot; class=&quot;java&quot;&gt;155. @Override
156. public boolean onKeyDown(int keyCode, KeyEvent event)
157. {
158. Log.d(&quot;onKeyDown:&quot;, &quot; keyCode=&quot; + keyCode + &quot; KeyEvent=&quot; + event);
159. switch (keyCode)
160. {
161. case KeyEvent.KEYCODE_DPAD_UP:
162.
163. break;
164. case KeyEvent.KEYCODE_DPAD_DOWN:
165.
166. break;
167. case KeyEvent.KEYCODE_DPAD_LEFT:
168. //右左按键可以控制第一进度的增减
169. pb.setProgress( pb.getProgress()-5 );
170. break;
171. case KeyEvent.KEYCODE_DPAD_RIGHT:
172. pb.setProgress( pb.getProgress()+5 );
173. break;
174. case KeyEvent.KEYCODE_DPAD_CENTER:
175.
176. break;
177. case KeyEvent.KEYCODE_0:
178. break;
179. }
180. return super.onKeyDown(keyCode, event);
181. }
182. }
155. @Override
156. public boolean onKeyDown(int keyCode, KeyEvent event)
157. {
158. Log.d(&quot;onKeyDown:&quot;, &quot; keyCode=&quot; + keyCode + &quot; KeyEvent=&quot; + event);
159. switch (keyCode)
160. {
161. case KeyEvent.KEYCODE_DPAD_UP:
162.
163. break;
164. case KeyEvent.KEYCODE_DPAD_DOWN:
165.
166. break;
167. case KeyEvent.KEYCODE_DPAD_LEFT:
168. //右左按键可以控制第一进度的增减
169. pb.setProgress( pb.getProgress()-5 );
170. break;
171. case KeyEvent.KEYCODE_DPAD_RIGHT:
172. pb.setProgress( pb.getProgress()+5 );
173. break;
174. case KeyEvent.KEYCODE_DPAD_CENTER:
175.
176. break;
177. case KeyEvent.KEYCODE_0:
178. break;
179. }
180. return super.onKeyDown(keyCode, event);
181. }
182. }
</code>
</RECORD>
<RECORD>
<snippet_key>397838</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Android 自定义横向的ProgressBar的颜色  http://blog.csdn.net/laotai909101/article/details/32150869#</comment>
<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;

&lt;!-- 这个是背景颜色 --&gt;
&lt;item android:id=&quot;@android:id/background&quot;&gt;
&lt;shape&gt;

&lt;!-- 这个是设置圆角还会直角，如果设置成0dip就是直角 --&gt;
&lt;corners android:radius=&quot;5dip&quot; /&gt;
&lt;!-- 设置背景的颜色，将startColor、centerColor、endColor都设置成同一个颜色值 --&gt;
&lt;!--
如果你不用颜色值也可以，可以直接用图片来代替，在item中添加这个属性就可以了，其他的不需要
android:drawable=&quot;@drawable/progressbar_bg&quot;
--&gt;
&lt;gradient
android:angle=&quot;270&quot;
android:centerColor=&quot;#a6e1ca&quot;
android:centerY=&quot;0.75&quot;
android:endColor=&quot;#a6e1ca&quot;
android:startColor=&quot;#a6e1ca&quot; /&gt;
&lt;/shape&gt;
&lt;/item&gt;
&lt;!-- 这个是第二进度条的颜色，没用到，大同小异 --&gt;
&lt;item android:id=&quot;@android:id/secondaryProgress&quot;&gt;
&lt;clip&gt;
&lt;shape&gt;
&lt;corners android:radius=&quot;5dip&quot; /&gt;

&lt;gradient
android:angle=&quot;270&quot;
android:centerColor=&quot;#80C07AB8&quot;
android:centerY=&quot;0.75&quot;
android:endColor=&quot;#a0C07AB8&quot;
android:startColor=&quot;#80C07AB8&quot; /&gt;
&lt;/shape&gt;
&lt;/clip&gt;
&lt;/item&gt;
&lt;!-- 这个是设置你进度的颜色 --&gt;
&lt;item android:id=&quot;@android:id/progress&quot;&gt;
&lt;clip&gt;
&lt;shape&gt;

&lt;!-- 这个也是设置时圆角还是直角，左边的 --&gt;
&lt;corners android:radius=&quot;5dip&quot; /&gt;
&lt;!-- 设置进度的颜色，将startColor、centerColor、endColor都设置成同一个颜色值 --&gt;
&lt;gradient
android:angle=&quot;270&quot;
android:centerColor=&quot;#65cea6&quot;
android:centerY=&quot;0.75&quot;
android:endColor=&quot;#65cea6&quot;
android:startColor=&quot;#65cea6&quot; /&gt;
&lt;/shape&gt;
&lt;/clip&gt;
&lt;/item&gt;

&lt;/layer-list&gt;
&lt;style name=&quot;progressBarHorizontal_color&quot; parent=&quot;android:Widget.ProgressBar.Horizontal&quot;&gt;
&lt;item name=&quot;android:indeterminateOnly&quot;&gt;false&lt;/item&gt;
&lt;!-- 这个属性就是配置进度的颜色和背景的颜色 --&gt;
&lt;item name=&quot;android:progressDrawable&quot;&gt;@drawable/progress_color_horizontal&lt;/item&gt;
&lt;item name=&quot;android:minHeight&quot;&gt;5dip&lt;/item&gt;
&lt;item name=&quot;android:maxHeight&quot;&gt;5dip&lt;/item&gt;
&lt;/style&gt;
&lt;ProgressBar
android:id=&quot;@+id/progress_horizontal_color&quot;
style=&quot;@style/progressBarHorizontal_color&quot;
android:layout_width=&quot;200dip&quot;
android:layout_height=&quot;10dip&quot;
android:indeterminate=&quot;true&quot;
android:layout_gravity=&quot;center_horizontal&quot;
android:layout_marginTop=&quot;20dip&quot;
android:max=&quot;200&quot;
android:progress=&quot;51&quot; /&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>136206</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：JavaSE_util+其他核心类  http://blog.csdn.net/u012576807/article/details/17714123#</comment>
<code>package uncommitted;
import java.util.Calendar;
public class CalendarDemo1 {
public static void main(String[] args) {
// Calendar
System.out.println();
method1();
}
public static void method5(int year) {
// 通过Calendar的add偏移字段,算出任意一年的2月有多少天!
Calendar c=Calendar.getInstance();
showDateTime(c);
//月份是从0算起的,2代表现实3月份
//设置日期为某一年的3月1日!
c.set(year, 2, 1);
showDateTime(c);
//将天数往前推1天即可!
c.add(Calendar.DAY_OF_MONTH, -1);
showDateTime(c);
}
public static void method4() {
// 通过Calendar的add偏移字段,算出任意一年的2月有多少天!
Calendar c=Calendar.getInstance();
showDateTime(c);
c.set(Calendar.YEAR, 2012);
c.set(Calendar.MONTH, 2);//月份是从0算起的,2代表现实3月份
c.set(Calendar.DAY_OF_MONTH, 1);//3月1号
c.add(Calendar.DAY_OF_MONTH, -1);//减去1天,就是2月XX日了!
showDateTime(c);
}
public static void method3() {
// Calendar通过set,设置日期,add偏移字段
Calendar c=Calendar.getInstance();
showDateTime(c);
c.set(Calendar.YEAR, 2013);
//月份增加9个月
c.add(Calendar.MONTH, 9);
showDateTime(c);
}
//自定义方法: 显示日期时间
public static void showDateTime(Calendar c) {
// Calendar通过get(字段),得到日期时间值,并显示!
// Calendar c=Calendar.getInstance();
int year=c.get(Calendar.YEAR);
int month=c.get(Calendar.MONTH);//0~11月
int day=c.get(Calendar.DAY_OF_MONTH);
int week=c.get(Calendar.DAY_OF_WEEK);
int hour=c.get(Calendar.HOUR_OF_DAY);
int minute=c.get(Calendar.MINUTE);
int second=c.get(Calendar.SECOND);
String week_str=toChineseWeek(week);
int CMonth=month+1;
sop(year+&quot;年&quot;+CMonth+&quot;月&quot;+day+&quot;日&quot;+week_str+&quot;,&quot;+hour+&quot;时&quot;+minute+&quot;分&quot;+second+&quot;秒&quot;);
}
//自定义方法: 显示中文的星期!
public static String toChineseWeek(int i) {
if(i&gt;7||i&lt;0){
return &quot;wrong number&quot;;
}
//老外从周日开始算第1天,所以周1就变成了第2天
String[] arr={&quot;&quot;,&quot;星期日&quot;,&quot;星期1&quot;,&quot;星期2&quot;,&quot;星期3&quot;,&quot;星期4&quot;,&quot;星期5&quot;,&quot;星期6&quot;};
return arr[i];
}


public static void method1() {
Calendar c=Calendar.getInstance();
sop(c+&quot;&quot;);//一大串信息
sop(c.get(Calendar.YEAR)+&quot;&quot;);
//2013
sop(c.get(Calendar.MONTH)+&quot;&quot;);
//0,代表的是1月....11代表12月
sop(c.get(Calendar.DAY_OF_MONTH)+&quot;&quot;);
//31日
sop(c.get(Calendar.DAY_OF_WEEK)+&quot;&quot;);
//3,老外从周日开始算1,所以周1就变成了2,周2就变成了3
sop(c.get(Calendar.HOUR_OF_DAY)+&quot;&quot;);//13点
sop(c.get(Calendar.MINUTE)+&quot;&quot;);//8分
sop(c.get(Calendar.SECOND)+&quot;&quot;);//22秒
//开始连接成字符串!
StringBuilder sb=new StringBuilder();
sb.append(c.get(Calendar.YEAR));
sb.append(c.get(Calendar.MONTH));
sb.append(c.get(Calendar.DAY_OF_MONTH));
sb.append(c.get(Calendar.HOUR_OF_DAY));
sb.append(c.get(Calendar.MINUTE));
sb.append(c.get(Calendar.SECOND));
sop(sb.toString());
//20131131 13822
}
//自定义方法:打印输出
public static void sop(String str) {
System.out.println(str);
}
}
/*java.util.GregorianCalendar
* [time=1167588947375,
* areFieldsSet=true,
* areAllFieldsSet=true,
* lenient=true,
zone=sun.util.calendar.ZoneInfo
[id=&quot;Asia/Shanghai&quot;,
offset=28800000,dstSavings=0,
useDaylight=false,
transitions=19,lastRule=null],
firstDayOfWeek=1,
minimalDaysInFirstWeek=1,ERA=1,
YEAR=2007,MONTH=0,
WEEK_OF_YEAR=1,
WEEK_OF_MONT
H=1,DAY_OF_MONTH=1,
DAY_OF_YEAR=1,DAY_OF_WEEK=2,
DAY_OF_WEEK_IN_MONTH=1,
AM_PM=0,HO
UR=2,HOUR_OF_DAY=2,MINUTE=15,
SECOND=47,MILLISECOND=375,
ZONE_OFFSET=28800000,DST_
OFFSET=0]*/
package uncommitted;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.junit.Test;
public class DateDemo1 {
//方法10:求两个日期的间隔的天数~
@Test
public void method10() throws ParseException {
// 2012-3-17到2012-4-6之间有多少天?
String s1=&quot;2012-3-17&quot;;
String s2=&quot;2012-4-6&quot;;
DateFormat d=DateFormat.getDateInstance();
// d=new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);两个都可以,千万注意大小写
Date d1=d.parse(s1);
Date d2=d.parse(s2);
Long l1=Math.abs(d1.getTime()-d2.getTime());
sop(l1/1000/60/60/24+&quot;&quot;);//20天!
}

//方法9:字符串 转 日期对象~
@Test
public void method9() throws ParseException {
String s1=&quot;2007年08月07日 星期一,北京时间01:56:15&quot;;
DateFormat d=DateFormat.getDateInstance();
d=new SimpleDateFormat(&quot;yyyy年MM月dd日 E,北京时间hh:mm:ss&quot;);
Date d1=d.parse(s1);
sop(d1+&quot;&quot;);//Tue Aug 07 01:56:15 CST 2007
}

//方法8: 字符串 转 日期对象
@Test
public void method8() throws ParseException {
String s1=&quot;2013-07-19&quot;;
DateFormat d=DateFormat.getDateInstance();
Date d1=d.parse(s1);
sop(d1+&quot;&quot;);//Fri Jul 19 00:00:00 CST 2013
}

//方法7: SimpleDateFormat自定义风格
@Test
public void method7() {
Date d1=new Date();
DateFormat d=new SimpleDateFormat(&quot;yyyy年MM月dd日 E,北京时间hh:mm:ss&quot;);
String s1=d.format(d1);
sop(s1);//2013年12月31日 星期二,北京时间01:27:42
}

//方法6: 给定风格
@Test
public void method6() {
Date d1=new Date();
DateFormat d=DateFormat.getDateTimeInstance(0, 0);
sop(d+&quot;&quot;);//java.text.SimpleDateFormat@535c7d7d
String s1=d.format(d1);
sop(s1);//2007年1月1日 星期一 上午01时29分42秒 CST
d=DateFormat.getDateTimeInstance(1,1);
s1=d.format(d1);
sop(s1);//2007年1月1日 上午01时31分11秒
d=DateFormat.getDateTimeInstance(2,2);
s1=d.format(d1);
sop(s1);//2007-1-1 1:32:40
d=DateFormat.getDateTimeInstance(0,1);
s1=d.format(d1);
sop(s1);//2007年1月1日 星期一 上午01时33分10秒
}

//方法5: 给定风格
@Test
public void method5() {
Date d1=new Date();
DateFormat d=DateFormat.getDateInstance(DateFormat.FULL);
String s1=d.format(d1);
sop(s1);//2007年1月1日 星期一
d=DateFormat.getDateInstance(DateFormat.LONG);
s1=d.format(d1);
sop(s1);//2007年1月1日
d=DateFormat.getDateInstance(DateFormat.MEDIUM);
s1=d.format(d1);
sop(s1);//2007-1-1
d=DateFormat.getDateInstance(DateFormat.SHORT);
s1=d.format(d1);
sop(s1);//07-1-1
}

//方法4: 静态方法获取日期+时间格式器
@Test
public void method4() {
Date d1=new Date();
DateFormat d=DateFormat.getDateTimeInstance();
String s1=d.format(d1);
sop(s1);//2007-1-1 1:24:55
}

//方法3: 静态方法获取日期格式器
@Test
public void method3() {
/*public static final DateFormat getDateInstance(int style)
获取日期格式器，该格式器具有默认语言环境的给定格式化风格*/
Date d1=new Date();
DateFormat d=DateFormat.getDateInstance();
String s1=d.format(d1);
sop(s1);//2007-1-1
}

//方法2: 打印毫秒值!Long 从1970年到现在的毫秒值~
@Test
public void method2() {
Date d1=new Date();
sop(d1.getTime()+&quot;&quot;);//1167585291640~1388467955578
sop(System.currentTimeMillis()+&quot;&quot;);//1388467955578
}

//方法1: 打印系统毫秒值!Long 从1970年到现在的毫秒值~
@Test
public void method1() {
long t1=System.currentTimeMillis();
sop(&quot;&quot;+t1);//1167584770515
Date d1=new Date();
sop(&quot;&quot;+d1);//Mon Jan 01 01:06:53 CST 2007
Date d2=new Date(1167584770515L);//注意这个是long要加L
sop(&quot;&quot;+d2);//Mon Jan 01 01:06:10 CST 2007
sop(d2.toString());//Mon Jan 01 01:06:10 CST 2007
}

//自定义打印输出~
public void sop(String str) {
System.out.println(str);
}
}
package uncommitted;
import java.util.Random;
import org.junit.Test;
public class MathDemo {
@Test
public void method6() {
/*public int nextInt(int n)返回一个伪随机数，
它是取自此随机数生成器序列的、
在 0（包括）和指定值（不包括）之间均匀分布的 int 值。*/
Random r=new Random();
for (int i = 0; i &lt; 10; i++) {
int d1=r.nextInt(6)+1;//0~5 +1 ---&gt; 色子1~6
sop(i+&quot;...&quot;+d1);
}
}
//色子1~6
@Test
public void method5() {
Random r=new Random();
for (int i = 0; i &lt; 10; i++) {
int d1=(int)(r.nextDouble()*6+1);//色子1~6
sop(i+&quot;...&quot;+d1);
}
}
@Test
public void method4() {
for (int i = 0; i &lt; 10; i++) {
// double d1=Math.random();//0&lt;=d1&lt;1
double d1=Math.floor(Math.random()*10);//0~9 向下取整
d1=Math.ceil(Math.random()*10);//1~10 向上取整
d1=Math.round(Math.random()*10);
//0~10 四舍五入 其实是加0.5后向下取整 (long)floor(a + 0.5d);
sop(i+&quot;...&quot;+d1);
}
}
@Test
public void method3() {
/*public static double random()返回带正号的 double 值，
该值大于等于 0.0 且小于 1.0。返回值是一个伪随机选择的数，
在该范围内（近似）均匀分布。
第一次调用该方法时，它将创建一个新的伪随机数生成器，
与以下表达式完全相同
new java.util.Random之后，
新的伪随机数生成器可用于此方法的所有调用
，但不能用于其他地方。*/
/*for (int i = 0; i &lt; 10; i++) {
double d1=Math.random();//0&lt;=d1&lt;1
sop(i+&quot;...&quot;+d1);
}*/
for (int i = 0; i &lt; 10; i++) {
// double d1=(int)(Math.random()*10);//
// int d1=(int)(Math.random()*6+1);//色子1~6
int d1=(int)(Math.random()*10);//3D 0~9
sop(i+&quot;...&quot;+d1);
}
}
//a的b次方
@Test
public void method2() {
double d1=Math.pow(10, 3);
sop(&quot;Math.pow(10, 3)---&gt;&quot;+d1);//---&gt;1000.0
}
@Test
public void method1() {
double d1=Math.ceil(11.3);
sop(&quot;11.3---&gt;ceil---&gt;&quot;+d1);
d1=Math.ceil(-11.3);
sop(&quot;-11.3---&gt;ceil---&gt;&quot;+d1);
d1=Math.floor(11.3);
sop(&quot;11.3---&gt;floor---&gt;&quot;+d1);
d1=Math.floor(-11.3);
sop(&quot;-11.3---&gt;floor---&gt;&quot;+d1);
sop(&quot;========= return (long)floor(a + 0.5d);=============&quot;);
// ========== return (long)floor(a + 0.5d);============
d1=Math.round(-11.4);
sop(&quot;-11.4---&gt;round---&gt;&quot;+d1);
d1=Math.round(-11.5);
sop(&quot;-11.5---&gt;round---&gt;&quot;+d1);
d1=Math.round(-11.51);
sop(&quot;-11.51---&gt;round---&gt;&quot;+d1);
d1=Math.round(-11.6);
sop(&quot;-11.6---&gt;round---&gt;&quot;+d1);
/*
11.3---&gt;ceil---&gt;12.0
-11.3---&gt;ceil---&gt;-11.0
11.3---&gt;floor---&gt;11.0
-11.3---&gt;floor---&gt;-12.0
========= return (long)floor(a + 0.5d);=============
-11.4---&gt;round---&gt;-11.0
-11.5---&gt;round---&gt;-11.0
-11.51---&gt;round---&gt;-12.0
-11.6---&gt;round---&gt;-12.0
*/
}
//自定义打印方法
public void sop(String str) {
System.out.println(str);
}

}
package uncommitted;
import java.io.IOException;
import org.junit.Test;
public class RuntimeDemo {
@Test
public void method3() throws IOException, InterruptedException {
Runtime r=Runtime.getRuntime();
Process p=r.exec(&quot;notepad.exe c:\\abc.txt&quot;);
//高级应用,用记事本打开txt,不存在会询问是否创建~
Thread.sleep(3000);
//控制自动结束进程
p.destroy();
}
@Test
public void method2() {
//打印虚拟机 的内存 默认64M,可以手动更改~
//右键 Run As~Open Debug Dialog~Args~-Xmx80M
//-Xmx 这个参数是设定使用的最大内存
//-Xms 这个参数是设定使用的最小内存
//同样，通过eclipse设置来修改此参数：
//Window-&gt;Preferences-&gt;Java-&gt;Installed JREs 双击jre，-Xmx80M
Runtime r=Runtime.getRuntime();
System.out.println(r.maxMemory()/1024/1024);//byte--&gt;M
System.out.println(r.freeMemory()/1024/1024);//byte--&gt;M
System.out.println(r.totalMemory()/1024/1024);//byte--&gt;M
}


public void method1() throws IOException {
// Runtime去使用程序打开关联的文件
Runtime r=Runtime.getRuntime();
// r.exec(&quot;notepad.exe&quot;);
// r.exec(&quot;calc.exe&quot;);
//r.exec(&quot;shutdown -s -t 60&quot;);//单位是秒
r.exec(&quot;shutdown -a&quot;);//取消
r.exec(&quot;notepad.exe c:\\abc.java&quot;);//高级应用,用纪事本打开java
}
}
package uncommitted;
import java.util.Iterator;
import java.util.Properties;
import java.util.Set;

import org.junit.Test;
public class SystemDemo1 {
static final String LINE_SEPARATOR=System.getProperty(&quot;line.separator&quot;);
@Test
public void method4() {
// 实例:行分割符!
String l_s=System.getProperty(&quot;line.separator&quot;);
System.out.println(&quot;林黛玉&quot;+l_s+&quot;薛宝钗&quot;);
}
public void method3() {
// 用新的增强for取Hashtable的子类Properties的键值对
Properties prop=System.getProperties();
// static Properties getProperties()
// 确定当前的系统属性。
for (String key : prop.stringPropertyNames()) {
String value=prop.getProperty(key);
System.out.println(key+&quot;...&quot;+value);
}
}
public void method2() {
// 用旧的迭代器取Hashtable的子类Properties的键值对
/* public Set&lt;String&gt; stringPropertyNames()
* JDK 1.6才有
返回此属性列表中的键集，
其中该键及其对应值是字符串，
如果在主属性列表中未找到同名的键，
则还包括默认属性列表中不同的键。
其键或值不是 String 类型的属性被忽略。
*/ Properties prop=System.getProperties();
Set&lt;String&gt; nameSet=prop.stringPropertyNames();
Iterator&lt;String&gt; it=nameSet.iterator();
while (it.hasNext()) {
String key = (String) it.next();
String value=prop.getProperty(key);
System.out.println(key+&quot;...&quot;+value);
}
}
@Test
public void method1() {
//返回1970年以来的毫秒值
System.out.println(System.currentTimeMillis());//1388470040796
}
}
/*
* 键 相关值的描述
java.version Java 运行时环境版本
java.vendor Java 运行时环境供应商
java.vendor.url Java 供应商的 URL
java.home Java 安装目录
java.vm.specification.version Java 虚拟机规范版本
java.vm.specification.vendor Java 虚拟机规范供应商
java.vm.specification.name Java 虚拟机规范名称
java.vm.version Java 虚拟机实现版本
java.vm.vendor Java 虚拟机实现供应商
java.vm.name Java 虚拟机实现名称
java.specification.version Java 运行时环境规范版本
java.specification.vendor Java 运行时环境规范供应商
java.specification.name Java 运行时环境规范名称
java.class.version Java 类格式版本号
java.class.path Java 类路径
java.library.path 加载库时搜索的路径列表
java.io.tmpdir 默认的临时文件路径
java.compiler 要使用的 JIT 编译器的名称
java.ext.dirs 一个或多个扩展目录的路径
os.name 操作系统的名称
os.arch 操作系统的架构
os.version 操作系统的版本
file.separator 文件分隔符（在 UNIX 系统中是“/”）
path.separator 路径分隔符（在 UNIX 系统中是“:”）
line.separator 行分隔符（在 UNIX 系统中是“/n”）
user.name 用户的账户名称
user.home 用户的主目录
user.dir 用户的当前工作目录
*/
/*
java.runtime.name...Java(TM) SE Runtime Environment
sun.boot.library.path...D:\Program Files\Java\jdk1.7.0_01\jre\bin
java.vm.version...21.1-b02
java.vm.vendor...Oracle Corporation
java.vendor.url...http://java.oracle.com/
path.separator...;
java.vm.name...Java HotSpot(TM) Client VM
file.encoding.pkg...sun.io
user.script...
sun.java.launcher...SUN_STANDARD
sun.os.patch.level...Service Pack 3
java.vm.specification.name...Java Virtual Machine Specification
user.dir...E:\javase\ework\source_code
java.runtime.version...1.7.0_01-b08
java.awt.graphicsenv...sun.awt.Win32GraphicsEnvironment
java.endorsed.dirs...D:\Program Files\Java\jdk1.7.0_01\jre\lib\endorsed
os.arch...x86
java.io.tmpdir...C:\DOCUME~1\ADMINI~1\LOCALS~1\Temp\
line.separator...

java.vm.specification.vendor...Oracle Corporation
user.variant...
os.name...Windows XP
sun.jnu.encoding...GBK
java.library.path...D:\Program Files\Java\jdk1.7.0_01\bin;C:\WINDOWS\Sun\Java\bi
n;C:\WINDOWS\system32;C:\WINDOWS;D:\Program Files\Java\jdk1.7.0_01\jre\bin;D:/Pr
ogram Files/Java/jdk1.7.0_01/bin/../jre/bin/client;D:/Program Files/Java/jdk1.7.
0_01/bin/../jre/bin;D:/Program Files/Java/jdk1.7.0_01/bin/../jre/lib/i386;D:\Pro
gram Files\Java\jdk1.7.0_01\bin;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System
32\Wbem;C:\Program Files\Common Files\Thunder Network\KanKan\Codecs;E:\javase\ec
lipse-java-kepler-SR1-win32\eclipse;;.
java.specification.name...Java Platform API Specification
java.class.version...51.0
sun.management.compiler...HotSpot Client Compiler
os.version...5.1
user.home...C:\Documents and Settings\Administrator
user.timezone...
java.awt.printerjob...sun.awt.windows.WPrinterJob
file.encoding...GBK
java.specification.version...1.7
user.name...Administrator
java.class.path...E:\javase\ework\source_code\bin
java.vm.specification.version...1.7
sun.arch.data.model...32
java.home...D:\Program Files\Java\jdk1.7.0_01\jre
sun.java.command...source_code.SystemDemo1
java.specification.vendor...Oracle Corporation
user.language...zh
awt.toolkit...sun.awt.windows.WToolkit
java.vm.info...mixed mode
java.version...1.7.0_01
java.ext.dirs...D:\Program Files\Java\jdk1.7.0_01\jre\lib\ext;C:\WINDOWS\Sun\Jav
a\lib\ext
sun.boot.class.path...D:\Program Files\Java\jdk1.7.0_01\jre\lib\resources.jar;D:
\Program Files\Java\jdk1.7.0_01\jre\lib\rt.jar;D:\Program Files\Java\jdk1.7.0_01
\jre\lib\sunrsasign.jar;D:\Program Files\Java\jdk1.7.0_01\jre\lib\jsse.jar;D:\Pr
ogram Files\Java\jdk1.7.0_01\jre\lib\jce.jar;D:\Program Files\Java\jdk1.7.0_01\j
re\lib\charsets.jar;D:\Program Files\Java\jdk1.7.0_01\jre\classes
java.vendor...Oracle Corporation
file.separator...\
java.vendor.url.bug...http://bugreport.sun.com/bugreport/
sun.cpu.endian...little
sun.io.unicode.encoding...UnicodeLittle
sun.desktop...windows
sun.cpu.isalist...
*/
</code>
</RECORD>
<RECORD>
<snippet_key>398350</snippet_key>
<tag></tag>
<comment>来自CSDN博客：自定义 SwitchButton http://blog.csdn.net/wangchunshun/article/details/32310941#</comment>
<code>public class SwitchButton extends CheckBox {
private Paint mPaint;

private ViewParent mParent;

private Bitmap mBottom,bu;

private Bitmap mCurBtnPic;

private Bitmap mBtnPressed;

private Bitmap mBtnNormal;

private Bitmap mFrame;

private Bitmap mMask;

private RectF mSaveLayerRectF;

private PorterDuffXfermode mXfermode;

private float mFirstDownY; // 首次按下的Y

private float mFirstDownX; // 首次按下的X

private float mRealPos; // 图片的绘制位置

private float mBtnPos; // 按钮的位置

public static float mBtnOnPos; // 开关打开的位置

public static float mBtnOffPos; // 开关关闭的位置

private float mMaskWidth;

private float mMaskHeight;

private float mBtnWidth;

private float mBtnInitPos;

private int mClickTimeout;

private int mTouchSlop;

private final int MAX_ALPHA = 255;

private int mAlpha = MAX_ALPHA;

private boolean mChecked = false;

private boolean mBroadcasting;

private boolean mTurningOn;

private PerformClick mPerformClick;

private OnCheckedChangeListener mOnCheckedChangeListener;

private OnCheckedChangeListener mOnCheckedChangeWidgetListener;

private boolean mAnimating;

private final float VELOCITY = 350;

private float mVelocity;

private final float EXTENDED_OFFSET_Y = 15;

private float mExtendOffsetY; // Y轴方向扩大的区域,增大点击区域

private float mAnimationPosition;

private float mAnimatedVelocity;

public SwitchButton(Context context, AttributeSet attrs) {
this(context, attrs, android.R.attr.checkboxStyle);
}

public SwitchButton(Context context) {
this(context, null);
}

public SwitchButton(Context context, AttributeSet attrs, int defStyle) {
super(context, attrs, defStyle);
initView(context);
}

private void initView(Context context) {
mPaint = new Paint();
mPaint.setColor(Color.WHITE);
Resources resources = context.getResources();

// get viewConfiguration
mClickTimeout = ViewConfiguration.getPressedStateDuration()
+ ViewConfiguration.getTapTimeout();
mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();

// get Bitmap
mBottom = BitmapFactory.decodeResource(resources, R.drawable.publish_bottom_zh);
mBtnPressed = BitmapFactory.decodeResource(resources, R.drawable.publish__pressed);
mBtnNormal = BitmapFactory.decodeResource(resources, R.drawable.publish_btn_unpressed);
mFrame = BitmapFactory.decodeResource(resources, R.drawable.publish_frame);
mMask = BitmapFactory.decodeResource(resources, R.drawable.publish_mask);
mCurBtnPic = mBtnNormal;

mBtnWidth = mBtnPressed.getWidth();
mMaskWidth = mMask.getWidth();
mMaskHeight = mMask.getHeight();

mBtnOffPos = mBtnWidth / 2;
mBtnOnPos = mMaskWidth - mBtnWidth / 2;

mBtnPos = mChecked ? mBtnOnPos : mBtnOffPos;
mRealPos = getRealPos(mBtnPos);

final float density = getResources().getDisplayMetrics().density;
mVelocity = (int) (VELOCITY * density + 0.5f);
mExtendOffsetY = (int) (EXTENDED_OFFSET_Y * density + 0.5f);

mSaveLayerRectF = new RectF(0, mExtendOffsetY, mMask.getWidth(), mMask.getHeight()
+ mExtendOffsetY);
mXfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_IN);
}

@Override
public void setEnabled(boolean enabled) {
mAlpha = enabled ? MAX_ALPHA : MAX_ALPHA / 2;
super.setEnabled(enabled);
}

public boolean isChecked() {
return mChecked;
}

public void toggle() {
setChecked(!mChecked);
}

/**
* 内部调用此方法设置checked状态，此方法会延迟执行各种回调函数，保证动画的流畅度
*
* @param checked
*/
private void setCheckedDelayed(final boolean checked) {
this.postDelayed(new Runnable() {

@Override
public void run() {
setChecked(checked);
}
}, 10);
}

/**
* &lt;p&gt;
* Changes the checked state of this button.
* &lt;/p&gt;
*
* @param checked true to check the button, false to uncheck it
*/
public void setChecked(boolean checked) {

if (mChecked != checked) {
mChecked = checked;

mBtnPos = checked ? mBtnOnPos : mBtnOffPos;
mRealPos = getRealPos(mBtnPos);
invalidate();

// Avoid infinite recursions if setChecked() is called from a
// listener
if (mBroadcasting) {
return;
}

mBroadcasting = true;
if (mOnCheckedChangeListener != null) {
mOnCheckedChangeListener.onCheckedChanged(SwitchButton.this, mChecked);
}
if (mOnCheckedChangeWidgetListener != null) {
mOnCheckedChangeWidgetListener.onCheckedChanged(SwitchButton.this, mChecked);
}

mBroadcasting = false;
}
}

/**
* Register a callback to be invoked when the checked state of this button
* changes.
*
* @param listener the callback to call on checked state change
*/
public void setOnCheckedChangeListener(OnCheckedChangeListener listener) {
mOnCheckedChangeListener = listener;
}

/**
* Register a callback to be invoked when the checked state of this button
* changes. This callback is used for internal purpose only.
*
* @param listener the callback to call on checked state change
* @hide
*/
void setOnCheckedChangeWidgetListener(OnCheckedChangeListener listener) {
mOnCheckedChangeWidgetListener = listener;
}

@Override
public boolean onTouchEvent(MotionEvent event) {
int action = event.getAction();
float x = event.getX();
float y = event.getY();
float deltaX = Math.abs(x - mFirstDownX);
float deltaY = Math.abs(y - mFirstDownY);
switch (action) {
case MotionEvent.ACTION_DOWN:
attemptClaimDrag();
mFirstDownX = x;
mFirstDownY = y;
mCurBtnPic = mBtnPressed;
mBtnInitPos = mChecked ? mBtnOnPos : mBtnOffPos;
break;
case MotionEvent.ACTION_MOVE:
float time = event.getEventTime() - event.getDownTime();
mBtnPos = mBtnInitPos + event.getX() - mFirstDownX;
if (mBtnPos &gt;= mBtnOffPos) {
mBtnPos = mBtnOffPos;
}
if (mBtnPos &lt;= mBtnOnPos) {
mBtnPos = mBtnOnPos;
}
mTurningOn = mBtnPos &gt; (mBtnOffPos - mBtnOnPos) / 2 + mBtnOnPos;
//判断状态
//Log.e(&quot;判断状态&quot;, mTurningOn+&quot;&quot;);
mRealPos = getRealPos(mBtnPos);
//Log.e(&quot;mRealPos&quot;, mRealPos+&quot;&quot;);

break;
case MotionEvent.ACTION_UP:
mCurBtnPic = mBtnNormal;
time = event.getEventTime() - event.getDownTime();
if (deltaY &lt; mTouchSlop &amp;&amp; deltaX &lt; mTouchSlop &amp;&amp; time &lt; mClickTimeout) {
if (mPerformClick == null) {
mPerformClick = new PerformClick();
}
if (!post(mPerformClick)) {
performClick();
}
} else {
startAnimation(!mTurningOn);
}
break;
}

invalidate();
return isEnabled();
}

private final class PerformClick implements Runnable {
public void run() {
performClick();
}
}

@Override
public boolean performClick() {
startAnimation(!mChecked);
return true;
}

/**
* Tries to claim the user&apos;s drag motion, and requests disallowing any
* ancestors from stealing events in the drag.
*/
private void attemptClaimDrag() {
mParent = getParent();
if (mParent != null) {
mParent.requestDisallowInterceptTouchEvent(true);
}
}

/**
* 将btnPos转换成RealPos
*
* @param btnPos
* @return
*/
private float getRealPos(float btnPos) {
return btnPos - mBtnWidth / 2;
}

@Override
protected void onDraw(Canvas canvas) {
canvas.saveLayerAlpha(mSaveLayerRectF, mAlpha, Canvas.MATRIX_SAVE_FLAG
| Canvas.CLIP_SAVE_FLAG | Canvas.HAS_ALPHA_LAYER_SAVE_FLAG
| Canvas.FULL_COLOR_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
// 绘制蒙板
canvas.drawBitmap(mMask, 0, mExtendOffsetY, mPaint);
mPaint.setXfermode(mXfermode);

// 绘制底部图片
canvas.drawBitmap(mBottom, mRealPos, mExtendOffsetY, mPaint);
mPaint.setXfermode(null);
// 绘制边框
canvas.drawBitmap(mFrame, 0, mExtendOffsetY, mPaint);

// 绘制按钮
canvas.drawBitmap(mCurBtnPic, mRealPos, mExtendOffsetY, mPaint);
canvas.restore();
}

@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
setMeasuredDimension((int) mMaskWidth, (int) (mMaskHeight + 2 * mExtendOffsetY));
}

private void startAnimation(boolean turnOn) {
mAnimating = true;
mAnimatedVelocity = turnOn ? -mVelocity : mVelocity;
mAnimationPosition = mBtnPos;

new SwitchAnimation().run();
}

private void stopAnimation() {
mAnimating = false;
}

private final class SwitchAnimation implements Runnable {

@Override
public void run() {
if (!mAnimating) {
return;
}
doAnimation();
FrameAnimationController.requestAnimationFrame(this);
}
}

private void doAnimation() {
mAnimationPosition += mAnimatedVelocity * FrameAnimationController.ANIMATION_FRAME_DURATION
/ 1000;
if (mAnimationPosition &lt;= mBtnOnPos) {
stopAnimation();
mAnimationPosition = mBtnOnPos;
setCheckedDelayed(true);
} else if (mAnimationPosition &gt;= mBtnOffPos) {
stopAnimation();
mAnimationPosition = mBtnOffPos;
setCheckedDelayed(false);
}
moveView(mAnimationPosition);
}

private void moveView(float position) {
mBtnPos = position;
mRealPos = getRealPos(mBtnPos);
//Log.e(&quot;mRealPos-------&quot;, mRealPos+&quot;&quot;);
invalidate();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>201998</snippet_key>
<tag>java 加密 解密</tag>
<comment>来自CSDN博客：运用异或运算符实现加密  http://blog.csdn.net/Jerry_1126/article/details/19821901#</comment>
<code>import java.util.Scanner;
public class Encypt {
public static void main(String args[]){
Scanner scan = new Scanner(System.in);
System.out.println(&quot;请输入一个英文字符串或解密字符串:&quot;);
String password = scan.nextLine(); //获取用户输入
char[] array = password.toCharArray(); //获取字符数组
for(int i=0;i&lt;array.length;i++) //遍历字符数组
{
array[i]=(char)(array[i]^20000); //对每个数组元素进行异或运算
}
System.out.println(&quot;加密或解密结果如下:&quot;);
System.out.println(new String(array));
}
}
请输入一个英文字符串或解密字符串:
www.sohu.com
加密或解密结果如下:
乗乗乗与乓乏么乕与乃乏乍
</code>
</RECORD>
<RECORD>
<snippet_key>464142</snippet_key>
<tag>184,327</tag>
<comment>来自CSDN博客：Java多线程生成测试文件 http://blog.csdn.net/earbao/article/details/39050235#</comment>
<code>import java.io.File;
import java.io.FileInputStream;


import java.io.FileOutputStream;

import org.boris.expr.Expr;
import org.boris.expr.ExprEvaluatable;
import org.boris.expr.parser.ExprParser;
import org.boris.expr.util.Exprs;
import org.boris.expr.util.SimpleEvaluationContext;
//使用到了expr
//http://nchc.dl.sourceforge.net/project/expr4j/expr4j/0.0.1/expr4j-0.0.1.zip
//多线程生成测试文件
public class TestData {

public static void main(String[] args) {

if (args.length != 3) {
System.out.println(&quot;Usage: inputFile size(M)/Expr threads&quot;);
//java -jar testData.jar data5g\明辉购房笔记.TXT 1024*5 15
return;
}
File inputFile = new File(args[0]);
if(!inputFile.exists())
{
System.out.println(&quot;源文件不存在&quot;);

return;
}
Expr expr = null;
try {
expr = ExprParser.parse(args[1]);
Exprs.toUpperCase(expr);
if (expr instanceof ExprEvaluatable) {
expr = ((ExprEvaluatable) expr).evaluate(new SimpleEvaluationContext());
}
System.out.println(&quot;表达式计算结果：&quot;+expr);
} catch (Exception e) {
e.printStackTrace();
return ;
}

long size = (long) (1024 * Double.parseDouble(expr.toString()));// m
long fileSize = inputFile.length() / 1024;
int threads = Integer.parseInt(args[2]);

long filecount = size / fileSize;
long parts = filecount / threads;// 每个线程生成的文件数目
Thread[] mythreads=new MyThread[threads];
for (int i = 0; i &lt; threads; i++) {
mythreads[i] = new MyThread(i+1, i * parts, (i + 1) * parts,inputFile);
mythreads[i].start();
}
while(true)
{
boolean isAllFinish=true;
for (Thread thread : mythreads) {
if(thread.isAlive())
{
isAllFinish=false;
}
}
if(isAllFinish)
{
System.out.println(&quot;全部执行完成&quot;);
break;
}
}

}

static class MyThread extends Thread {

private int id;
private long startIndex;
private long endIndex;
private File inputFile;
//private boolean isFinish=false;

public MyThread(){}

public MyThread(int i, long l, long m, File inputFile) {
this.id = i;
this.startIndex = l;
this.endIndex = m;
this.inputFile = inputFile;
}

@Override
public void run() {

try {
System.out.println(&quot;线程&quot;+id+&quot;启动&quot;);
for (long i = startIndex; i &lt; endIndex; i++) {
copyFile(inputFile, new File(inputFile.getParent(), (i+1)+ inputFile.getName()));
}
//isFinish=true;
System.out.println(&quot;线程&quot;+id+&quot;执行完成&quot;);
} catch (Exception e) {
e.printStackTrace();
}
super.run();
}

}

private static void copyFile(File inputfile, File outputFile)
throws Exception {

FileInputStream fileInputStream = new FileInputStream(inputfile);
FileOutputStream fileOutputStream = new FileOutputStream(outputFile);
byte[] buffer = new byte[1024];
int len = 0;
while ((len = fileInputStream.read(buffer)) != -1) {
fileOutputStream.write(buffer, 0, len);
}
fileOutputStream.flush();
fileOutputStream.close();
fileInputStream.close();

}
}
</code>
</RECORD>
<RECORD>
<snippet_key>136718</snippet_key>
<tag>java</tag>
<comment>来自CSDN博客：java动态代理实现  http://blog.csdn.net/xia562653223/article/details/17719155#</comment>
<code>public interface Action {
void move(String name);
void stop();
}
public class ActionImpl implements Action {

@Override
public void move(String name) {
System.out.println(&quot;moving &quot; + name);
}

@Override
public void stop() {
System.out.println(&quot;stop&quot;);
}


}
public class LogHandler implements InvocationHandler {

private Object target;

public LogHandler(Object target) {
super();
this.target = target;
}

@Override
public Object invoke(Object proxy, Method method, Object[] args)
throws Throwable {
System.out.println(method.getName() + &quot;: log start&quot;);
method.invoke(target, args);
System.out.println(method.getName() + &quot;: log end&quot;);
return null;
}

}
&lt;pre code_snippet_id=&quot;136718&quot; snippet_file_name=&quot;blog_20131231_4_3385792&quot;&gt;
}
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;
public class Client {
&lt;span style=&quot;white-space:pre&quot;&gt; public static void main(String[] args) {&lt;/span&gt;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;getAction(new ActionImpl()).move(&quot;car2&quot;);
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}
&lt;pre code_snippet_id=&quot;136718&quot; snippet_file_name=&quot;blog_20131231_11_5698276&quot; name=&quot;code&quot; class=&quot;java&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;public static Action getAction(final Action a) {
return (Action)Proxy.newProxyInstance(a.getClass().getClassLoader(), a.getClass().getInterfaces(),
new InvocationHandler() {

@Override
public Object invoke(Object proxy, Method method, Object[] args)
throws Throwable {
System.out.println(method.getName() + &quot;: log start&quot;);
method.invoke(a, args);
System.out.println(method.getName() + &quot;: log end&quot;);
return null;
}
});
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;public static Action getAction(final Action a) {
return (Action)Proxy.newProxyInstance(a.getClass().getClassLoader(), a.getClass().getInterfaces(),
new InvocationHandler() {

@Override
public Object invoke(Object proxy, Method method, Object[] args)
throws Throwable {
System.out.println(method.getName() + &quot;: log start&quot;);
method.invoke(a, args);
System.out.println(method.getName() + &quot;: log end&quot;);
return null;
}
});
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}
}
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;proxy.stop();
}
}
public class Client {
public static void main(String[] args) {
Action a = new ActionImpl();
InvocationHandler h = new LogHandler(a);
Action proxy = (Action)Proxy.newProxyInstance(a.getClass().getClassLoader(), a.getClass().getInterfaces(), h);
proxy.move(&quot;car&quot;);
proxy.stop();
}
}
public class Client {
public static void main(String[] args) {
getAction(new ActionImpl()).move(&quot;car2&quot;);
}
public static Action getAction(final Action a) {
return (Action)Proxy.newProxyInstance(a.getClass().getClassLoader(), a.getClass().getInterfaces(),
new InvocationHandler() {

@Override
public Object invoke(Object proxy, Method method, Object[] args)
throws Throwable {
System.out.println(method.getName() + &quot;: log start&quot;);
method.invoke(a, args);
System.out.println(method.getName() + &quot;: log end&quot;);
return null;
}
});
}
}
public class Client {
public static void main(String[] args) {
getAction(new ActionImpl()).move(&quot;car2&quot;);
}
public static Action getAction(final Action a) {
return (Action)Proxy.newProxyInstance(a.getClass().getClassLoader(), a.getClass().getInterfaces(),
new InvocationHandler() {

@Override
public Object invoke(Object proxy, Method method, Object[] args)
throws Throwable {
System.out.println(method.getName() + &quot;: log start&quot;);
method.invoke(a, args);
System.out.println(method.getName() + &quot;: log end&quot;);
return null;
}
});
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>202254</snippet_key>
<tag>android csdn google apk frameworks</tag>
<comment>来自CSDN博客：Android 长按电源键和短按电源键的详细处理流程  http://blog.csdn.net/luckkof/article/details/19829341#</comment>
<code>private final Runnable mPowerLongPress = new Runnable() {
public void run() {
// The context isn&apos;t read
if (mLongPressOnPowerBehavior &lt; 0) {
mLongPressOnPowerBehavior = mContext.getResources().getInteger(
com.android.internal.R.integer.config_longPressOnPowerBehavior);
}
switch (mLongPressOnPowerBehavior) {
case LONG_PRESS_POWER_NOTHING:
break;
case LONG_PRESS_POWER_GLOBAL_ACTIONS:
mPowerKeyHandled = true;
performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);
showGlobalActionsDialog();
break;
case LONG_PRESS_POWER_SHUT_OFF:
mPowerKeyHandled = true;
performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);
ShutdownThread.shutdown(mContext, true);
break;
}
}
};
case KeyEvent.KEYCODE_POWER: {
result &amp;= ~ACTION_PASS_TO_USER;
if (down) {
if (isScreenOn &amp;&amp; !mPowerKeyTriggered
&amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) {
mPowerKeyTriggered = true;
mPowerKeyTime = event.getDownTime();
interceptScreenshotChord();
}

...
// Power Key down, set mPowerLongPress executing after 500ms
interceptPowerKeyDown(!isScreenOn || hungUp
|| mVolumeDownKeyTriggered || mVolumeUpKeyTriggered);
} else {
mPowerKeyTriggered = false;
cancelPendingScreenshotChordAction();
if (interceptPowerKeyUp(canceled || mPendingPowerKeyUpCanceled)) {
result = (result &amp; ~ACTION_POKE_USER_ACTIVITY) | ACTION_GO_TO_SLEEP;
}
// Power key up, remove the mPowerLongPress, that is, if user release
// power key during 500ms, mPowerLongPress will not be execute, then execute sleep
mPendingPowerKeyUpCanceled = false;
}
break;
}
private void interceptPowerKeyDown(boolean handled) {
mPowerKeyHandled = handled;
if (!handled) {
mHandler.postDelayed(mPowerLongPress, ViewConfiguration.getGlobalActionKeyTimeout()/*500ms*/);
}
}

private boolean interceptPowerKeyUp(boolean canceled) {
if (!mPowerKeyHandled) {
mHandler.removeCallbacks(mPowerLongPress);
return !canceled;
}
return false;
}
</code>
</RECORD>
<RECORD>
<snippet_key>282885</snippet_key>
<tag>5</tag>
<comment>来自CSDN博客：黑马程序员_面向对象（上）  http://blog.csdn.net/a254830856/article/details/22977615#</comment>
<code>/**
成员变量和局部变量
*/
class Demo
{
public static void main(String[] args)
{
Car c = new Car();
c.num = 4;
c.run(&quot;红色&quot;);
}
}
class Car
{
static int num;//num是成员变量
public static void run(String color)//方法里的color是局部变量
{
System.out.println(num+&quot;轮&quot;+color+&quot;车跑了&quot;);
}
}
class Bike
{
int num = 2;
String color = &quot;red&quot;;
public void go()
{
System.out.println(&quot;This bike is...&quot;+color+&quot;...&quot;+num);
}
}
class BikeDemo
{
public static void main(String[] args)
{
//Bike b = new Bike();
//b.go();
new Bike().go();//匿名对象调用所属类中定义的方法
fix(new Bike());//匿名对象作为参数进行传递
}
public static void fix(Bike b)
{
b.num = 3;
b.color = &quot;black&quot;;
b.go();
}
}
class Bike
{
private int num = 2;//成员变量num被私有后，只能在本类中被调用
String color = &quot;red&quot;;
public void go()//该方法被权限最大的public修饰，是对外提供的公共访问方式，外部类中的对象可以通过此方法来访问这个类
{
System.out.println(&quot;This bike is...&quot;+color+&quot;...&quot;+num);
}
}
class BikeDemo
{
public static void main(String[] args)
{
//Bike b = new Bike();
//b.go();
new Bike().go();
fix(new Bike());
}
public static void fix(Bike b)
{
b.num = 3;//因为num被私有了，所以这句会报错
b.color = &quot;black&quot;;
b.go();
}
}
class Person
{
private String name;
private int age;
//Person(){}默认的空参数构造函数，如果定义了构造函数，那么这个构造函数就消失了
public Person()//构造函数,无返回值类型，和类名相同（包括大小写）
{
String name =&quot;zhangsan&quot;;
int age = 24;
System.out.println(&quot;name:&quot;+name+&quot;...age:&quot;+age);
}
}
class PersonDemo
{
public static void main(String[] args)
{
new Person();
}
}
class Person
{
String name;
int age;
public Person()//构造函数
{
String name = &quot;zhangsan&quot;;
age = 77;
System.out.println(name+&quot;...&quot;+age);
}
}
class Funtion
{
public static void main(String[] args)
{
Person p = new Person();//对象一建立就执行构造函数
fix(&quot;lisi&quot;,23);
}
public static void fix(String name,int age)//一般函数，调用时，此函数运行，否则不执行
{
System.out.println(name+&quot;...&quot;+age);
}
}
class Person
{
{
System.out.println(&quot;这是构造代码块&quot;);
}
private String name;
Person(String name)
{
System.out.println(&quot;这是&quot;+name+&quot;的构造函数&quot;);
}
}

class CodeBlock
{
public static void main(String[] args)
{
Person p1 = new Person(&quot;zhangsan&quot;);
Person p2 = new Person(&quot;lisi&quot;);
}
}
/**
this关键字的应用
需求：
初始化一个对象
修改对象中的参数，
输出修改后对象的信息
*/
class Person
{
private String name =&quot;lisi&quot;;
private int age = 23;
Person()
{
this.name = name;
this.age = age;
System.out.println(&quot;name:&quot;+name+&quot;...age&quot;+age);
}
void setName(String name)
{
this.name = name;//p2调用setName方法，this就等同于this,这句话可以写成p2.name = name;
System.out.println(&quot;name:&quot;+name);
}
void setAge(int age)
{
this.age = age;
System.out.println(&quot;age:&quot;+age);
}
void info(String name,int age)
{
System.out.println(&quot;name:&quot;+name+&quot;...age:&quot;+age);
}
public String toString()
{
return (&quot;name:&quot;+name+&quot;...age:&quot;+age);
}

}
class ThisKeyWord1
{
public static void main(String[] args)
{
//p1和p2的默认初始化值相同都是：lisi,23
Person p1 = new Person();
Person p2 = new Person();
//p2经过以下代码的修改后
p2.setName(&quot;zhangsan&quot;);
p2.setAge(23);
//p2输出一个全新的值
System.out.println(p2.toString());
}
}
/**
静态应用
当对象中出现共享数据时，该数据被静态所修饰
对象中的特有数据要定义成非静态存在于堆内存中
*/
class Person
{
private String name;
private int age;
private static String country = &quot;cn&quot;;//共享数据
Person(String name,int age)
{
this.name = name;
this.age = age;
}
public void setName(String name)
{
this.name = name;
Person.show();
}
public static void show()//特有数据
{
System.out.println(&quot;good name&quot;);
}
}
class StaticDemo
{
public static void main(String[] args)
{
Person p = new Person(&quot;ok&quot;,50);
p.setName(&quot;lisi&quot;);
}
}
/**
对象中成员的调用过程
*/
class Student
{
private Student(){};
private String name;
private int age;
private static String school = &quot;middle school&quot;;
Student(String name,int age)
{
this.name = name;
this.age = age;
}
public void setName(String name)
{
this.name = name;
}
public String toString()//输出对象的自我描述信息
{
return &quot;name:&quot;+name+&quot;...age:&quot;+age;
}
}
class StudentDemo
{
public static void main(String[] args)
{
Student s = new Student(&quot;zhangsan&quot;,11);
s.setName(&quot;lisi&quot;);
System.out.println(s.toString());
}
}
class Single
{


private Single(){};

private static Single s = new Single();

public static Single getInstance()
{
return s;
}
}
class SingleDemo
{
public static void main(String[] args)
{
Single s1 = Single.getInstance();
Single s2 = Single.getInstance();
}
}
class Single
{
private static Single s = null;
private Single(){};
public static Single getInstance()
{
if(s==null)
{
synchronized(Single.class)
{
if(s==null)
s = new Single();
}
}
return s;
}
}
class SingleDemo
{
public static void main(String[] args)
{
Single s1 = Single.getInstance();
Single s2 = Single.getInstance();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>464398</snippet_key>
<tag>向桌面添加快捷方式 为应用程序添加快捷方式</tag>
<comment>来自CSDN博客：Android开发之向桌面添加快捷方式  http://blog.csdn.net/fengyuzhengfan/article/details/39076517#</comment>
<code>/**
* 向桌面添加快捷方式
* @author jph
* Date:2014.09.05
*/
public class AddShortcut extends Activity {
Button btnAddShortCut;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.mian);
btnAddShortCut=(Button)findViewById(R.id.btnAddShortCut);
btnAddShortCut.setOnClickListener(new OnClickListener() {
@Override
public void onClick(View v) {
// TODO Auto-generated method stub
//创建一个添加快捷方式的Intent
Intent addSC=new Intent(&quot;com.android.launcher.action.INSTALL_SHORTCUT&quot;);
//快捷键的标题
String title=getResources().getString(R.string.shotcut_title);
//快捷键的图标
Parcelable icon=Intent.ShortcutIconResource.fromContext(
AddShortcut.this, R.drawable.ic_launcher);
//创建单击快捷键启动本程序的Intent
Intent launcherIntent=new Intent(AddShortcut.this, AddShortcut.class);
//设置快捷键的标题
addSC.putExtra(Intent.EXTRA_SHORTCUT_NAME, title);
//设置快捷键的图标
addSC.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, icon);
//设置单击此快捷键启动的程序
addSC.putExtra(Intent.EXTRA_SHORTCUT_INTENT,launcherIntent);
//向系统发送添加快捷键的广播
sendBroadcast(addSC);
}
});
}
}
&lt;!-- 指定添加安装快捷方式的权限 --&gt;
&lt;uses-permission android:name=&quot;com.android.launcher.permission.INSTALL_SHORTCUT&quot; /&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>202510</snippet_key>
<tag></tag>
<comment>来自CSDN博客：【毕设资料】Web版RSS阅读器（四）——定制自己的Rss解析库myrsslib4j  http://blog.csdn.net/Angiexia/article/details/19835339#</comment>
<code>connection.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)&quot;); //用UA伪装访问连接对象
/**
* Set rss resource by URL
* @param ur the remote url
* @throws RSSException
*/
public void setXmlResource(URL ur) throws RSSException{
try{

URLConnection con = u.openConnection();

//-----------------------------
//添加时间：2013-08-14 21:00:17
//人员：@龙轩
//博客：http://blog.csdn.net/xiaoxian8023
//添加内容：由于服务器屏蔽java作为客户端访问rss，所以设置User-Agent
con.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)&quot;);
//-----------------------------

con.setReadTimeout(10000);
String charset = Charset.guess(ur);
is = new InputSource (new UnicodeReader(con.getInputStream(),charset));
if (con.getContentLength() == -1 &amp;&amp; is == null){
this.fixZeroLength();
}
}catch(IOException e){
throw new RSSException(&quot;RSSParser::setXmlResource fails: &quot;+e.getMessage());
}
}
//judge from url
public static String guess(URL url) throws IOException {

//-----------------------------
//修改时间：2013-08-14 21:00:17
//人员：@龙轩
//博客：http://blog.csdn.net/xiaoxian8023
//修改内容：注释InputStream，创建URLConnection，设置User-Agent，通过URLConnection对象创建InputStream

//InputStream in = url.openStream();
URLConnection con = url.openConnection();
con.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)&quot;);
InputStream in = con.getInputStream();
//-----------------------------

return guess(in);
}
//-----------------------------------
//添加时间：2013-08-14 19:32:15
//人员：@龙轩
//添加内容：添加getSummary()方法，返回文章摘要信息
/**
* Get the element&apos;s summary
* @return the summary
*/
public String getSummary(){

String summary = getDescription();
if (summary.length() &gt;= 300) {
summary = summary.substring(0, 300);
}

String regEx_html = &quot;\\s|&lt;[^&gt;]+&gt;|&amp;\\w{1,5};&quot;; // 定义HTML标签和特殊字符的正则表达式

Pattern pattern = Pattern.compile(regEx_html,Pattern.CASE_INSENSITIVE);
Matcher matcher = pattern.matcher(summary);
summary = matcher.replaceAll(&quot;&quot;); // 过滤script标签

if (summary.length() &gt;= 100) {
summary = summary.substring(0, 100);
}
summary = summary + &quot;...&quot;;

return summary;
}
//添加结束-----------------------------------------------
/**
* Receive notification of the end of an element
* @param uri The Namespace URI, or the empty string if the element has no Namespace URI or if Namespace processing is not being performed.
* @param localName The local name (without prefix), or the empty string if Namespace processing is not being performed
* @param qName The qualified name (with prefix), or the empty string if qualified names are not available
*/
public void endElement(String uri,
String localName,
String qName){


String data = buff.toString().trim();

if (qName.equals(current_tag)){
data = buff.toString().trim();
buff = new StringBuffer();
}


if (reading_chan)
processChannel(qName,data);

if (reading_item)
processItem(qName,data);

if (reading_image)
processImage(qName,data);

if (reading_input)
processTextInput(qName,data);

if (tagIsEqual(qName,CHANNEL_TAG)){
reading_chan = false;
chan.setSyndicationModule(sy);
}

if (tagIsEqual(qName,ITEM_TAG)){
reading_item = false;
//-----------------------------------------
//添加时间：2013-08-14 21:00:17
//人员：@龙轩
//博客：http://blog.csdn.net/xiaoxian8023
//添加内容：重新允许解析channel
reading_chan = true;
//添加结束---------------------------------
chan.addItem(itm);
}

if (tagIsEqual(qName,IMAGE_TAG)){
reading_image = false;
//-----------------------------------------
//添加时间：2013-08-14 21:00:17
//人员：@龙轩
//博客：http://blog.csdn.net/xiaoxian8023
//添加内容：重新允许解析channel
reading_chan = true;
//添加结束---------------------------------
chan.setRSSImage(img);
}


if (tagIsEqual(qName,SEQ_TAG)){
reading_seq = false;
chan.addRSSSequence(seq);
}

if (tagIsEqual(qName,TEXTINPUT_TAG)){
reading_input = false;
//-----------------------------------------
//添加时间：2013-08-14 21:00:17
//人员：@龙轩
//博客：http://blog.csdn.net/xiaoxian8023
//添加内容：重新允许解析channel
reading_chan = true;
//添加结束---------------------------------
chan.setRSSTextInput(input);
}

}
package org.javali.util.test;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;

import org.gnu.stealthp.rsslib.RSSChannel;
import org.gnu.stealthp.rsslib.RSSException;
import org.gnu.stealthp.rsslib.RSSHandler;
import org.gnu.stealthp.rsslib.RSSItem;
import org.gnu.stealthp.rsslib.RSSParser;




public class RssNewsFetcher {

/**
* rss订阅列表
*/
private final static String[] rssArr = new String[] {
//&quot;http://news.baidu.com/n?cmd=1&amp;class=civilnews&amp;tn=rss&quot;,
&quot;http://xiaoxian100.blog.163.com/rss&quot;,
&quot;http://blog.csdn.net/xiaoxian8023/rss/list&quot;
};

/**
* 测试解析rss订阅
* @throws IOException
*/
public void testFetchRssNews() throws IOException {
for (int i = 0; i &lt; rssArr.length; i++) {
try {

//获取rss订阅地址
URL url = new URL(rssArr[i]);
RSSHandler handler = new RSSHandler();

//解析rss
RSSParser.parseXmlFile(url, handler, false);

//获取Rss频道信息
RSSChannel ch = handler.getRSSChannel();

System.out.println(&quot;---------------------------------------------&quot;);
System.out.println(&quot;博客标题：&quot; + ch.getTitle());
System.out.println(&quot;博客链接：&quot; + ch.getLink());
System.out.println(&quot;博客描述：&quot; + ch.getDescription());
System.out.println(&quot;博客语言：&quot; + ch.getLanguage());
System.out.println(&quot;发布时间：&quot; + ch.getPubDate());
System.out.println(&quot;图片地址：&quot; +ch.getRSSImage().getUrl());
System.out.println(&quot;图片指向：&quot; +ch.getRSSImage().getLink());

System.out.println(&quot;共有文章数目为：&quot; + ch.getItems().size());
// for(i=0;i&lt;ch.getItems().size();i++){
for(int j=0;j&lt;1;j++){ //这里为了方便测试，只取一次循环，真实使用时，需选用上面那句代码
RSSItem item = (RSSItem)ch.getItems().get(j);
System.out.println(&quot;文章标题：&quot; + item.getTitle());
System.out.println(&quot;文章摘要：&quot; + item.getSummary());
//System.out.println(&quot;文章正文：&quot; + item.getDescription());
//这里为了演示方便，我取正文的前100个字符，真实使用时，需选用上面那句代码
System.out.println(&quot;文章正文：&quot; + item.getDescription().substring(0, 100));
System.out.println(&quot;文章链接：&quot; + item.getLink());
System.out.println(&quot;发表时间：&quot; + item.getPubDate());
System.out.println(&quot;文章作者：&quot; + item.getAuthor());
System.out.println(&quot;最新修改：&quot; + item.getDate());
}

} catch (MalformedURLException e) {
e.printStackTrace();
} catch (RSSException e) {
e.printStackTrace();
}
}
}

public static void main(String[] args) throws IOException{
RssNewsFetcher fetcher = new RssNewsFetcher();
fetcher.testFetchRssNews();
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>283141</snippet_key>
<tag>android JNI</tag>
<comment>来自CSDN博客：Android JNI 图片作为传递参数1  http://blog.csdn.net/xunwukong/article/details/23276705#</comment>
<code>public static native int[] ImgFun(int[] buf, int w, int h);
Bitmap img1 = ((BitmapDrawable) getResources().getDrawable(R.drawable.test1)).getBitmap();

int w = img1.getWidth(), h = img1.getHeight();

int[] pix = new int[w * h];

img1.getPixels(pix, 0, w, 0, 0, w, h);

int[] resultInt=ImgActivity.ImgFun(pix, w, h);
JNIEXPORT jintArray JNICALL Java_xj_example1_opencvjnitest_ImgActivity_ImgFun
(JNIEnv *env, jclass, jintArray buf, jint w, jint h)
{
jint *cbuf = env-&gt;GetIntArrayElements(buf,0);

if(cbuf == NULL)

{
return 0;
}

Mat myimg(h, w, CV_8UC3, (unsigned char*)cbuf);
imwrite(&quot;/sdcard2/objdetect/test1.jpg&quot;, myimg);

//对图像做处理

imwrite(&quot;/sdcard2/objdetect/test2.jpg&quot;, myimg);

int size = w * h;

jintArray result = env-&gt;NewIntArray(size);

env-&gt;SetIntArrayRegion(result, 0, size, cbuf);

env-&gt;ReleaseIntArrayElements(buf, cbuf, 0);

return result;
}
public static native void detect(long imgaddr);
Mat dstMat = Highgui.imread(&quot;/sdcard2/objdetect/img/t4.jpg&quot;);
//call jni to detect
DetectionActivity.detect(dstMat.getNativeObjAddr());
&lt;pre name=&quot;code&quot; class=&quot;cpp&quot;&gt;JNIEXPORT void JNICALL Java_hisense_xj_objdetect_DetectionActivity_detect
(JNIEnv *env, jclass, jlong imgaddr)
{
Mat *img = (cv::Mat*)imgaddr;
}
{
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;Mat *img = (cv::Mat*)imgaddr;
}
JNIEXPORT void JNICALL Java_hisense_xj_objdetect_DetectionActivity_detect
(JNIEnv *env, jclass, jlong imgaddr)
{
Mat *img = (cv::Mat*)imgaddr;
}
</code>
</RECORD>
<RECORD>
<snippet_key>268046</snippet_key>
<tag>java 数据库 级联删除</tag>
<comment>来自CSDN博客：通过添加字段实现级联删除  http://blog.csdn.net/u013613707/article/details/22717219#</comment>
<code>String cate_ids = &quot;&quot;;
t_category categoty = (t_category) oc.findObjById(category_id, t_category.class);
while (ChkTools.isNotNull(categoty)) {
cate_ids += categoty.get_id() + &quot;,&quot;;
categoty = (t_category) oc.findObjById(categoty.getSuper_id(),
t_category.class);
}
field.setCate_ids(cate_ids);
oc.saveObj(field);
String sql1 = &quot;update t_category_field set status=-100 where cate_ids like ?&quot;;
List&lt;String&gt; params1 = new ArrayList&lt;String&gt;();
params1.add(&quot;%&quot; + category_id + &quot;%&quot;);
jc.update(sql1, params1.toArray());
</code>
</RECORD>
<RECORD>
<snippet_key>71694</snippet_key>
<tag>blog mm csdn博客</tag>
<comment>来自CSDN博客：yyyy/MM/dd HH:mm:ss 和 yyyy/MM/dd hh:mm:ss的区别  http://blog.csdn.net/qadada/article/details/15812065#</comment>
<code>SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy/MM/dd hh:mm:ss&quot;);\nDate date1 = format.parse(date);
</code>
</RECORD>
<RECORD>
<snippet_key>152325</snippet_key>
<tag></tag>
<comment>来自CSDN博客：代码备份 http://blog.csdn.net/Alv_s/article/details/18133337#</comment>
<code>public static Dataset getDataSet(Script script,Chart javaChart, String type) {
DatasetReader reader = javaChart.getReader();
String labelField = javaChart.getLabelField(); //x-axis data
ArrayList plotData = javaChart.getPlotData(); //available data for specific dataset
ArrayList fieldData = javaChart.getFieldData(); //y-axis data

// initialize XYDataset fieldCollection.
ArrayList&lt;String&gt; fields = new ArrayList&lt;String&gt;(); //different fields name
ArrayList&lt;XYSeries&gt; series = null; // different fields
XYSeriesCollection xySeriesCollection = null; // different data in the same field
int flag = 0;// flag is a mark for different type dataset.

if(reader == null || labelField == null || plotData == null || plotData.isEmpty()){
return null;
}

// classify different diagram to different dataset
if(type.equals(&quot;4&quot;)||type.equals(&quot;11&quot;)||type.equals(&quot;14&quot;)
||type.equals(&quot;15&quot;)||type.equals(&quot;16&quot;)){
dataset = new DefaultXYDataset();
series = new ArrayList&lt;XYSeries&gt;();
xySeriesCollection = new XYSeriesCollection();
flag = 2;
}

Dataset set = null; // the raw data
try {
set = reader.read(script, -1);
} catch (Exception e1) {
e1.printStackTrace();
return null;
}

for (int i = 0; i &lt; set.getRowCount(); i++) {
// if one row has more than one y-value, combine them
String legendField = &quot;&quot;;
String field = &quot;&quot;;
for (int k = 0; k &lt; fieldData.size(); k++) {
if (!fieldData.isEmpty()) {
legendField = (String) fieldData.get(k);
field = (set.getValueAt(i, legendField) + field).toString();
} else {
legendField = null;
field = null;
}// end if
} // end for
System.out.println(&quot;field = &quot; + field);

// classify data into different fields
if(!fields.contains(field) &amp;&amp; flag == 2){
fields.add(field);
XYSeries xyseries = new XYSeries(field);
series.add(xyseries);
}

for (int j = 0; j &lt; plotData.size(); j++) {
String label = set.getValueAt(i, labelField) + &quot;&quot;;
double val = 0.0;
System.out.println(&quot;the field is: &quot; + ((PlotData) plotData.get(j)).getField());
System.out.println(&quot;the value is: &quot; +
set.getValueAt(i,((PlotData) plotData.get(j)).getField()));

Object o = set.getValueAt(i,((PlotData) plotData.get(j)).getField());

if(o==null||o.getClass().toString().equals(&quot;class java.lang.String&quot;))
continue;

Number n = (Number) o;
val = n.doubleValue();
LabelValue testValue = new LabelValue(label, i);
String label2 = testValue.toString();

// reassemble data which are in same field into XYDataset structure
if(flag == 2){
try{
double x = Double.parseDouble(label2);
int num = fields.indexOf(field);
series.get(num).add(Double.parseDouble(label2), val);
}catch(Exception e){
e.printStackTrace();
return error;
}
}else{
addValue(dataset, val, field + &apos;-&apos; +
((PlotData) plotData.get(j)).getField(),label2);
}// end if
System.out.println(&quot;value: &quot; + val
+ &quot;.fild: &quot; + ((PlotData) plotData.get(j)).getField()
+ &quot;.label: &quot; + label2);
}// end for

if(flag == 2){
Iterator iterator = series.iterator();
while(iterator.hasNext()){
xySeriesCollection.addSeries((XYSeries) iterator.next());
} // end while
return xySeriesCollection;
}else{
return dataset;
} // end if
}

</code>
</RECORD>
<RECORD>
<snippet_key>268302</snippet_key>
<tag>java 黑马程序员</tag>
<comment>来自CSDN博客：黑马程序员_JAVA基础  http://blog.csdn.net/a254830856/article/details/22726231#</comment>
<code>&lt;span style=&quot;font-size:14px;&quot;&gt;class HelloWorld//定义类，注意类名的命名规则
{
public static voidmain(String[] args) //主函数
{
System.out.println(&quot;HelloWorld!&quot;);//输出语句
}
}&lt;/span&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>348933</snippet_key>
<tag></tag>
<comment>来自CSDN博客：感到很供电公司辅导教师规范的施工反攻倒算 http://blog.csdn.net/u014423493/article/details/25982855#</comment>
<code>msxf.net/book/99073/index.html
msxf.net/book/99454/index.html
</code>
</RECORD>
<RECORD>
<snippet_key>414469</snippet_key>
<tag>303</tag>
<comment>来自CSDN博客：Java Socekt 入门 一  http://blog.csdn.net/JackieLiuLixi/article/details/36477881#</comment>
<code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;


public class EchoServer {
public static void main(String[] args) throws IOException {
System.out.println(&quot;=============开启了服务器端程序============&quot;);
ServerSocket serverSocket = new ServerSocket(8000);
int index = 0;
while (true) {
Socket socket = serverSocket.accept();
System.out.println(&quot;开起了第&quot;+index+&quot;个连接&quot;);
System.out.println(&quot;server : &quot; + socket.getInetAddress() + &quot; : &quot; + socket.getPort());
BufferedReader bf = new BufferedReader(new InputStreamReader(socket.getInputStream()));
while (true) {
String readContent = bf.readLine();
System.out.println(&quot;server : &quot; + readContent);// 此处是 println，不能是print
PrintWriter pw = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()), true);
pw.println(&quot;echo : &quot; + readContent);

if (&quot;exit&quot;.equals(readContent)) {
if (socket != null) {
socket.close();
}
}
}
}

}
}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.Socket;
import java.net.UnknownHostException;

public class EchoClient {
public static void main(String[] args) throws UnknownHostException, IOException {
Socket socket = new Socket(&quot;localhost&quot;, 8000);
PrintWriter pw = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()), true);
BufferedReader brS = new BufferedReader(new InputStreamReader(socket.getInputStream()));
while (true) {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
System.out.println(&quot;输入：&quot;);
String readContent = &quot;&quot;;
while (true) {
readContent = br.readLine();
System.out.println(&quot;client : &quot; + readContent);
pw.println(readContent);// 此处是 println，不能是print
System.out.println(brS.readLine());
if (&quot;exit&quot;.equals(readContent)) {
if (socket != null) {
socket.close();
break;
}
}
}

}

}
}
</code>
</RECORD>
<RECORD>
<snippet_key>87045</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Android 之 远程图片获取和本地缓存  http://blog.csdn.net/yangxi_001/article/details/17010943#</comment>
<code>private void saveBmpToSd(Bitmap bm, Stringurl) {
if (bm == null) {
Log.w(TAG, &quot; trying to savenull bitmap&quot;);
return;
}
//判断sdcard上的空间
if (FREE_SD_SPACE_NEEDED_TO_CACHE &gt;freeSpaceOnSd()) {
Log.w(TAG, &quot;Low free space onsd, do not cache&quot;);
return;
}
String filename =convertUrlToFileName(url);
String dir = getDirectory(filename);
File file = new File(dir +&quot;/&quot; + filename);
try {
file.createNewFile();
OutputStream outStream = newFileOutputStream(file);
bm.compress(Bitmap.CompressFormat.JPEG, 100, outStream);
outStream.flush();
outStream.close();
Log.i(TAG, &quot;Image saved tosd&quot;);
} catch (FileNotFoundException e) {
Log.w(TAG,&quot;FileNotFoundException&quot;);
} catch (IOException e) {
Log.w(TAG,&quot;IOException&quot;);
}
}
/**
* 计算sdcard上的剩余空间
* @return
*/
private int freeSpaceOnSd() {
StatFs stat = newStatFs(Environment.getExternalStorageDirectory() .getPath());
double sdFreeMB = ((double)stat.getAvailableBlocks() * (double) stat.getBlockSize()) / MB;
return (int) sdFreeMB;
}
/**
* 修改文件的最后修改时间
* @param dir
* @param fileName
*/
private void updateFileTime(String dir,String fileName) {
File file = new File(dir,fileName);
long newModifiedTime =System.currentTimeMillis();
file.setLastModified(newModifiedTime);
}
/**
*计算存储目录下的文件大小，当文件总大小大于规定的CACHE_SIZE或者sdcard剩余空间小于FREE_SD_SPACE_NEEDED_TO_CACHE的规定
* 那么删除40%最近没有被使用的文件
* @param dirPath
* @param filename
*/
private void removeCache(String dirPath) {
File dir = new File(dirPath);
File[] files = dir.listFiles();
if (files == null) {
return;
}
int dirSize = 0;
for (int i = 0; i &lt; files.length;i++) {
if(files[i].getName().contains(WHOLESALE_CONV)) {
dirSize += files[i].length();
}
}
if (dirSize &gt; CACHE_SIZE * MB ||FREE_SD_SPACE_NEEDED_TO_CACHE &gt; freeSpaceOnSd()) {
int removeFactor = (int) ((0.4 *files.length) + 1);

Arrays.sort(files, newFileLastModifSort());

Log.i(TAG, &quot;Clear some expiredcache files &quot;);

for (int i = 0; i &lt;removeFactor; i++) {

if(files[i].getName().contains(WHOLESALE_CONV)) {

files[i].delete();

}

}

}

}
/**
* 删除过期文件
* @param dirPath
* @param filename
*/
private void removeExpiredCache(StringdirPath, String filename) {

File file = new File(dirPath,filename);

if (System.currentTimeMillis() -file.lastModified() &gt; mTimeDiff) {

Log.i(TAG, &quot;Clear some expiredcache files &quot;);

file.delete();

}

}
/**
* TODO 根据文件的最后修改时间进行排序 *
*/
classFileLastModifSort implements Comparator&lt;File&gt;{
public int compare(File arg0, File arg1) {
if (arg0.lastModified() &gt;arg1.lastModified()) {
return 1;
} else if (arg0.lastModified() ==arg1.lastModified()) {
return 0;
} else {
return -1;
}
}
}
private final HashMap&lt;String, Bitmap&gt;mHardBitmapCache = new LinkedHashMap&lt;String, Bitmap&gt;(HARD_CACHE_CAPACITY/ 2, 0.75f, true) {
@Override
protected booleanremoveEldestEntry(LinkedHashMap.Entry&lt;String, Bitmap&gt; eldest) {
if (size() &gt;HARD_CACHE_CAPACITY) {
//当map的size大于30时，把最近不常用的key放到mSoftBitmapCache中，从而保证mHardBitmapCache的效率
mSoftBitmapCache.put(eldest.getKey(), newSoftReference&lt;Bitmap&gt;(eldest.getValue()));
return true;
} else
return false;
}
};
/**
*当mHardBitmapCache的key大于30的时候，会根据LRU算法把最近没有被使用的key放入到这个缓存中。
*Bitmap使用了SoftReference，当内存空间不足时，此cache中的bitmap会被垃圾回收掉
*/
private final staticConcurrentHashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt; mSoftBitmapCache =new ConcurrentHashMap&lt;String,SoftReference&lt;Bitmap&gt;&gt;(HARD_CACHE_CAPACITY / 2);
/**
* 从缓存中获取图片
*/
private Bitmap getBitmapFromCache(Stringurl) {
// 先从mHardBitmapCache缓存中获取
synchronized (mHardBitmapCache) {
final Bitmap bitmap =mHardBitmapCache.get(url);
if (bitmap != null) {
//如果找到的话，把元素移到linkedhashmap的最前面，从而保证在LRU算法中是最后被删除
mHardBitmapCache.remove(url);
mHardBitmapCache.put(url,bitmap);
return bitmap;
}
}
//如果mHardBitmapCache中找不到，到mSoftBitmapCache中找
SoftReference&lt;Bitmap&gt;bitmapReference = mSoftBitmapCache.get(url);
if (bitmapReference != null) {
final Bitmap bitmap =bitmapReference.get();
if (bitmap != null) {
return bitmap;
} else {
mSoftBitmapCache.remove(url);
}
}
return null;
}
/**
* 异步下载图片
*/
class ImageDownloaderTask extendsAsyncTask&lt;String, Void, Bitmap&gt; {
private static final int IO_BUFFER_SIZE= 4 * 1024;
private String url;
private finalWeakReference&lt;ImageView&gt; imageViewReference;
public ImageDownloaderTask(ImageViewimageView) {
imageViewReference = newWeakReference&lt;ImageView&gt;(imageView);
}

 @Override
protected BitmapdoInBackground(String... params) {
final AndroidHttpClient client =AndroidHttpClient.newInstance(&quot;Android&quot;);
url = params[0];
final HttpGet getRequest = newHttpGet(url);
try {
HttpResponse response =client.execute(getRequest);
final int statusCode =response.getStatusLine().getStatusCode();
if (statusCode !=HttpStatus.SC_OK) {
Log.w(TAG, &quot;从&quot; +url + &quot;中下载图片时出错!,错误码:&quot; + statusCode);
return null;
}
final HttpEntity entity =response.getEntity();
if (entity != null) {
InputStream inputStream =null;
OutputStream outputStream =null;
try {
inputStream =entity.getContent();
finalByteArrayOutputStream dataStream = new ByteArrayOutputStream();
outputStream = newBufferedOutputStream(dataStream, IO_BUFFER_SIZE);
copy(inputStream,outputStream);
outputStream.flush();
final byte[] data =dataStream.toByteArray();
final Bitmap bitmap =BitmapFactory.decodeByteArray(data, 0, data.length);
return bitmap;
} finally {
if (inputStream !=null) {
inputStream.close();
}
if (outputStream !=null) {
outputStream.close();
}
entity.consumeContent();
}
}
} catch (IOException e) {
getRequest.abort();
Log.w(TAG, &quot;I/O errorwhile retrieving bitmap from &quot; + url, e);
} catch (IllegalStateException e) {
getRequest.abort();
Log.w(TAG, &quot;Incorrect URL:&quot; + url);
} catch (Exception e) {
getRequest.abort();
Log.w(TAG, &quot;Error whileretrieving bitmap from &quot; + url, e);
} finally {
if (client != null) {
client.close();
}
}
return null;
}
</code>
</RECORD>
<RECORD>
<snippet_key>268558</snippet_key>
<tag></tag>
<comment>java 中关于路径</comment>
<code>1.? 获取web服务器项目的真实物理路径
request.getSession().getServletContext().getRealPath(&quot;/&quot;);
2.? 相对路径的获得
说明:相对路径(即不写明时候到底相对谁)均可通过以下方式获得（不论是一般的java项目还是web项目）
String relativelyPath=System.getProperty(&quot;user.dir&quot;);
上述相对路径中，java项目中的文件是相对于项目的根目录
web项目中的文件路径视不同的web服务器不同而不同
（tomcat是相对于 tomcat安装目录\bin）
3.? 类加载目录的获得(即当运行时某一类时获得其装载目录)
3.1. 通用的方法一
(不论是一般的java项目还是web项目,先定位到能看到包路径的第一级目录 ) 
 InputStream is=TestAction.class.getClassLoader().getResourceAsStream(&quot;test.txt&quot;);
 (test.txt文件的路径为项目名\src\test.txt;类TestAction所在包的第一级目录位于src目录下) 
 上式中将TestAction，test.txt替换成对应成相应的类名和文件名字即可
3.2. 通用方法二 (此方法和1.1中的方法类似,不同的是此方法必须以&apos;/&apos;开头)
 InputStream is=Test1.class.getResourceAsStream(&quot;/test.txt&quot;);
 (test.txt文件的路径为项目名\src\test.txt,类Test1所在包的第一级目录位于src目录下) 
4.? web项目根目录的获得(发布之后)
4.1. 从servlet出发
 可建立一个servlet在其的init方法中写入如下语句
 ServletContext s1=this.getServletContext();
 String temp=s1.getRealPath(&quot;/&quot;); (关键)
 结果形如：D:\工具\Tomcat-6.0\webapps\002_ext\ (002_ext为项目名字)
 如果是调用了s1.getRealPath(&quot;&quot;)则输出D:\工具\Tomcat-6.0\webapps\002_ext(少了一个&quot;\&quot;)
4.2. 从httpServletRequest出发
 String cp11111=request.getSession().getServletContext().getRealPath(&quot;/&quot;);
?
 结果形如:D:\工具\Tomcat-6.0\webapps\002_ext\
5.? classpath的获取
(在Eclipse中为获得src或者classes目录的路径)
5.1. 方法一
?????? Thread.currentThread().getContextClassLoader().getResource(&quot;&quot;).getPath();
?????? eg:
 String t=Thread.currentThread().getContextClassLoader().getResource(&quot;&quot;).getPath();
 System.out.println(&quot;t---&quot;+t);
 输出:t---/E:/order/002_ext/WebRoot/WEB-INF/classes/ 
5.2. 方法二
JdomParse.class.getClassLoader().getResource(&quot;&quot;).getPath() (JdomParse为src某一个包中的类,下同)
 eg:
String p1=JdomParse.class.getClassLoader().getResource(&quot;&quot;).getPath();
System.out.println(&quot;JdomParse.class.getClassLoader().getResource--&quot;+p1);
输出:
JdomParse.class.getClassLoader().getResource--/E:/order/002_ext/WebRoot/WEB-INF/classes/
另外,如果想把文件放在某一包中,则可以通过以下方式获得到文件(先定位到该包的最后一级目录)
eg
String p2=JdomParse.class.getResource(&quot;&quot;).getPath();
System.out.println(&quot;JdomParse.class.getResource---&quot;+p2);
输出:
JdomParse.class.getResource---/E:/order/002_ext/WebRoot/WEB-INF/classes/jdom/
(JdomParse为src目录下jdom包中的类)
在jsp和class文件中调用的相对路径不同。 在jsp里，根目录是WebRoot 在class文件中，根目录是WebRoot/WEB-INF/classes 当然你也可以用System.getProperty(&quot;user.dir&quot;)获取你工程的绝对路径。
6.? 在Jsp,Servlet,Java中详细获得路径的方法
6.1. jsp中取得路径：
以工程名为TEST为例：
(1)得到包含工程名的当前页面全路径：request.getRequestURI()
结果：/TEST/test.jsp
(2)得到工程名：request.getContextPath()
结果：/TEST
(3)得到当前页面所在目录下全名称：request.getServletPath()
结果：如果页面在jsp目录下 /TEST/jsp/test.jsp
(4)得到页面所在服务器的全路径：application.getRealPath(&quot;页面.jsp&quot;)
结果：D:\resin\webapps\TEST\test.jsp
(5)得到页面所在服务器的绝对路径：absPath=new java.io.File(application.getRealPath(request.getRequestURI())).getParent();
结果：D:\resin\webapps\TEST
6.2. 在类中取得路径：
(1)类的绝对路径：Class.class.getClass().getResource(&quot;/&quot;).getPath()
结果：/D:/TEST/WebRoot/WEB-INF/classes/pack/
(2)得到工程的路径：System.getProperty(&quot;user.dir&quot;)
结果：D:\TEST
6.3. 在Servlet中取得路径：
(1)得到工程目录：request.getSession().getServletContext().getRealPath(&quot;&quot;) 参数可具体到包名。
结果：E:\Tomcat\webapps\TEST
(2)得到IE地址栏地址：request.getRequestURL()
结果：http://localhost:8080/TEST/test
(3)得到相对地址：request.getRequestURI()
结果：/TEST/test
</code>
</RECORD>
<RECORD>
<snippet_key>414725</snippet_key>
<tag></tag>
<comment>来自CSDN博客：HBase概念学习（九）HTablePool为何弃用？  http://blog.csdn.net/jiq408694711/article/details/36526433#</comment>
<code>public void addUser(User user) throws IOException
{
HTableInterface usersTable = conn.getTable(TABLE_NAME);

Put put = makePut(user);
usersTable.put(put);

usersTable.close();
log.info(&quot;Add a User:&quot;+user.name+&quot; successfully&quot;);
}
public class HBaseUtils {

private static final String QUORUM = &quot;192.168.1.100&quot;;
private static final String CLIENTPORT = &quot;2181&quot;;
private static Configuration conf = null;
private static HConnection conn = null;

/**
* 获取全局唯一的Configuration实例
* @return
*/
public static synchronized Configuration getConfiguration()
{
if(conf == null)
{
conf = HBaseConfiguration.create();
conf.set(&quot;hbase.zookeeper.quorum&quot;, QUORUM);
conf.set(&quot;hbase.zookeeper.property.clientPort&quot;, CLIENTPORT);
}
return conf;
}

/**
* 获取全局唯一的HConnection实例
* @return
* @throws ZooKeeperConnectionException
*/
public static synchronized HConnection getHConnection() throws ZooKeeperConnectionException
{
if(conn == null)
{
/*
* * 创建一个HConnection
* HConnection connection = HConnectionManager.createConnection(conf);
* HTableInterface table = connection.getTable(&quot;mytable&quot;);
* table.get(...); ...
* table.close();
* connection.close();
* */
conn = HConnectionManager.createConnection(getConfiguration());
}

return conn;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>152837</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Longest Consecutive Sequence http://blog.csdn.net/sunjilong/article/details/18178121#</comment>
<code>public class Solution {
public int longestConsecutive(int[] a) {
HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
int max = 1;
for (int i : a) {
if (map.containsKey(i)) continue;
map.put(i, 1);
if (map.containsKey(i - 1)) {
max = Math.max(max, merge(map, i-1, i));
}
if (map.containsKey(i + 1)) {
max = Math.max(max, merge(map, i, i+1));
}
}
return max;
}

private int merge(HashMap&lt;Integer, Integer&gt; map, int left, int right) {
int upper = right + map.get(right) - 1;
int lower = left - map.get(left) + 1;
int len = upper - lower + 1;
map.put(upper, len);
map.put(lower, len);
return len;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>334606</snippet_key>
<tag></tag>
<comment>来自CSDN博客：用 flying saucer 生成pdf文件时的报错 http://blog.csdn.net/elfxwt/article/details/25318023#</comment>
<code>public static String getHtml(String templateName, Map&lt;String, Object&gt; items)
throws IOException {
String html = getHtml(templateName);
for (String key : items.keySet()) {
String tag = &quot;{&quot; + key + &quot;}&quot;;
if (html.indexOf(tag) &gt; 0) {

if (items.get(key) != null) {
if(items.get(key).getClass().getName() == &quot;java.math.BigDecimal&quot;)
items.put(key, ((java.math.BigDecimal)items.get(key)).doubleValue());
//System.out.println(items.get(key).toString());
html = html.replace(
tag,
items.get(key).toString().trim()
.replace(&quot;&lt;&quot;, &quot;&lt;&quot;)
.replace(&quot;&gt;&quot;, &quot;&gt;&quot;)
.replaceAll(&quot; &quot;, &quot; &quot;)
.replaceAll(&quot;\\n&quot;, &quot;&lt;br /&gt;&quot;)
.replaceAll(&quot;&amp;&quot;, &quot; &quot;))
; // 要将内容中的特殊字符替换
} else{
html = html.replace(tag, &quot;&quot;);
}

}
}
//System.out.println(html);
return html;
}
</code>
</RECORD>
<RECORD>
<snippet_key>269326</snippet_key>
<tag></tag>
<comment>来自CSDN博客：第4周作业-数学学习工具 http://blog.csdn.net/u013900749/article/details/22755663#</comment>
<code>import java.util.Scanner;

public class AdditionQuiz {

public static void main(String[] args) {
int number1 = (int)(System.currentTimeMillis() % 10);
int number2 = (int)(System.currentTimeMillis() % 10);

//Create a Scanner
Scanner input = new Scanner(System.in);

System.out.println(&quot;what is &quot; + number2 + &quot; ? &quot; );
int answer = input.nextInt();

System.out.println(number1 + &quot;+&quot;+ number2 + &quot;=&quot; + answer + &quot; is &quot; + (number1 + number2 == answer));


}

}
</code>
</RECORD>
<RECORD>
<snippet_key>269582</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：java模仿斗地主随机洗牌 发牌，TreeMap、ArrayList、TreeSet练习  http://blog.csdn.net/qq1053781225/article/details/22760263#</comment>
<code>/**
* 模仿斗地主洗牌，随机发牌
* 使用TreeMap、ArrayList、TreeSet
* 思想：
* 使用TreeMap存54张牌，每张牌作为值，key为每张牌整数编号1-54，取出键进行乱序牌，
* 之后发给三个人存在TreeSet自动会排序，然后偶循环通过键获得每张牌，斗地主不考虑花色
*/
import java.util.ArrayList;
import java.util.Collections;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

public class Poker1 {

public static void main(String[] args) {
// 定义点数
String[] point = { &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;J&quot;, &quot;Q&quot;,
&quot;K&quot;, &quot;A&quot;, &quot;2&quot; };
// 定义花色
// String[] fC = { &quot;红心&quot;, &quot;方块&quot;, &quot;黑桃&quot;, &quot;梅花&quot; };
String[] fC = { &quot;♥&quot;, &quot;♦&quot;, &quot;♠&quot;, &quot;♣&quot; };
// 定义扑克集合
TreeMap&lt;Integer, String&gt; mapPoker = new TreeMap&lt;&gt;();
// 生成扑克
int sum = 0;
for (String s1 : point) {
for (String s2 : fC) {
mapPoker.put(++sum, s2.concat(s1));
}
}
mapPoker.put(++sum, &quot;小王&quot;);
mapPoker.put(++sum, &quot;大王&quot;);
// System.out.println(mapPoker + &quot;\n&quot;);

//获取所有键
Set&lt;Integer&gt; keys = mapPoker.keySet();
//把键个封装到ArrayList集合，便于使用Collections集合工具类洗牌
ArrayList&lt;Integer&gt; poker = new ArrayList&lt;&gt;();
for (Integer integer : keys) {
poker.add(integer);
}
// System.out.println(&quot;洗牌前key：&quot; + poker);

// 洗牌
//使用集合工具类洗牌
Collections.shuffle(poker);
// System.out.println(&quot;洗牌后key：&quot; + poker + &quot;\n&quot; + poker.size());

// 派牌、码牌(TreeSet)，定义了三个人man1、man2、man3，底牌 diPoker
TreeSet&lt;Integer&gt; man1 = new TreeSet&lt;&gt;();
TreeSet&lt;Integer&gt; man2 = new TreeSet&lt;&gt;();
TreeSet&lt;Integer&gt; man3 = new TreeSet&lt;&gt;();
ArrayList&lt;Integer&gt; diPoker = new ArrayList&lt;&gt;(poker.subList(
poker.size() - 3, poker.size()));
//每人一张发牌
for (int i = 0; i &lt; poker.size() - 3; i++) {
Integer s = poker.get(i);
if (i % 3 == 1) {
man1.add(s);
} else if (i % 3 == 2) {
man2.add(s);
} else if (i % 3 == 0) {
man3.add(s);
}
}

// 看牌
//三方牌装到ArrayList便于每个man遍历打印
ArrayList&lt;Set&lt;Integer&gt;&gt; sets = new ArrayList&lt;&gt;();
sets.add(man1);
sets.add(man2);
sets.add(man3);
//外层遍历ArrayList的man封装，内层打印牌
for (int i = 0; i &lt; sets.size(); i++) {
//三目嵌套打出每个人
System.out.print(i == 0 ? &quot;man1：&quot; : (i == 1 ? &quot;man2：&quot;
: (i == 2 ? &quot;man3：&quot; : &quot;&quot;)));
Set&lt;Integer&gt; set = sets.get(i);
for (Integer te : set) {
System.out.print(mapPoker.get(te) + &quot; &quot;);
}
System.out.println();
}
//打印底牌
System.out.print(&quot;\ndiPoker：&quot;);
for (Integer te : diPoker) {
System.out.print(mapPoker.get(te) + &quot; &quot;);
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>218885</snippet_key>
<tag>63</tag>
<comment>来自CSDN博客：设计自己的Annotation  http://blog.csdn.net/u012081562/article/details/20553171#</comment>
<code>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target {
ElementType[] value();
}
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Retention {
RetentionPolicy value();
}
public enum RetentionPolicy {
SOURCE,
CLASS,
RUNTIME
}
public enum ElementType {
TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR,
LOCAL_VARIABLE, ANNOTATION_TYPE,PACKAGE
}
package lighter.iteye.com;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Description {
String value();
}
package lighter.iteye.com;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

//注意这里的@Target与@Description里的不同,参数成员也不同
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Name {
String originate();
String community();
}
package lighter.iteye.com;

@Description(&quot;javaeye,做最棒的软件开发交流社区&quot;)
public class JavaEyer {
@Name(originate=&quot;创始人:robbin&quot;,community=&quot;javaEye&quot;)
public String getName()
{
return null;
}

@Name(originate=&quot;创始人:江南白衣&quot;,community=&quot;springside&quot;)
public String getName2()
{
return &quot;借用两位的id一用,写这一个例子,请见谅!&quot;;
}
}
package lighter.iteye.com;

import java.lang.reflect.Method;
import java.util.HashSet;
import java.util.Set;

public class TestAnnotation {
/**
* author lighter
* 说明:具体关天Annotation的API的用法请参见javaDoc文档
*/
public static void main(String[] args) throws Exception {
String CLASS_NAME = &quot;lighter.iteye.com.JavaEyer&quot;;
Class test = Class.forName(CLASS_NAME);
Method[] method = test.getMethods();
boolean flag = test.isAnnotationPresent(Description.class);
if(flag)
{
Description des = (Description)test.getAnnotation(Description.class);
System.out.println(&quot;描述:&quot;+des.value());
System.out.println(&quot;-----------------&quot;);
}

//把JavaEyer这一类有利用到@Name的全部方法保存到Set中去
Set&lt;Method&gt; set = new HashSet&lt;Method&gt;();
for(int i=0;i&lt;method.length;i++)
{
boolean otherFlag = method[i].isAnnotationPresent(Name.class);
if(otherFlag) set.add(method[i]);
}
for(Method m: set)
{
Name name = m.getAnnotation(Name.class);
System.out.println(name.originate());
System.out.println(&quot;创建的社区:&quot;+name.community());
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>415493</snippet_key>
<tag></tag>
<comment>来自CSDN博客：PhoneGap优化解决方案 http://blog.csdn.net/u014227228/article/details/36665811#</comment>
<code>window.myjs.runOnAndroidJavaScript();
</code>
</RECORD>
<RECORD>
<snippet_key>219141</snippet_key>
<tag>184,327</tag>
<comment>来自CSDN博客：四种遍历 map 的方式 http://blog.csdn.net/robby_chan/article/details/20559063#</comment>
<code>import java.io.*;
import java.util.*;

public class FourTravelmap {
public static void main(String[] args) {

Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();

map.put(&quot;1&quot;, &quot;value1&quot;);
map.put(&quot;2&quot;, &quot;value2&quot;);
map.put(&quot;3&quot;, &quot;value3&quot;);

// 第一种：普遍使用，二次取值
System.out.println(&quot;通过Map.keySet遍历key和value：&quot;);
for (String key : map.keySet()) {
System.out.println(&quot;key= &quot; + key + &quot; and value= &quot; + map.get(key));
}

// 第二种
System.out.println(&quot;通过Map.entrySet使用iterator遍历key和value：&quot;);
Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();
while (it.hasNext()) {
Map.Entry&lt;String, String&gt; entry = it.next();
System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot;
+ entry.getValue());
}

// 第三种：推荐，尤其是容量大时
System.out.println(&quot;通过Map.entrySet遍历key和value&quot;);
for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {
System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot;
+ entry.getValue());
}
// 第四种
System.out.println(&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;);
for (String v : map.values()) {
System.out.println(&quot;value= &quot; + v);
}
}
}
// 当一个人找不到出路的时候，最好的办法就是将当前能做好的事情做到极致，做到无人能及。
</code>
</RECORD>
<RECORD>
<snippet_key>466446</snippet_key>
<tag>205</tag>
<comment>来自CSDN博客：Java加强—注释Annotation  http://blog.csdn.net/mayor125/article/details/39177835#</comment>
<code>package cn.itcast.day2;

public class AnnotationTest {
@SuppressWarnings(&quot;deprecation&quot;) //该Annotation标识表示忽略抑制编译器的警告。
public static void main(String[]args) {
System.runFinalizersOnExit(true);
}

@Deprecated //该Annotation标识表示此方法已经过时。
public static void sayHello(){
System.out.println(&quot;hello world&quot;);
}

@Override //该Annotation标识表示次方法是重写了父类的方法。
public String toString(){
return &quot;&quot;;
}
}
package com.hy.test;

class Person{
public String getInfo(){
return &quot;person run&quot;;
}
}

class Student extends Person{ //Student类继承Person类
@Override //此处明确标识出方法覆写的操作。
public String getInfo(){
return &quot;student run ...&quot;;
}
}

public class OverrideAnnotationDemo {
public static void main(String[]args) {
//输出信息。
System.out.println(newStudent().getInfo());
//输出结果：student run …
}
}
package com.hy.test;

class Demo{
@Deprecated //标识声明该方法已经过期，不建议使用。
public String getInfo(){
return &quot;hello java&quot;;
}
}

public class DeprecatedAnnotationDemo {
public static void main(String[]args) {
System.out.println(new Demo().getInfo());
}
}
package com.hy.test;

public class AnnotationTest {
@SuppressWarnings(&quot;deprecation&quot;) //单个警告：抑制划横线的方法已过时提示的警告。
public static void main(String[] args) {
System.runFinalizersOnExit(true);
}
}
package com.hy.test;

@Deprecated
class Test&lt;T&gt;{ //定义泛型类，并标识此类已经过期。
private T var;

public T getVar() {
return var;
}
public void setVar(T var) {
this.var = var;
}
}

public class AnnotationTest {
@SuppressWarnings({&quot;unchecked&quot;,&quot;deprecation&quot;}) //同时抑制两条警告。
public static void main(String[]args) {
Test t = new Test();
t.setVar(&quot;hello world&quot;);
System.out.println(t.getVar());
}
}
package com.hy.test;

@Deprecated
class Test2&lt;T&gt;{
private T var;

public T getVar() {
return var;
}
public void setVar(T var) {
this.var = var;
}
}

public class AnnotationTest2 {
@SuppressWarnings(value={&quot;unchecked&quot;,&quot;deprecation&quot;}) //另外一种同时抑制两种警告的方式。
public static void main(String[]args) {
Test2 t2 = new Test2();
t2.setVar(&quot;hello java&quot;);
System.out.println(t2.getVar());
}
}
package com.hy.test;

public @interface MyAnnotationNoneMethod{ //自定义Annotation

}

@MyAnnotationNoneMethod //使用自定义的Annotation
class Demo{

}
package com.hy.test;

public @interface MyAnnotationSingleParam{
public String value(); //记住：此处的变量名必须是value，写成其它的则会提示报错。
}

@MyAnnotationSingleParam(&quot;java&quot;) //带一个参数的自定义Annotation
class Demo{

}
package com.hy.test;

public @interface MyAnnotationSingleParam{
public String value();
}

@MyAnnotationSingleParam(value=&quot;java&quot;) //另外一种设置方式。此种方式一般用于带多个参数时才会使用。
class Demo{

}
package com.hy.test;

public @interface MyAnnotationMoreParam{
public String key(); //变量的名称必须要为key或者value
public String value();
}

@MyAnnotationMoreParam(key=&quot;hello&quot;,value=&quot;java&quot;)
class Demo{

}
package com.hy.test;

public @interface MyAnnotationArrayParam{
public String[] value(); //接收设置的内容是一个字符串数组。
}

//使自定义的单个参数属性有多个内容。
@MyAnnotationArrayParam(value={&quot;hello&quot;,&quot;java&quot;,&quot;123&quot;})
class Demo{

}
package com.hy.test;

public @interface MyAnnotationDefaultValue{
//该自定义Annotation内定义了两个变量属性。
public String key();
public String value();
}

@MyAnnotationDefaultValue //该类使用Annotation时没有指定具体属性内容。
class Demo{

}

class MyAnnotationDefaultValueDemo{
public static void main(String[]args) {
new Demo();
}
}
package com.hy.test;

public @interface MyAnnotationDefaultValue{
public String key() default &quot;hello&quot;; //设置变量属性的默认值内容。
public String value() default &quot;java&quot;; //设置变量属性的默认值内容。
}

@MyAnnotationDefaultValue //此处没有设置属性内容。
class Demo4 {

}
package com.hy.test;

enum Technology{ //定义枚举类。
JAVA,JSP,HTML; //定义枚举类中的元素内容。
}

public @interface MyAnnotationEnum{
//设置默认值，且默认值必须为枚举中定义的取值内容。
public Technology tech() default Technology.JAVA;
}

@MyAnnotationEnum(tech=Technology.JSP) //使用自定义的Annotation，传入参数内容，参数内容为枚举类中的指定元素内容。
class Demo5{

}
package com.hy.test;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

enum Tech{
JAVA,JSP,HTML;
}

@Retention(value=RetentionPolicy.RUNTIME) //此Annotation在执行时会被加载进JVM
public @interface MyDefaultRetentionAnnotation{
public Tech value() default Tech.JAVA; //设置Annotation的默认值为枚举中的内容。
}

@MyDefaultRetentionAnnotation(value=Tech.HTML)
class Demo{

}
package com.hy.test;

import java.lang.annotation.Annotation;
import java.lang.reflect.Method;

class Demo{
@Deprecated
@Override
@SuppressWarnings(&quot;all&quot;)
public String toString(){
return &quot;Hello Java&quot;;
}
}

public class GetAnnotations {
public static void main(String[]args) throws Exception {
Class c = Class.forName(&quot;com.hy.test.Demo&quot;);
Method method = c.getMethod(&quot;toString&quot;);
Annotation[] annotation = method.getAnnotations();
for(Annotation an : annotation){
System.out.println(an);
}
}
}
package com.hy.test;

importjava.lang.annotation.Retention;
importjava.lang.annotation.RetentionPolicy;

//定义一个使用RUNTIME方式声明的Annotation
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotationReflect {
public String key() default &quot;zhangsan&quot;; //设置key的默认值。
public String value() default &quot;20&quot;; //设置value的默认值。
}

class Demo8{
@Override
@Deprecated
@SuppressWarnings(&quot;all&quot;)
@MyAnnotationReflect(key=&quot;lisi&quot;,value=&quot;28&quot;) //使用自定义的Annotation并设置两个属性参数的值。
public String toString(){ //覆写toString()方法。
return &quot;Hello JAVA&quot;;
}
}
package com.hy.test;

import java.lang.reflect.Method;

public class AnnotationReflect{
public static void main(String[]args) throws Exception{
//获取Class类的实例。
Class c = Class.forName(&quot;com.hy.test.Demo8&quot;);
//获取toString()方法。
Method method = c.getMethod(&quot;toString&quot;);

//判断自定义的Annotation上是否存在注释。
if(method.isAnnotationPresent(MyAnnotationReflect.class)){
//声明自定义Annotation的对象。
MyAnnotationReflect mar = method.getAnnotation(MyAnnotationReflect.class);

//获取自定义Annotation中指定变量参数的内容。
String key = mar.key();
Stringvalue = mar.value();

//输出获取到的Annotation变量参数的内容。
System.out.println(&quot;key=&quot;+key);
System.out.println(&quot;value=&quot;+value);
}
}
}
package com.hy.test;

//自定义Annotation，并指定属性变量初始值。
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotationReflect {
public String key() default &quot;zhangsan&quot;;
public String value() default &quot;20&quot;;
}

@MyAnnotationReflect(key=&quot;lisi&quot;,value=&quot;22&quot;)
public class SimpleBean {
//使用自定义的Annotation，并设置两个属性参数的内容。
@MyAnnotationReflect(key=&quot;wangwu&quot;,value=&quot;25&quot;)
public String toString(){
return &quot;Hello Java&quot;;
}
}
package com.hy.test;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE) //使用@Target注释明确指定该Annotation只能在类上使用。
@Retention(value=RetentionPolicy.RUNTIME)
public @interface MyTargetAnnotation{
public String key() default &quot;JAVA&quot;; //定义变量以及默认值。
public String value() default &quot;Android&quot;;
}

@MyTargetAnnotation(key=&quot;PHP&quot;,value=&quot;HTML&quot;) //在类上使用自定义的Annotation。
classTargetAnnotationTest{
//在方法上使用自定义的Annotation，会报错，因为Annotation中使用@Target注释明确限定使用的位置是在类上。
@MyTargetAnnotation(key=&quot;JAVAEE&quot;,value=&quot;Hadoop&quot;)
public String sayHello(){
return &quot;Hello JAVA &amp; Android&quot;;
}
}
package com.hy.test;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.TYPE,ElementType.METHOD}) //通过在@Target注释中传入一个ElementType类型的数组，可以允许该自定义Annotation同时在类的多个位置上使用。
@Retention(value=RetentionPolicy.RUNTIME)
public @interface MyTargetAnnotation{
public String key() default &quot;JAVA&quot;;
public String value() default &quot;Android&quot;;
}

@MyTargetAnnotation(key=&quot;PHP&quot;,value=&quot;HTML&quot;) //在类上使用自定义的Annotation。
classTargetAnnotationTest{
//在方法上使用自定义的Annotation。
@MyTargetAnnotation(key=&quot;JAVA EE&quot;,value=&quot;Hadoop&quot;)
public String sayHello(){
return &quot;Hello JAVA &amp; Android&quot;;
}
}
package com.hy.test;

import java.lang.annotation.Documented;

//自定义Annotation，使用@Documented注释。
@Documented
public @interface MyDocumentedAnnotation {
public String key();
public String value();
}
package com.hy.test;

@MyDocumentedAnnotation(key=&quot;JAVA&quot;,value=&quot;HTML&quot;)
public class MyDocumentedAnnotationTest {
/**
* 此方法在对象输出时调用，返回对象的信息
*/
@MyDocumentedAnnotation(key=&quot;JAVA&quot;,value=&quot;Android&quot;)
public String toString(){
return &quot;Hello World&quot;;
}
}
package com.hy.test;

import java.lang.annotation.Documented;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Inherited //此自定义注释可以被子类继承。
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface MyIneritedAnnotation {
public String name();
}
package com.hy.test;

//定义父类Persons，使用自定义的Annotation
@MyIneritedAnnotation(name=&quot;zhangsan&quot;)
class Persons {}

//定义子类继承Persons
class Students extends Persons{}
package com.hy.test;

importjava.lang.annotation.Annotation;

public class MyInheritedDemo {
public static void main(String[]args) throws Exception {
//获取Class类实例对象。
Class c = Class.forName(&quot;com.hy.test.Students&quot;);
//获取全部的Annotation。
Annotation[] annotation = c.getAnnotations();
for(Annotation an : annotation){
System.out.println(an); //输出获取到的所有Annotation
}

if(c.isAnnotationPresent(MyIneritedAnnotation.class)){
//获取自定义的Annotation，且此Annotation是从父类继承过来的。
MyIneritedAnnotation mia = (MyIneritedAnnotation) c.getAnnotation(MyIneritedAnnotation.class);
String name = mia.name(); //获取自定义Annotation中的指定变量的内容。
System.out.println(&quot;name = &quot;+name);
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>350213</snippet_key>
<tag>poi excel 水印</tag>
<comment>来自CSDN博客：POI导出EXCEL带水印,以及单元格格式设置  http://blog.csdn.net/qq315737546/article/details/26069117#</comment>
<code>File file = new File(&quot;D://target.xls&quot;);//目标文件
String templatePath = &quot;D://template.xls&quot;;//模版文件
POIFSFileSystem fs=new POIFSFileSystem(new FileInputStream(templatePath));
HSSFWorkbook workbook = new HSSFWorkbook(fs);
HSSFSheet sheet = workbook.getSheetAt(0);
FileOutputStream out = new FileOutputStream(file);
workbook.setSheetName(0, &quot;test&quot;);//sheet名称
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt; HSSFFont fontContent4 = workbook.createFont(); // 生成一个字体
fontContent4.setFontHeightInPoints((short) 11);//字体大小
fontContent4.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);//字体加粗
fontContent4.setFontName(&quot;仿宋_GB2312&quot;);
HSSFCellStyle styleContent4 = workbook.createCellStyle();
styleContent4.setFont(fontContent4);
styleContent4.setAlignment(HSSFCellStyle.ALIGN_CENTER);//水平居中
styleContent4.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);//垂直居中
styleContent4.setWrapText(true);//自动换行
styleContent4.setBorderBottom(HSSFCellStyle.BORDER_THIN);//边框 4个边都要设置
styleContent4.setBorderLeft(HSSFCellStyle.BORDER_THIN);
styleContent4.setBorderRight(HSSFCellStyle.BORDER_THIN);
styleContent4.setBorderTop(HSSFCellStyle.BORDER_THIN);
//设置默认列宽和列宽
sheet.setDefaultColumnWidth(5);
sheet.setDefaultRowHeight((short) 500);

HSSFRow row6 = sheet.createRow(startRow);
HSSFCell r6c0 = row6.createCell(0);
r6c0.setCellValue(new HSSFRichTextString(&quot;平均分&quot;));
r6c0.setCellStyle(styleContent4);
row6.createCell(1).setCellStyle(styleContent4);//空的单元格也设置格式
row6.createCell(2).setCellStyle(styleContent4);//空的单元格也设置格式
sheet.addMergedRegion(new CellRangeAddress(0,1,0,2));//合并单元格(起始行,结束行,起始列,结束列)

//同一个单元格设置不同字体
HSSFRichTextString advise = new HSSFRichTextString(report.getAdvise());
advise.applyFont(0, 9, fontContent3);
advise.applyFont(9, 16, fontTitle3);
advise.applyFont(16, advise.length(),fontContent3);
r6c1.setCellValue(advise);//
r6c1.setCellStyle(styleContent3);
HSSFFont fontContent4 = workbook.createFont(); // 生成一个字体
fontContent4.setFontHeightInPoints((short) 11);//字体大小
fontContent4.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);//字体加粗
fontContent4.setFontName(&quot;仿宋_GB2312&quot;);
HSSFCellStyle styleContent4 = workbook.createCellStyle();
styleContent4.setFont(fontContent4);
styleContent4.setAlignment(HSSFCellStyle.ALIGN_CENTER);//水平居中
styleContent4.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);//垂直居中
styleContent4.setWrapText(true);//自动换行
styleContent4.setBorderBottom(HSSFCellStyle.BORDER_THIN);//边框 4个边都要设置
styleContent4.setBorderLeft(HSSFCellStyle.BORDER_THIN);
styleContent4.setBorderRight(HSSFCellStyle.BORDER_THIN);
styleContent4.setBorderTop(HSSFCellStyle.BORDER_THIN);
</code>
</RECORD>
<RECORD>
<snippet_key>415749</snippet_key>
<tag>471</tag>
<comment>来自CSDN博客：【Leetcode】Merge Two Sorted Lists  http://blog.csdn.net/yyz20002008/article/details/36687061#</comment>
<code>public class Solution {
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
// Start typing your Java solution below
// DO NOT write main() function
ListNode temp = new ListNode(0);
ListNode prev = temp;

while(l1!=null &amp;&amp; l2!=null){
if(l1.val&gt;l2.val){
prev.next=l2;
l2=l2.next;
}else{
prev.next=l1;
l1=l1.next;
}
prev=prev.next;
}
if(l1!=null) prev.next=l1;
else if(l2!=null) prev.next=l2;
return temp.next;
}
}
/**
* Definition for singly-linked list.
* public class ListNode {
* int val;
* ListNode next;
* ListNode(int x) {
* val = x;
* next = null;
* }
* }
*/
public class Solution {
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
if (l1 == null) {
return l2;
}
if (l2 == null) {
return l1;
}

ListNode node = null;
ListNode head = null;

while (l1 != null &amp;&amp; l2 != null) {
if (l1.val &lt;= l2.val) {
if (node == null) {
node = l1;
head = node;
} else {
node.next = l1;
node = node.next;
}

l1 = l1.next;
} else {
if (node == null) {
node = l2;
head = node;
} else {
node.next = l2;
node = node.next;
}

l2 = l2.next;
}
}

if (l1 != null) {
node.next = l1;
} else if (l2 != null) {
node.next = l2;
}

return head;
}
}
public class Solution {
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
ListNode temp = new ListNode(0);
ListNode prev = temp;

while(l1!=null &amp;&amp; l2!=null){
if(l1.val&gt;l2.val){
temp.next=l2;
l2=l2.next;
}else{
temp.next=l1;
l1=l1.next;
}
temp=temp.next;
}
if(l1!=null) temp.next=l1;
else if(l2!=null) temp.next=l2;
return prev.next;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>204814</snippet_key>
<tag>java 递归 leetcode</tag>
<comment>来自CSDN博客：LeetCode | Populating Next Right Pointers in Each Node  http://blog.csdn.net/perfect8886/article/details/19932463#</comment>
<code>public class PopulatingNextRightPointersInEachNode {
public class TreeLinkNode {
int val;
TreeLinkNode left, right, next;

TreeLinkNode(int x) {
val = x;
}
}

public void connect(TreeLinkNode root) {
if (root == null) {
return;
}
if (root.left != null) {
root.left.next = root.right;
}
if (root.right != null &amp;&amp; root.next != null) {
root.right.next = root.next.left;
}
connect(root.left);
connect(root.right);
}
}
public class PopulatingNextRightPointersInEachNode {
public class TreeLinkNode {
int val;
TreeLinkNode left, right, next;

TreeLinkNode(int x) {
val = x;
}
}

public void connect(TreeLinkNode root) {
TreeLinkNode leftMostNode = root;
while (leftMostNode != null) {
TreeLinkNode node = leftMostNode;
while (node != null) {
if (node.left != null) {
node.left.next = node.right;
}
if (node.right != null &amp;&amp; node.next != null) {
node.right.next = node.next.left;
}
node = node.next;
}
leftMostNode = leftMostNode.left;
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>350725</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：黑马程序员---多线程  http://blog.csdn.net/u013440163/article/details/24836347#</comment>
<code>package cn.itcast.heima;

public class TraditionalThread {

public static void main(String[] args) {

Thread thread1 = new Thread() {
public void run() {
int i = 9;
while(i&gt;0)
{
System.out.println(i--+&quot;.....&quot;+Thread.currentThread().getName());
System.out.println(i--+&quot;.....&quot;+this.getName());
}
}
};
thread1.start();

Thread thread2 = new Thread(new Runnable() {
public void run() {
int i = 9;
while(i&gt;0)
{
System.out.println(i--+&quot;......&quot;+Thread.currentThread().getName());
}
}
});
thread2.start();

new Thread(new Runnable() {
public void run() {
System.out.println(&quot;Runnable...&quot;+Thread.currentThread().getName());
}
}) {
public void run() {
System.out.println(&quot;Thread...&quot;+Thread.currentThread().getName());
}
}.start();
}
}
package cn.itcast.heima;

import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;

public class TraditionalTimerTest {

private static int count = 0;
public static void main(String[] args) {

class MyTimerTask extends TimerTask{
@Override
public void run() {
count = (count+1)%2;
System.out.println(&quot;bombing&quot;);
new Timer().schedule(new MyTimerTask(), 2000+2000*count);
}
}

new Timer().schedule(new MyTimerTask(),2000);//过2秒炸，过4秒炸，过2秒炸，过4秒再炸，循环。。。

//秒表
while(true) {
System.out.println(new Date().getSeconds());
try {
Thread.sleep(1000);
} catch (InterruptedException e) {
e.printStackTrace();
}
}
}

}

//星期一到星期五每天凌晨三点收邮件，周六周日不收。这种问题可以用工具：quartz 来解决。
package cn.itcast.heima;

public class TraditionalThreadSynchronized {
public static void main(String[] args) {
//1.碰到多线程要操作同一份数据的时候，就要考虑线程安全的问题。
/*2.静态方法不可以new内部类的实例对象。
* 因为内部类是可以访问外部类的成员变量的。
* 而成员变量一定是外部类产生实例对象的时候才分配内存空间的。
* 而静态方法的使用可以不new对象，
* 这时候内部类要访问外部类的成员变量，
* 现在都没有产生外部类实例对象，
* 去哪找成员变量的值呢？*/

new TraditionalThreadSynchronized().init();
}

public void init() {
final Outputer out = new Outputer();
new Thread(new Runnable() {
@Override
public void run() {
while(true) {
try {
Thread.sleep(10);
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
out.output(&quot;lihuoming&quot;);
}
}
}).start();

new Thread(new Runnable() {
@Override
public void run() {
while(true) {
try {
Thread.sleep(10);
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
out.output2(&quot;bixiangdong&quot;);
}
}
}).start();
}

class Outputer {

public void output(String name) {
int len = name.length();
synchronized (this)
{
for (int i = 0; i &lt; len; i++) {
System.out.print(name.charAt(i));
}
System.out.println();
}
}

public synchronized void output2(String name) {
int len = name.length();
synchronized (this)
{
for (int i = 0; i &lt; len; i++) {
System.out.print(name.charAt(i));
}
System.out.println();
}
}

}
}
//方法上的synchronized，锁是this对象。
//静态方法上的synchronized，锁是类的字节码对象。
package cn.itcast.heima;

public class TraditionalThreadCommunication {

public static void main(String[] args) {
final Business business = new Business();
new Thread(
new Runnable() {
@Override
public void run() {
for(int j=1; j &lt;= 50; j++) {
business.sub(j);
}
}
}).start();

for(int j=1; j &lt;= 50; j++) {
business.main(j);
}
}
}

class Business {
private boolean bShouldSub = true;

public synchronized void sub(int j) {
//用while更健壮，防止伪唤醒。
while(!bShouldSub) {
try {
this.wait();//这里synchronized的锁是什么对象，wait就用什么对象调用。
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}
for (int i = 1; i &lt;= 10; i++) {
System.out.println(&quot;sub thread sequence of&quot;
+ i + &quot;, loop of&quot; + j);
}
bShouldSub = false;
this.notify();//这里synchronized的锁是什么对象，notify就用什么对象调用。
}

public synchronized void main(int j) {
while(bShouldSub) {
try {
this.wait();
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}
for (int i = 1; i &lt;= 10; i++) {
System.out.println(&quot;main thread sequence of&quot; + i
+ &quot;, loop of&quot; + j);
}
bShouldSub = true;
this.notify();
}
}
//同步互斥的代码不是写在线程上，而是写在线程要访问的那个资源类的方法内部的。
//好处是以后任何线程要访问这个资源类，拿到以后就可以编译通过，很方便。
package cn.itcast.heima;

import java.util.Random;

public class ThreadLocalTest {

private static ThreadLocal&lt;Integer&gt; x = new ThreadLocal&lt;Integer&gt;();

public static void main(String[] args) {
for(int i=0;i&lt;2;i++) {
new Thread(new Runnable() {
@Override
public void run() {
int data = new Random().nextInt();//给全局静态变量data赋一个随机数。
System.out.println(Thread.currentThread().getName()
+ &quot; has put data &quot; + data);

x.set(data);
Student.getThreadInstance().setName(&quot;name&quot;+data);
Student.getThreadInstance().setAge(data);

new A().get();
new B().get();
}
}).start();
}
}

static class A {
public void get() {
int data = x.get();
System.out.println(&quot;A from &quot; + Thread.currentThread().getName()
+ &quot; get data &quot; + data);

System.out.println(&quot;A from &quot; + Thread.currentThread().getName()
+ &quot; get Student &quot; + Student.getThreadInstance().getName()
+ &quot;, age&quot; + Student.getThreadInstance().getAge());
}
}

static class B {
public void get() {
int data = x.get();
System.out.println(&quot;B from &quot; + Thread.currentThread().getName()
+ &quot; get data &quot; + data);

System.out.println(&quot;B from &quot; + Thread.currentThread().getName()
+ &quot; get Student &quot; + Student.getThreadInstance().getName()
+ &quot;, age&quot; + Student.getThreadInstance().getAge());
}
}

static class Student {

private Student() {}
private static ThreadLocal&lt;Student&gt; threadLocalStu = new ThreadLocal&lt;Student&gt;();

public static Student getThreadInstance() {
Student stu = threadLocalStu.get();
if(stu == null) {
stu = new Student();
threadLocalStu.set(stu);
}
return stu;
}

String name;
int age;

public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
public int getAge() {
return age;
}
public void setAge(int age) {
this.age = age;
}
}

}
//线程范围内的共享变量。这个学生去了不同的线程有不同的名字和年龄，入乡随俗。
package cn.itcast.heima;
/*一、如果线程执行代码相同，就可以把共享数据封装在一个Runnable里。例如：卖票。
public class MultiThreadShareData {
public static void main(String[] args) {
MyData data = new MyData(100);
new Thread(data).start();
new Thread(data).start();
}
}
class MyData implements Runnable {
private int count;
MyData(int count){
this.count = count;
}
@Override
public void run() {
while(count&gt;0){
sale();
}
}
private synchronized void sale(){
if(count&gt;0){
count--;
System.out.println(Thread.currentThread().getName()+&quot;---sale---&quot;+count);
}
}
}*/


/*二、如果线程执行代码不一样，例如：一个加加，一个减减。
* 可以将数据封装在一个外部类里，并提供两个同步方法：一个加加方法和一个减减方法。
* 创建两个Runnable类，一个调用加加方法，一个调用减减方法。
public class MultiThreadShareData {
public static void main(String[] args) {
MyData data = new MyData();
new Thread(new Decrease(data)).start();
new Thread(new Increase(data)).start();
}
}
class Decrease implements Runnable{
private MyData data;
Decrease(MyData data){
this.data = data;
}
@Override
public void run() {
// TODO Auto-generated method stub
for(int i=0;i&lt;2;i++){
data.decrease();
}
}
}
class Increase implements Runnable{
private MyData data;
Increase(MyData data){
this.data = data;
}
@Override
public void run() {
// TODO Auto-generated method stub
for(int i=0;i&lt;2;i++){
data.increase();
}
}
}
class MyData {
private int j;
public synchronized void decrease(){
j--;
System.out.println(Thread.currentThread().getName()+&quot;---dec---&quot;+j);
}
public synchronized void increase(){
j++;
System.out.println(Thread.currentThread().getName()+&quot;---inc---&quot;+j);
}
}*/

/*三、
public class MultiThreadShareData {
//位置一：外部类的成员变量，要想被静态方法中的内部类所使用需加static关键字修饰。
//private static MyData data = new MyData();

public static void main(String[] args) {
//位置二：局部变量，要想被方法中内部类使用，需加final关键字修饰。
final MyData data = new MyData();

new Thread(new Runnable() {
@Override
public void run() {
for(int i=0;i&lt;2;i++){
data.decrease();
}
}
}).start();
new Thread(new Runnable() {
@Override
public void run() {
for(int i=0;i&lt;2;i++){
data.increase();
}
}
}).start();
}
}
class MyData {
private int j;
public synchronized void decrease(){
j--;
System.out.println(Thread.currentThread().getName()+&quot;---dec---&quot;+j);
}
public synchronized void increase(){
j++;
System.out.println(Thread.currentThread().getName()+&quot;---inc---&quot;+j);
}
}*/

/*四、四个线程共享一个数据j，两个线程j++，两个线程j--*/
public class MultiThreadShareData {

private int j;

public static void main(String[] args){
MultiThreadShareData tt = new MultiThreadShareData();
Dec dec = tt.new Dec();
Inc inc = tt.new Inc();
for(int i=0; i&lt;2; i++){
Thread t = new Thread(dec);
t.start();
t = new Thread(inc);
t.start();
}
}

private synchronized void dec(){
j--;
System.out.println(Thread.currentThread().getName()+&quot;---dec---&quot;+j);
}

private synchronized void inc(){
j++;
System.out.println(Thread.currentThread().getName()+&quot;---inc---&quot;+j);
}

class Dec implements Runnable{
@Override
public void run() {
dec();
}
}

class Inc implements Runnable{
@Override
public void run() {
inc();
}
}
}
package cn.itcast.heima;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ThreadPoolTest {

public static void main(String[] args) {
//ExecutorService threadPool = Executors.newFixedThreadPool(3);//固定线程的线程池。
//ExecutorService threadPool = Executors.newCachedThreadPool();//有几个任务就创建几个线程的线程池。

//单线程的线程池，它的特殊之处在于线程死了以后还会生成一个替补线程。永远保持有一个线程在那里。
ExecutorService threadPool = Executors.newSingleThreadExecutor();

for(int i=1;i&lt;=6;i++){
final int task = i;
threadPool.execute(new Runnable(){
@Override
public void run() {
for(int j=1;j&lt;=5;j++){
System.out.println(Thread.currentThread().getName()+&quot;, is looping of &quot;+j+&quot;, for task of &quot;+task);
}
}
});
}
System.out.println(&quot;All of 6 tasks hava committed.&quot;);
threadPool.shutdown();


//可被定时调度的线程池：
ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(2);

//线程池的延期调度：
scheduledThreadPool.schedule(new Runnable(){
@Override
public void run() {
System.out.println(Thread.currentThread().getName()+&quot;, bombing! task-1&quot;);
}
}, 5/*delay延期*/, TimeUnit.SECONDS);


//线程池的固定频率调度：
scheduledThreadPool.scheduleAtFixedRate(new Runnable(){
@Override
public void run() {
System.out.println(Thread.currentThread().getName()+&quot;, bombing! task-2&quot;);
}
}, 6/*delay*/, 2/*period周期*/, TimeUnit.SECONDS);
}

}
package cn.itcast.heima;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class CallableAndFuture {

public static void main(String[] args) {

ExecutorService threadPool = Executors.newSingleThreadExecutor();

Future&lt;String&gt; future =
threadPool.submit(new Callable&lt;String&gt;(){
@Override
public String call() throws Exception {
Thread.sleep(2000);
return &quot;hello&quot;;
}
});

try {
System.out.println(&quot;future: &quot;+future.get());
} catch (InterruptedException | ExecutionException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}
}
package cn.itcast.heima;

import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.CompletionService;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorCompletionService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class CallableAndFuture {

public static void main(String[] args) {

ExecutorService threadPool2 = Executors.newFixedThreadPool(10);//定义10个线程的线程池。
//将线程池交给收割机调度。
CompletionService&lt;Integer&gt; completionService = new ExecutorCompletionService&lt;Integer&gt;(threadPool2);

//提交10个任务
for(int i=1; i&lt;=10; i++) {
final int sequence = i;
//由收割机代替线程池提交任务。
completionService.submit(new Callable&lt;Integer&gt;() {
@Override
public Integer call() throws Exception {
Thread.sleep(new Random().nextInt(5000));//每个任务小睡的时间不一样，最多不超过5秒。
return sequence;//返回任务的序号。
}
});
}
for(int i=1; i&lt;=10; i++) {
try {
Future&lt;Integer&gt; future = completionService.take();//谁先熟了，先收割谁。
System.out.println(future.get());
} catch (InterruptedException | ExecutionException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}
}
}
package cn.itcast.heima;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class LockTest {
public static void main(String[] args) {
new LockTest().init();
}

public void init() {
final Outputer out = new Outputer();

new Thread(new Runnable() {
@Override
public void run() {
while(true)
{
try {
Thread.sleep(10);
} catch (InterruptedException e) {
e.printStackTrace();
}
out.output(&quot;lihuoming&quot;);
}
}
}).start();

new Thread(new Runnable() {
@Override
public void run() {
while(true) {

try {
Thread.sleep(10);
} catch (InterruptedException e) {
e.printStackTrace();
}
out.output(&quot;bixiangdong&quot;);
}
}
}).start();
}

class Outputer {
Lock lock = new ReentrantLock();
public void output(String name) {
int len = name.length();
lock.lock();
//以防万一在执行里面程序的时候抛异常了，这个方法就退出了，不会执行到unlock方法，其他线程就进不去了。
try{
for (int i=0; i&lt;len; i++) {
System.out.print(name.charAt(i));
}
System.out.println();
}finally{
lock.unlock();
}
}
}
}
package cn.itcast.heima;

import java.util.Random;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockTest {
//static Queue queue = new Queue();
public static void main(String[] args) {
final Queue queue = new Queue();
for(int i=0;i&lt;3;i++){ //共开启3个读线程，3个写线程。
new Thread(){
public void run(){
while(true){ //每开启一个线程，它就在不停的读。
queue.get();
}
}
}.start();
new Thread(){
public void run(){
while(true){ //每开启一个线程，它就在不停的写。
queue.set(new Random().nextInt(10000));
}
}
}.start();
}
}
}
//因为读和写要操作的是同一个数据，那么读和写方法就得在同一个类里。
class Queue {
private Object data = null;
private ReadWriteLock rwl = new ReentrantReadWriteLock();
public void get(){
rwl.readLock().lock();
try {
System.out.println(Thread.currentThread().getName()+&quot; be ready to read data!&quot;);
Thread.sleep((long)(Math.random()*1000));
System.out.println(Thread.currentThread().getName()+&quot; hava read data &quot;+data+&quot; !&quot;);
}catch (InterruptedException e) {
e.printStackTrace();
}finally {
rwl.readLock().unlock();
}
}
public void set(Object data){
rwl.writeLock().lock();
try {
System.out.println(Thread.currentThread().getName()+&quot; be ready to write data!!&quot;);
Thread.sleep((long)(Math.random()*1000));
this.data = data;
System.out.println(Thread.currentThread().getName()+&quot; hava written data &quot;+data+&quot; !!&quot;);
}catch (InterruptedException e) {
e.printStackTrace();
}finally {
rwl.writeLock().unlock();
}
}
}
class CachedData {
Object data;
volatile boolean cacheValid;
ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

void processCachedData() {
rwl.readLock().lock();
if (!cacheValid) {
// Must release read lock before acquiring write lock
rwl.readLock().unlock();
rwl.writeLock().lock();
// Recheck state because another thread might have acquired
// write lock and changed state before we did.
if (!cacheValid) {
data = ...
cacheValid = true;
}
// Downgrade by acquiring read lock before releasing write lock
rwl.readLock().lock();
rwl.writeLock().unlock(); // Unlock write, still hold read
}

use(data);
rwl.readLock().unlock();
}
}
package cn.itcast.heima;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/* 缓存类：
* 你要找数据的时候先别找数据库，先找我，如果我没有你再找数据库。
*/

public class CacheDemo {

//先定义一个Map，用来存放缓存数据。用户通过对象的名字进行查找。
private Map&lt;String,Object&gt; cache = new HashMap&lt;String,Object&gt;();

public static void main(String[] args) {}

/*如果A、B、C三个线程同时来这里查，走到value＝＝null的时候，要查几遍数据库啊，所以这里应该加上锁。
* 多个读的时候，应该可以并发的，不会造成数据的破坏，不会冲突。所以它们进来读的时候，都给它们上读锁。
* 但是一旦发现没有数据可读，就要有一个线程负责去读数据了，
* 这时候它去数据库把数据读出来了，在它填充数据的时候就要上写锁。
* 写之间不能被读走，所以这时候上写锁。
* 数据填充完了，把写锁释放掉，再给它还原成为读锁。
* 这样就读与写、写与写之间进行了互斥。又可以有多个并发的读。系统性能就很高了。*/

private ReadWriteLock rwl = new ReentrantReadWriteLock();

public Object getData(String key){
rwl.readLock().lock();
Object value = null;
try{
value = cache.get(key);
if(value == null) {
rwl.readLock().unlock(); //假如三个线程都走到这里了
rwl.writeLock().lock(); //只有第一个线程可以进入，等这个线程将写锁释放掉，其它两个线程又进入。
try{
if(value==null){ //这里为了避免重复，加上一句判断。就算其它两个线程接着想来写的时候，它们发现这个数据不用再写了。
value = &quot;aaaa&quot;;//实际失去queryDB();
}
}finally{
rwl.writeLock().unlock();
}
rwl.readLock().lock();
}
}finally{
rwl.readLock().unlock();
}
return value;
}
}
package cn.itcast.heima;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/*子线程循环10次，主线程循环10次，子线程再循环10次，主线程再循环10次，如此循环50次。*/

public class ConditionCommunication {

public static void main(String[] args) {
final Business business = new Business();
new Thread(
new Runnable() {
@Override
public void run() {
for(int j=1; j &lt;= 50; j++) {
business.sub(j);
}
}
}).start();

for(int j=1; j &lt;= 50; j++) {
business.main(j);
}
}

//静态方法不能创建内部类的实例，所以在类前加static。它的作用类似于外部类。它现在的完整名称是ConditionCommunication.Business。
static class Business {

Lock lock = new ReentrantLock();
Condition condition = lock.newCondition();
private boolean bShouldSub = true;

public void sub(int j) {
lock.lock();
try{
while(!bShouldSub){
try {
condition.await();
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}
for (int i = 1; i &lt;= 10; i++) {
System.out.println(&quot;sub thread sequence of&quot;
+ i + &quot;, loop of&quot; + j);
}
bShouldSub = false;
condition.signal();
}finally{
lock.unlock();
}
}

public synchronized void main(int j) {
lock.lock();
try{
while(bShouldSub){
try {
condition.await();
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}
for (int i = 1; i &lt;= 10; i++) {
System.out.println(&quot;main thread sequence of&quot; + i
+ &quot;, loop of&quot; + j);
}
bShouldSub = true;
condition.signal();
}finally{
lock.unlock();
}
}
}
}

//本例中主要演示：Condition的await和signal方法。
//必须在synchronized同步监视器内部才可以用wait和notify。
package cn.itcast.heima;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class BoundedBuffer {
final Lock lock = new ReentrantLock();
final Condition notFull = lock.newCondition();
final Condition notEmpty = lock.newCondition();

final Object[] items = new Object[100];
int putptr, takeptr, count;

public void put(Object x) throws InterruptedException {
lock.lock();
try{
while(count == items.length)
notFull.await();
items[putptr] = x;
if (++putptr == items.length) putptr = 0;
++count;
notEmpty.signal();
} finally {
lock.unlock();
}
}

public Object take() throws InterruptedException {
lock.lock();
try{
while(count == 0)
notEmpty.await();
Object x = items[takeptr];
if (++takeptr == items.length) takeptr = 0;
--count;
notFull.signal();
return x;
} finally {
lock.unlock();
}
}
}
package cn.itcast.heima;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/*三个线程，老大循环10次，老二循环10次，老三循环10次，再老大循环10次...如此循环50次。*/

public class ThreeConditionCommunication {

static Business business = new Business();

public static void main(String[] args) {
new Thread(
new Runnable(){
@Override
public void run() {
for(int j=1; j &lt;= 50; j++) {
business.first(j);
}
}
}).start();

new Thread(
new Runnable() {
@Override
public void run() {
for(int j=1; j &lt;= 50; j++) {
business.second(j);
}
}
}).start();

new Thread(
new Runnable() {
@Override
public void run() {
for(int j=1; j&lt;=50;j++) {
business.third(j);
}
}
}).start();
}

//静态方法不能创建内部类的实例，所以在类前加static。它的作用类似于外部类。它现在的完整名称是ConditionCommunication.Business。
static class Business {

Lock lock = new ReentrantLock();
Condition condition1 = lock.newCondition();
Condition condition2 = lock.newCondition();
Condition condition3 = lock.newCondition();

private int runptr = 1;

public void first(int j) {
lock.lock();
try{
while(runptr!=1){
try {
condition1.await();
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}
for (int i = 1; i &lt;= 10; i++) {
System.out.println(&quot;first thread sequence of&quot;
+ i + &quot;, loop of&quot; + j);
}
runptr = 2;
condition2.signal();
}finally{
lock.unlock();
}
}

public void second(int j) {
lock.lock();
try{
while(runptr!=2){
try {
condition2.await();
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}
for (int i = 1; i &lt;= 10; i++) {
System.out.println(&quot;second thread sequence of&quot; + i
+ &quot;, loop of&quot; + j);
}
runptr = 3;
condition3.signal();
}finally{
lock.unlock();
}
}

public void third(int j) {
lock.lock();
try{
while(runptr!=3){
try {
condition3.await();
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}
for(int i=1;i&lt;=10;i++){
System.out.println(&quot;third thread sequence of&quot; + i
+ &quot;, loop of&quot; + j);
}
runptr = 1;
condition1.signal();
}finally{
lock.unlock();
}
}
}
}

//老大只可以唤醒老二，老二只可以唤醒老三，老三只可以唤醒老大。
package cn.itcast.heima;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;

public class SemaphoreTest {

public static void main(String[] args) {

ExecutorService service = Executors.newCachedThreadPool();

final Semaphore sp = new Semaphore(3);

for(int i=0;i&lt;10;i++){

Runnable runnable = new Runnable(){
@Override
public void run() {
try {
sp.acquire();//这里
} catch (InterruptedException e1) {
e1.printStackTrace();
}

System.out.println(&quot;线程&quot; + Thread.currentThread().getName() +
&quot;进入，当前已有&quot; + (3-sp.availablePermits()) + &quot;个并发&quot;);

try {
Thread.sleep((long)(Math.random()*10000));
} catch (InterruptedException e) {
e.printStackTrace();
}

System.out.println(&quot;线程&quot; + Thread.currentThread().getName() +
&quot;即将离开&quot;);

sp.release();

//下面代码有时候执行不准确，因为其没有和上面的代码合成原子单元
System.out.println(&quot;线程&quot; + Thread.currentThread().getName() +
&quot;已离开，当前已有&quot; + (3-sp.availablePermits()) + &quot;个并发&quot;);
}
};
service.execute(runnable);//此cached线程池，是往线程池里丢几个runnable，就开启几个线程。
}
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>219909</snippet_key>
<tag>ajax</tag>
<comment>来自CSDN博客：学习AJAX（三）  http://blog.csdn.net/woshishen__74/article/details/20577121#</comment>
<code>response.setCharacterEncoding(&quot;UTF-8&quot;);
User user1 = new User(1, &quot;忘不&quot;, 22);
User user2 = new User(2, &quot;李四&quot;, 22);
User user3 = new User(3, &quot;王五&quot;, 22);
User user4 = new User(4, &quot;赵六&quot;, 22);
List&lt;User&gt; list = new ArrayList&lt;User&gt;();
list.add(user1);
list.add(user2);
list.add(user3);
list.add(user4);

JSONArray array=JSONArray.fromObject(list);
System.out.println(array.toString());
response.getWriter().write(array.toString());
&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.6.2.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
function findUser(){
$.get(&quot;TestCollServlet&quot;,function(data){
alert(data);
var list=jQuery.parseJSON(data);
for(var i=0;i&lt;list.length;i++){
var user=list[i];
var tr=$(&quot;&lt;tr&gt;&quot;);
tr
.append($(&quot;&lt;td&gt;&quot;).text(user.name))
.append($(&quot;&lt;td&gt;&quot;).text(user.age))
.appendTo($(&quot;#list&quot;));
}
});
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table border=&quot;1&quot; width=&quot;80%&quot; align=&quot;center&quot;&gt;
&lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt;
&lt;th&gt;年龄&lt;/th&gt;
&lt;/tr&gt;
&lt;tbody id=&quot;list&quot;&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;input type=&quot;button&quot; value=&quot;取得信息&quot; onclick=&quot;findUser()&quot; /&gt;
&lt;/body&gt;
&lt;/html&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>467214</snippet_key>
<tag></tag>
<comment>来自CSDN博客：汽车类 属性私有，生成其共有的get/set http://blog.csdn.net/u012369106/article/details/39208257#</comment>
<code>public class TestVehicle {

/**
* @param args
*/
public static void main(String[] args) {
// TODO 自动生成的方法存根
Vehicle vehicle = new Vehicle(&quot;兰博基尼&quot;,&quot;装逼&quot;,&quot;超级跑车&quot;,&quot;1L/1公里&quot;,&quot;黄色&quot;,&quot;3000万人民币&quot;);
vehicle.show();
}

}
class Vehicle{
private String vehId;
private String vehUse;
private String author;
private String oil;
private String color;
private String price;

public Vehicle(){

}
public Vehicle(String vehId,String vehUse,String author,String oil,String color,String price){
this.vehId = vehId;
this.vehUse = vehUse;
this.author = author;
this.oil = oil;
this.color = color;
this.price = price;
}
public void show(){
System.out.println(&quot;车辆型号：&quot;+vehId);
System.out.println(&quot;用途：&quot;+vehUse);
System.out.println(&quot;性能：&quot;+author);
System.out.println(&quot;油耗：&quot;+oil);
System.out.println(&quot;颜色：&quot;+color);
System.out.println(&quot;价钱：&quot;+price);
}
public void start(){

}
public void stop(){

}
public String getVehId() {
return vehId;
}
public void setVehId(String vehId) {
this.vehId = vehId;
}
public String getVehUse() {
return vehUse;
}
public void setVehUse(String vehUse) {
this.vehUse = vehUse;
}
public String getAuthor() {
return author;
}
public void setAuthor(String author) {
this.author = author;
}
public String getOil() {
return oil;
}
public void setOil(String oil) {
this.oil = oil;
}
public String getColor() {
return color;
}
public void setColor(String color) {
this.color = color;
}
public String getPrice() {
return price;
}
public void setPrice(String price) {
this.price = price;
}



}
</code>
</RECORD>
<RECORD>
<snippet_key>416773</snippet_key>
<tag>471</tag>
<comment>来自CSDN博客：java谢尔排序 http://blog.csdn.net/zhang434/article/details/16898253#</comment>
<code>package contcurrentandalgorithm;

/**
*
* @author Administrator
* zyyjiao@mail.ustc.edu.cn
*/
public class ShellSort {

public static void main(String[] args) {
int a[] = {2, 1, 3, 6, 5, 4, 8, 7};
shellSort(a, 8);
for (int i = 0; i &lt; 8; i++) {
System.out.println(a[i]);
}
}

public static void shellSort(int a[], int n) {

int k = n / 2;//第一个间距 分成两个一组
while (k &gt; 0) {
for (int i = k; i &lt; n; i++)//从与第一个值间距 n/2开始比较
{
int t = a[i];//与第一个值间距 n/2的值
int j = i - k;//第一趟 i=k 取的第一个数
while (j &gt;= 0 &amp;&amp; t &lt; a[j])//后面的数是不是小 ？
{
a[j + k] = a[j];
j = j - k; //如果互换了 这里将变成负的
}
a[j + k] = t;
}


k = k / 2;
}



}
}



</code>
</RECORD>
<RECORD>
<snippet_key>139790</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Hadoop作业的一生  http://blog.csdn.net/lizhe10177/article/details/22861259#</comment>
<code>public static RunningJob runJob(JobConf job) throws IOException {
JobClient jc = new JobClient(job);
RunningJob rj = jc.submitJob(job);
try {
if (!jc.monitorAndPrintJob(job, rj)) {
throw new IOException(&quot;Job failed!&quot;);
}
} catch (InterruptedException ie) {
Thread.currentThread().interrupt();
}
return rj;
}
/**
* Submit a job to the MR system.
* This returns a handle to the {@link RunningJob} which can be used to track
* the running-job.
*
* @param job the job configuration.
* @return a handle to the {@link RunningJob} which can be used to track the
* running-job.
* @throws FileNotFoundException
* @throws IOException
*/
public RunningJob submitJob(JobConf job) throws FileNotFoundException,
IOException {
try {
return &lt;span style=&quot;color:#ff0000;&quot;&gt;submitJobInternal(job);
&lt;/span&gt; } catch (InterruptedException ie) {
throw new IOException(&quot;interrupted&quot;, ie);
} catch (ClassNotFoundException cnfe) {
throw new IOException(&quot;class not found&quot;, cnfe);
}
}
/**
* Internal method for submitting jobs to the system.
* @param job the configuration to submit
* @return a proxy object for the running job
* @throws FileNotFoundException
* @throws ClassNotFoundException
* @throws InterruptedException
* @throws IOException
*/
public
RunningJob submitJobInternal(JobConf job
) throws FileNotFoundException,
ClassNotFoundException,
InterruptedException,
IOException {
/*
* configure the command line options correctly on the submitting dfs
*/

JobID jobId = jobSubmitClient.&lt;span style=&quot;color:#ff0000;&quot;&gt;getNewJobId&lt;/span&gt;();//&lt;span style=&quot;color:#009900;&quot;&gt;1产生一个新的JobId
&lt;/span&gt; Path submitJobDir = new Path(&lt;span style=&quot;color:#ff0000;&quot;&gt;getSystemDir(), &lt;/span&gt;jobId.toString());//&lt;span style=&quot;color:#009900;&quot;&gt;2&lt;/span&gt;
Path submitJarFile = new Path(submitJobDir, &quot;job.jar&quot;);//&lt;span style=&quot;color:#009900;&quot;&gt;3
&lt;/span&gt; Path submitSplitFile = new Path(submitJobDir, &quot;job.split&quot;);
configureCommandLineOptions(job, submitJobDir, submitJarFile);//&lt;span style=&quot;color:#009900;&quot;&gt;4
&lt;/span&gt; Path submitJobFile = new Path(submitJobDir, &quot;job.xml&quot;);
int reduces = job.getNumReduceTasks();
JobContext context = new JobContext(job, jobId);

// Check the output specification
if (reduces == 0 ? job.getUseNewMapper() : job.getUseNewReducer()) {
org.apache.hadoop.mapreduce.OutputFormat&lt;?,?&gt; output =
ReflectionUtils.newInstance(context.getOutputFormatClass(), job);
output.checkOutputSpecs(context);
} else {
job.getOutputFormat().checkOutputSpecs(fs, job);
}

// Create the splits for the job
LOG.debug(&quot;Creating splits at &quot; + fs.makeQualified(submitSplitFile));
int maps;
if (job.getUseNewMapper()) {
maps = writeNewSplits(context, submitSplitFile);
} else {
maps = writeOldSplits(job, submitSplitFile);
}
job.set(&quot;mapred.job.split.file&quot;, submitSplitFile.toString());
job.setNumMapTasks(maps);

&lt;span style=&quot;color:#ff0000;&quot;&gt; // Write job file to JobTracker&apos;s fs &lt;/span&gt;
FSDataOutputStream out =
FileSystem.create(fs, submitJobFile,
new FsPermission(JOB_FILE_PERMISSION));

try {
job.writeXml(out);
} finally {
out.close();
}

&lt;span style=&quot;color:#ff0000;&quot;&gt; //
// Now, actually submit the job (using the submit name)
//
&lt;/span&gt; JobStatus status = jobSubmitClient.&lt;span style=&quot;color:#ff0000;&quot;&gt;submitJob&lt;/span&gt;(jobId);//&lt;span style=&quot;color:#009900;&quot;&gt;5
&lt;/span&gt; if (status != null) {
return new NetworkedJob(status);
} else {
throw new IOException(&quot;Could not launch job&quot;);
}
}
private static int jobid = 0;
public synchronized JobID getNewJobId() {
return new JobID(&quot;local&quot;, ++jobid);
}
public String getSystemDir() {
Path sysDir = new Path(conf.&lt;span style=&quot;color:#ff0000;&quot;&gt;get&lt;/span&gt;(&quot;mapred.system.dir&quot;, &quot;/tmp/hadoop/mapred/system&quot;));
return fs.makeQualified(sysDir).toString();
}
public String getSystemDir() {
Path sysDir = new Path(conf.&lt;span style=&quot;color:#ff0000;&quot;&gt;get&lt;/span&gt;(&quot;mapred.system.dir&quot;, &quot;/tmp/hadoop/mapred/system&quot;));
return fs.makeQualified(sysDir).toString();
}
/**
* configure the jobconf of the user with the command line options of
* -libjars, -files, -archives
* @param conf
* @throws IOException
*/
private void configureCommandLineOptions(JobConf job, Path submitJobDir, Path submitJarFile)
throws IOException {

if (!(job.getBoolean(&quot;mapred.used.genericoptionsparser&quot;, false))) {
LOG.warn(&quot;Use GenericOptionsParser for parsing the arguments. &quot; +
&quot;Applications should implement Tool for the same.&quot;);
}

// get all the command line arguments into the
// jobconf passed in by the user conf
String files = null;
String libjars = null;
String archives = null;

files = job.get(&quot;tmpfiles&quot;);
libjars = job.get(&quot;tmpjars&quot;);
archives = job.get(&quot;tmparchives&quot;);
/*
* &lt;span style=&quot;color:#ff0000;&quot;&gt;set this user&apos;s id in job configuration, so later job files can be
* accessed using this user&apos;s id&lt;/span&gt;
*/
UnixUserGroupInformation ugi = getUGI(job);

//
// Figure out what fs the JobTracker is using. Copy the
// job to it, under a temporary name. This allows DFS to work,
// and under the local fs also provides UNIX-like object loading
// semantics. (that is, if the job file is deleted right after
// submission, we can still run the submission to completion)
//

// Create a number of filenames in the JobTracker&apos;s fs namespace
FileSystem fs = getFs();
LOG.debug(&quot;default FileSystem: &quot; + fs.getUri());
fs.delete(submitJobDir, true);
submitJobDir = fs.makeQualified(submitJobDir);
submitJobDir = new Path(submitJobDir.toUri().getPath());
FsPermission mapredSysPerms = new FsPermission(JOB_DIR_PERMISSION);
FileSystem.mkdirs(fs, submitJobDir, mapredSysPerms);
Path filesDir = new Path(submitJobDir, &quot;files&quot;);
Path archivesDir = new Path(submitJobDir, &quot;archives&quot;);
Path libjarsDir = new Path(submitJobDir, &quot;libjars&quot;);
short replication = (short)job.getInt(&quot;mapred.submit.replication&quot;, 10);
// &lt;span style=&quot;color:#ff0000;&quot;&gt;add all the command line files/ jars and archive
// first copy them to jobtrackers filesystem
&lt;/span&gt;
if (files != null) {
FileSystem.mkdirs(fs, filesDir, mapredSysPerms);
String[] fileArr = files.split(&quot;,&quot;);
for (String tmpFile: fileArr) {
Path tmp = new Path(tmpFile);
Path newPath = copyRemoteFiles(fs,filesDir, tmp, job, replication);
try {
URI pathURI = new URI(newPath.toUri().toString() + &quot;#&quot; + newPath.getName());
DistributedCache.addCacheFile(pathURI, job);
} catch(URISyntaxException ue) {
//should not throw a uri exception
throw new IOException(&quot;Failed to create uri for &quot; + tmpFile);
}
DistributedCache.createSymlink(job);
}
}

if (libjars != null) {
FileSystem.mkdirs(fs, libjarsDir, mapredSysPerms);
String[] libjarsArr = libjars.split(&quot;,&quot;);
for (String tmpjars: libjarsArr) {
Path tmp = new Path(tmpjars);
Path newPath = copyRemoteFiles(fs, libjarsDir, tmp, job, replication);
DistributedCache.addArchiveToClassPath(newPath, job);
}
}


if (archives != null) {
FileSystem.mkdirs(fs, archivesDir, mapredSysPerms);
String[] archivesArr = archives.split(&quot;,&quot;);
for (String tmpArchives: archivesArr) {
Path tmp = new Path(tmpArchives);
Path newPath = copyRemoteFiles(fs, archivesDir, tmp, job, replication);
try {
URI pathURI = new URI(newPath.toUri().toString() + &quot;#&quot; + newPath.getName());
DistributedCache.addCacheArchive(pathURI, job);
} catch(URISyntaxException ue) {
//should not throw an uri excpetion
throw new IOException(&quot;Failed to create uri for &quot; + tmpArchives);
}
DistributedCache.createSymlink(job);
}
}

// set the timestamps of the archives and files
URI[] tarchives = DistributedCache.getCacheArchives(job);
if (tarchives != null) {
StringBuffer archiveTimestamps =
new StringBuffer(String.valueOf(DistributedCache.getTimestamp(job, tarchives[0])));
for (int i = 1; i &lt; tarchives.length; i++) {
archiveTimestamps.append(&quot;,&quot;);
archiveTimestamps.append(String.valueOf(DistributedCache.getTimestamp(job, tarchives[i])));
}
DistributedCache.setArchiveTimestamps(job, archiveTimestamps.toString());
}

URI[] tfiles = DistributedCache.getCacheFiles(job);
if (tfiles != null) {
StringBuffer fileTimestamps =
new StringBuffer(String.valueOf(DistributedCache.getTimestamp(job, tfiles[0])));
for (int i = 1; i &lt; tfiles.length; i++) {
fileTimestamps.append(&quot;,&quot;);
fileTimestamps.append(String.valueOf(DistributedCache.getTimestamp(job, tfiles[i])));
}
DistributedCache.setFileTimestamps(job, fileTimestamps.toString());
}

String originalJarPath = job.getJar();

if (originalJarPath != null) { // copy jar to JobTracker&apos;s fs
// use jar name if job is not named.
if (&quot;&quot;.equals(job.getJobName())){
job.setJobName(new Path(originalJarPath).getName());
}
job.setJar(submitJarFile.toString());
fs.copyFromLocalFile(new Path(originalJarPath), submitJarFile);
fs.setReplication(submitJarFile, replication);
fs.setPermission(submitJarFile, new FsPermission(JOB_FILE_PERMISSION));
} else {
LOG.warn(&quot;No job jar file set. User classes may not be found. &quot;+
&quot;See JobConf(Class) or JobConf#setJar(String).&quot;);
}

// &lt;span style=&quot;color:#ff0000;&quot;&gt;Set the user&apos;s name and working directory
&lt;/span&gt; job.setUser(ugi.getUserName());
if (ugi.getGroupNames().length &gt; 0) {
job.set(&quot;group.name&quot;, ugi.getGroupNames()[0]);
}
if (job.getWorkingDirectory() == null) {
job.setWorkingDirectory(fs.getWorkingDirectory());
}

}
public JobStatus submitJob(JobID jobid) throws IOException {
return new Job(jobid, this.conf).status;
}
public Job(JobID jobid, JobConf conf) throws IOException {
this.file = new Path(getSystemDir(), jobid + &quot;/job.xml&quot;);
this.id = jobid;
this.mapoutputFile = new MapOutputFile(jobid);
this.mapoutputFile.setConf(conf);

this.localFile = new JobConf(conf).getLocalPath(jobDir+id+&quot;.xml&quot;);
this.localFs = FileSystem.getLocal(conf);

fs.copyToLocalFile(file, localFile);
this.job = new JobConf(localFile);
profile = new JobProfile(job.getUser(), id, file.toString(),
&quot;http://localhost:8080/&quot;, job.getJobName());
status = new JobStatus(id, 0.0f, 0.0f, JobStatus.RUNNING);

jobs.put(id, this);

this.start();
}
public void run() {
JobID jobId = profile.getJobID();
JobContext jContext = new JobContext(conf, jobId);
OutputCommitter outputCommitter = job.getOutputCommitter();
try {
// split input into minimum number of splits
RawSplit[] rawSplits;
if (job.getUseNewMapper()) {
org.apache.hadoop.mapreduce.InputFormat&lt;?,?&gt; input =
ReflectionUtils.newInstance(jContext.getInputFormatClass(), jContext.getJobConf());

List&lt;org.apache.hadoop.mapreduce.InputSplit&gt; splits = input.getSplits(jContext);
rawSplits = new RawSplit[splits.size()];
DataOutputBuffer buffer = new DataOutputBuffer();
SerializationFactory factory = new SerializationFactory(conf);
Serializer serializer =
factory.getSerializer(splits.get(0).getClass());
serializer.open(buffer);
for (int i = 0; i &lt; splits.size(); i++) {
buffer.reset();
serializer.serialize(splits.get(i));
RawSplit rawSplit = new RawSplit();
rawSplit.setClassName(splits.get(i).getClass().getName());
rawSplit.setDataLength(splits.get(i).getLength());
rawSplit.setBytes(buffer.getData(), 0, buffer.getLength());
rawSplit.setLocations(splits.get(i).getLocations());
rawSplits[i] = rawSplit;
}

} else {
InputSplit[] splits = job.getInputFormat().getSplits(job, 1);
rawSplits = new RawSplit[splits.length];
DataOutputBuffer buffer = new DataOutputBuffer();
for (int i = 0; i &lt; splits.length; i++) {
buffer.reset();
splits[i].write(buffer);
RawSplit rawSplit = new RawSplit();
rawSplit.setClassName(splits[i].getClass().getName());
rawSplit.setDataLength(splits[i].getLength());
rawSplit.setBytes(buffer.getData(), 0, buffer.getLength());
rawSplit.setLocations(splits[i].getLocations());
rawSplits[i] = rawSplit;
}
}

int numReduceTasks = job.getNumReduceTasks();
if (numReduceTasks &gt; 1 || numReduceTasks &lt; 0) {
// we only allow 0 or 1 reducer in local mode
numReduceTasks = 1;
job.setNumReduceTasks(1);
}
outputCommitter.setupJob(jContext);
status.setSetupProgress(1.0f);
//根据分片数创建MapTask
for (int i = 0; i &lt; rawSplits.length; i++) {
if (!this.isInterrupted()) {
TaskAttemptID mapId = new TaskAttemptID(new TaskID(jobId, true, i),0);
mapIds.add(mapId);
MapTask map = new MapTask(file.toString(),
mapId, i,
rawSplits[i].getClassName(),
rawSplits[i].getBytes());
JobConf localConf = new JobConf(job);
map.setJobFile(localFile.toString());
map.localizeConfiguration(localConf);
map.setConf(localConf);
map_tasks += 1;
myMetrics.launchMap(mapId);
map.run(localConf, this);
myMetrics.completeMap(mapId);
map_tasks -= 1;
updateCounters(map);
} else {
throw new InterruptedException();
}
}
TaskAttemptID reduceId =
new TaskAttemptID(new TaskID(jobId, false, 0), 0);
try {
if (numReduceTasks &gt; 0) {
// move map output to reduce input
for (int i = 0; i &lt; mapIds.size(); i++) {
if (!this.isInterrupted()) {
TaskAttemptID mapId = mapIds.get(i);
Path mapOut = this.mapoutputFile.getOutputFile(mapId);
Path reduceIn = this.mapoutputFile.getInputFileForWrite(
mapId.getTaskID(),reduceId,
localFs.getLength(mapOut));
if (!localFs.mkdirs(reduceIn.getParent())) {
throw new IOException(&quot;Mkdirs failed to create &quot;
+ reduceIn.getParent().toString());
}
if (!localFs.rename(mapOut, reduceIn))
throw new IOException(&quot;Couldn&apos;t rename &quot; + mapOut);
} else {
throw new InterruptedException();
}
}
if (!this.isInterrupted()) {
ReduceTask reduce = new ReduceTask(file.toString(),
reduceId, 0, mapIds.size());
JobConf localConf = new JobConf(job);
reduce.setJobFile(localFile.toString());
reduce.localizeConfiguration(localConf);
reduce.setConf(localConf);
reduce_tasks += 1;
myMetrics.launchReduce(reduce.getTaskID());
reduce.run(localConf, this);
myMetrics.completeReduce(reduce.getTaskID());
reduce_tasks -= 1;
updateCounters(reduce);
} else {
throw new InterruptedException();
}
}
} finally {
for (TaskAttemptID mapId: mapIds) {
this.mapoutputFile.removeAll(mapId);
}
if (numReduceTasks == 1) {
this.mapoutputFile.removeAll(reduceId);
}
}
// delete the temporary directory in output directory
outputCommitter.cleanupJob(jContext);
status.setCleanupProgress(1.0f);

if (killed) {
this.status.setRunState(JobStatus.KILLED);
} else {
this.status.setRunState(JobStatus.SUCCEEDED);
}

JobEndNotifier.localRunnerNotification(job, status);

} catch (Throwable t) {
try {
outputCommitter.cleanupJob(jContext);
} catch (IOException ioe) {
LOG.info(&quot;Error cleaning up job:&quot; + id);
}
status.setCleanupProgress(1.0f);
if (killed) {
this.status.setRunState(JobStatus.KILLED);
} else {
this.status.setRunState(JobStatus.FAILED);
}
LOG.warn(id, t);

JobEndNotifier.localRunnerNotification(job, status);

} finally {
try {
fs.delete(file.getParent(), true); // delete submit dir
localFs.delete(localFile, true); // delete local copy
} catch (IOException e) {
LOG.warn(&quot;Error cleaning up &quot;+id+&quot;: &quot;+e);
}
}
}
/**
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements. See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership. The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* &quot;License&quot;); you may not use this file except in compliance
* with the License. You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
package org.apache.hadoop.mapred;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;

import org.apache.hadoop.io.Text;
import org.apache.hadoop.io.Writable;
import org.apache.hadoop.io.WritableFactories;
import org.apache.hadoop.io.WritableFactory;
import org.apache.hadoop.io.WritableUtils;

/**************************************************
* Describes the current status of a job. This is
* not intended to be a comprehensive piece of data.
* For that, look at JobProfile.
**************************************************/
public class JobStatus implements Writable, Cloneable {

static { // register a ctor
WritableFactories.setFactory
(JobStatus.class,
new WritableFactory() {
public Writable newInstance() { return new JobStatus(); }
});
}

public static final int RUNNING = 1;
public static final int SUCCEEDED = 2;
public static final int FAILED = 3;
public static final int PREP = 4;
public static final int KILLED = 5;

private JobID jobid;
private float mapProgress;
private float reduceProgress;
private float cleanupProgress;
private float setupProgress;
private int runState;
private long startTime;
private String user;
private JobPriority priority;
private String schedulingInfo=&quot;NA&quot;;

/**
*/
public JobStatus() {
}

/**
* Create a job status object for a given jobid.
* @param jobid The jobid of the job
* @param mapProgress The progress made on the maps
* @param reduceProgress The progress made on the reduces
* @param cleanupProgress The progress made on cleanup
* @param runState The current state of the job
*/
public JobStatus(JobID jobid, float mapProgress, float reduceProgress,
float cleanupProgress, int runState) {
this(jobid, mapProgress, reduceProgress, cleanupProgress, runState,
JobPriority.NORMAL);
}

/**
* Create a job status object for a given jobid.
* @param jobid The jobid of the job
* @param mapProgress The progress made on the maps
* @param reduceProgress The progress made on the reduces
* @param runState The current state of the job
*/
public JobStatus(JobID jobid, float mapProgress, float reduceProgress,
int runState) {
this(jobid, mapProgress, reduceProgress, 0.0f, runState);
}

/**
* Create a job status object for a given jobid.
* @param jobid The jobid of the job
* @param mapProgress The progress made on the maps
* @param reduceProgress The progress made on the reduces
* @param runState The current state of the job
* @param jp Priority of the job.
*/
public JobStatus(JobID jobid, float mapProgress, float reduceProgress,
float cleanupProgress, int runState, JobPriority jp) {
this(jobid, 0.0f, mapProgress, reduceProgress,
cleanupProgress, runState, jp);
}

/**
* Create a job status object for a given jobid.
* @param jobid The jobid of the job
* @param setupProgress The progress made on the setup
* @param mapProgress The progress made on the maps
* @param reduceProgress The progress made on the reduces
* @param cleanupProgress The progress made on the cleanup
* @param runState The current state of the job
* @param jp Priority of the job.
*/
public JobStatus(JobID jobid, float setupProgress, float mapProgress,
float reduceProgress, float cleanupProgress,
int runState, JobPriority jp) {
this.jobid = jobid;
this.setupProgress = setupProgress;
this.mapProgress = mapProgress;
this.reduceProgress = reduceProgress;
this.cleanupProgress = cleanupProgress;
this.runState = runState;
this.user = &quot;nobody&quot;;
if (jp == null) {
throw new IllegalArgumentException(&quot;Job Priority cannot be null.&quot;);
}
priority = jp;
}

/**
* @deprecated use getJobID instead
*/
@Deprecated
public String getJobId() { return jobid.toString(); }

/**
* @return The jobid of the Job
*/
public JobID getJobID() { return jobid; }

/**
* @return Percentage of progress in maps
*/
public synchronized float mapProgress() { return mapProgress; }

/**
* Sets the map progress of this job
* @param p The value of map progress to set to
*/
synchronized void setMapProgress(float p) {
this.mapProgress = (float) Math.min(1.0, Math.max(0.0, p));
}

/**
* @return Percentage of progress in cleanup
*/
public synchronized float cleanupProgress() { return cleanupProgress; }

/**
* Sets the cleanup progress of this job
* @param p The value of cleanup progress to set to
*/
synchronized void setCleanupProgress(float p) {
this.cleanupProgress = (float) Math.min(1.0, Math.max(0.0, p));
}

/**
* @return Percentage of progress in setup
*/
public synchronized float setupProgress() { return setupProgress; }

/**
* Sets the setup progress of this job
* @param p The value of setup progress to set to
*/
synchronized void setSetupProgress(float p) {
this.setupProgress = (float) Math.min(1.0, Math.max(0.0, p));
}

/**
* @return Percentage of progress in reduce
*/
public synchronized float reduceProgress() { return reduceProgress; }

/**
* Sets the reduce progress of this Job
* @param p The value of reduce progress to set to
*/
synchronized void setReduceProgress(float p) {
this.reduceProgress = (float) Math.min(1.0, Math.max(0.0, p));
}

/**
* @return running state of the job
*/
public synchronized int getRunState() { return runState; }

/**
* Change the current run state of the job.
*/
public synchronized void setRunState(int state) {
this.runState = state;
}

/**
* Set the start time of the job
* @param startTime The startTime of the job
*/
synchronized void setStartTime(long startTime) { this.startTime = startTime;}

/**
* @return start time of the job
*/
synchronized public long getStartTime() { return startTime;}

@Override
public Object clone() {
try {
return super.clone();
} catch (CloneNotSupportedException cnse) {
// Shouldn&apos;t happen since we do implement Clonable
throw new InternalError(cnse.toString());
}
}

/**
* @param user The username of the job
*/
synchronized void setUsername(String userName) { this.user = userName;}

/**
* @return the username of the job
*/
public synchronized String getUsername() { return this.user;}

/**
* Gets the Scheduling information associated to a particular Job.
* @return the scheduling information of the job
*/
public synchronized String getSchedulingInfo() {
return schedulingInfo;
}

/**
* Used to set the scheduling information associated to a particular Job.
*
* @param schedulingInfo Scheduling information of the job
*/
public synchronized void setSchedulingInfo(String schedulingInfo) {
this.schedulingInfo = schedulingInfo;
}

/**
* Return the priority of the job
* @return job priority
*/
public synchronized JobPriority getJobPriority() { return priority; }

/**
* Set the priority of the job, defaulting to NORMAL.
* @param jp new job priority
*/
public synchronized void setJobPriority(JobPriority jp) {
if (jp == null) {
throw new IllegalArgumentException(&quot;Job priority cannot be null.&quot;);
}
priority = jp;
}

/**
* Returns true if the status is for a completed job.
*/
public synchronized boolean isJobComplete() {
return (runState == JobStatus.SUCCEEDED || runState == JobStatus.FAILED
|| runState == JobStatus.KILLED);
}

///////////////////////////////////////
// Writable
///////////////////////////////////////
public synchronized void write(DataOutput out) throws IOException {
jobid.write(out);
out.writeFloat(setupProgress);
out.writeFloat(mapProgress);
out.writeFloat(reduceProgress);
out.writeFloat(cleanupProgress);
out.writeInt(runState);
out.writeLong(startTime);
Text.writeString(out, user);
WritableUtils.writeEnum(out, priority);
Text.writeString(out, schedulingInfo);
}

public synchronized void readFields(DataInput in) throws IOException {
this.jobid = JobID.read(in);
this.setupProgress = in.readFloat();
this.mapProgress = in.readFloat();
this.reduceProgress = in.readFloat();
this.cleanupProgress = in.readFloat();
this.runState = in.readInt();
this.startTime = in.readLong();
this.user = Text.readString(in);
this.priority = WritableUtils.readEnum(in, JobPriority.class);
this.schedulingInfo = Text.readString(in);
}
}
public void run(final JobConf job, final TaskUmbilicalProtocol umbilical)
throws IOException, ClassNotFoundException, InterruptedException {
this.umbilical = umbilical;

// start thread that will handle communication with parent
TaskReporter reporter = new TaskReporter(getProgress(), umbilical);
reporter.startCommunicationThread();
boolean useNewApi = job.getUseNewMapper();
initialize(job, getJobID(), reporter, useNewApi);

// check if it is a cleanupJobTask
if (jobCleanup) {
runJobCleanupTask(umbilical, reporter);
return;
}
if (jobSetup) {
runJobSetupTask(umbilical, reporter);
return;
}
if (taskCleanup) {
runTaskCleanupTask(umbilical, reporter);
return;
}

if (useNewApi) {
runNewMapper(job, split, umbilical, reporter);
} else {
runOldMapper(job, split, umbilical, reporter);
}
done(umbilical, reporter);
}
private &lt;INKEY,INVALUE,OUTKEY,OUTVALUE&gt;
void runNewMapper(final JobConf job,
final BytesWritable rawSplit,
final TaskUmbilicalProtocol umbilical,
TaskReporter reporter
) throws IOException, ClassNotFoundException,
InterruptedException {
// make a task context so we can get the classes
org.apache.hadoop.mapreduce.TaskAttemptContext taskContext =
new org.apache.hadoop.mapreduce.TaskAttemptContext(job, getTaskID());
// make a mapper
org.apache.hadoop.mapreduce.Mapper&lt;INKEY,INVALUE,OUTKEY,OUTVALUE&gt; mapper =
(org.apache.hadoop.mapreduce.Mapper&lt;INKEY,INVALUE,OUTKEY,OUTVALUE&gt;)
ReflectionUtils.newInstance(taskContext.getMapperClass(), job);
// make the input format
org.apache.hadoop.mapreduce.InputFormat&lt;INKEY,INVALUE&gt; inputFormat =
(org.apache.hadoop.mapreduce.InputFormat&lt;INKEY,INVALUE&gt;)
ReflectionUtils.newInstance(taskContext.getInputFormatClass(), job);
// rebuild the input split
org.apache.hadoop.mapreduce.InputSplit split = null;
DataInputBuffer splitBuffer = new DataInputBuffer();
splitBuffer.reset(rawSplit.getBytes(), 0, rawSplit.getLength());
SerializationFactory factory = new SerializationFactory(job);
Deserializer&lt;? extends org.apache.hadoop.mapreduce.InputSplit&gt;
deserializer =
(Deserializer&lt;? extends org.apache.hadoop.mapreduce.InputSplit&gt;)
factory.getDeserializer(job.getClassByName(splitClass));
deserializer.open(splitBuffer);
split = deserializer.deserialize(null);

org.apache.hadoop.mapreduce.RecordReader&lt;INKEY,INVALUE&gt; input =
new NewTrackingRecordReader&lt;INKEY,INVALUE&gt;
(inputFormat.createRecordReader(split, taskContext), reporter);

job.setBoolean(&quot;mapred.skip.on&quot;, isSkipping());
org.apache.hadoop.mapreduce.RecordWriter output = null;
org.apache.hadoop.mapreduce.Mapper&lt;INKEY,INVALUE,OUTKEY,OUTVALUE&gt;.Context
mapperContext = null;
try {
Constructor&lt;org.apache.hadoop.mapreduce.Mapper.Context&gt; contextConstructor =
org.apache.hadoop.mapreduce.Mapper.Context.class.getConstructor
(new Class[]{org.apache.hadoop.mapreduce.Mapper.class,
Configuration.class,
org.apache.hadoop.mapreduce.TaskAttemptID.class,
org.apache.hadoop.mapreduce.RecordReader.class,
org.apache.hadoop.mapreduce.RecordWriter.class,
org.apache.hadoop.mapreduce.OutputCommitter.class,
org.apache.hadoop.mapreduce.StatusReporter.class,
org.apache.hadoop.mapreduce.InputSplit.class});

// get an output object
if (job.getNumReduceTasks() == 0) {
output =
new NewDirectOutputCollector(taskContext, job, umbilical, reporter);
} else {
output = new NewOutputCollector(taskContext, job, umbilical, reporter);
}

mapperContext = contextConstructor.newInstance(mapper, job, getTaskID(),
input, output, committer,
reporter, split);

input.initialize(split, mapperContext);
mapper.run(mapperContext);//////////////////////////
input.close();
output.close(mapperContext);
} catch (NoSuchMethodException e) {
throw new IOException(&quot;Can&apos;t find Context constructor&quot;, e);
} catch (InstantiationException e) {
throw new IOException(&quot;Can&apos;t create Context&quot;, e);
} catch (InvocationTargetException e) {
throw new IOException(&quot;Can&apos;t invoke Context constructor&quot;, e);
} catch (IllegalAccessException e) {
throw new IOException(&quot;Can&apos;t invoke Context constructor&quot;, e);
}
}
public void init(JobConf conf) throws IOException {
String tracker = conf.get(&quot;mapred.job.tracker&quot;, &quot;local&quot;);
if (&quot;local&quot;.equals(tracker)) {
this.jobSubmitClient = new LocalJobRunner(conf);
} else {
this.jobSubmitClient = createRPCProxy(JobTracker.getAddress(conf), conf);
}
}
/**
* JobTracker.submitJob() kicks off a new job.
*
* Create a &apos;JobInProgress&apos; object, which contains both JobProfile
* and JobStatus. Those two sub-objects are sometimes shipped outside
* of the JobTracker. But JobInProgress adds info that&apos;s useful for
* the JobTracker alone.
*/
public synchronized JobStatus submitJob(JobID jobId) throws IOException {
if(jobs.containsKey(jobId)) {
//job already running, don&apos;t start twice
return jobs.get(jobId).getStatus();
}

JobInProgress job = new JobInProgress(jobId, this, this.conf);

String queue = job.getProfile().getQueueName();
if(!(queueManager.getQueues().contains(queue))) {
new CleanupQueue().addToQueue(conf,getSystemDirectoryForJob(jobId));
throw new IOException(&quot;Queue \&quot;&quot; + queue + &quot;\&quot; does not exist&quot;);
}

// check for access
try {
checkAccess(job, QueueManager.QueueOperation.SUBMIT_JOB);
} catch (IOException ioe) {
LOG.warn(&quot;Access denied for user &quot; + job.getJobConf().getUser()
+ &quot;. Ignoring job &quot; + jobId, ioe);
new CleanupQueue().addToQueue(conf, getSystemDirectoryForJob(jobId));
throw ioe;
}

// Check the job if it cannot run in the cluster because of invalid memory
// requirements.
try {
checkMemoryRequirements(job);
} catch (IOException ioe) {
new CleanupQueue().addToQueue(conf, getSystemDirectoryForJob(jobId));
throw ioe;
}

return addJob(jobId, job);
}
/**
* Adds a job to the jobtracker. Make sure that the checks are inplace before
* adding a job. This is the core job submission logic
* @param jobId The id for the job submitted which needs to be added
*/
private synchronized JobStatus addJob(JobID jobId, JobInProgress job) {
totalSubmissions++;

synchronized (jobs) {
synchronized (taskScheduler) {
jobs.put(job.getProfile().getJobID(), job);
for (JobInProgressListener listener : jobInProgressListeners) {
try {
listener.jobAdded(job);
} catch (IOException ioe) {
LOG.warn(&quot;Failed to add and so skipping the job : &quot;
+ job.getJobID() + &quot;. Exception : &quot; + ioe);
}
}
}
}
myInstrumentation.submitJob(job.getJobConf(), jobId);
return job.getStatus();
}
JobClient jc = new JobClient(job);
RunningJob rj = jc.submitJob(job);
return submitJobInternal(job);
int maps;
if (job.getUseNewMapper()) {
maps = writeNewSplits(context, submitSplitFile);
} else {
maps = writeOldSplits(job, submitSplitFile);
}
job.set(&quot;mapred.job.split.file&quot;, submitSplitFile.toString());
job.setNumMapTasks(maps);
FSDataOutputStream out =
FileSystem.create(fs, submitJobFile,
new FsPermission(JOB_FILE_PERMISSION));

try {
job.writeXml(out);
} finally {
out.close();
}
configureCommandLineOptions(job, submitJobDir, submitJarFile);
JobStatus status = jobSubmitClient.submitJob(jobId);
this.jobSubmitClient = createRPCProxy(JobTracker.getAddress(conf), conf);
JobInProgress job = new JobInProgress(jobId, this, this.conf);
return addJob(jobId, job);
JobID jobId = jobSubmitClient.getNewJobId();
public
RunningJob submitJobInternal(JobConf job
) throws FileNotFoundException,
ClassNotFoundException,
InterruptedException,
IOException {
/*
* configure the command line options correctly on the submitting dfs
*/

JobID jobId = jobSubmitClient.getNewJobId();
Path submitJobDir = new Path(getSystemDir(), jobId.toString());
Path submitJarFile = new Path(submitJobDir, &quot;job.jar&quot;);
Path submitSplitFile = new Path(submitJobDir, &quot;job.split&quot;);
configureCommandLineOptions(job, submitJobDir, submitJarFile);
Path submitJobFile = new Path(submitJobDir, &quot;job.xml&quot;);
int reduces = job.getNumReduceTasks();
JobContext context = new JobContext(job, jobId);

// Check the output specification
if (reduces == 0 ? job.getUseNewMapper() : job.getUseNewReducer()) {
org.apache.hadoop.mapreduce.OutputFormat&lt;?,?&gt; output =
ReflectionUtils.newInstance(context.getOutputFormatClass(), job);
output.checkOutputSpecs(context);
} else {
job.getOutputFormat().checkOutputSpecs(fs, job);
}

// Create the splits for the job
LOG.debug(&quot;Creating splits at &quot; + fs.makeQualified(submitSplitFile));
int maps;
if (job.getUseNewMapper()) {
maps = writeNewSplits(context, submitSplitFile);
} else {
maps = writeOldSplits(job, submitSplitFile);
}
job.set(&quot;mapred.job.split.file&quot;, submitSplitFile.toString());
job.setNumMapTasks(maps);

// Write job file to JobTracker&apos;s fs
FSDataOutputStream out =
FileSystem.create(fs, submitJobFile,
new FsPermission(JOB_FILE_PERMISSION));

try {
job.writeXml(out);
} finally {
out.close();
}

//
// Now, actually submit the job (using the submit name)
//
JobStatus status = jobSubmitClient.submitJob(jobId);
if (status != null) {
return new NetworkedJob(status);
} else {
throw new IOException(&quot;Could not launch job&quot;);
}
}
private JobSubmissionProtocol jobSubmitClient;
public void init(JobConf conf) throws IOException {
String tracker = conf.get(&quot;mapred.job.tracker&quot;, &quot;local&quot;);
if (&quot;local&quot;.equals(tracker)) {
this.jobSubmitClient = new LocalJobRunner(conf);
} else {
this.jobSubmitClient = createRPCProxy(JobTracker.getAddress(conf), conf);
}
}
submitJobInternal完整方法
它的主要代码为
其中的listener调用JobTracker的initJob方法初始化job，生成与job.split的个数相应的任务。
之后job被添加进job队列等待调度。
&lt;p&gt; &lt;/p&gt;&lt;pre class=&quot;java&quot; name=&quot;code&quot;&gt;public class WordCount {

public static class TokenizerMapper extends
Mapper&lt;Object, Text, Text, IntWritable&gt; {

private final static IntWritable one = new IntWritable(1);
private Text word = new Text();

public void map(Object key, Text value, Context context)
throws IOException, InterruptedException {
// StringTokenizer itr = new StringTokenizer(value.toString());
String line = value.toString();
String[] line1 = line.split(&quot;\\W&quot;);
for (String line2 : line1) {
String[] words = line2.split(&quot; &quot;);
for (String wordend : words) {
word.set(wordend);
context.write(word, one);
}
}
// while (itr.hasMoreTokens()) {
// word.set(itr.nextToken());
// context.write(word, one);
// }
}
}

public static class IntSumReducer extends
Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {
private IntWritable result = new IntWritable();

public void reduce(Text key, Iterable&lt;IntWritable&gt; values,
Context context) throws IOException, InterruptedException {
int sum = 0;
for (IntWritable val : values) {
sum += val.get();
}
result.set(sum);
context.write(key, result);
}
}

public static void main(String[] args) throws Exception {
try {
Configuration conf = new Configuration();
String[] otherArgs = new GenericOptionsParser(conf, args)
.getRemainingArgs();
if (otherArgs.length != 2) {
System.err.println(&quot;Usage: wordcount &lt;in&gt; &lt;out&gt;&quot;);
System.exit(2);
}
Job job = new Job(conf, &quot;word count&quot;);
job.setJarByClass(WordCount.class);
job.setMapperClass(TokenizerMapper.class);
job.setCombinerClass(IntSumReducer.class);
job.setReducerClass(IntSumReducer.class);
job.setOutputKeyClass(Text.class);
job.setOutputValueClass(IntWritable.class);
FileInputFormat.addInputPath(job, new Path(otherArgs[0]));
FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));
System.out.println(&quot;job start!&quot;);
System.exit(job.waitForCompletion(true) ? 0 : 1);
System.out.println(&quot;completed!&quot;);
} catch (Exception e) {
e.printStackTrace();
}

}
}
public boolean waitForCompletion(boolean verbose
) throws IOException, InterruptedException,
ClassNotFoundException {
if (state == JobState.DEFINE) {
submit();
}
if (verbose) {
jobClient.monitorAndPrintJob(conf, info);
} else {
info.waitForCompletion();
}
return isSuccessful();
}
public void submit() throws IOException, InterruptedException,
ClassNotFoundException {
ensureState(JobState.DEFINE);
setUseNewAPI();
info = jobClient.submitJobInternal(conf);
super.setJobID(info.getID());
state = JobState.RUNNING;
}
public Job(Configuration conf) throws IOException {
super(conf, null);
jobClient = new JobClient((JobConf) getConfiguration());
}
public
RunningJob submitJobInternal(JobConf job
) throws FileNotFoundException,
ClassNotFoundException,
InterruptedException,
IOException {
/*
* configure the command line options correctly on the submitting dfs
*/

JobID jobId = jobSubmitClient.getNewJobId();
Path submitJobDir = new Path(getSystemDir(), jobId.toString());
Path submitJarFile = new Path(submitJobDir, &quot;job.jar&quot;);
Path submitSplitFile = new Path(submitJobDir, &quot;job.split&quot;);
configureCommandLineOptions(job, submitJobDir, submitJarFile);
Path submitJobFile = new Path(submitJobDir, &quot;job.xml&quot;);
int reduces = job.getNumReduceTasks();
JobContext context = new JobContext(job, jobId);

// Check the output specification
if (reduces == 0 ? job.getUseNewMapper() : job.getUseNewReducer()) {
org.apache.hadoop.mapreduce.OutputFormat&lt;?,?&gt; output =
ReflectionUtils.newInstance(context.getOutputFormatClass(), job);
output.checkOutputSpecs(context);
} else {
job.getOutputFormat().checkOutputSpecs(fs, job);
}

// Create the splits for the job
LOG.debug(&quot;Creating splits at &quot; + fs.makeQualified(submitSplitFile));
int maps;
if (job.getUseNewMapper()) {
maps = writeNewSplits(context, submitSplitFile);
} else {
maps = writeOldSplits(job, submitSplitFile);
}
job.set(&quot;mapred.job.split.file&quot;, submitSplitFile.toString());
job.setNumMapTasks(maps);

// Write job file to JobTracker&apos;s fs
FSDataOutputStream out =
FileSystem.create(fs, submitJobFile,
new FsPermission(JOB_FILE_PERMISSION));

try {
job.writeXml(out);
} finally {
out.close();
}

//
// Now, actually submit the job (using the submit name)
//
JobStatus status = jobSubmitClient.submitJob(jobId);
if (status != null) {
return new NetworkedJob(status);
} else {
throw new IOException(&quot;Could not launch job&quot;);
}
}
&lt;p&gt; &lt;/p&gt;&lt;pre class=&quot;java&quot; name=&quot;code&quot;&gt;public class WordCount {

public static class TokenizerMapper extends
Mapper&lt;Object, Text, Text, IntWritable&gt; {

private final static IntWritable one = new IntWritable(1);
private Text word = new Text();

public void map(Object key, Text value, Context context)
throws IOException, InterruptedException {
// StringTokenizer itr = new StringTokenizer(value.toString());
String line = value.toString();
String[] line1 = line.split(&quot;\\W&quot;);
for (String line2 : line1) {
String[] words = line2.split(&quot; &quot;);
for (String wordend : words) {
word.set(wordend);
context.write(word, one);
}
}
// while (itr.hasMoreTokens()) {
// word.set(itr.nextToken());
// context.write(word, one);
// }
}
}

public static class IntSumReducer extends
Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {
private IntWritable result = new IntWritable();

public void reduce(Text key, Iterable&lt;IntWritable&gt; values,
Context context) throws IOException, InterruptedException {
int sum = 0;
for (IntWritable val : values) {
sum += val.get();
}
result.set(sum);
context.write(key, result);
}
}

public static void main(String[] args) throws Exception {
try {
Configuration conf = new Configuration();
String[] otherArgs = new GenericOptionsParser(conf, args)
.getRemainingArgs();
if (otherArgs.length != 2) {
System.err.println(&quot;Usage: wordcount &lt;in&gt; &lt;out&gt;&quot;);
System.exit(2);
}
Job job = new Job(conf, &quot;word count&quot;);
job.setJarByClass(WordCount.class);
job.setMapperClass(TokenizerMapper.class);
job.setCombinerClass(IntSumReducer.class);
job.setReducerClass(IntSumReducer.class);
job.setOutputKeyClass(Text.class);
job.setOutputValueClass(IntWritable.class);
FileInputFormat.addInputPath(job, new Path(otherArgs[0]));
FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));
System.out.println(&quot;job start!&quot;);
System.exit(job.waitForCompletion(true) ? 0 : 1);
System.out.println(&quot;completed!&quot;);
} catch (Exception e) {
e.printStackTrace();
}

}
}
public boolean waitForCompletion(boolean verbose
) throws IOException, InterruptedException,
ClassNotFoundException {
if (state == JobState.DEFINE) {
submit();
}
if (verbose) {
jobClient.monitorAndPrintJob(conf, info);
} else {
info.waitForCompletion();
}
return isSuccessful();
}
public void submit() throws IOException, InterruptedException,
ClassNotFoundException {
ensureState(JobState.DEFINE);
setUseNewAPI();
info = jobClient.submitJobInternal(conf);
super.setJobID(info.getID());
state = JobState.RUNNING;
}
public Job(Configuration conf) throws IOException {
super(conf, null);
jobClient = new JobClient((JobConf) getConfiguration());
}
public
RunningJob submitJobInternal(JobConf job
) throws FileNotFoundException,
ClassNotFoundException,
InterruptedException,
IOException {
/*
* configure the command line options correctly on the submitting dfs
*/

JobID jobId = jobSubmitClient.getNewJobId();
Path submitJobDir = new Path(getSystemDir(), jobId.toString());
Path submitJarFile = new Path(submitJobDir, &quot;job.jar&quot;);
Path submitSplitFile = new Path(submitJobDir, &quot;job.split&quot;);
configureCommandLineOptions(job, submitJobDir, submitJarFile);
Path submitJobFile = new Path(submitJobDir, &quot;job.xml&quot;);
int reduces = job.getNumReduceTasks();
JobContext context = new JobContext(job, jobId);

// Check the output specification
if (reduces == 0 ? job.getUseNewMapper() : job.getUseNewReducer()) {
org.apache.hadoop.mapreduce.OutputFormat&lt;?,?&gt; output =
ReflectionUtils.newInstance(context.getOutputFormatClass(), job);
output.checkOutputSpecs(context);
} else {
job.getOutputFormat().checkOutputSpecs(fs, job);
}

// Create the splits for the job
LOG.debug(&quot;Creating splits at &quot; + fs.makeQualified(submitSplitFile));
int maps;
if (job.getUseNewMapper()) {
maps = writeNewSplits(context, submitSplitFile);
} else {
maps = writeOldSplits(job, submitSplitFile);
}
job.set(&quot;mapred.job.split.file&quot;, submitSplitFile.toString());
job.setNumMapTasks(maps);

// Write job file to JobTracker&apos;s fs
FSDataOutputStream out =
FileSystem.create(fs, submitJobFile,
new FsPermission(JOB_FILE_PERMISSION));

try {
job.writeXml(out);
} finally {
out.close();
}

//
// Now, actually submit the job (using the submit name)
//
JobStatus status = jobSubmitClient.submitJob(jobId);
if (status != null) {
return new NetworkedJob(status);
} else {
throw new IOException(&quot;Could not launch job&quot;);
}
}
private JobSubmissionProtocol createRPCProxy(InetSocketAddress addr,
Configuration conf) throws IOException {
return (JobSubmissionProtocol) RPC.getProxy(JobSubmissionProtocol.class,
JobSubmissionProtocol.versionID, addr, getUGI(conf), conf,
NetUtils.getSocketFactory(conf, JobSubmissionProtocol.class));
}
&lt;p&gt; &lt;/p&gt;&lt;pre class=&quot;java&quot; name=&quot;code&quot;&gt;public class WordCount {

public static class TokenizerMapper extends
Mapper&lt;Object, Text, Text, IntWritable&gt; {

private final static IntWritable one = new IntWritable(1);
private Text word = new Text();

public void map(Object key, Text value, Context context)
throws IOException, InterruptedException {
// StringTokenizer itr = new StringTokenizer(value.toString());
String line = value.toString();
String[] line1 = line.split(&quot;\\W&quot;);
for (String line2 : line1) {
String[] words = line2.split(&quot; &quot;);
for (String wordend : words) {
word.set(wordend);
context.write(word, one);
}
}
// while (itr.hasMoreTokens()) {
// word.set(itr.nextToken());
// context.write(word, one);
// }
}
}

public static class IntSumReducer extends
Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {
private IntWritable result = new IntWritable();

public void reduce(Text key, Iterable&lt;IntWritable&gt; values,
Context context) throws IOException, InterruptedException {
int sum = 0;
for (IntWritable val : values) {
sum += val.get();
}
result.set(sum);
context.write(key, result);
}
}

public static void main(String[] args) throws Exception {
try {
Configuration conf = new Configuration();
String[] otherArgs = new GenericOptionsParser(conf, args)
.getRemainingArgs();
if (otherArgs.length != 2) {
System.err.println(&quot;Usage: wordcount &lt;in&gt; &lt;out&gt;&quot;);
System.exit(2);
}
Job job = new Job(conf, &quot;word count&quot;);
job.setJarByClass(WordCount.class);
job.setMapperClass(TokenizerMapper.class);
job.setCombinerClass(IntSumReducer.class);
job.setReducerClass(IntSumReducer.class);
job.setOutputKeyClass(Text.class);
job.setOutputValueClass(IntWritable.class);
FileInputFormat.addInputPath(job, new Path(otherArgs[0]));
FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));
System.out.println(&quot;job start!&quot;);
System.exit(job.waitForCompletion(true) ? 0 : 1);
System.out.println(&quot;completed!&quot;);
} catch (Exception e) {
e.printStackTrace();
}

}
}
public boolean waitForCompletion(boolean verbose
) throws IOException, InterruptedException,
ClassNotFoundException {
if (state == JobState.DEFINE) {
submit();
}
if (verbose) {
jobClient.monitorAndPrintJob(conf, info);
} else {
info.waitForCompletion();
}
return isSuccessful();
}
public void submit() throws IOException, InterruptedException,
ClassNotFoundException {
ensureState(JobState.DEFINE);
setUseNewAPI();
info = jobClient.submitJobInternal(conf);
super.setJobID(info.getID());
state = JobState.RUNNING;
}
public Job(Configuration conf) throws IOException {
super(conf, null);
jobClient = new JobClient((JobConf) getConfiguration());
}
public
RunningJob submitJobInternal(JobConf job
) throws FileNotFoundException,
ClassNotFoundException,
InterruptedException,
IOException {
/*
* configure the command line options correctly on the submitting dfs
*/

JobID jobId = jobSubmitClient.getNewJobId();
Path submitJobDir = new Path(getSystemDir(), jobId.toString());
Path submitJarFile = new Path(submitJobDir, &quot;job.jar&quot;);
Path submitSplitFile = new Path(submitJobDir, &quot;job.split&quot;);
configureCommandLineOptions(job, submitJobDir, submitJarFile);
Path submitJobFile = new Path(submitJobDir, &quot;job.xml&quot;);
int reduces = job.getNumReduceTasks();
JobContext context = new JobContext(job, jobId);

// Check the output specification
if (reduces == 0 ? job.getUseNewMapper() : job.getUseNewReducer()) {
org.apache.hadoop.mapreduce.OutputFormat&lt;?,?&gt; output =
ReflectionUtils.newInstance(context.getOutputFormatClass(), job);
output.checkOutputSpecs(context);
} else {
job.getOutputFormat().checkOutputSpecs(fs, job);
}

// Create the splits for the job
LOG.debug(&quot;Creating splits at &quot; + fs.makeQualified(submitSplitFile));
int maps;
if (job.getUseNewMapper()) {
maps = writeNewSplits(context, submitSplitFile);
} else {
maps = writeOldSplits(job, submitSplitFile);
}
job.set(&quot;mapred.job.split.file&quot;, submitSplitFile.toString());
job.setNumMapTasks(maps);

// Write job file to JobTracker&apos;s fs
FSDataOutputStream out =
FileSystem.create(fs, submitJobFile,
new FsPermission(JOB_FILE_PERMISSION));

try {
job.writeXml(out);
} finally {
out.close();
}

//
// Now, actually submit the job (using the submit name)
//
JobStatus status = jobSubmitClient.submitJob(jobId);
if (status != null) {
return new NetworkedJob(status);
} else {
throw new IOException(&quot;Could not launch job&quot;);
}
}
private JobSubmissionProtocol createRPCProxy(InetSocketAddress addr,
Configuration conf) throws IOException {
return (JobSubmissionProtocol) RPC.getProxy(JobSubmissionProtocol.class,
JobSubmissionProtocol.versionID, addr, getUGI(conf), conf,
NetUtils.getSocketFactory(conf, JobSubmissionProtocol.class));
}
&lt;p&gt; &lt;/p&gt;&lt;pre class=&quot;java&quot; name=&quot;code&quot;&gt;public class WordCount {

public static class TokenizerMapper extends
Mapper&lt;Object, Text, Text, IntWritable&gt; {

private final static IntWritable one = new IntWritable(1);
private Text word = new Text();

public void map(Object key, Text value, Context context)
throws IOException, InterruptedException {
// StringTokenizer itr = new StringTokenizer(value.toString());
String line = value.toString();
String[] line1 = line.split(&quot;\\W&quot;);
for (String line2 : line1) {
String[] words = line2.split(&quot; &quot;);
for (String wordend : words) {
word.set(wordend);
context.write(word, one);
}
}
// while (itr.hasMoreTokens()) {
// word.set(itr.nextToken());
// context.write(word, one);
// }
}
}

public static class IntSumReducer extends
Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {
private IntWritable result = new IntWritable();

public void reduce(Text key, Iterable&lt;IntWritable&gt; values,
Context context) throws IOException, InterruptedException {
int sum = 0;
for (IntWritable val : values) {
sum += val.get();
}
result.set(sum);
context.write(key, result);
}
}

public static void main(String[] args) throws Exception {
try {
Configuration conf = new Configuration();
String[] otherArgs = new GenericOptionsParser(conf, args)
.getRemainingArgs();
if (otherArgs.length != 2) {
System.err.println(&quot;Usage: wordcount &lt;in&gt; &lt;out&gt;&quot;);
System.exit(2);
}
Job job = new Job(conf, &quot;word count&quot;);
job.setJarByClass(WordCount.class);
job.setMapperClass(TokenizerMapper.class);
job.setCombinerClass(IntSumReducer.class);
job.setReducerClass(IntSumReducer.class);
job.setOutputKeyClass(Text.class);
job.setOutputValueClass(IntWritable.class);
FileInputFormat.addInputPath(job, new Path(otherArgs[0]));
FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));
System.out.println(&quot;job start!&quot;);
System.exit(job.waitForCompletion(true) ? 0 : 1);
System.out.println(&quot;completed!&quot;);
} catch (Exception e) {
e.printStackTrace();
}

}
}
public boolean waitForCompletion(boolean verbose
) throws IOException, InterruptedException,
ClassNotFoundException {
if (state == JobState.DEFINE) {
submit();
}
if (verbose) {
jobClient.monitorAndPrintJob(conf, info);
} else {
info.waitForCompletion();
}
return isSuccessful();
}
public void submit() throws IOException, InterruptedException,
ClassNotFoundException {
ensureState(JobState.DEFINE);
setUseNewAPI();
info = jobClient.submitJobInternal(conf);
super.setJobID(info.getID());
state = JobState.RUNNING;
}
public Job(Configuration conf) throws IOException {
super(conf, null);
jobClient = new JobClient((JobConf) getConfiguration());
}
public
RunningJob submitJobInternal(JobConf job
) throws FileNotFoundException,
ClassNotFoundException,
InterruptedException,
IOException {
/*
* configure the command line options correctly on the submitting dfs
*/

JobID jobId = jobSubmitClient.getNewJobId();
Path submitJobDir = new Path(getSystemDir(), jobId.toString());
Path submitJarFile = new Path(submitJobDir, &quot;job.jar&quot;);
Path submitSplitFile = new Path(submitJobDir, &quot;job.split&quot;);
configureCommandLineOptions(job, submitJobDir, submitJarFile);
Path submitJobFile = new Path(submitJobDir, &quot;job.xml&quot;);
int reduces = job.getNumReduceTasks();
JobContext context = new JobContext(job, jobId);

// Check the output specification
if (reduces == 0 ? job.getUseNewMapper() : job.getUseNewReducer()) {
org.apache.hadoop.mapreduce.OutputFormat&lt;?,?&gt; output =
ReflectionUtils.newInstance(context.getOutputFormatClass(), job);
output.checkOutputSpecs(context);
} else {
job.getOutputFormat().checkOutputSpecs(fs, job);
}

// Create the splits for the job
LOG.debug(&quot;Creating splits at &quot; + fs.makeQualified(submitSplitFile));
int maps;
if (job.getUseNewMapper()) {
maps = writeNewSplits(context, submitSplitFile);
} else {
maps = writeOldSplits(job, submitSplitFile);
}
job.set(&quot;mapred.job.split.file&quot;, submitSplitFile.toString());
job.setNumMapTasks(maps);

// Write job file to JobTracker&apos;s fs
FSDataOutputStream out =
FileSystem.create(fs, submitJobFile,
new FsPermission(JOB_FILE_PERMISSION));

try {
job.writeXml(out);
} finally {
out.close();
}

//
// Now, actually submit the job (using the submit name)
//
JobStatus status = jobSubmitClient.submitJob(jobId);
if (status != null) {
return new NetworkedJob(status);
} else {
throw new IOException(&quot;Could not launch job&quot;);
}
}
private JobSubmissionProtocol createRPCProxy(InetSocketAddress addr,
Configuration conf) throws IOException {
return (JobSubmissionProtocol) RPC.getProxy(JobSubmissionProtocol.class,
JobSubmissionProtocol.versionID, addr, getUGI(conf), conf,
NetUtils.getSocketFactory(conf, JobSubmissionProtocol.class));
}
&lt;p&gt; &lt;/p&gt;&lt;pre class=&quot;java&quot; name=&quot;code&quot;&gt;public class WordCount {

public static class TokenizerMapper extends
Mapper&lt;Object, Text, Text, IntWritable&gt; {

private final static IntWritable one = new IntWritable(1);
private Text word = new Text();

public void map(Object key, Text value, Context context)
throws IOException, InterruptedException {
// StringTokenizer itr = new StringTokenizer(value.toString());
String line = value.toString();
String[] line1 = line.split(&quot;\\W&quot;);
for (String line2 : line1) {
String[] words = line2.split(&quot; &quot;);
for (String wordend : words) {
word.set(wordend);
context.write(word, one);
}
}
// while (itr.hasMoreTokens()) {
// word.set(itr.nextToken());
// context.write(word, one);
// }
}
}

public static class IntSumReducer extends
Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {
private IntWritable result = new IntWritable();

public void reduce(Text key, Iterable&lt;IntWritable&gt; values,
Context context) throws IOException, InterruptedException {
int sum = 0;
for (IntWritable val : values) {
sum += val.get();
}
result.set(sum);
context.write(key, result);
}
}

public static void main(String[] args) throws Exception {
try {
Configuration conf = new Configuration();
String[] otherArgs = new GenericOptionsParser(conf, args)
.getRemainingArgs();
if (otherArgs.length != 2) {
System.err.println(&quot;Usage: wordcount &lt;in&gt; &lt;out&gt;&quot;);
System.exit(2);
}
Job job = new Job(conf, &quot;word count&quot;);
job.setJarByClass(WordCount.class);
job.setMapperClass(TokenizerMapper.class);
job.setCombinerClass(IntSumReducer.class);
job.setReducerClass(IntSumReducer.class);
job.setOutputKeyClass(Text.class);
job.setOutputValueClass(IntWritable.class);
FileInputFormat.addInputPath(job, new Path(otherArgs[0]));
FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));
System.out.println(&quot;job start!&quot;);
System.exit(job.waitForCompletion(true) ? 0 : 1);
System.out.println(&quot;completed!&quot;);
} catch (Exception e) {
e.printStackTrace();
}

}
}
public boolean waitForCompletion(boolean verbose
) throws IOException, InterruptedException,
ClassNotFoundException {
if (state == JobState.DEFINE) {
submit();
}
if (verbose) {
jobClient.monitorAndPrintJob(conf, info);
} else {
info.waitForCompletion();
}
return isSuccessful();
}
public void submit() throws IOException, InterruptedException,
ClassNotFoundException {
ensureState(JobState.DEFINE);
setUseNewAPI();
info = jobClient.submitJobInternal(conf);
super.setJobID(info.getID());
state = JobState.RUNNING;
}
public Job(Configuration conf) throws IOException {
super(conf, null);
jobClient = new JobClient((JobConf) getConfiguration());
}
public
RunningJob submitJobInternal(JobConf job
) throws FileNotFoundException,
ClassNotFoundException,
InterruptedException,
IOException {
/*
* configure the command line options correctly on the submitting dfs
*/

JobID jobId = jobSubmitClient.getNewJobId();
Path submitJobDir = new Path(getSystemDir(), jobId.toString());
Path submitJarFile = new Path(submitJobDir, &quot;job.jar&quot;);
Path submitSplitFile = new Path(submitJobDir, &quot;job.split&quot;);
configureCommandLineOptions(job, submitJobDir, submitJarFile);
Path submitJobFile = new Path(submitJobDir, &quot;job.xml&quot;);
int reduces = job.getNumReduceTasks();
JobContext context = new JobContext(job, jobId);

// Check the output specification
if (reduces == 0 ? job.getUseNewMapper() : job.getUseNewReducer()) {
org.apache.hadoop.mapreduce.OutputFormat&lt;?,?&gt; output =
ReflectionUtils.newInstance(context.getOutputFormatClass(), job);
output.checkOutputSpecs(context);
} else {
job.getOutputFormat().checkOutputSpecs(fs, job);
}

// Create the splits for the job
LOG.debug(&quot;Creating splits at &quot; + fs.makeQualified(submitSplitFile));
int maps;
if (job.getUseNewMapper()) {
maps = writeNewSplits(context, submitSplitFile);
} else {
maps = writeOldSplits(job, submitSplitFile);
}
job.set(&quot;mapred.job.split.file&quot;, submitSplitFile.toString());
job.setNumMapTasks(maps);

// Write job file to JobTracker&apos;s fs
FSDataOutputStream out =
FileSystem.create(fs, submitJobFile,
new FsPermission(JOB_FILE_PERMISSION));

try {
job.writeXml(out);
} finally {
out.close();
}

//
// Now, actually submit the job (using the submit name)
//
JobStatus status = jobSubmitClient.submitJob(jobId);
if (status != null) {
return new NetworkedJob(status);
} else {
throw new IOException(&quot;Could not launch job&quot;);
}
}
private JobSubmissionProtocol createRPCProxy(InetSocketAddress addr,
Configuration conf) throws IOException {
return (JobSubmissionProtocol) RPC.getProxy(JobSubmissionProtocol.class,
JobSubmissionProtocol.versionID, addr, getUGI(conf), conf,
NetUtils.getSocketFactory(conf, JobSubmissionProtocol.class));
}
public static void main(String argv[]
) throws IOException, InterruptedException {
StringUtils.startupShutdownMessage(JobTracker.class, argv, LOG);
if (argv.length != 0) {
System.out.println(&quot;usage: JobTracker&quot;);
System.exit(-1);
}

try {
JobTracker tracker = startTracker(new JobConf());
tracker.offerService();
} catch (Throwable e) {
LOG.fatal(StringUtils.stringifyException(e));
System.exit(-1);
}
}
public static JobTracker startTracker(JobConf conf, String identifier)
throws IOException, InterruptedException {
JobTracker result = null;
while (true) {
try {
result = new JobTracker(conf, identifier);
result.taskScheduler.setTaskTrackerManager(result);
break;
} catch (VersionMismatch e) {
throw e;
} catch (BindException e) {
throw e;
} catch (UnknownHostException e) {
throw e;
} catch (AccessControlException ace) {
// in case of jobtracker not having right access
// bail out
throw ace;
} catch (IOException e) {
LOG.warn(&quot;Error starting tracker: &quot; +
StringUtils.stringifyException(e));
}
Thread.sleep(1000);
}
if (result != null) {
JobEndNotifier.startNotifier();
}
return result;
}
Class&lt;? extends TaskScheduler&gt; schedulerClass
= conf.getClass(&quot;mapred.jobtracker.taskScheduler&quot;,
JobQueueTaskScheduler.class, TaskScheduler.class);
taskScheduler = (TaskScheduler) ReflectionUtils.newInstance(schedulerClass, conf);
public void offerService() throws InterruptedException, IOException {
// Prepare for recovery. This is done irrespective of the status of restart
// flag.
while (true) {
try {
recoveryManager.updateRestartCount();
break;
} catch (IOException ioe) {
LOG.warn(&quot;Failed to initialize recovery manager. &quot;, ioe);
// wait for some time
Thread.sleep(FS_ACCESS_RETRY_PERIOD);
LOG.warn(&quot;Retrying...&quot;);
}
}

taskScheduler.start();

// Start the recovery after starting the scheduler
try {
recoveryManager.recover();
} catch (Throwable t) {
LOG.warn(&quot;Recovery manager crashed! Ignoring.&quot;, t);
}

this.expireTrackersThread = new Thread(this.expireTrackers,
&quot;expireTrackers&quot;);
this.expireTrackersThread.start();
this.retireJobsThread = new Thread(this.retireJobs, &quot;retireJobs&quot;);
this.retireJobsThread.start();
expireLaunchingTaskThread.start();

if (completedJobStatusStore.isActive()) {
completedJobsStoreThread = new Thread(completedJobStatusStore,
&quot;completedjobsStore-housekeeper&quot;);
completedJobsStoreThread.start();
}

// start the inter-tracker server once the jt is ready
this.interTrackerServer.start();

synchronized (this) {
state = State.RUNNING;
}
LOG.info(&quot;Starting RUNNING&quot;);

this.interTrackerServer.join();
LOG.info(&quot;Stopped interTrackerServer&quot;);
}
public synchronized void start() throws IOException {
super.start();
taskTrackerManager.addJobInProgressListener(jobQueueJobInProgressListener);
eagerTaskInitializationListener.setTaskTrackerManager(taskTrackerManager);
eagerTaskInitializationListener.start();
taskTrackerManager.addJobInProgressListener(
eagerTaskInitializationListener);
}
public void start() throws IOException {
this.jobInitManagerThread = new Thread(jobInitManager, &quot;jobInitManager&quot;);
jobInitManagerThread.setDaemon(true);
this.jobInitManagerThread.start();
}
class JobInitManager implements Runnable {

public void run() {
JobInProgress job = null;
while (true) {
try {
synchronized (jobInitQueue) {
while (jobInitQueue.isEmpty()) {
jobInitQueue.wait();
}
job = jobInitQueue.remove(0);
}
threadPool.execute(new InitJob(job));
} catch (InterruptedException t) {
LOG.info(&quot;JobInitManagerThread interrupted.&quot;);
break;
}
}
LOG.info(&quot;Shutting down thread pool&quot;);
threadPool.shutdownNow();
}
}
class InitJob implements Runnable {

private JobInProgress job;

public InitJob(JobInProgress job) {
this.job = job;
}

public void run() {
ttm.initJob(job);
}
}
public void setTaskTrackerManager(TaskTrackerManager ttm) {
this.ttm = ttm;
}
result.taskScheduler.setTaskTrackerManager(result);
public void initJob(JobInProgress job) {
if (null == job) {
LOG.info(&quot;Init on null job is not valid&quot;);
return;
}

try {
JobStatus prevStatus = (JobStatus)job.getStatus().clone();
LOG.info(&quot;Initializing &quot; + job.getJobID());
job.initTasks();
// Inform the listeners if the job state has changed
// Note : that the job will be in PREP state.
JobStatus newStatus = (JobStatus)job.getStatus().clone();
if (prevStatus.getRunState() != newStatus.getRunState()) {
JobStatusChangeEvent event =
new JobStatusChangeEvent(job, EventType.RUN_STATE_CHANGED, prevStatus,
newStatus);
synchronized (JobTracker.this) {
updateJobInProgressListeners(event);
}
}
} catch (KillInterruptedException kie) {
// If job was killed during initialization, job state will be KILLED
LOG.error(&quot;Job initialization interrupted:\n&quot; +
StringUtils.stringifyException(kie));
killJob(job);
} catch (Throwable t) {
// If the job initialization is failed, job state will be FAILED
LOG.error(&quot;Job initialization failed:\n&quot; +
StringUtils.stringifyException(t));
failJob(job);
}
}
/**
* Construct the splits, etc. This is invoked from an async
* thread so that split-computation doesn&apos;t block anyone.
*/
public synchronized void initTasks()
throws IOException, KillInterruptedException {
if (tasksInited.get() || isComplete()) {
return;
}
synchronized(jobInitKillStatus){
if(jobInitKillStatus.killed || jobInitKillStatus.initStarted) {
return;
}
jobInitKillStatus.initStarted = true;
}

LOG.info(&quot;Initializing &quot; + jobId);

// log job info
JobHistory.JobInfo.logSubmitted(getJobID(), conf, jobFile.toString(),
this.startTime, hasRestarted());
// log the job priority
setPriority(this.priority);

//
// read input splits and create a map per a split
//
String jobFile = profile.getJobFile();

Path sysDir = new Path(this.jobtracker.getSystemDir());
FileSystem fs = sysDir.getFileSystem(conf);
DataInputStream splitFile =
fs.open(new Path(conf.get(&quot;mapred.job.split.file&quot;)));
JobClient.RawSplit[] splits;
try {
splits = JobClient.readSplitFile(splitFile);
} finally {
splitFile.close();
}
numMapTasks = splits.length;


// if the number of splits is larger than a configured value
// then fail the job.
int maxTasks = jobtracker.getMaxTasksPerJob();
if (maxTasks &gt; 0 &amp;&amp; numMapTasks + numReduceTasks &gt; maxTasks) {
throw new IOException(
&quot;The number of tasks for this job &quot; +
(numMapTasks + numReduceTasks) +
&quot; exceeds the configured limit &quot; + maxTasks);
}
jobtracker.getInstrumentation().addWaiting(
getJobID(), numMapTasks + numReduceTasks);

maps = new TaskInProgress[numMapTasks];
for(int i=0; i &lt; numMapTasks; ++i) {
inputLength += splits[i].getDataLength();
maps[i] = new TaskInProgress(jobId, jobFile,
splits[i],
jobtracker, conf, this, i);
}
LOG.info(&quot;Input size for job &quot; + jobId + &quot; = &quot; + inputLength
+ &quot;. Number of splits = &quot; + splits.length);
if (numMapTasks &gt; 0) {
nonRunningMapCache = createCache(splits, maxLevel);
}

// set the launch time
this.launchTime = System.currentTimeMillis();

//
// Create reduce tasks
//
this.reduces = new TaskInProgress[numReduceTasks];
for (int i = 0; i &lt; numReduceTasks; i++) {
reduces[i] = new TaskInProgress(jobId, jobFile,
numMapTasks, i,
jobtracker, conf, this);
nonRunningReduces.add(reduces[i]);
}

// Calculate the minimum number of maps to be complete before
// we should start scheduling reduces
completedMapsForReduceSlowstart =
(int)Math.ceil(
(conf.getFloat(&quot;mapred.reduce.slowstart.completed.maps&quot;,
DEFAULT_COMPLETED_MAPS_PERCENT_FOR_REDUCE_SLOWSTART) *
numMapTasks));

// create cleanup two cleanup tips, one map and one reduce.
cleanup = new TaskInProgress[2];

// cleanup map tip. This map doesn&apos;t use any splits. Just assign an empty
// split.
JobClient.RawSplit emptySplit = new JobClient.RawSplit();
cleanup[0] = new TaskInProgress(jobId, jobFile, emptySplit,
jobtracker, conf, this, numMapTasks);
cleanup[0].setJobCleanupTask();

// cleanup reduce tip.
cleanup[1] = new TaskInProgress(jobId, jobFile, numMapTasks,
numReduceTasks, jobtracker, conf, this);
cleanup[1].setJobCleanupTask();

// create two setup tips, one map and one reduce.
setup = new TaskInProgress[2];

// setup map tip. This map doesn&apos;t use any split. Just assign an empty
// split.
setup[0] = new TaskInProgress(jobId, jobFile, emptySplit,
jobtracker, conf, this, numMapTasks + 1 );
setup[0].setJobSetupTask();

// setup reduce tip.
setup[1] = new TaskInProgress(jobId, jobFile, numMapTasks,
numReduceTasks + 1, jobtracker, conf, this);
setup[1].setJobSetupTask();

synchronized(jobInitKillStatus){
jobInitKillStatus.initDone = true;
if(jobInitKillStatus.killed) {
throw new KillInterruptedException(&quot;Job &quot; + jobId + &quot; killed in init&quot;);
}
}

tasksInited.set(true);
JobHistory.JobInfo.logInited(profile.getJobID(), this.launchTime,
numMapTasks, numReduceTasks);
}
this.interTrackerServer = RPC.getServer(this, addr.getHostName(), addr.getPort(), handlerCount, false, conf);
this.interTrackerServer.start();
this.jobClient = (InterTrackerProtocol)
RPC.waitForProxy(InterTrackerProtocol.class,
InterTrackerProtocol.versionID,
jobTrackAddr, this.fConf);
public static void main(String argv[]) throws Exception {
StringUtils.startupShutdownMessage(TaskTracker.class, argv, LOG);
if (argv.length != 0) {
System.out.println(&quot;usage: TaskTracker&quot;);
System.exit(-1);
}
try {
JobConf conf=new JobConf();
// enable the server to track time spent waiting on locks
ReflectionUtils.setContentionTracing
(conf.getBoolean(&quot;tasktracker.contention.tracking&quot;, false));
new TaskTracker(conf).run();
} catch (Throwable e) {
LOG.error(&quot;Can not start task tracker because &quot;+
StringUtils.stringifyException(e));
System.exit(-1);
}
}
public void run() {
try {
startCleanupThreads();
boolean denied = false;
while (running &amp;&amp; !shuttingDown &amp;&amp; !denied) {
boolean staleState = false;
try {
// This while-loop attempts reconnects if we get network errors
while (running &amp;&amp; !staleState &amp;&amp; !shuttingDown &amp;&amp; !denied) {
try {
State osState = offerService();
if (osState == State.STALE) {
staleState = true;
} else if (osState == State.DENIED) {
denied = true;
}
} catch (Exception ex) {
if (!shuttingDown) {
LOG.info(&quot;Lost connection to JobTracker [&quot; +
jobTrackAddr + &quot;]. Retrying...&quot;, ex);
try {
Thread.sleep(5000);
} catch (InterruptedException ie) {
}
}
}
}
} finally {
close();
}
if (shuttingDown) { return; }
LOG.warn(&quot;Reinitializing local state&quot;);
initialize();
}
if (denied) {
shutdown();
}
} catch (IOException iex) {
LOG.error(&quot;Got fatal exception while reinitializing TaskTracker: &quot; +
StringUtils.stringifyException(iex));
return;
}
}
State offerService() throws Exception {
long lastHeartbeat = 0;

while (running &amp;&amp; !shuttingDown) {
try {
long now = System.currentTimeMillis();

long waitTime = heartbeatInterval - (now - lastHeartbeat);
if (waitTime &gt; 0) {
// sleeps for the wait time
Thread.sleep(waitTime);
}

// If the TaskTracker is just starting up:
// 1. Verify the buildVersion
// 2. Get the system directory &amp; filesystem
if(justInited) {
String jobTrackerBV = jobClient.getBuildVersion();
if(!VersionInfo.getBuildVersion().equals(jobTrackerBV)) {
String msg = &quot;Shutting down. Incompatible buildVersion.&quot; +
&quot;\nJobTracker&apos;s: &quot; + jobTrackerBV +
&quot;\nTaskTracker&apos;s: &quot;+ VersionInfo.getBuildVersion();
LOG.error(msg);
try {
jobClient.reportTaskTrackerError(taskTrackerName, null, msg);
} catch(Exception e ) {
LOG.info(&quot;Problem reporting to jobtracker: &quot; + e);
}
return State.DENIED;
}

String dir = jobClient.getSystemDir();
if (dir == null) {
throw new IOException(&quot;Failed to get system directory&quot;);
}
systemDirectory = new Path(dir);
systemFS = systemDirectory.getFileSystem(fConf);
}

// Send the heartbeat and process the jobtracker&apos;s directives
HeartbeatResponse heartbeatResponse = transmitHeartBeat(now);

// Note the time when the heartbeat returned, use this to decide when to send the
// next heartbeat
lastHeartbeat = System.currentTimeMillis();


// Check if the map-event list needs purging
Set&lt;JobID&gt; jobs = heartbeatResponse.getRecoveredJobs();
if (jobs.size() &gt; 0) {
synchronized (this) {
// purge the local map events list
for (JobID job : jobs) {
RunningJob rjob;
synchronized (runningJobs) {
rjob = runningJobs.get(job);
if (rjob != null) {
synchronized (rjob) {
FetchStatus f = rjob.getFetchStatus();
if (f != null) {
f.reset();
}
}
}
}
}

// Mark the reducers in shuffle for rollback
synchronized (shouldReset) {
for (Map.Entry&lt;TaskAttemptID, TaskInProgress&gt; entry
: runningTasks.entrySet()) {
if (entry.getValue().getStatus().getPhase() == Phase.SHUFFLE) {
this.shouldReset.add(entry.getKey());
}
}
}
}
}

TaskTrackerAction[] actions = heartbeatResponse.getActions();
if(LOG.isDebugEnabled()) {
LOG.debug(&quot;Got heartbeatResponse from JobTracker with responseId: &quot; +
heartbeatResponse.getResponseId() + &quot; and &quot; +
((actions != null) ? actions.length : 0) + &quot; actions&quot;);
}
if (reinitTaskTracker(actions)) {
return State.STALE;
}

// resetting heartbeat interval from the response.
heartbeatInterval = heartbeatResponse.getHeartbeatInterval();
justStarted = false;
justInited = false;
if (actions != null){
for(TaskTrackerAction action: actions) {
if (action instanceof LaunchTaskAction) {
addToTaskQueue((LaunchTaskAction)action);
} else if (action instanceof CommitTaskAction) {
CommitTaskAction commitAction = (CommitTaskAction)action;
if (!commitResponses.contains(commitAction.getTaskID())) {
LOG.info(&quot;Received commit task action for &quot; +
commitAction.getTaskID());
commitResponses.add(commitAction.getTaskID());
}
} else {
tasksToCleanup.put(action);
}
}
}
markUnresponsiveTasks();
killOverflowingTasks();

//we&apos;ve cleaned up, resume normal operation
if (!acceptNewTasks &amp;&amp; isIdle()) {
acceptNewTasks=true;
}
//The check below may not be required every iteration but we are
//erring on the side of caution here. We have seen many cases where
//the call to jetty&apos;s getLocalPort() returns different values at
//different times. Being a real paranoid here.
checkJettyPort(server.getPort());
} catch (InterruptedException ie) {
LOG.info(&quot;Interrupted. Closing down.&quot;);
return State.INTERRUPTED;
} catch (DiskErrorException de) {
String msg = &quot;Exiting task tracker for disk error:\n&quot; +
StringUtils.stringifyException(de);
LOG.error(msg);
synchronized (this) {
jobClient.reportTaskTrackerError(taskTrackerName,
&quot;DiskErrorException&quot;, msg);
}
return State.STALE;
} catch (RemoteException re) {
String reClass = re.getClassName();
if (DisallowedTaskTrackerException.class.getName().equals(reClass)) {
LOG.info(&quot;Tasktracker disallowed by JobTracker.&quot;);
return State.DENIED;
}
} catch (Exception except) {
String msg = &quot;Caught exception: &quot; +
StringUtils.stringifyException(except);
LOG.error(msg);
}
}

return State.NORMAL;
}
private void addToTaskQueue(LaunchTaskAction action) {
if (action.getTask().isMapTask()) {
mapLauncher.addToTaskQueue(action);
} else {
reduceLauncher.addToTaskQueue(action);
}
}
public void addToTaskQueue(LaunchTaskAction action) {
synchronized (tasksToLaunch) {
TaskInProgress tip = registerTask(action, this);
tasksToLaunch.add(tip);
tasksToLaunch.notifyAll();
}
}
private TaskInProgress registerTask(LaunchTaskAction action,
TaskLauncher launcher) {
Task t = action.getTask();
LOG.info(&quot;LaunchTaskAction (registerTask): &quot; + t.getTaskID() +
&quot; task&apos;s state:&quot; + t.getState());
TaskInProgress tip = new TaskInProgress(t, this.fConf, launcher);
synchronized (this) {
tasks.put(t.getTaskID(), tip);
runningTasks.put(t.getTaskID(), tip);
boolean isMap = t.isMapTask();
if (isMap) {
mapTotal++;
} else {
reduceTotal++;
}
}
return tip;
}
private HeartbeatResponse transmitHeartBeat(long now) throws IOException {
// Send Counters in the status once every COUNTER_UPDATE_INTERVAL
boolean sendCounters;
if (now &gt; (previousUpdate + COUNTER_UPDATE_INTERVAL)) {
sendCounters = true;
previousUpdate = now;
}
else {
sendCounters = false;
}

//
// Check if the last heartbeat got through...
// if so then build the heartbeat information for the JobTracker;
// else resend the previous status information.
//
if (status == null) {
synchronized (this) {
status = new TaskTrackerStatus(taskTrackerName, localHostname,
httpPort,
cloneAndResetRunningTaskStatuses(
sendCounters),
failures,
maxCurrentMapTasks,
maxCurrentReduceTasks);
}
} else {
LOG.info(&quot;Resending &apos;status&apos; to &apos;&quot; + jobTrackAddr.getHostName() +
&quot;&apos; with reponseId &apos;&quot; + heartbeatResponseId);
}

//
// Check if we should ask for a new Task
//
boolean askForNewTask;
long localMinSpaceStart;
synchronized (this) {
askForNewTask = (status.countMapTasks() &lt; maxCurrentMapTasks ||
status.countReduceTasks() &lt; maxCurrentReduceTasks) &amp;&amp;
acceptNewTasks;
localMinSpaceStart = minSpaceStart;
}
if (askForNewTask) {
checkLocalDirs(fConf.getLocalDirs());
askForNewTask = enoughFreeSpace(localMinSpaceStart);
long freeDiskSpace = getFreeSpace();
long totVmem = getTotalVirtualMemoryOnTT();
long totPmem = getTotalPhysicalMemoryOnTT();

status.getResourceStatus().setAvailableSpace(freeDiskSpace);
status.getResourceStatus().setTotalVirtualMemory(totVmem);
status.getResourceStatus().setTotalPhysicalMemory(totPmem);
status.getResourceStatus().setMapSlotMemorySizeOnTT(
mapSlotMemorySizeOnTT);
status.getResourceStatus().setReduceSlotMemorySizeOnTT(
reduceSlotSizeMemoryOnTT);
}

//
// Xmit the heartbeat
//
HeartbeatResponse heartbeatResponse = jobClient.heartbeat(status,
justStarted,
justInited,
askForNewTask,
heartbeatResponseId);

//
// The heartbeat got through successfully!
//
heartbeatResponseId = heartbeatResponse.getResponseId();

synchronized (this) {
for (TaskStatus taskStatus : status.getTaskReports()) {
if (taskStatus.getRunState() != TaskStatus.State.RUNNING &amp;&amp;
taskStatus.getRunState() != TaskStatus.State.UNASSIGNED &amp;&amp;
taskStatus.getRunState() != TaskStatus.State.COMMIT_PENDING &amp;&amp;
!taskStatus.inTaskCleanupPhase()) {
if (taskStatus.getIsMap()) {
mapTotal--;
} else {
reduceTotal--;
}
try {
myInstrumentation.completeTask(taskStatus.getTaskID());
} catch (MetricsException me) {
LOG.warn(&quot;Caught: &quot; + StringUtils.stringifyException(me));
}
runningTasks.remove(taskStatus.getTaskID());
}
}

// Clear transient status information which should only
// be sent once to the JobTracker
for (TaskInProgress tip: runningTasks.values()) {
tip.getStatus().clearStatus();
}
}

// Force a rebuild of &apos;status&apos; on the next iteration
status = null;

return heartbeatResponse;
}
&lt;pre class=&quot;java&quot; name=&quot;code&quot;&gt; public synchronized HeartbeatResponse heartbeat(TaskTrackerStatus status,
boolean restarted,
boolean initialContact,
boolean acceptNewTasks,
short responseId)
throws IOException {
LOG.debug(&quot;Got heartbeat from: &quot; + status.getTrackerName() +
&quot; (restarted: &quot; + restarted +
&quot; initialContact: &quot; + initialContact +
&quot; acceptNewTasks: &quot; + acceptNewTasks + &quot;)&quot; +
&quot; with responseId: &quot; + responseId);

// Make sure heartbeat is from a tasktracker allowed by the jobtracker.
if (!acceptTaskTracker(status)) {
throw new DisallowedTaskTrackerException(status);
}

// First check if the last heartbeat response got through
String trackerName = status.getTrackerName();
long now = System.currentTimeMillis();
boolean isBlacklisted = false;
if (restarted) {
faultyTrackers.markTrackerHealthy(status.getHost());
} else {
isBlacklisted =
faultyTrackers.shouldAssignTasksToTracker(status.getHost(), now);
}

HeartbeatResponse prevHeartbeatResponse =
trackerToHeartbeatResponseMap.get(trackerName);
boolean addRestartInfo = false;

if (initialContact != true) {
// If this isn&apos;t the &apos;initial contact&apos; from the tasktracker,
// there is something seriously wrong if the JobTracker has
// no record of the &apos;previous heartbeat&apos;; if so, ask the
// tasktracker to re-initialize itself.
if (prevHeartbeatResponse == null) {
// This is the first heartbeat from the old tracker to the newly
// started JobTracker
if (hasRestarted()) {
addRestartInfo = true;
// inform the recovery manager about this tracker joining back
recoveryManager.unMarkTracker(trackerName);
} else {
// Jobtracker might have restarted but no recovery is needed
// otherwise this code should not be reached
LOG.warn(&quot;Serious problem, cannot find record of &apos;previous&apos; &quot; +
&quot;heartbeat for &apos;&quot; + trackerName +
&quot;&apos;; reinitializing the tasktracker&quot;);
return new HeartbeatResponse(responseId,
new TaskTrackerAction[] {new ReinitTrackerAction()});
}

} else {

// It is completely safe to not process a &apos;duplicate&apos; heartbeat from a
// {@link TaskTracker} since it resends the heartbeat when rpcs are
// lost see {@link TaskTracker.transmitHeartbeat()};
// acknowledge it by re-sending the previous response to let the
// {@link TaskTracker} go forward.
if (prevHeartbeatResponse.getResponseId() != responseId) {
LOG.info(&quot;Ignoring &apos;duplicate&apos; heartbeat from &apos;&quot; +
trackerName + &quot;&apos;; resending the previous &apos;lost&apos; response&quot;);
return prevHeartbeatResponse;
}
}
}

// Process this heartbeat
short newResponseId = (short)(responseId + 1);
status.setLastSeen(now);
if (!processHeartbeat(status, initialContact)) {
if (prevHeartbeatResponse != null) {
trackerToHeartbeatResponseMap.remove(trackerName);
}
return new HeartbeatResponse(newResponseId,
new TaskTrackerAction[] {new ReinitTrackerAction()});
}

// Initialize the response to be sent for the heartbeat
HeartbeatResponse response = new HeartbeatResponse(newResponseId, null);
List&lt;TaskTrackerAction&gt; actions = new ArrayList&lt;TaskTrackerAction&gt;();

// Check for new tasks to be executed on the tasktracker
if (recoveryManager.shouldSchedule() &amp;&amp; acceptNewTasks &amp;&amp; !isBlacklisted) {
TaskTrackerStatus taskTrackerStatus = getTaskTracker(trackerName);
if (taskTrackerStatus == null) {
LOG.warn(&quot;Unknown task tracker polling; ignoring: &quot; + trackerName);
} else {
List&lt;Task&gt; tasks = getSetupAndCleanupTasks(taskTrackerStatus);
if (tasks == null ) {
tasks = taskScheduler.assignTasks(taskTrackerStatus);
}
if (tasks != null) {
for (Task task : tasks) {
expireLaunchingTasks.addNewTask(task.getTaskID());
LOG.debug(trackerName + &quot; -&gt; LaunchTask: &quot; + task.getTaskID());
actions.add(new LaunchTaskAction(task));
}
}
}
}

// Check for tasks to be killed
List&lt;TaskTrackerAction&gt; killTasksList = getTasksToKill(trackerName);
if (killTasksList != null) {
actions.addAll(killTasksList);
}

// Check for jobs to be killed/cleanedup
List&lt;TaskTrackerAction&gt; killJobsList = getJobsForCleanup(trackerName);
if (killJobsList != null) {
actions.addAll(killJobsList);
}

// Check for tasks whose outputs can be saved
List&lt;TaskTrackerAction&gt; commitTasksList = getTasksToSave(status);
if (commitTasksList != null) {
actions.addAll(commitTasksList);
}

// calculate next heartbeat interval and put in heartbeat response
int nextInterval = getNextHeartbeatInterval();
response.setHeartbeatInterval(nextInterval);
response.setActions(
actions.toArray(new TaskTrackerAction[actions.size()]));

// check if the restart info is req
if (addRestartInfo) {
response.setRecoveredJobs(recoveryManager.getJobsToRecover());
}

// Update the trackerToHeartbeatResponseMap
trackerToHeartbeatResponseMap.put(trackerName, response);

// Done processing the hearbeat, now remove &apos;marked&apos; tasks
removeMarkedTasks(trackerName);

return response;
}
public synchronized List&lt;Task&gt; assignTasks(TaskTrackerStatus taskTracker)
throws IOException {

ClusterStatus clusterStatus = taskTrackerManager.getClusterStatus();
final int numTaskTrackers = clusterStatus.getTaskTrackers();
final int clusterMapCapacity = clusterStatus.getMaxMapTasks();
final int clusterReduceCapacity = clusterStatus.getMaxReduceTasks();

Collection&lt;JobInProgress&gt; jobQueue =
jobQueueJobInProgressListener.getJobQueue();

//
// Get map + reduce counts for the current tracker.
//
final int trackerMapCapacity = taskTracker.getMaxMapTasks();
final int trackerReduceCapacity = taskTracker.getMaxReduceTasks();
final int trackerRunningMaps = taskTracker.countMapTasks();
final int trackerRunningReduces = taskTracker.countReduceTasks();

// Assigned tasks
List&lt;Task&gt; assignedTasks = new ArrayList&lt;Task&gt;();

//
// Compute (running + pending) map and reduce task numbers across pool
//
int remainingReduceLoad = 0;
int remainingMapLoad = 0;
synchronized (jobQueue) {
for (JobInProgress job : jobQueue) {
if (job.getStatus().getRunState() == JobStatus.RUNNING) {
remainingMapLoad += (job.desiredMaps() - job.finishedMaps());
if (job.scheduleReduces()) {
remainingReduceLoad +=
(job.desiredReduces() - job.finishedReduces());
}
}
}
}

// Compute the &apos;load factor&apos; for maps and reduces
double mapLoadFactor = 0.0;
if (clusterMapCapacity &gt; 0) {
mapLoadFactor = (double)remainingMapLoad / clusterMapCapacity;
}
double reduceLoadFactor = 0.0;
if (clusterReduceCapacity &gt; 0) {
reduceLoadFactor = (double)remainingReduceLoad / clusterReduceCapacity;
}

//
// In the below steps, we allocate first map tasks (if appropriate),
// and then reduce tasks if appropriate. We go through all jobs
// in order of job arrival; jobs only get serviced if their
// predecessors are serviced, too.
//

//
// We assign tasks to the current taskTracker if the given machine
// has a workload that&apos;s less than the maximum load of that kind of
// task.
// However, if the cluster is close to getting loaded i.e. we don&apos;t
// have enough _padding_ for speculative executions etc., we only
// schedule the &quot;highest priority&quot; task i.e. the task from the job
// with the highest priority.
//

final int trackerCurrentMapCapacity =
Math.min((int)Math.ceil(mapLoadFactor * trackerMapCapacity),
trackerMapCapacity);
int availableMapSlots = trackerCurrentMapCapacity - trackerRunningMaps;
boolean exceededMapPadding = false;
if (availableMapSlots &gt; 0) {
exceededMapPadding =
exceededPadding(true, clusterStatus, trackerMapCapacity);
}

int numLocalMaps = 0;
int numNonLocalMaps = 0;
scheduleMaps:
for (int i=0; i &lt; availableMapSlots; ++i) {
synchronized (jobQueue) {
for (JobInProgress job : jobQueue) {
if (job.getStatus().getRunState() != JobStatus.RUNNING) {
continue;
}

Task t = null;

// Try to schedule a node-local or rack-local Map task
t =
job.obtainNewLocalMapTask(taskTracker, numTaskTrackers,
taskTrackerManager.getNumberOfUniqueHosts());
if (t != null) {
assignedTasks.add(t);
++numLocalMaps;

// Don&apos;t assign map tasks to the hilt!
// Leave some free slots in the cluster for future task-failures,
// speculative tasks etc. beyond the highest priority job
if (exceededMapPadding) {
break scheduleMaps;
}

// Try all jobs again for the next Map task
break;
}

// Try to schedule a node-local or rack-local Map task
t =
job.obtainNewNonLocalMapTask(taskTracker, numTaskTrackers,
taskTrackerManager.getNumberOfUniqueHosts());

if (t != null) {
assignedTasks.add(t);
++numNonLocalMaps;

// We assign at most 1 off-switch or speculative task
// This is to prevent TaskTrackers from stealing local-tasks
// from other TaskTrackers.
break scheduleMaps;
}
}
}
}
int assignedMaps = assignedTasks.size();

//
// Same thing, but for reduce tasks
// However we _never_ assign more than 1 reduce task per heartbeat
//
final int trackerCurrentReduceCapacity =
Math.min((int)Math.ceil(reduceLoadFactor * trackerReduceCapacity),
trackerReduceCapacity);
final int availableReduceSlots =
Math.min((trackerCurrentReduceCapacity - trackerRunningReduces), 1);
boolean exceededReducePadding = false;
if (availableReduceSlots &gt; 0) {
exceededReducePadding = exceededPadding(false, clusterStatus,
trackerReduceCapacity);
synchronized (jobQueue) {
for (JobInProgress job : jobQueue) {
if (job.getStatus().getRunState() != JobStatus.RUNNING ||
job.numReduceTasks == 0) {
continue;
}

Task t =
job.obtainNewReduceTask(taskTracker, numTaskTrackers,
taskTrackerManager.getNumberOfUniqueHosts()
);
if (t != null) {
assignedTasks.add(t);
break;
}

// Don&apos;t assign reduce tasks to the hilt!
// Leave some free slots in the cluster for future task-failures,
// speculative tasks etc. beyond the highest priority job
if (exceededReducePadding) {
break;
}
}
}
}

if (LOG.isDebugEnabled()) {
LOG.debug(&quot;Task assignments for &quot; + taskTracker.getTrackerName() + &quot; --&gt; &quot; +
&quot;[&quot; + mapLoadFactor + &quot;, &quot; + trackerMapCapacity + &quot;, &quot; +
trackerCurrentMapCapacity + &quot;, &quot; + trackerRunningMaps + &quot;] -&gt; [&quot; +
(trackerCurrentMapCapacity - trackerRunningMaps) + &quot;, &quot; +
assignedMaps + &quot; (&quot; + numLocalMaps + &quot;, &quot; + numNonLocalMaps +
&quot;)] [&quot; + reduceLoadFactor + &quot;, &quot; + trackerReduceCapacity + &quot;, &quot; +
trackerCurrentReduceCapacity + &quot;,&quot; + trackerRunningReduces +
&quot;] -&gt; [&quot; + (trackerCurrentReduceCapacity - trackerRunningReduces) +
&quot;, &quot; + (assignedTasks.size()-assignedMaps) + &quot;]&quot;);
}

return assignedTasks;
}
public TaskTracker(JobConf conf) throws IOException {
originalConf = conf;
maxCurrentMapTasks = conf.getInt(
&quot;mapred.tasktracker.map.tasks.maximum&quot;, 2);
maxCurrentReduceTasks = conf.getInt(
&quot;mapred.tasktracker.reduce.tasks.maximum&quot;, 2);
this.jobTrackAddr = JobTracker.getAddress(conf);
String infoAddr =
NetUtils.getServerAddress(conf,
&quot;tasktracker.http.bindAddress&quot;,
&quot;tasktracker.http.port&quot;,
&quot;mapred.task.tracker.http.address&quot;);
InetSocketAddress infoSocAddr = NetUtils.createSocketAddr(infoAddr);
String httpBindAddress = infoSocAddr.getHostName();
int httpPort = infoSocAddr.getPort();
this.server = new HttpServer(&quot;task&quot;, httpBindAddress, httpPort,
httpPort == 0, conf);
workerThreads = conf.getInt(&quot;tasktracker.http.threads&quot;, 40);
this.shuffleServerMetrics = new ShuffleServerMetrics(conf);
server.setThreads(1, workerThreads);
// let the jsp pages get to the task tracker, config, and other relevant
// objects
FileSystem local = FileSystem.getLocal(conf);
this.localDirAllocator = new LocalDirAllocator(&quot;mapred.local.dir&quot;);
server.setAttribute(&quot;task.tracker&quot;, this);
server.setAttribute(&quot;local.file.system&quot;, local);
server.setAttribute(&quot;conf&quot;, conf);
server.setAttribute(&quot;log&quot;, LOG);
server.setAttribute(&quot;localDirAllocator&quot;, localDirAllocator);
server.setAttribute(&quot;shuffleServerMetrics&quot;, shuffleServerMetrics);
server.addInternalServlet(&quot;mapOutput&quot;, &quot;/mapOutput&quot;, MapOutputServlet.class);
server.addInternalServlet(&quot;taskLog&quot;, &quot;/tasklog&quot;, TaskLogServlet.class);
server.start();
this.httpPort = server.getPort();
checkJettyPort(httpPort);
initialize();
}
synchronized void initialize() throws IOException {
// use configured nameserver &amp; interface to get local hostname
this.fConf = new JobConf(originalConf);
if (fConf.get(&quot;slave.host.name&quot;) != null) {
this.localHostname = fConf.get(&quot;slave.host.name&quot;);
}
if (localHostname == null) {
this.localHostname =
DNS.getDefaultHost
(fConf.get(&quot;mapred.tasktracker.dns.interface&quot;,&quot;default&quot;),
fConf.get(&quot;mapred.tasktracker.dns.nameserver&quot;,&quot;default&quot;));
}

//check local disk
checkLocalDirs(this.fConf.getLocalDirs());
fConf.deleteLocalFiles(SUBDIR);

// Clear out state tables
this.tasks.clear();
this.runningTasks = new LinkedHashMap&lt;TaskAttemptID, TaskInProgress&gt;();
this.runningJobs = new TreeMap&lt;JobID, RunningJob&gt;();
this.mapTotal = 0;
this.reduceTotal = 0;
this.acceptNewTasks = true;
this.status = null;

this.minSpaceStart = this.fConf.getLong(&quot;mapred.local.dir.minspacestart&quot;, 0L);
this.minSpaceKill = this.fConf.getLong(&quot;mapred.local.dir.minspacekill&quot;, 0L);
//tweak the probe sample size (make it a function of numCopiers)
probe_sample_size = this.fConf.getInt(&quot;mapred.tasktracker.events.batchsize&quot;, 500);

Class&lt;? extends TaskTrackerInstrumentation&gt; metricsInst = getInstrumentationClass(fConf);
try {
java.lang.reflect.Constructor&lt;? extends TaskTrackerInstrumentation&gt; c =
metricsInst.getConstructor(new Class[] {TaskTracker.class} );
this.myInstrumentation = c.newInstance(this);
} catch(Exception e) {
//Reflection can throw lots of exceptions -- handle them all by
//falling back on the default.
LOG.error(&quot;failed to initialize taskTracker metrics&quot;, e);
this.myInstrumentation = new TaskTrackerMetricsInst(this);
}

// bind address
String address =
NetUtils.getServerAddress(fConf,
&quot;mapred.task.tracker.report.bindAddress&quot;,
&quot;mapred.task.tracker.report.port&quot;,
&quot;mapred.task.tracker.report.address&quot;);
InetSocketAddress socAddr = NetUtils.createSocketAddr(address);
String bindAddress = socAddr.getHostName();
int tmpPort = socAddr.getPort();

this.jvmManager = new JvmManager(this);

// Set service-level authorization security policy
if (this.fConf.getBoolean(
ServiceAuthorizationManager.SERVICE_AUTHORIZATION_CONFIG, false)) {
PolicyProvider policyProvider =
(PolicyProvider)(ReflectionUtils.newInstance(
this.fConf.getClass(PolicyProvider.POLICY_PROVIDER_CONFIG,
MapReducePolicyProvider.class, PolicyProvider.class),
this.fConf));
SecurityUtil.setPolicy(new ConfiguredPolicy(this.fConf, policyProvider));
}

// RPC initialization
int max = maxCurrentMapTasks &gt; maxCurrentReduceTasks ?
maxCurrentMapTasks : maxCurrentReduceTasks;
//set the num handlers to max*2 since canCommit may wait for the duration
//of a heartbeat RPC
this.taskReportServer =
RPC.getServer(this, bindAddress, tmpPort, 2 * max, false, this.fConf);
this.taskReportServer.start();

// get the assigned address
this.taskReportAddress = taskReportServer.getListenerAddress();
this.fConf.set(&quot;mapred.task.tracker.report.address&quot;,
taskReportAddress.getHostName() + &quot;:&quot; + taskReportAddress.getPort());
LOG.info(&quot;TaskTracker up at: &quot; + this.taskReportAddress);

this.taskTrackerName = &quot;tracker_&quot; + localHostname + &quot;:&quot; + taskReportAddress;
LOG.info(&quot;Starting tracker &quot; + taskTrackerName);

// Clear out temporary files that might be lying around
DistributedCache.purgeCache(this.fConf);
cleanupStorage();

this.jobClient = (InterTrackerProtocol)
RPC.waitForProxy(InterTrackerProtocol.class,
InterTrackerProtocol.versionID,
jobTrackAddr, this.fConf);
this.justInited = true;
this.running = true;
// start the thread that will fetch map task completion events
this.mapEventsFetcher = new MapEventsFetcherThread();
mapEventsFetcher.setDaemon(true);
mapEventsFetcher.setName(
&quot;Map-events fetcher for all reduce tasks &quot; + &quot;on &quot; +
taskTrackerName);
mapEventsFetcher.start();

initializeMemoryManagement();

this.indexCache = new IndexCache(this.fConf);

mapLauncher = new TaskLauncher(maxCurrentMapTasks);
reduceLauncher = new TaskLauncher(maxCurrentReduceTasks);
mapLauncher.start();
reduceLauncher.start();
}
public void run() {
while (!Thread.interrupted()) {
try {
TaskInProgress tip;
synchronized (tasksToLaunch) {
while (tasksToLaunch.isEmpty()) {
tasksToLaunch.wait();
}
//get the TIP
tip = tasksToLaunch.remove(0);
LOG.info(&quot;Trying to launch : &quot; + tip.getTask().getTaskID());
}
//wait for a slot to run
synchronized (numFreeSlots) {
while (numFreeSlots.get() == 0) {
numFreeSlots.wait();
}
LOG.info(&quot;In TaskLauncher, current free slots : &quot; + numFreeSlots.get()+
&quot; and trying to launch &quot;+tip.getTask().getTaskID());
numFreeSlots.set(numFreeSlots.get() - 1);
assert (numFreeSlots.get() &gt;= 0);
}
synchronized (tip) {
//to make sure that there is no kill task action for this
if (tip.getRunState() != TaskStatus.State.UNASSIGNED &amp;&amp;
tip.getRunState() != TaskStatus.State.FAILED_UNCLEAN &amp;&amp;
tip.getRunState() != TaskStatus.State.KILLED_UNCLEAN) {
//got killed externally while still in the launcher queue
addFreeSlot();
continue;
}
tip.slotTaken = true;
}
//got a free slot. launch the task
startNewTask(tip);
} catch (InterruptedException e) {
return; // ALL DONE
} catch (Throwable th) {
LOG.error(&quot;TaskLauncher error &quot; +
StringUtils.stringifyException(th));
}
}
}
}
private void startNewTask(TaskInProgress tip) {
try {
localizeJob(tip);
} catch (Throwable e) {
String msg = (&quot;Error initializing &quot; + tip.getTask().getTaskID() +
&quot;:\n&quot; + StringUtils.stringifyException(e));
LOG.warn(msg);
tip.reportDiagnosticInfo(msg);
try {
tip.kill(true);
tip.cleanup(true);
} catch (IOException ie2) {
LOG.info(&quot;Error cleaning up &quot; + tip.getTask().getTaskID() + &quot;:\n&quot; +
StringUtils.stringifyException(ie2));
}

// Careful!
// This might not be an &apos;Exception&apos; - don&apos;t handle &apos;Error&apos; here!
if (e instanceof Error) {
throw ((Error) e);
}
}
}

private void localizeJob(TaskInProgress tip) throws IOException {
Path localJarFile = null;
Task t = tip.getTask();
JobID jobId = t.getJobID();
Path jobFile = new Path(t.getJobFile());
// Get sizes of JobFile and JarFile
// sizes are -1 if they are not present.
FileStatus status = null;
long jobFileSize = -1;
try {
status = systemFS.getFileStatus(jobFile);
jobFileSize = status.getLen();
} catch(FileNotFoundException fe) {
jobFileSize = -1;
}
Path localJobFile = lDirAlloc.getLocalPathForWrite(
getLocalJobDir(jobId.toString())
+ Path.SEPARATOR + &quot;job.xml&quot;,
jobFileSize, fConf);
RunningJob rjob = addTaskToJob(jobId, tip);
synchronized (rjob) {
if (!rjob.localized) {

FileSystem localFs = FileSystem.getLocal(fConf);
// this will happen on a partial execution of localizeJob.
// Sometimes the job.xml gets copied but copying job.jar
// might throw out an exception
// we should clean up and then try again
Path jobDir = localJobFile.getParent();
if (localFs.exists(jobDir)){
localFs.delete(jobDir, true);
boolean b = localFs.mkdirs(jobDir);
if (!b)
throw new IOException(&quot;Not able to create job directory &quot;
+ jobDir.toString());
}
systemFS.copyToLocalFile(jobFile, localJobFile);
JobConf localJobConf = new JobConf(localJobFile);

// create the &apos;work&apos; directory
// job-specific shared directory for use as scratch space
Path workDir = lDirAlloc.getLocalPathForWrite(
(getLocalJobDir(jobId.toString())
+ Path.SEPARATOR + &quot;work&quot;), fConf);
if (!localFs.mkdirs(workDir)) {
throw new IOException(&quot;Mkdirs failed to create &quot;
+ workDir.toString());
}
System.setProperty(&quot;job.local.dir&quot;, workDir.toString());
localJobConf.set(&quot;job.local.dir&quot;, workDir.toString());

// copy Jar file to the local FS and unjar it.
String jarFile = localJobConf.getJar();
long jarFileSize = -1;
if (jarFile != null) {
Path jarFilePath = new Path(jarFile);
try {
status = systemFS.getFileStatus(jarFilePath);
jarFileSize = status.getLen();
} catch(FileNotFoundException fe) {
jarFileSize = -1;
}
// Here we check for and we check five times the size of jarFileSize
// to accommodate for unjarring the jar file in work directory
localJarFile = new Path(lDirAlloc.getLocalPathForWrite(
getLocalJobDir(jobId.toString())
+ Path.SEPARATOR + &quot;jars&quot;,
5 * jarFileSize, fConf), &quot;job.jar&quot;);
if (!localFs.mkdirs(localJarFile.getParent())) {
throw new IOException(&quot;Mkdirs failed to create jars directory &quot;);
}
systemFS.copyToLocalFile(jarFilePath, localJarFile);
localJobConf.setJar(localJarFile.toString());
OutputStream out = localFs.create(localJobFile);
try {
localJobConf.writeXml(out);
} finally {
out.close();
}
// also unjar the job.jar files
RunJar.unJar(new File(localJarFile.toString()),
new File(localJarFile.getParent().toString()));
}
rjob.keepJobFiles = ((localJobConf.getKeepTaskFilesPattern() != null) ||
localJobConf.getKeepFailedTaskFiles());
rjob.localized = true;
rjob.jobConf = localJobConf;
}
}
launchTaskForJob(tip, new JobConf(rjob.jobConf));
}
private void launchTaskForJob(TaskInProgress tip, JobConf jobConf) throws IOException{
synchronized (tip) {
tip.setJobConf(jobConf);
tip.launchTask();
}
}
public synchronized void launchTask() throws IOException {
if (this.taskStatus.getRunState() == TaskStatus.State.UNASSIGNED ||
this.taskStatus.getRunState() == TaskStatus.State.FAILED_UNCLEAN ||
this.taskStatus.getRunState() == TaskStatus.State.KILLED_UNCLEAN) {
localizeTask(task);
if (this.taskStatus.getRunState() == TaskStatus.State.UNASSIGNED) {
this.taskStatus.setRunState(TaskStatus.State.RUNNING);
}
this.runner = task.createRunner(TaskTracker.this, this);
this.runner.start();
this.taskStatus.setStartTime(System.currentTimeMillis());
} else {
LOG.info(&quot;Not launching task: &quot; + task.getTaskID() +
&quot; since it&apos;s state is &quot; + this.taskStatus.getRunState());
}
}
public final void run() {
try {

//before preparing the job localize
//all the archives
TaskAttemptID taskid = t.getTaskID();
LocalDirAllocator lDirAlloc = new LocalDirAllocator(&quot;mapred.local.dir&quot;);
File jobCacheDir = null;
if (conf.getJar() != null) {
jobCacheDir = new File(
new Path(conf.getJar()).getParent().toString());
}
File workDir = new File(lDirAlloc.getLocalPathToRead(
TaskTracker.getLocalTaskDir(
t.getJobID().toString(),
t.getTaskID().toString(),
t.isTaskCleanupTask())
+ Path.SEPARATOR + MRConstants.WORKDIR,
conf). toString());

URI[] archives = DistributedCache.getCacheArchives(conf);
URI[] files = DistributedCache.getCacheFiles(conf);
FileStatus fileStatus;
FileSystem fileSystem;
Path localPath;
String baseDir;

if ((archives != null) || (files != null)) {
if (archives != null) {
String[] archivesTimestamps =
DistributedCache.getArchiveTimestamps(conf);
Path[] p = new Path[archives.length];
for (int i = 0; i &lt; archives.length;i++){
fileSystem = FileSystem.get(archives[i], conf);
fileStatus = fileSystem.getFileStatus(
new Path(archives[i].getPath()));
String cacheId = DistributedCache.makeRelative(archives[i],conf);
String cachePath = TaskTracker.getCacheSubdir() +
Path.SEPARATOR + cacheId;

localPath = lDirAlloc.getLocalPathForWrite(cachePath,
fileStatus.getLen(), conf);
baseDir = localPath.toString().replace(cacheId, &quot;&quot;);
p[i] = DistributedCache.getLocalCache(archives[i], conf,
new Path(baseDir),
fileStatus,
true, Long.parseLong(
archivesTimestamps[i]),
new Path(workDir.
getAbsolutePath()),
false);

}
DistributedCache.setLocalArchives(conf, stringifyPathArray(p));
}
if ((files != null)) {
String[] fileTimestamps = DistributedCache.getFileTimestamps(conf);
Path[] p = new Path[files.length];
for (int i = 0; i &lt; files.length;i++){
fileSystem = FileSystem.get(files[i], conf);
fileStatus = fileSystem.getFileStatus(
new Path(files[i].getPath()));
String cacheId = DistributedCache.makeRelative(files[i], conf);
String cachePath = TaskTracker.getCacheSubdir() +
Path.SEPARATOR + cacheId;

localPath = lDirAlloc.getLocalPathForWrite(cachePath,
fileStatus.getLen(), conf);
baseDir = localPath.toString().replace(cacheId, &quot;&quot;);
p[i] = DistributedCache.getLocalCache(files[i], conf,
new Path(baseDir),
fileStatus,
false, Long.parseLong(
fileTimestamps[i]),
new Path(workDir.
getAbsolutePath()),
false);
}
DistributedCache.setLocalFiles(conf, stringifyPathArray(p));
}
Path localTaskFile = new Path(t.getJobFile());
FileSystem localFs = FileSystem.getLocal(conf);
localFs.delete(localTaskFile, true);
OutputStream out = localFs.create(localTaskFile);
try {
conf.writeXml(out);
} finally {
out.close();
}
}

if (!prepare()) {
return;
}

String sep = System.getProperty(&quot;path.separator&quot;);
StringBuffer classPath = new StringBuffer();
// start with same classpath as parent process
classPath.append(System.getProperty(&quot;java.class.path&quot;));
classPath.append(sep);
if (!workDir.mkdirs()) {
if (!workDir.isDirectory()) {
LOG.fatal(&quot;Mkdirs failed to create &quot; + workDir.toString());
}
}

String jar = conf.getJar();
if (jar != null) {
// if jar exists, it into workDir
File[] libs = new File(jobCacheDir, &quot;lib&quot;).listFiles();
if (libs != null) {
for (int i = 0; i &lt; libs.length; i++) {
classPath.append(sep); // add libs from jar to classpath
classPath.append(libs[i]);
}
}
classPath.append(sep);
classPath.append(new File(jobCacheDir, &quot;classes&quot;));
classPath.append(sep);
classPath.append(jobCacheDir);

}

// include the user specified classpath

//archive paths
Path[] archiveClasspaths = DistributedCache.getArchiveClassPaths(conf);
if (archiveClasspaths != null &amp;&amp; archives != null) {
Path[] localArchives = DistributedCache
.getLocalCacheArchives(conf);
if (localArchives != null){
for (int i=0;i&lt;archives.length;i++){
for(int j=0;j&lt;archiveClasspaths.length;j++){
if (archives[i].getPath().equals(
archiveClasspaths[j].toString())){
classPath.append(sep);
classPath.append(localArchives[i]
.toString());
}
}
}
}
}
//file paths
Path[] fileClasspaths = DistributedCache.getFileClassPaths(conf);
if (fileClasspaths!=null &amp;&amp; files != null) {
Path[] localFiles = DistributedCache
.getLocalCacheFiles(conf);
if (localFiles != null) {
for (int i = 0; i &lt; files.length; i++) {
for (int j = 0; j &lt; fileClasspaths.length; j++) {
if (files[i].getPath().equals(
fileClasspaths[j].toString())) {
classPath.append(sep);
classPath.append(localFiles[i].toString());
}
}
}
}
}

classPath.append(sep);
classPath.append(workDir);
// Build exec child jmv args.
Vector&lt;String&gt; vargs = new Vector&lt;String&gt;(8);
File jvm = // use same jvm as parent
new File(new File(System.getProperty(&quot;java.home&quot;), &quot;bin&quot;), &quot;java&quot;);

vargs.add(jvm.toString());

// Add child (task) java-vm options.
//
// The following symbols if present in mapred.child.java.opts value are
// replaced:
// + @taskid@ is interpolated with value of TaskID.
// Other occurrences of @ will not be altered.
//
// Example with multiple arguments and substitutions, showing
// jvm GC logging, and start of a passwordless JVM JMX agent so can
// connect with jconsole and the likes to watch child memory, threads
// and get thread dumps.
//
// &lt;property&gt;
// &lt;name&gt;mapred.child.java.opts&lt;/name&gt;
// &lt;value&gt;-verbose:gc -Xloggc:/tmp/@taskid@.gc \
// -Dcom.sun.management.jmxremote.authenticate=false \
// -Dcom.sun.management.jmxremote.ssl=false \
// &lt;/value&gt;
// &lt;/property&gt;
//
String javaOpts = conf.get(&quot;mapred.child.java.opts&quot;, &quot;-Xmx200m&quot;);
javaOpts = javaOpts.replace(&quot;@taskid@&quot;, taskid.toString());
String [] javaOptsSplit = javaOpts.split(&quot; &quot;);

// Add java.library.path; necessary for loading native libraries.
//
// 1. To support native-hadoop library i.e. libhadoop.so, we add the
// parent processes&apos; java.library.path to the child.
// 2. We also add the &apos;cwd&apos; of the task to it&apos;s java.library.path to help
// users distribute native libraries via the DistributedCache.
// 3. The user can also specify extra paths to be added to the
// java.library.path via mapred.child.java.opts.
//
String libraryPath = System.getProperty(&quot;java.library.path&quot;);
if (libraryPath == null) {
libraryPath = workDir.getAbsolutePath();
} else {
libraryPath += sep + workDir;
}
boolean hasUserLDPath = false;
for(int i=0; i&lt;javaOptsSplit.length ;i++) {
if(javaOptsSplit[i].startsWith(&quot;-Djava.library.path=&quot;)) {
javaOptsSplit[i] += sep + libraryPath;
hasUserLDPath = true;
break;
}
}
if(!hasUserLDPath) {
vargs.add(&quot;-Djava.library.path=&quot; + libraryPath);
}
for (int i = 0; i &lt; javaOptsSplit.length; i++) {
vargs.add(javaOptsSplit[i]);
}

// add java.io.tmpdir given by mapred.child.tmp
String tmp = conf.get(&quot;mapred.child.tmp&quot;, &quot;./tmp&quot;);
Path tmpDir = new Path(tmp);

// if temp directory path is not absolute
// prepend it with workDir.
if (!tmpDir.isAbsolute()) {
tmpDir = new Path(workDir.toString(), tmp);
}
FileSystem localFs = FileSystem.getLocal(conf);
if (!localFs.mkdirs(tmpDir) &amp;&amp; !localFs.getFileStatus(tmpDir).isDir()) {
throw new IOException(&quot;Mkdirs failed to create &quot; + tmpDir.toString());
}
vargs.add(&quot;-Djava.io.tmpdir=&quot; + tmpDir.toString());

// Add classpath.
vargs.add(&quot;-classpath&quot;);
vargs.add(classPath.toString());

// Setup the log4j prop
long logSize = TaskLog.getTaskLogLength(conf);
vargs.add(&quot;-Dhadoop.log.dir=&quot; +
new File(System.getProperty(&quot;hadoop.log.dir&quot;)
).getAbsolutePath());
vargs.add(&quot;-Dhadoop.root.logger=INFO,TLA&quot;);
vargs.add(&quot;-Dhadoop.tasklog.taskid=&quot; + taskid);
vargs.add(&quot;-Dhadoop.tasklog.totalLogFileSize=&quot; + logSize);

if (conf.getProfileEnabled()) {
if (conf.getProfileTaskRange(t.isMapTask()
).isIncluded(t.getPartition())) {
File prof = TaskLog.getTaskLogFile(taskid, TaskLog.LogName.PROFILE);
vargs.add(String.format(conf.getProfileParams(), prof.toString()));
}
}

// Add main class and its arguments
vargs.add(Child.class.getName()); // main of Child
// pass umbilical address
InetSocketAddress address = tracker.getTaskTrackerReportAddress();
vargs.add(address.getAddress().getHostAddress());
vargs.add(Integer.toString(address.getPort()));
vargs.add(taskid.toString()); // pass task identifier

String pidFile = lDirAlloc.getLocalPathForWrite(
(TaskTracker.getPidFile(t.getJobID().toString(),
taskid.toString(), t.isTaskCleanupTask())),
this.conf).toString();
t.setPidFile(pidFile);
tracker.addToMemoryManager(t.getTaskID(), t.isMapTask(), conf, pidFile);

// set memory limit using ulimit if feasible and necessary ...
String[] ulimitCmd = Shell.getUlimitMemoryCommand(conf);
List&lt;String&gt; setup = null;
if (ulimitCmd != null) {
setup = new ArrayList&lt;String&gt;();
for (String arg : ulimitCmd) {
setup.add(arg);
}
}

// Set up the redirection of the task&apos;s stdout and stderr streams
File stdout = TaskLog.getTaskLogFile(taskid, TaskLog.LogName.STDOUT);
File stderr = TaskLog.getTaskLogFile(taskid, TaskLog.LogName.STDERR);
stdout.getParentFile().mkdirs();
tracker.getTaskTrackerInstrumentation().reportTaskLaunch(taskid, stdout, stderr);

Map&lt;String, String&gt; env = new HashMap&lt;String, String&gt;();
StringBuffer ldLibraryPath = new StringBuffer();
ldLibraryPath.append(workDir.toString());
String oldLdLibraryPath = null;
oldLdLibraryPath = System.getenv(&quot;LD_LIBRARY_PATH&quot;);
if (oldLdLibraryPath != null) {
ldLibraryPath.append(sep);
ldLibraryPath.append(oldLdLibraryPath);
}
env.put(&quot;LD_LIBRARY_PATH&quot;, ldLibraryPath.toString());
jvmManager.launchJvm(this,
jvmManager.constructJvmEnv(setup,vargs,stdout,stderr,logSize,
workDir, env, pidFile, conf));
synchronized (lock) {
while (!done) {
lock.wait();
}
}
tracker.getTaskTrackerInstrumentation().reportTaskEnd(t.getTaskID());
if (exitCodeSet) {
if (!killed &amp;&amp; exitCode != 0) {
if (exitCode == 65) {
tracker.getTaskTrackerInstrumentation().taskFailedPing(t.getTaskID());
}
throw new IOException(&quot;Task process exit with nonzero status of &quot; +
exitCode + &quot;.&quot;);
}
}
} catch (FSError e) {
LOG.fatal(&quot;FSError&quot;, e);
try {
tracker.fsError(t.getTaskID(), e.getMessage());
} catch (IOException ie) {
LOG.fatal(t.getTaskID()+&quot; reporting FSError&quot;, ie);
}
} catch (Throwable throwable) {
LOG.warn(t.getTaskID()+&quot; Child Error&quot;, throwable);
ByteArrayOutputStream baos = new ByteArrayOutputStream();
throwable.printStackTrace(new PrintStream(baos));
try {
tracker.reportDiagnosticInfo(t.getTaskID(), baos.toString());
} catch (IOException e) {
LOG.warn(t.getTaskID()+&quot; Reporting Diagnostics&quot;, e);
}
} finally {
try{
URI[] archives = DistributedCache.getCacheArchives(conf);
URI[] files = DistributedCache.getCacheFiles(conf);
if (archives != null){
for (int i = 0; i &lt; archives.length; i++){
DistributedCache.releaseCache(archives[i], conf);
}
}
if (files != null){
for(int i = 0; i &lt; files.length; i++){
DistributedCache.releaseCache(files[i], conf);
}
}
}catch(IOException ie){
LOG.warn(&quot;Error releasing caches : Cache files might not have been cleaned up&quot;);
}
tip.reportTaskFinished();
}
}
public void launchJvm(TaskRunner t, JvmEnv env) {
if (t.getTask().isMapTask()) {
mapJvmManager.reapJvm(t, env);
} else {
reduceJvmManager.reapJvm(t, env);
}
}
private synchronized void reapJvm(
TaskRunner t, JvmEnv env) {
if (t.getTaskInProgress().wasKilled()) {
//the task was killed in-flight
//no need to do the rest of the operations
return;
}
boolean spawnNewJvm = false;
JobID jobId = t.getTask().getJobID();
//Check whether there is a free slot to start a new JVM.
//,or, Kill a (idle) JVM and launch a new one
//When this method is called, we *must*
// (1) spawn a new JVM (if we are below the max)
// (2) find an idle JVM (that belongs to the same job), or,
// (3) kill an idle JVM (from a different job)
// (the order of return is in the order above)
int numJvmsSpawned = jvmIdToRunner.size();
JvmRunner runnerToKill = null;
if (numJvmsSpawned &gt;= maxJvms) {
//go through the list of JVMs for all jobs.
Iterator&lt;Map.Entry&lt;JVMId, JvmRunner&gt;&gt; jvmIter =
jvmIdToRunner.entrySet().iterator();

while (jvmIter.hasNext()) {
JvmRunner jvmRunner = jvmIter.next().getValue();
JobID jId = jvmRunner.jvmId.getJobId();
//look for a free JVM for this job; if one exists then just break
if (jId.equals(jobId) &amp;&amp; !jvmRunner.isBusy() &amp;&amp; !jvmRunner.ranAll()){
setRunningTaskForJvm(jvmRunner.jvmId, t); //reserve the JVM
LOG.info(&quot;No new JVM spawned for jobId/taskid: &quot; +
jobId+&quot;/&quot;+t.getTask().getTaskID() +
&quot;. Attempting to reuse: &quot; + jvmRunner.jvmId);
return;
}
//Cases when a JVM is killed:
// (1) the JVM under consideration belongs to the same job
// (passed in the argument). In this case, kill only when
// the JVM ran all the tasks it was scheduled to run (in terms
// of count).
// (2) the JVM under consideration belongs to a different job and is
// currently not busy
//But in both the above cases, we see if we can assign the current
//task to an idle JVM (hence we continue the loop even on a match)
if ((jId.equals(jobId) &amp;&amp; jvmRunner.ranAll()) ||
(!jId.equals(jobId) &amp;&amp; !jvmRunner.isBusy())) {
runnerToKill = jvmRunner;
spawnNewJvm = true;
}
}
} else {
spawnNewJvm = true;
}

if (spawnNewJvm) {
if (runnerToKill != null) {
LOG.info(&quot;Killing JVM: &quot; + runnerToKill.jvmId);
runnerToKill.kill();
}
spawnNewJvm(jobId, env, t);
return;
}
//*MUST* never reach this
throw new RuntimeException(&quot;Inconsistent state!!! &quot; +
&quot;JVM Manager reached an unstable state &quot; +
&quot;while reaping a JVM for task: &quot; + t.getTask().getTaskID()+
&quot; &quot; + getDetails());
}
private void spawnNewJvm(JobID jobId, JvmEnv env,
TaskRunner t) {
JvmRunner jvmRunner = new JvmRunner(env,jobId);
jvmIdToRunner.put(jvmRunner.jvmId, jvmRunner);
//spawn the JVM in a new thread. Note that there will be very little
//extra overhead of launching the new thread for a new JVM since
//most of the cost is involved in launching the process. Moreover,
//since we are going to be using the JVM for running many tasks,
//the thread launch cost becomes trivial when amortized over all
//tasks. Doing it this way also keeps code simple.
jvmRunner.setDaemon(true);
jvmRunner.setName(&quot;JVM Runner &quot; + jvmRunner.jvmId + &quot; spawned.&quot;);
setRunningTaskForJvm(jvmRunner.jvmId, t);
LOG.info(jvmRunner.getName());
jvmRunner.start();
}
private class JvmRunner extends Thread {
JvmEnv env;
volatile boolean killed = false;
volatile int numTasksRan;
final int numTasksToRun;
JVMId jvmId;
volatile boolean busy = true;
private ShellCommandExecutor shexec; // shell terminal for running the task
public JvmRunner(JvmEnv env, JobID jobId) {
this.env = env;
this.jvmId = new JVMId(jobId, isMap, rand.nextInt());
this.numTasksToRun = env.conf.getNumTasksToExecutePerJvm();
LOG.info(&quot;In JvmRunner constructed JVM ID: &quot; + jvmId);
}
public void run() {
runChild(env);
}

public void runChild(JvmEnv env) {
try {
env.vargs.add(Integer.toString(jvmId.getId()));
List&lt;String&gt; wrappedCommand =
TaskLog.captureOutAndError(env.setup, env.vargs, env.stdout, env.stderr,
env.logSize, env.pidFile);
shexec = new ShellCommandExecutor(wrappedCommand.toArray(new String[0]),
env.workDir, env.env);
shexec.execute();
} catch (IOException ioe) {
// do nothing
// error and output are appropriately redirected
} finally { // handle the exit code
if (shexec == null) {
return;
}
int exitCode = shexec.getExitCode();
updateOnJvmExit(jvmId, exitCode, killed);
LOG.info(&quot;JVM : &quot; + jvmId +&quot; exited. Number of tasks it ran: &quot; +
numTasksRan);
try {
// In case of jvm-reuse,
//the task jvm cleans up the common workdir for every
//task at the beginning of each task in the task JVM.
//For the last task, we do it here.
if (env.conf.getNumTasksToExecutePerJvm() != 1) {
FileUtil.fullyDelete(env.workDir);
}
} catch (IOException ie){}
}
}
public void execute() throws IOException {
this.run();
}
/** check to see if a command needs to be executed and execute if needed */
protected void run() throws IOException {
if (lastTime + interval &gt; System.currentTimeMillis())
return;
exitCode = 0; // reset for next run
runCommand();
}

/** Run a command */
private void runCommand() throws IOException {
ProcessBuilder builder = new ProcessBuilder(getExecString());
boolean completed = false;

if (environment != null) {
builder.environment().putAll(this.environment);
}
if (dir != null) {
builder.directory(this.dir);
}

process = builder.start();
final BufferedReader errReader =
new BufferedReader(new InputStreamReader(process
.getErrorStream()));
BufferedReader inReader =
new BufferedReader(new InputStreamReader(process
.getInputStream()));
final StringBuffer errMsg = new StringBuffer();

// read error and input streams as this would free up the buffers
// free the error stream buffer
Thread errThread = new Thread() {
@Override
public void run() {
try {
String line = errReader.readLine();
while((line != null) &amp;&amp; !isInterrupted()) {
errMsg.append(line);
errMsg.append(System.getProperty(&quot;line.separator&quot;));
line = errReader.readLine();
}
} catch(IOException ioe) {
LOG.warn(&quot;Error reading the error stream&quot;, ioe);
}
}
};
try {
errThread.start();
} catch (IllegalStateException ise) { }
try {
parseExecResult(inReader); // parse the output
// clear the input stream buffer
String line = inReader.readLine();
while(line != null) {
line = inReader.readLine();
}
// wait for the process to finish and check the exit code
exitCode = process.waitFor();
try {
// make sure that the error thread exits
errThread.join();
} catch (InterruptedException ie) {
LOG.warn(&quot;Interrupted while reading the error stream&quot;, ie);
}
completed = true;
if (exitCode != 0) {
throw new ExitCodeException(exitCode, errMsg.toString());
}
} catch (InterruptedException ie) {
throw new IOException(ie.toString());
} finally {
// close the input stream
try {
inReader.close();
} catch (IOException ioe) {
LOG.warn(&quot;Error while closing the input stream&quot;, ioe);
}
if (!completed) {
errThread.interrupt();
}
try {
errReader.close();
} catch (IOException ioe) {
LOG.warn(&quot;Error while closing the error stream&quot;, ioe);
}
process.destroy();
lastTime = System.currentTimeMillis();
}
}
// Create the splits for the job
LOG.debug(&quot;Creating splits at &quot; + fs.makeQualified(submitSplitFile));
int maps;
if (job.getUseNewMapper()) {
maps = writeNewSplits(context, submitSplitFile);
} else {
maps = writeOldSplits(job, submitSplitFile);
}
job.set(&quot;mapred.job.split.file&quot;, submitSplitFile.toString());
job.setNumMapTasks(maps);
int writeNewSplits(JobContext job, Path submitSplitFile
) throws IOException, InterruptedException,
ClassNotFoundException {
JobConf conf = job.getJobConf();
org.apache.hadoop.mapreduce.InputFormat&lt;?,?&gt; input =
ReflectionUtils.newInstance(job.getInputFormatClass(), job.getJobConf());

List&lt;org.apache.hadoop.mapreduce.InputSplit&gt; splits = input.getSplits(job);
T[] array = (T[])
splits.toArray(new org.apache.hadoop.mapreduce.InputSplit[splits.size()]);

// sort the splits into order based on size, so that the biggest
// go first
Arrays.sort(array, new NewSplitComparator());
DataOutputStream out = writeSplitsFileHeader(conf, submitSplitFile,
array.length);
try {
if (array.length != 0) {
DataOutputBuffer buffer = new DataOutputBuffer();
RawSplit rawSplit = new RawSplit();
SerializationFactory factory = new SerializationFactory(conf);
Serializer&lt;T&gt; serializer =
factory.getSerializer((Class&lt;T&gt;) array[0].getClass());
serializer.open(buffer);
for(T split: array) {
rawSplit.setClassName(split.getClass().getName());
buffer.reset();
serializer.serialize(split);
rawSplit.setDataLength(split.getLength());
rawSplit.setBytes(buffer.getData(), 0, buffer.getLength());
rawSplit.setLocations(split.getLocations());
rawSplit.write(out);
}
serializer.close();
}
} finally {
out.close();
}
return array.length;
}
org.apache.hadoop.mapreduce.InputFormat&lt;?,?&gt; input =
ReflectionUtils.newInstance(job.getInputFormatClass(), job.getJobConf());

List&lt;org.apache.hadoop.mapreduce.InputSplit&gt; splits = input.getSplits(job);
public InputSplit[] getSplits(JobConf job, int numSplits)
throws IOException {
FileStatus[] files = listStatus(job);

long totalSize = 0; // compute total size
for (FileStatus file: files) { // check we have valid files
if (file.isDir()) {
throw new IOException(&quot;Not a file: &quot;+ file.getPath());
}
totalSize += file.getLen();
}

long goalSize = totalSize / (numSplits == 0 ? 1 : numSplits);
long minSize = Math.max(job.getLong(&quot;mapred.min.split.size&quot;, 1),
minSplitSize);

// generate splits
ArrayList&lt;FileSplit&gt; splits = new ArrayList&lt;FileSplit&gt;(numSplits);
NetworkTopology clusterMap = new NetworkTopology();
for (FileStatus file: files) {
Path path = file.getPath();
FileSystem fs = path.getFileSystem(job);
long length = file.getLen();
BlockLocation[] blkLocations = fs.getFileBlockLocations(file, 0, length);
if ((length != 0) &amp;&amp; isSplitable(fs, path)) {
long blockSize = file.getBlockSize();
long splitSize = computeSplitSize(goalSize, minSize, blockSize);

long bytesRemaining = length;
while (((double) bytesRemaining)/splitSize &gt; SPLIT_SLOP) {
String[] splitHosts = getSplitHosts(blkLocations,
length-bytesRemaining, splitSize, clusterMap);
splits.add(new FileSplit(path, length-bytesRemaining, splitSize,
splitHosts));
bytesRemaining -= splitSize;
}

if (bytesRemaining != 0) {
splits.add(new FileSplit(path, length-bytesRemaining, bytesRemaining,
blkLocations[blkLocations.length-1].getHosts()));
}
} else if (length != 0) {
String[] splitHosts = getSplitHosts(blkLocations,0,length,clusterMap);
splits.add(new FileSplit(path, 0, length, splitHosts));
} else {
//Create empty hosts array for zero length files
splits.add(new FileSplit(path, 0, length, new String[0]));
}
}
LOG.debug(&quot;Total # of splits: &quot; + splits.size());
return splits.toArray(new FileSplit[splits.size()]);
}
rawSplit.setBytes(buffer.getData(), 0, buffer.getLength());
public void setBytes(byte[] data, int offset, int length) {
bytes.set(data, offset, length);
}
public void set(byte[] newData, int offset, int length) {
setSize(0);
setSize(length);
System.arraycopy(newData, offset, bytes, 0, size);
}
&lt;pre class=&quot;java&quot; name=&quot;code&quot;&gt; //
// read input splits and create a map per a split
//
String jobFile = profile.getJobFile();

Path sysDir = new Path(this.jobtracker.getSystemDir());
FileSystem fs = sysDir.getFileSystem(conf);
DataInputStream splitFile =
fs.open(new Path(conf.get(&quot;mapred.job.split.file&quot;)));
JobClient.RawSplit[] splits;
try {
splits = JobClient.readSplitFile(splitFile);
} finally {
splitFile.close();
}
numMapTasks = splits.length;
static RawSplit[] readSplitFile(DataInput in) throws IOException {
byte[] header = new byte[SPLIT_FILE_HEADER.length];
in.readFully(header);
if (!Arrays.equals(SPLIT_FILE_HEADER, header)) {
throw new IOException(&quot;Invalid header on split file&quot;);
}
int vers = WritableUtils.readVInt(in);
if (vers != CURRENT_SPLIT_FILE_VERSION) {
throw new IOException(&quot;Unsupported split version &quot; + vers);
}
int len = WritableUtils.readVInt(in);
RawSplit[] result = new RawSplit[len];
for(int i=0; i &lt; len; ++i) {
result[i] = new RawSplit();
result[i].readFields(in);
}
return result;
}
maps = new TaskInProgress[numMapTasks];
for(int i=0; i &lt; numMapTasks; ++i) {
inputLength += splits[i].getDataLength();
maps[i] = new TaskInProgress(jobId, jobFile,
splits[i],
jobtracker, conf, this, i);
}
&lt;p&gt; &lt;/p&gt;&lt;pre class=&quot;java&quot; name=&quot;code&quot;&gt;public class WordCount {

public static class TokenizerMapper extends
Mapper&lt;Object, Text, Text, IntWritable&gt; {

private final static IntWritable one = new IntWritable(1);
private Text word = new Text();

public void map(Object key, Text value, Context context)
throws IOException, InterruptedException {
// StringTokenizer itr = new StringTokenizer(value.toString());
String line = value.toString();
String[] line1 = line.split(&quot;\\W&quot;);
for (String line2 : line1) {
String[] words = line2.split(&quot; &quot;);
for (String wordend : words) {
word.set(wordend);
context.write(word, one);
}
}
// while (itr.hasMoreTokens()) {
// word.set(itr.nextToken());
// context.write(word, one);
// }
}
}

public static class IntSumReducer extends
Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {
private IntWritable result = new IntWritable();

public void reduce(Text key, Iterable&lt;IntWritable&gt; values,
Context context) throws IOException, InterruptedException {
int sum = 0;
for (IntWritable val : values) {
sum += val.get();
}
result.set(sum);
context.write(key, result);
}
}

public static void main(String[] args) throws Exception {
try {
Configuration conf = new Configuration();
String[] otherArgs = new GenericOptionsParser(conf, args)
.getRemainingArgs();
if (otherArgs.length != 2) {
System.err.println(&quot;Usage: wordcount &lt;in&gt; &lt;out&gt;&quot;);
System.exit(2);
}
Job job = new Job(conf, &quot;word count&quot;);
job.setJarByClass(WordCount.class);
job.setMapperClass(TokenizerMapper.class);
job.setCombinerClass(IntSumReducer.class);
job.setReducerClass(IntSumReducer.class);
job.setOutputKeyClass(Text.class);
job.setOutputValueClass(IntWritable.class);
FileInputFormat.addInputPath(job, new Path(otherArgs[0]));
FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));
System.out.println(&quot;job start!&quot;);
System.exit(job.waitForCompletion(true) ? 0 : 1);
System.out.println(&quot;completed!&quot;);
} catch (Exception e) {
e.printStackTrace();
}

}
}
public boolean waitForCompletion(boolean verbose
) throws IOException, InterruptedException,
ClassNotFoundException {
if (state == JobState.DEFINE) {
submit();
}
if (verbose) {
jobClient.monitorAndPrintJob(conf, info);
} else {
info.waitForCompletion();
}
return isSuccessful();
}
public void submit() throws IOException, InterruptedException,
ClassNotFoundException {
ensureState(JobState.DEFINE);
setUseNewAPI();
info = jobClient.submitJobInternal(conf);
super.setJobID(info.getID());
state = JobState.RUNNING;
}
public Job(Configuration conf) throws IOException {
super(conf, null);
jobClient = new JobClient((JobConf) getConfiguration());
}
public
RunningJob submitJobInternal(JobConf job
) throws FileNotFoundException,
ClassNotFoundException,
InterruptedException,
IOException {
/*
* configure the command line options correctly on the submitting dfs
*/

JobID jobId = jobSubmitClient.getNewJobId();
Path submitJobDir = new Path(getSystemDir(), jobId.toString());
Path submitJarFile = new Path(submitJobDir, &quot;job.jar&quot;);
Path submitSplitFile = new Path(submitJobDir, &quot;job.split&quot;);
configureCommandLineOptions(job, submitJobDir, submitJarFile);
Path submitJobFile = new Path(submitJobDir, &quot;job.xml&quot;);
int reduces = job.getNumReduceTasks();
JobContext context = new JobContext(job, jobId);

// Check the output specification
if (reduces == 0 ? job.getUseNewMapper() : job.getUseNewReducer()) {
org.apache.hadoop.mapreduce.OutputFormat&lt;?,?&gt; output =
ReflectionUtils.newInstance(context.getOutputFormatClass(), job);
output.checkOutputSpecs(context);
} else {
job.getOutputFormat().checkOutputSpecs(fs, job);
}

// Create the splits for the job
LOG.debug(&quot;Creating splits at &quot; + fs.makeQualified(submitSplitFile));
int maps;
if (job.getUseNewMapper()) {
maps = writeNewSplits(context, submitSplitFile);
} else {
maps = writeOldSplits(job, submitSplitFile);
}
job.set(&quot;mapred.job.split.file&quot;, submitSplitFile.toString());
job.setNumMapTasks(maps);

// Write job file to JobTracker&apos;s fs
FSDataOutputStream out =
FileSystem.create(fs, submitJobFile,
new FsPermission(JOB_FILE_PERMISSION));

try {
job.writeXml(out);
} finally {
out.close();
}

//
// Now, actually submit the job (using the submit name)
//
JobStatus status = jobSubmitClient.submitJob(jobId);
if (status != null) {
return new NetworkedJob(status);
} else {
throw new IOException(&quot;Could not launch job&quot;);
}
}
private JobSubmissionProtocol createRPCProxy(InetSocketAddress addr,
Configuration conf) throws IOException {
return (JobSubmissionProtocol) RPC.getProxy(JobSubmissionProtocol.class,
JobSubmissionProtocol.versionID, addr, getUGI(conf), conf,
NetUtils.getSocketFactory(conf, JobSubmissionProtocol.class));
}
public static void main(String argv[]
) throws IOException, InterruptedException {
StringUtils.startupShutdownMessage(JobTracker.class, argv, LOG);
if (argv.length != 0) {
System.out.println(&quot;usage: JobTracker&quot;);
System.exit(-1);
}

try {
JobTracker tracker = startTracker(new JobConf());
tracker.offerService();
} catch (Throwable e) {
LOG.fatal(StringUtils.stringifyException(e));
System.exit(-1);
}
}
public static JobTracker startTracker(JobConf conf, String identifier)
throws IOException, InterruptedException {
JobTracker result = null;
while (true) {
try {
result = new JobTracker(conf, identifier);
result.taskScheduler.setTaskTrackerManager(result);
break;
} catch (VersionMismatch e) {
throw e;
} catch (BindException e) {
throw e;
} catch (UnknownHostException e) {
throw e;
} catch (AccessControlException ace) {
// in case of jobtracker not having right access
// bail out
throw ace;
} catch (IOException e) {
LOG.warn(&quot;Error starting tracker: &quot; +
StringUtils.stringifyException(e));
}
Thread.sleep(1000);
}
if (result != null) {
JobEndNotifier.startNotifier();
}
return result;
}
Class&lt;? extends TaskScheduler&gt; schedulerClass
= conf.getClass(&quot;mapred.jobtracker.taskScheduler&quot;,
JobQueueTaskScheduler.class, TaskScheduler.class);
taskScheduler = (TaskScheduler) ReflectionUtils.newInstance(schedulerClass, conf);
public void offerService() throws InterruptedException, IOException {
// Prepare for recovery. This is done irrespective of the status of restart
// flag.
while (true) {
try {
recoveryManager.updateRestartCount();
break;
} catch (IOException ioe) {
LOG.warn(&quot;Failed to initialize recovery manager. &quot;, ioe);
// wait for some time
Thread.sleep(FS_ACCESS_RETRY_PERIOD);
LOG.warn(&quot;Retrying...&quot;);
}
}

taskScheduler.start();

// Start the recovery after starting the scheduler
try {
recoveryManager.recover();
} catch (Throwable t) {
LOG.warn(&quot;Recovery manager crashed! Ignoring.&quot;, t);
}

this.expireTrackersThread = new Thread(this.expireTrackers,
&quot;expireTrackers&quot;);
this.expireTrackersThread.start();
this.retireJobsThread = new Thread(this.retireJobs, &quot;retireJobs&quot;);
this.retireJobsThread.start();
expireLaunchingTaskThread.start();

if (completedJobStatusStore.isActive()) {
completedJobsStoreThread = new Thread(completedJobStatusStore,
&quot;completedjobsStore-housekeeper&quot;);
completedJobsStoreThread.start();
}

// start the inter-tracker server once the jt is ready
this.interTrackerServer.start();

synchronized (this) {
state = State.RUNNING;
}
LOG.info(&quot;Starting RUNNING&quot;);

this.interTrackerServer.join();
LOG.info(&quot;Stopped interTrackerServer&quot;);
}
public synchronized void start() throws IOException {
super.start();
taskTrackerManager.addJobInProgressListener(jobQueueJobInProgressListener);
eagerTaskInitializationListener.setTaskTrackerManager(taskTrackerManager);
eagerTaskInitializationListener.start();
taskTrackerManager.addJobInProgressListener(
eagerTaskInitializationListener);
}
public void start() throws IOException {
this.jobInitManagerThread = new Thread(jobInitManager, &quot;jobInitManager&quot;);
jobInitManagerThread.setDaemon(true);
this.jobInitManagerThread.start();
}
class JobInitManager implements Runnable {

public void run() {
JobInProgress job = null;
while (true) {
try {
synchronized (jobInitQueue) {
while (jobInitQueue.isEmpty()) {
jobInitQueue.wait();
}
job = jobInitQueue.remove(0);
}
threadPool.execute(new InitJob(job));
} catch (InterruptedException t) {
LOG.info(&quot;JobInitManagerThread interrupted.&quot;);
break;
}
}
LOG.info(&quot;Shutting down thread pool&quot;);
threadPool.shutdownNow();
}
}
class InitJob implements Runnable {

private JobInProgress job;

public InitJob(JobInProgress job) {
this.job = job;
}

public void run() {
ttm.initJob(job);
}
}
public void setTaskTrackerManager(TaskTrackerManager ttm) {
this.ttm = ttm;
}
result.taskScheduler.setTaskTrackerManager(result);
public void initJob(JobInProgress job) {
if (null == job) {
LOG.info(&quot;Init on null job is not valid&quot;);
return;
}

try {
JobStatus prevStatus = (JobStatus)job.getStatus().clone();
LOG.info(&quot;Initializing &quot; + job.getJobID());
job.initTasks();
// Inform the listeners if the job state has changed
// Note : that the job will be in PREP state.
JobStatus newStatus = (JobStatus)job.getStatus().clone();
if (prevStatus.getRunState() != newStatus.getRunState()) {
JobStatusChangeEvent event =
new JobStatusChangeEvent(job, EventType.RUN_STATE_CHANGED, prevStatus,
newStatus);
synchronized (JobTracker.this) {
updateJobInProgressListeners(event);
}
}
} catch (KillInterruptedException kie) {
// If job was killed during initialization, job state will be KILLED
LOG.error(&quot;Job initialization interrupted:\n&quot; +
StringUtils.stringifyException(kie));
killJob(job);
} catch (Throwable t) {
// If the job initialization is failed, job state will be FAILED
LOG.error(&quot;Job initialization failed:\n&quot; +
StringUtils.stringifyException(t));
failJob(job);
}
}
/**
* Construct the splits, etc. This is invoked from an async
* thread so that split-computation doesn&apos;t block anyone.
*/
public synchronized void initTasks()
throws IOException, KillInterruptedException {
if (tasksInited.get() || isComplete()) {
return;
}
synchronized(jobInitKillStatus){
if(jobInitKillStatus.killed || jobInitKillStatus.initStarted) {
return;
}
jobInitKillStatus.initStarted = true;
}

LOG.info(&quot;Initializing &quot; + jobId);

// log job info
JobHistory.JobInfo.logSubmitted(getJobID(), conf, jobFile.toString(),
this.startTime, hasRestarted());
// log the job priority
setPriority(this.priority);

//
// read input splits and create a map per a split
//
String jobFile = profile.getJobFile();

Path sysDir = new Path(this.jobtracker.getSystemDir());
FileSystem fs = sysDir.getFileSystem(conf);
DataInputStream splitFile =
fs.open(new Path(conf.get(&quot;mapred.job.split.file&quot;)));
JobClient.RawSplit[] splits;
try {
splits = JobClient.readSplitFile(splitFile);
} finally {
splitFile.close();
}
numMapTasks = splits.length;


// if the number of splits is larger than a configured value
// then fail the job.
int maxTasks = jobtracker.getMaxTasksPerJob();
if (maxTasks &gt; 0 &amp;&amp; numMapTasks + numReduceTasks &gt; maxTasks) {
throw new IOException(
&quot;The number of tasks for this job &quot; +
(numMapTasks + numReduceTasks) +
&quot; exceeds the configured limit &quot; + maxTasks);
}
jobtracker.getInstrumentation().addWaiting(
getJobID(), numMapTasks + numReduceTasks);

maps = new TaskInProgress[numMapTasks];
for(int i=0; i &lt; numMapTasks; ++i) {
inputLength += splits[i].getDataLength();
maps[i] = new TaskInProgress(jobId, jobFile,
splits[i],
jobtracker, conf, this, i);
}
LOG.info(&quot;Input size for job &quot; + jobId + &quot; = &quot; + inputLength
+ &quot;. Number of splits = &quot; + splits.length);
if (numMapTasks &gt; 0) {
nonRunningMapCache = createCache(splits, maxLevel);
}

// set the launch time
this.launchTime = System.currentTimeMillis();

//
// Create reduce tasks
//
this.reduces = new TaskInProgress[numReduceTasks];
for (int i = 0; i &lt; numReduceTasks; i++) {
reduces[i] = new TaskInProgress(jobId, jobFile,
numMapTasks, i,
jobtracker, conf, this);
nonRunningReduces.add(reduces[i]);
}

// Calculate the minimum number of maps to be complete before
// we should start scheduling reduces
completedMapsForReduceSlowstart =
(int)Math.ceil(
(conf.getFloat(&quot;mapred.reduce.slowstart.completed.maps&quot;,
DEFAULT_COMPLETED_MAPS_PERCENT_FOR_REDUCE_SLOWSTART) *
numMapTasks));

// create cleanup two cleanup tips, one map and one reduce.
cleanup = new TaskInProgress[2];

// cleanup map tip. This map doesn&apos;t use any splits. Just assign an empty
// split.
JobClient.RawSplit emptySplit = new JobClient.RawSplit();
cleanup[0] = new TaskInProgress(jobId, jobFile, emptySplit,
jobtracker, conf, this, numMapTasks);
cleanup[0].setJobCleanupTask();

// cleanup reduce tip.
cleanup[1] = new TaskInProgress(jobId, jobFile, numMapTasks,
numReduceTasks, jobtracker, conf, this);
cleanup[1].setJobCleanupTask();

// create two setup tips, one map and one reduce.
setup = new TaskInProgress[2];

// setup map tip. This map doesn&apos;t use any split. Just assign an empty
// split.
setup[0] = new TaskInProgress(jobId, jobFile, emptySplit,
jobtracker, conf, this, numMapTasks + 1 );
setup[0].setJobSetupTask();

// setup reduce tip.
setup[1] = new TaskInProgress(jobId, jobFile, numMapTasks,
numReduceTasks + 1, jobtracker, conf, this);
setup[1].setJobSetupTask();

synchronized(jobInitKillStatus){
jobInitKillStatus.initDone = true;
if(jobInitKillStatus.killed) {
throw new KillInterruptedException(&quot;Job &quot; + jobId + &quot; killed in init&quot;);
}
}

tasksInited.set(true);
JobHistory.JobInfo.logInited(profile.getJobID(), this.launchTime,
numMapTasks, numReduceTasks);
}
this.interTrackerServer = RPC.getServer(this, addr.getHostName(), addr.getPort(), handlerCount, false, conf);
this.interTrackerServer.start();
this.jobClient = (InterTrackerProtocol)
RPC.waitForProxy(InterTrackerProtocol.class,
InterTrackerProtocol.versionID,
jobTrackAddr, this.fConf);
public static void main(String argv[]) throws Exception {
StringUtils.startupShutdownMessage(TaskTracker.class, argv, LOG);
if (argv.length != 0) {
System.out.println(&quot;usage: TaskTracker&quot;);
System.exit(-1);
}
try {
JobConf conf=new JobConf();
// enable the server to track time spent waiting on locks
ReflectionUtils.setContentionTracing
(conf.getBoolean(&quot;tasktracker.contention.tracking&quot;, false));
new TaskTracker(conf).run();
} catch (Throwable e) {
LOG.error(&quot;Can not start task tracker because &quot;+
StringUtils.stringifyException(e));
System.exit(-1);
}
}
public void run() {
try {
startCleanupThreads();
boolean denied = false;
while (running &amp;&amp; !shuttingDown &amp;&amp; !denied) {
boolean staleState = false;
try {
// This while-loop attempts reconnects if we get network errors
while (running &amp;&amp; !staleState &amp;&amp; !shuttingDown &amp;&amp; !denied) {
try {
State osState = offerService();
if (osState == State.STALE) {
staleState = true;
} else if (osState == State.DENIED) {
denied = true;
}
} catch (Exception ex) {
if (!shuttingDown) {
LOG.info(&quot;Lost connection to JobTracker [&quot; +
jobTrackAddr + &quot;]. Retrying...&quot;, ex);
try {
Thread.sleep(5000);
} catch (InterruptedException ie) {
}
}
}
}
} finally {
close();
}
if (shuttingDown) { return; }
LOG.warn(&quot;Reinitializing local state&quot;);
initialize();
}
if (denied) {
shutdown();
}
} catch (IOException iex) {
LOG.error(&quot;Got fatal exception while reinitializing TaskTracker: &quot; +
StringUtils.stringifyException(iex));
return;
}
}
State offerService() throws Exception {
long lastHeartbeat = 0;

while (running &amp;&amp; !shuttingDown) {
try {
long now = System.currentTimeMillis();

long waitTime = heartbeatInterval - (now - lastHeartbeat);
if (waitTime &gt; 0) {
// sleeps for the wait time
Thread.sleep(waitTime);
}

// If the TaskTracker is just starting up:
// 1. Verify the buildVersion
// 2. Get the system directory &amp; filesystem
if(justInited) {
String jobTrackerBV = jobClient.getBuildVersion();
if(!VersionInfo.getBuildVersion().equals(jobTrackerBV)) {
String msg = &quot;Shutting down. Incompatible buildVersion.&quot; +
&quot;\nJobTracker&apos;s: &quot; + jobTrackerBV +
&quot;\nTaskTracker&apos;s: &quot;+ VersionInfo.getBuildVersion();
LOG.error(msg);
try {
jobClient.reportTaskTrackerError(taskTrackerName, null, msg);
} catch(Exception e ) {
LOG.info(&quot;Problem reporting to jobtracker: &quot; + e);
}
return State.DENIED;
}

String dir = jobClient.getSystemDir();
if (dir == null) {
throw new IOException(&quot;Failed to get system directory&quot;);
}
systemDirectory = new Path(dir);
systemFS = systemDirectory.getFileSystem(fConf);
}

// Send the heartbeat and process the jobtracker&apos;s directives
HeartbeatResponse heartbeatResponse = transmitHeartBeat(now);

// Note the time when the heartbeat returned, use this to decide when to send the
// next heartbeat
lastHeartbeat = System.currentTimeMillis();


// Check if the map-event list needs purging
Set&lt;JobID&gt; jobs = heartbeatResponse.getRecoveredJobs();
if (jobs.size() &gt; 0) {
synchronized (this) {
// purge the local map events list
for (JobID job : jobs) {
RunningJob rjob;
synchronized (runningJobs) {
rjob = runningJobs.get(job);
if (rjob != null) {
synchronized (rjob) {
FetchStatus f = rjob.getFetchStatus();
if (f != null) {
f.reset();
}
}
}
}
}

// Mark the reducers in shuffle for rollback
synchronized (shouldReset) {
for (Map.Entry&lt;TaskAttemptID, TaskInProgress&gt; entry
: runningTasks.entrySet()) {
if (entry.getValue().getStatus().getPhase() == Phase.SHUFFLE) {
this.shouldReset.add(entry.getKey());
}
}
}
}
}

TaskTrackerAction[] actions = heartbeatResponse.getActions();
if(LOG.isDebugEnabled()) {
LOG.debug(&quot;Got heartbeatResponse from JobTracker with responseId: &quot; +
heartbeatResponse.getResponseId() + &quot; and &quot; +
((actions != null) ? actions.length : 0) + &quot; actions&quot;);
}
if (reinitTaskTracker(actions)) {
return State.STALE;
}

// resetting heartbeat interval from the response.
heartbeatInterval = heartbeatResponse.getHeartbeatInterval();
justStarted = false;
justInited = false;
if (actions != null){
for(TaskTrackerAction action: actions) {
if (action instanceof LaunchTaskAction) {
addToTaskQueue((LaunchTaskAction)action);
} else if (action instanceof CommitTaskAction) {
CommitTaskAction commitAction = (CommitTaskAction)action;
if (!commitResponses.contains(commitAction.getTaskID())) {
LOG.info(&quot;Received commit task action for &quot; +
commitAction.getTaskID());
commitResponses.add(commitAction.getTaskID());
}
} else {
tasksToCleanup.put(action);
}
}
}
markUnresponsiveTasks();
killOverflowingTasks();

//we&apos;ve cleaned up, resume normal operation
if (!acceptNewTasks &amp;&amp; isIdle()) {
acceptNewTasks=true;
}
//The check below may not be required every iteration but we are
//erring on the side of caution here. We have seen many cases where
//the call to jetty&apos;s getLocalPort() returns different values at
//different times. Being a real paranoid here.
checkJettyPort(server.getPort());
} catch (InterruptedException ie) {
LOG.info(&quot;Interrupted. Closing down.&quot;);
return State.INTERRUPTED;
} catch (DiskErrorException de) {
String msg = &quot;Exiting task tracker for disk error:\n&quot; +
StringUtils.stringifyException(de);
LOG.error(msg);
synchronized (this) {
jobClient.reportTaskTrackerError(taskTrackerName,
&quot;DiskErrorException&quot;, msg);
}
return State.STALE;
} catch (RemoteException re) {
String reClass = re.getClassName();
if (DisallowedTaskTrackerException.class.getName().equals(reClass)) {
LOG.info(&quot;Tasktracker disallowed by JobTracker.&quot;);
return State.DENIED;
}
} catch (Exception except) {
String msg = &quot;Caught exception: &quot; +
StringUtils.stringifyException(except);
LOG.error(msg);
}
}

return State.NORMAL;
}
private void addToTaskQueue(LaunchTaskAction action) {
if (action.getTask().isMapTask()) {
mapLauncher.addToTaskQueue(action);
} else {
reduceLauncher.addToTaskQueue(action);
}
}
public void addToTaskQueue(LaunchTaskAction action) {
synchronized (tasksToLaunch) {
TaskInProgress tip = registerTask(action, this);
tasksToLaunch.add(tip);
tasksToLaunch.notifyAll();
}
}
private TaskInProgress registerTask(LaunchTaskAction action,
TaskLauncher launcher) {
Task t = action.getTask();
LOG.info(&quot;LaunchTaskAction (registerTask): &quot; + t.getTaskID() +
&quot; task&apos;s state:&quot; + t.getState());
TaskInProgress tip = new TaskInProgress(t, this.fConf, launcher);
synchronized (this) {
tasks.put(t.getTaskID(), tip);
runningTasks.put(t.getTaskID(), tip);
boolean isMap = t.isMapTask();
if (isMap) {
mapTotal++;
} else {
reduceTotal++;
}
}
return tip;
}
private HeartbeatResponse transmitHeartBeat(long now) throws IOException {
// Send Counters in the status once every COUNTER_UPDATE_INTERVAL
boolean sendCounters;
if (now &gt; (previousUpdate + COUNTER_UPDATE_INTERVAL)) {
sendCounters = true;
previousUpdate = now;
}
else {
sendCounters = false;
}

//
// Check if the last heartbeat got through...
// if so then build the heartbeat information for the JobTracker;
// else resend the previous status information.
//
if (status == null) {
synchronized (this) {
status = new TaskTrackerStatus(taskTrackerName, localHostname,
httpPort,
cloneAndResetRunningTaskStatuses(
sendCounters),
failures,
maxCurrentMapTasks,
maxCurrentReduceTasks);
}
} else {
LOG.info(&quot;Resending &apos;status&apos; to &apos;&quot; + jobTrackAddr.getHostName() +
&quot;&apos; with reponseId &apos;&quot; + heartbeatResponseId);
}

//
// Check if we should ask for a new Task
//
boolean askForNewTask;
long localMinSpaceStart;
synchronized (this) {
askForNewTask = (status.countMapTasks() &lt; maxCurrentMapTasks ||
status.countReduceTasks() &lt; maxCurrentReduceTasks) &amp;&amp;
acceptNewTasks;
localMinSpaceStart = minSpaceStart;
}
if (askForNewTask) {
checkLocalDirs(fConf.getLocalDirs());
askForNewTask = enoughFreeSpace(localMinSpaceStart);
long freeDiskSpace = getFreeSpace();
long totVmem = getTotalVirtualMemoryOnTT();
long totPmem = getTotalPhysicalMemoryOnTT();

status.getResourceStatus().setAvailableSpace(freeDiskSpace);
status.getResourceStatus().setTotalVirtualMemory(totVmem);
status.getResourceStatus().setTotalPhysicalMemory(totPmem);
status.getResourceStatus().setMapSlotMemorySizeOnTT(
mapSlotMemorySizeOnTT);
status.getResourceStatus().setReduceSlotMemorySizeOnTT(
reduceSlotSizeMemoryOnTT);
}

//
// Xmit the heartbeat
//
HeartbeatResponse heartbeatResponse = jobClient.heartbeat(status,
justStarted,
justInited,
askForNewTask,
heartbeatResponseId);

//
// The heartbeat got through successfully!
//
heartbeatResponseId = heartbeatResponse.getResponseId();

synchronized (this) {
for (TaskStatus taskStatus : status.getTaskReports()) {
if (taskStatus.getRunState() != TaskStatus.State.RUNNING &amp;&amp;
taskStatus.getRunState() != TaskStatus.State.UNASSIGNED &amp;&amp;
taskStatus.getRunState() != TaskStatus.State.COMMIT_PENDING &amp;&amp;
!taskStatus.inTaskCleanupPhase()) {
if (taskStatus.getIsMap()) {
mapTotal--;
} else {
reduceTotal--;
}
try {
myInstrumentation.completeTask(taskStatus.getTaskID());
} catch (MetricsException me) {
LOG.warn(&quot;Caught: &quot; + StringUtils.stringifyException(me));
}
runningTasks.remove(taskStatus.getTaskID());
}
}

// Clear transient status information which should only
// be sent once to the JobTracker
for (TaskInProgress tip: runningTasks.values()) {
tip.getStatus().clearStatus();
}
}

// Force a rebuild of &apos;status&apos; on the next iteration
status = null;

return heartbeatResponse;
}
&lt;pre class=&quot;java&quot; name=&quot;code&quot;&gt; public synchronized HeartbeatResponse heartbeat(TaskTrackerStatus status,
boolean restarted,
boolean initialContact,
boolean acceptNewTasks,
short responseId)
throws IOException {
LOG.debug(&quot;Got heartbeat from: &quot; + status.getTrackerName() +
&quot; (restarted: &quot; + restarted +
&quot; initialContact: &quot; + initialContact +
&quot; acceptNewTasks: &quot; + acceptNewTasks + &quot;)&quot; +
&quot; with responseId: &quot; + responseId);

// Make sure heartbeat is from a tasktracker allowed by the jobtracker.
if (!acceptTaskTracker(status)) {
throw new DisallowedTaskTrackerException(status);
}

// First check if the last heartbeat response got through
String trackerName = status.getTrackerName();
long now = System.currentTimeMillis();
boolean isBlacklisted = false;
if (restarted) {
faultyTrackers.markTrackerHealthy(status.getHost());
} else {
isBlacklisted =
faultyTrackers.shouldAssignTasksToTracker(status.getHost(), now);
}

HeartbeatResponse prevHeartbeatResponse =
trackerToHeartbeatResponseMap.get(trackerName);
boolean addRestartInfo = false;

if (initialContact != true) {
// If this isn&apos;t the &apos;initial contact&apos; from the tasktracker,
// there is something seriously wrong if the JobTracker has
// no record of the &apos;previous heartbeat&apos;; if so, ask the
// tasktracker to re-initialize itself.
if (prevHeartbeatResponse == null) {
// This is the first heartbeat from the old tracker to the newly
// started JobTracker
if (hasRestarted()) {
addRestartInfo = true;
// inform the recovery manager about this tracker joining back
recoveryManager.unMarkTracker(trackerName);
} else {
// Jobtracker might have restarted but no recovery is needed
// otherwise this code should not be reached
LOG.warn(&quot;Serious problem, cannot find record of &apos;previous&apos; &quot; +
&quot;heartbeat for &apos;&quot; + trackerName +
&quot;&apos;; reinitializing the tasktracker&quot;);
return new HeartbeatResponse(responseId,
new TaskTrackerAction[] {new ReinitTrackerAction()});
}

} else {

// It is completely safe to not process a &apos;duplicate&apos; heartbeat from a
// {@link TaskTracker} since it resends the heartbeat when rpcs are
// lost see {@link TaskTracker.transmitHeartbeat()};
// acknowledge it by re-sending the previous response to let the
// {@link TaskTracker} go forward.
if (prevHeartbeatResponse.getResponseId() != responseId) {
LOG.info(&quot;Ignoring &apos;duplicate&apos; heartbeat from &apos;&quot; +
trackerName + &quot;&apos;; resending the previous &apos;lost&apos; response&quot;);
return prevHeartbeatResponse;
}
}
}

// Process this heartbeat
short newResponseId = (short)(responseId + 1);
status.setLastSeen(now);
if (!processHeartbeat(status, initialContact)) {
if (prevHeartbeatResponse != null) {
trackerToHeartbeatResponseMap.remove(trackerName);
}
return new HeartbeatResponse(newResponseId,
new TaskTrackerAction[] {new ReinitTrackerAction()});
}

// Initialize the response to be sent for the heartbeat
HeartbeatResponse response = new HeartbeatResponse(newResponseId, null);
List&lt;TaskTrackerAction&gt; actions = new ArrayList&lt;TaskTrackerAction&gt;();

// Check for new tasks to be executed on the tasktracker
if (recoveryManager.shouldSchedule() &amp;&amp; acceptNewTasks &amp;&amp; !isBlacklisted) {
TaskTrackerStatus taskTrackerStatus = getTaskTracker(trackerName);
if (taskTrackerStatus == null) {
LOG.warn(&quot;Unknown task tracker polling; ignoring: &quot; + trackerName);
} else {
List&lt;Task&gt; tasks = getSetupAndCleanupTasks(taskTrackerStatus);
if (tasks == null ) {
tasks = taskScheduler.assignTasks(taskTrackerStatus);
}
if (tasks != null) {
for (Task task : tasks) {
expireLaunchingTasks.addNewTask(task.getTaskID());
LOG.debug(trackerName + &quot; -&gt; LaunchTask: &quot; + task.getTaskID());
actions.add(new LaunchTaskAction(task));
}
}
}
}

// Check for tasks to be killed
List&lt;TaskTrackerAction&gt; killTasksList = getTasksToKill(trackerName);
if (killTasksList != null) {
actions.addAll(killTasksList);
}

// Check for jobs to be killed/cleanedup
List&lt;TaskTrackerAction&gt; killJobsList = getJobsForCleanup(trackerName);
if (killJobsList != null) {
actions.addAll(killJobsList);
}

// Check for tasks whose outputs can be saved
List&lt;TaskTrackerAction&gt; commitTasksList = getTasksToSave(status);
if (commitTasksList != null) {
actions.addAll(commitTasksList);
}

// calculate next heartbeat interval and put in heartbeat response
int nextInterval = getNextHeartbeatInterval();
response.setHeartbeatInterval(nextInterval);
response.setActions(
actions.toArray(new TaskTrackerAction[actions.size()]));

// check if the restart info is req
if (addRestartInfo) {
response.setRecoveredJobs(recoveryManager.getJobsToRecover());
}

// Update the trackerToHeartbeatResponseMap
trackerToHeartbeatResponseMap.put(trackerName, response);

// Done processing the hearbeat, now remove &apos;marked&apos; tasks
removeMarkedTasks(trackerName);

return response;
}
public synchronized List&lt;Task&gt; assignTasks(TaskTrackerStatus taskTracker)
throws IOException {

ClusterStatus clusterStatus = taskTrackerManager.getClusterStatus();
final int numTaskTrackers = clusterStatus.getTaskTrackers();
final int clusterMapCapacity = clusterStatus.getMaxMapTasks();
final int clusterReduceCapacity = clusterStatus.getMaxReduceTasks();

Collection&lt;JobInProgress&gt; jobQueue =
jobQueueJobInProgressListener.getJobQueue();

//
// Get map + reduce counts for the current tracker.
//
final int trackerMapCapacity = taskTracker.getMaxMapTasks();
final int trackerReduceCapacity = taskTracker.getMaxReduceTasks();
final int trackerRunningMaps = taskTracker.countMapTasks();
final int trackerRunningReduces = taskTracker.countReduceTasks();

// Assigned tasks
List&lt;Task&gt; assignedTasks = new ArrayList&lt;Task&gt;();

//
// Compute (running + pending) map and reduce task numbers across pool
//
int remainingReduceLoad = 0;
int remainingMapLoad = 0;
synchronized (jobQueue) {
for (JobInProgress job : jobQueue) {
if (job.getStatus().getRunState() == JobStatus.RUNNING) {
remainingMapLoad += (job.desiredMaps() - job.finishedMaps());
if (job.scheduleReduces()) {
remainingReduceLoad +=
(job.desiredReduces() - job.finishedReduces());
}
}
}
}

// Compute the &apos;load factor&apos; for maps and reduces
double mapLoadFactor = 0.0;
if (clusterMapCapacity &gt; 0) {
mapLoadFactor = (double)remainingMapLoad / clusterMapCapacity;
}
double reduceLoadFactor = 0.0;
if (clusterReduceCapacity &gt; 0) {
reduceLoadFactor = (double)remainingReduceLoad / clusterReduceCapacity;
}

//
// In the below steps, we allocate first map tasks (if appropriate),
// and then reduce tasks if appropriate. We go through all jobs
// in order of job arrival; jobs only get serviced if their
// predecessors are serviced, too.
//

//
// We assign tasks to the current taskTracker if the given machine
// has a workload that&apos;s less than the maximum load of that kind of
// task.
// However, if the cluster is close to getting loaded i.e. we don&apos;t
// have enough _padding_ for speculative executions etc., we only
// schedule the &quot;highest priority&quot; task i.e. the task from the job
// with the highest priority.
//

final int trackerCurrentMapCapacity =
Math.min((int)Math.ceil(mapLoadFactor * trackerMapCapacity),
trackerMapCapacity);
int availableMapSlots = trackerCurrentMapCapacity - trackerRunningMaps;
boolean exceededMapPadding = false;
if (availableMapSlots &gt; 0) {
exceededMapPadding =
exceededPadding(true, clusterStatus, trackerMapCapacity);
}

int numLocalMaps = 0;
int numNonLocalMaps = 0;
scheduleMaps:
for (int i=0; i &lt; availableMapSlots; ++i) {
synchronized (jobQueue) {
for (JobInProgress job : jobQueue) {
if (job.getStatus().getRunState() != JobStatus.RUNNING) {
continue;
}

Task t = null;

// Try to schedule a node-local or rack-local Map task
t =
job.obtainNewLocalMapTask(taskTracker, numTaskTrackers,
taskTrackerManager.getNumberOfUniqueHosts());
if (t != null) {
assignedTasks.add(t);
++numLocalMaps;

// Don&apos;t assign map tasks to the hilt!
// Leave some free slots in the cluster for future task-failures,
// speculative tasks etc. beyond the highest priority job
if (exceededMapPadding) {
break scheduleMaps;
}

// Try all jobs again for the next Map task
break;
}

// Try to schedule a node-local or rack-local Map task
t =
job.obtainNewNonLocalMapTask(taskTracker, numTaskTrackers,
taskTrackerManager.getNumberOfUniqueHosts());

if (t != null) {
assignedTasks.add(t);
++numNonLocalMaps;

// We assign at most 1 off-switch or speculative task
// This is to prevent TaskTrackers from stealing local-tasks
// from other TaskTrackers.
break scheduleMaps;
}
}
}
}
int assignedMaps = assignedTasks.size();

//
// Same thing, but for reduce tasks
// However we _never_ assign more than 1 reduce task per heartbeat
//
final int trackerCurrentReduceCapacity =
Math.min((int)Math.ceil(reduceLoadFactor * trackerReduceCapacity),
trackerReduceCapacity);
final int availableReduceSlots =
Math.min((trackerCurrentReduceCapacity - trackerRunningReduces), 1);
boolean exceededReducePadding = false;
if (availableReduceSlots &gt; 0) {
exceededReducePadding = exceededPadding(false, clusterStatus,
trackerReduceCapacity);
synchronized (jobQueue) {
for (JobInProgress job : jobQueue) {
if (job.getStatus().getRunState() != JobStatus.RUNNING ||
job.numReduceTasks == 0) {
continue;
}

Task t =
job.obtainNewReduceTask(taskTracker, numTaskTrackers,
taskTrackerManager.getNumberOfUniqueHosts()
);
if (t != null) {
assignedTasks.add(t);
break;
}

// Don&apos;t assign reduce tasks to the hilt!
// Leave some free slots in the cluster for future task-failures,
// speculative tasks etc. beyond the highest priority job
if (exceededReducePadding) {
break;
}
}
}
}

if (LOG.isDebugEnabled()) {
LOG.debug(&quot;Task assignments for &quot; + taskTracker.getTrackerName() + &quot; --&gt; &quot; +
&quot;[&quot; + mapLoadFactor + &quot;, &quot; + trackerMapCapacity + &quot;, &quot; +
trackerCurrentMapCapacity + &quot;, &quot; + trackerRunningMaps + &quot;] -&gt; [&quot; +
(trackerCurrentMapCapacity - trackerRunningMaps) + &quot;, &quot; +
assignedMaps + &quot; (&quot; + numLocalMaps + &quot;, &quot; + numNonLocalMaps +
&quot;)] [&quot; + reduceLoadFactor + &quot;, &quot; + trackerReduceCapacity + &quot;, &quot; +
trackerCurrentReduceCapacity + &quot;,&quot; + trackerRunningReduces +
&quot;] -&gt; [&quot; + (trackerCurrentReduceCapacity - trackerRunningReduces) +
&quot;, &quot; + (assignedTasks.size()-assignedMaps) + &quot;]&quot;);
}

return assignedTasks;
}
public TaskTracker(JobConf conf) throws IOException {
originalConf = conf;
maxCurrentMapTasks = conf.getInt(
&quot;mapred.tasktracker.map.tasks.maximum&quot;, 2);
maxCurrentReduceTasks = conf.getInt(
&quot;mapred.tasktracker.reduce.tasks.maximum&quot;, 2);
this.jobTrackAddr = JobTracker.getAddress(conf);
String infoAddr =
NetUtils.getServerAddress(conf,
&quot;tasktracker.http.bindAddress&quot;,
&quot;tasktracker.http.port&quot;,
&quot;mapred.task.tracker.http.address&quot;);
InetSocketAddress infoSocAddr = NetUtils.createSocketAddr(infoAddr);
String httpBindAddress = infoSocAddr.getHostName();
int httpPort = infoSocAddr.getPort();
this.server = new HttpServer(&quot;task&quot;, httpBindAddress, httpPort,
httpPort == 0, conf);
workerThreads = conf.getInt(&quot;tasktracker.http.threads&quot;, 40);
this.shuffleServerMetrics = new ShuffleServerMetrics(conf);
server.setThreads(1, workerThreads);
// let the jsp pages get to the task tracker, config, and other relevant
// objects
FileSystem local = FileSystem.getLocal(conf);
this.localDirAllocator = new LocalDirAllocator(&quot;mapred.local.dir&quot;);
server.setAttribute(&quot;task.tracker&quot;, this);
server.setAttribute(&quot;local.file.system&quot;, local);
server.setAttribute(&quot;conf&quot;, conf);
server.setAttribute(&quot;log&quot;, LOG);
server.setAttribute(&quot;localDirAllocator&quot;, localDirAllocator);
server.setAttribute(&quot;shuffleServerMetrics&quot;, shuffleServerMetrics);
server.addInternalServlet(&quot;mapOutput&quot;, &quot;/mapOutput&quot;, MapOutputServlet.class);
server.addInternalServlet(&quot;taskLog&quot;, &quot;/tasklog&quot;, TaskLogServlet.class);
server.start();
this.httpPort = server.getPort();
checkJettyPort(httpPort);
initialize();
}
synchronized void initialize() throws IOException {
// use configured nameserver &amp; interface to get local hostname
this.fConf = new JobConf(originalConf);
if (fConf.get(&quot;slave.host.name&quot;) != null) {
this.localHostname = fConf.get(&quot;slave.host.name&quot;);
}
if (localHostname == null) {
this.localHostname =
DNS.getDefaultHost
(fConf.get(&quot;mapred.tasktracker.dns.interface&quot;,&quot;default&quot;),
fConf.get(&quot;mapred.tasktracker.dns.nameserver&quot;,&quot;default&quot;));
}

//check local disk
checkLocalDirs(this.fConf.getLocalDirs());
fConf.deleteLocalFiles(SUBDIR);

// Clear out state tables
this.tasks.clear();
this.runningTasks = new LinkedHashMap&lt;TaskAttemptID, TaskInProgress&gt;();
this.runningJobs = new TreeMap&lt;JobID, RunningJob&gt;();
this.mapTotal = 0;
this.reduceTotal = 0;
this.acceptNewTasks = true;
this.status = null;

this.minSpaceStart = this.fConf.getLong(&quot;mapred.local.dir.minspacestart&quot;, 0L);
this.minSpaceKill = this.fConf.getLong(&quot;mapred.local.dir.minspacekill&quot;, 0L);
//tweak the probe sample size (make it a function of numCopiers)
probe_sample_size = this.fConf.getInt(&quot;mapred.tasktracker.events.batchsize&quot;, 500);

Class&lt;? extends TaskTrackerInstrumentation&gt; metricsInst = getInstrumentationClass(fConf);
try {
java.lang.reflect.Constructor&lt;? extends TaskTrackerInstrumentation&gt; c =
metricsInst.getConstructor(new Class[] {TaskTracker.class} );
this.myInstrumentation = c.newInstance(this);
} catch(Exception e) {
//Reflection can throw lots of exceptions -- handle them all by
//falling back on the default.
LOG.error(&quot;failed to initialize taskTracker metrics&quot;, e);
this.myInstrumentation = new TaskTrackerMetricsInst(this);
}

// bind address
String address =
NetUtils.getServerAddress(fConf,
&quot;mapred.task.tracker.report.bindAddress&quot;,
&quot;mapred.task.tracker.report.port&quot;,
&quot;mapred.task.tracker.report.address&quot;);
InetSocketAddress socAddr = NetUtils.createSocketAddr(address);
String bindAddress = socAddr.getHostName();
int tmpPort = socAddr.getPort();

this.jvmManager = new JvmManager(this);

// Set service-level authorization security policy
if (this.fConf.getBoolean(
ServiceAuthorizationManager.SERVICE_AUTHORIZATION_CONFIG, false)) {
PolicyProvider policyProvider =
(PolicyProvider)(ReflectionUtils.newInstance(
this.fConf.getClass(PolicyProvider.POLICY_PROVIDER_CONFIG,
MapReducePolicyProvider.class, PolicyProvider.class),
this.fConf));
SecurityUtil.setPolicy(new ConfiguredPolicy(this.fConf, policyProvider));
}

// RPC initialization
int max = maxCurrentMapTasks &gt; maxCurrentReduceTasks ?
maxCurrentMapTasks : maxCurrentReduceTasks;
//set the num handlers to max*2 since canCommit may wait for the duration
//of a heartbeat RPC
this.taskReportServer =
RPC.getServer(this, bindAddress, tmpPort, 2 * max, false, this.fConf);
this.taskReportServer.start();

// get the assigned address
this.taskReportAddress = taskReportServer.getListenerAddress();
this.fConf.set(&quot;mapred.task.tracker.report.address&quot;,
taskReportAddress.getHostName() + &quot;:&quot; + taskReportAddress.getPort());
LOG.info(&quot;TaskTracker up at: &quot; + this.taskReportAddress);

this.taskTrackerName = &quot;tracker_&quot; + localHostname + &quot;:&quot; + taskReportAddress;
LOG.info(&quot;Starting tracker &quot; + taskTrackerName);

// Clear out temporary files that might be lying around
DistributedCache.purgeCache(this.fConf);
cleanupStorage();

this.jobClient = (InterTrackerProtocol)
RPC.waitForProxy(InterTrackerProtocol.class,
InterTrackerProtocol.versionID,
jobTrackAddr, this.fConf);
this.justInited = true;
this.running = true;
// start the thread that will fetch map task completion events
this.mapEventsFetcher = new MapEventsFetcherThread();
mapEventsFetcher.setDaemon(true);
mapEventsFetcher.setName(
&quot;Map-events fetcher for all reduce tasks &quot; + &quot;on &quot; +
taskTrackerName);
mapEventsFetcher.start();

initializeMemoryManagement();

this.indexCache = new IndexCache(this.fConf);

mapLauncher = new TaskLauncher(maxCurrentMapTasks);
reduceLauncher = new TaskLauncher(maxCurrentReduceTasks);
mapLauncher.start();
reduceLauncher.start();
}
public void run() {
while (!Thread.interrupted()) {
try {
TaskInProgress tip;
synchronized (tasksToLaunch) {
while (tasksToLaunch.isEmpty()) {
tasksToLaunch.wait();
}
//get the TIP
tip = tasksToLaunch.remove(0);
LOG.info(&quot;Trying to launch : &quot; + tip.getTask().getTaskID());
}
//wait for a slot to run
synchronized (numFreeSlots) {
while (numFreeSlots.get() == 0) {
numFreeSlots.wait();
}
LOG.info(&quot;In TaskLauncher, current free slots : &quot; + numFreeSlots.get()+
&quot; and trying to launch &quot;+tip.getTask().getTaskID());
numFreeSlots.set(numFreeSlots.get() - 1);
assert (numFreeSlots.get() &gt;= 0);
}
synchronized (tip) {
//to make sure that there is no kill task action for this
if (tip.getRunState() != TaskStatus.State.UNASSIGNED &amp;&amp;
tip.getRunState() != TaskStatus.State.FAILED_UNCLEAN &amp;&amp;
tip.getRunState() != TaskStatus.State.KILLED_UNCLEAN) {
//got killed externally while still in the launcher queue
addFreeSlot();
continue;
}
tip.slotTaken = true;
}
//got a free slot. launch the task
startNewTask(tip);
} catch (InterruptedException e) {
return; // ALL DONE
} catch (Throwable th) {
LOG.error(&quot;TaskLauncher error &quot; +
StringUtils.stringifyException(th));
}
}
}
}
private void startNewTask(TaskInProgress tip) {
try {
localizeJob(tip);
} catch (Throwable e) {
String msg = (&quot;Error initializing &quot; + tip.getTask().getTaskID() +
&quot;:\n&quot; + StringUtils.stringifyException(e));
LOG.warn(msg);
tip.reportDiagnosticInfo(msg);
try {
tip.kill(true);
tip.cleanup(true);
} catch (IOException ie2) {
LOG.info(&quot;Error cleaning up &quot; + tip.getTask().getTaskID() + &quot;:\n&quot; +
StringUtils.stringifyException(ie2));
}

// Careful!
// This might not be an &apos;Exception&apos; - don&apos;t handle &apos;Error&apos; here!
if (e instanceof Error) {
throw ((Error) e);
}
}
}

private void localizeJob(TaskInProgress tip) throws IOException {
Path localJarFile = null;
Task t = tip.getTask();
JobID jobId = t.getJobID();
Path jobFile = new Path(t.getJobFile());
// Get sizes of JobFile and JarFile
// sizes are -1 if they are not present.
FileStatus status = null;
long jobFileSize = -1;
try {
status = systemFS.getFileStatus(jobFile);
jobFileSize = status.getLen();
} catch(FileNotFoundException fe) {
jobFileSize = -1;
}
Path localJobFile = lDirAlloc.getLocalPathForWrite(
getLocalJobDir(jobId.toString())
+ Path.SEPARATOR + &quot;job.xml&quot;,
jobFileSize, fConf);
RunningJob rjob = addTaskToJob(jobId, tip);
synchronized (rjob) {
if (!rjob.localized) {

FileSystem localFs = FileSystem.getLocal(fConf);
// this will happen on a partial execution of localizeJob.
// Sometimes the job.xml gets copied but copying job.jar
// might throw out an exception
// we should clean up and then try again
Path jobDir = localJobFile.getParent();
if (localFs.exists(jobDir)){
localFs.delete(jobDir, true);
boolean b = localFs.mkdirs(jobDir);
if (!b)
throw new IOException(&quot;Not able to create job directory &quot;
+ jobDir.toString());
}
systemFS.copyToLocalFile(jobFile, localJobFile);
JobConf localJobConf = new JobConf(localJobFile);

// create the &apos;work&apos; directory
// job-specific shared directory for use as scratch space
Path workDir = lDirAlloc.getLocalPathForWrite(
(getLocalJobDir(jobId.toString())
+ Path.SEPARATOR + &quot;work&quot;), fConf);
if (!localFs.mkdirs(workDir)) {
throw new IOException(&quot;Mkdirs failed to create &quot;
+ workDir.toString());
}
System.setProperty(&quot;job.local.dir&quot;, workDir.toString());
localJobConf.set(&quot;job.local.dir&quot;, workDir.toString());

// copy Jar file to the local FS and unjar it.
String jarFile = localJobConf.getJar();
long jarFileSize = -1;
if (jarFile != null) {
Path jarFilePath = new Path(jarFile);
try {
status = systemFS.getFileStatus(jarFilePath);
jarFileSize = status.getLen();
} catch(FileNotFoundException fe) {
jarFileSize = -1;
}
// Here we check for and we check five times the size of jarFileSize
// to accommodate for unjarring the jar file in work directory
localJarFile = new Path(lDirAlloc.getLocalPathForWrite(
getLocalJobDir(jobId.toString())
+ Path.SEPARATOR + &quot;jars&quot;,
5 * jarFileSize, fConf), &quot;job.jar&quot;);
if (!localFs.mkdirs(localJarFile.getParent())) {
throw new IOException(&quot;Mkdirs failed to create jars directory &quot;);
}
systemFS.copyToLocalFile(jarFilePath, localJarFile);
localJobConf.setJar(localJarFile.toString());
OutputStream out = localFs.create(localJobFile);
try {
localJobConf.writeXml(out);
} finally {
out.close();
}
// also unjar the job.jar files
RunJar.unJar(new File(localJarFile.toString()),
new File(localJarFile.getParent().toString()));
}
rjob.keepJobFiles = ((localJobConf.getKeepTaskFilesPattern() != null) ||
localJobConf.getKeepFailedTaskFiles());
rjob.localized = true;
rjob.jobConf = localJobConf;
}
}
launchTaskForJob(tip, new JobConf(rjob.jobConf));
}
private void launchTaskForJob(TaskInProgress tip, JobConf jobConf) throws IOException{
synchronized (tip) {
tip.setJobConf(jobConf);
tip.launchTask();
}
}
public synchronized void launchTask() throws IOException {
if (this.taskStatus.getRunState() == TaskStatus.State.UNASSIGNED ||
this.taskStatus.getRunState() == TaskStatus.State.FAILED_UNCLEAN ||
this.taskStatus.getRunState() == TaskStatus.State.KILLED_UNCLEAN) {
localizeTask(task);
if (this.taskStatus.getRunState() == TaskStatus.State.UNASSIGNED) {
this.taskStatus.setRunState(TaskStatus.State.RUNNING);
}
this.runner = task.createRunner(TaskTracker.this, this);
this.runner.start();
this.taskStatus.setStartTime(System.currentTimeMillis());
} else {
LOG.info(&quot;Not launching task: &quot; + task.getTaskID() +
&quot; since it&apos;s state is &quot; + this.taskStatus.getRunState());
}
}
public final void run() {
try {

//before preparing the job localize
//all the archives
TaskAttemptID taskid = t.getTaskID();
LocalDirAllocator lDirAlloc = new LocalDirAllocator(&quot;mapred.local.dir&quot;);
File jobCacheDir = null;
if (conf.getJar() != null) {
jobCacheDir = new File(
new Path(conf.getJar()).getParent().toString());
}
File workDir = new File(lDirAlloc.getLocalPathToRead(
TaskTracker.getLocalTaskDir(
t.getJobID().toString(),
t.getTaskID().toString(),
t.isTaskCleanupTask())
+ Path.SEPARATOR + MRConstants.WORKDIR,
conf). toString());

URI[] archives = DistributedCache.getCacheArchives(conf);
URI[] files = DistributedCache.getCacheFiles(conf);
FileStatus fileStatus;
FileSystem fileSystem;
Path localPath;
String baseDir;

if ((archives != null) || (files != null)) {
if (archives != null) {
String[] archivesTimestamps =
DistributedCache.getArchiveTimestamps(conf);
Path[] p = new Path[archives.length];
for (int i = 0; i &lt; archives.length;i++){
fileSystem = FileSystem.get(archives[i], conf);
fileStatus = fileSystem.getFileStatus(
new Path(archives[i].getPath()));
String cacheId = DistributedCache.makeRelative(archives[i],conf);
String cachePath = TaskTracker.getCacheSubdir() +
Path.SEPARATOR + cacheId;

localPath = lDirAlloc.getLocalPathForWrite(cachePath,
fileStatus.getLen(), conf);
baseDir = localPath.toString().replace(cacheId, &quot;&quot;);
p[i] = DistributedCache.getLocalCache(archives[i], conf,
new Path(baseDir),
fileStatus,
true, Long.parseLong(
archivesTimestamps[i]),
new Path(workDir.
getAbsolutePath()),
false);

}
DistributedCache.setLocalArchives(conf, stringifyPathArray(p));
}
if ((files != null)) {
String[] fileTimestamps = DistributedCache.getFileTimestamps(conf);
Path[] p = new Path[files.length];
for (int i = 0; i &lt; files.length;i++){
fileSystem = FileSystem.get(files[i], conf);
fileStatus = fileSystem.getFileStatus(
new Path(files[i].getPath()));
String cacheId = DistributedCache.makeRelative(files[i], conf);
String cachePath = TaskTracker.getCacheSubdir() +
Path.SEPARATOR + cacheId;

localPath = lDirAlloc.getLocalPathForWrite(cachePath,
fileStatus.getLen(), conf);
baseDir = localPath.toString().replace(cacheId, &quot;&quot;);
p[i] = DistributedCache.getLocalCache(files[i], conf,
new Path(baseDir),
fileStatus,
false, Long.parseLong(
fileTimestamps[i]),
new Path(workDir.
getAbsolutePath()),
false);
}
DistributedCache.setLocalFiles(conf, stringifyPathArray(p));
}
Path localTaskFile = new Path(t.getJobFile());
FileSystem localFs = FileSystem.getLocal(conf);
localFs.delete(localTaskFile, true);
OutputStream out = localFs.create(localTaskFile);
try {
conf.writeXml(out);
} finally {
out.close();
}
}

if (!prepare()) {
return;
}

String sep = System.getProperty(&quot;path.separator&quot;);
StringBuffer classPath = new StringBuffer();
// start with same classpath as parent process
classPath.append(System.getProperty(&quot;java.class.path&quot;));
classPath.append(sep);
if (!workDir.mkdirs()) {
if (!workDir.isDirectory()) {
LOG.fatal(&quot;Mkdirs failed to create &quot; + workDir.toString());
}
}

String jar = conf.getJar();
if (jar != null) {
// if jar exists, it into workDir
File[] libs = new File(jobCacheDir, &quot;lib&quot;).listFiles();
if (libs != null) {
for (int i = 0; i &lt; libs.length; i++) {
classPath.append(sep); // add libs from jar to classpath
classPath.append(libs[i]);
}
}
classPath.append(sep);
classPath.append(new File(jobCacheDir, &quot;classes&quot;));
classPath.append(sep);
classPath.append(jobCacheDir);

}

// include the user specified classpath

//archive paths
Path[] archiveClasspaths = DistributedCache.getArchiveClassPaths(conf);
if (archiveClasspaths != null &amp;&amp; archives != null) {
Path[] localArchives = DistributedCache
.getLocalCacheArchives(conf);
if (localArchives != null){
for (int i=0;i&lt;archives.length;i++){
for(int j=0;j&lt;archiveClasspaths.length;j++){
if (archives[i].getPath().equals(
archiveClasspaths[j].toString())){
classPath.append(sep);
classPath.append(localArchives[i]
.toString());
}
}
}
}
}
//file paths
Path[] fileClasspaths = DistributedCache.getFileClassPaths(conf);
if (fileClasspaths!=null &amp;&amp; files != null) {
Path[] localFiles = DistributedCache
.getLocalCacheFiles(conf);
if (localFiles != null) {
for (int i = 0; i &lt; files.length; i++) {
for (int j = 0; j &lt; fileClasspaths.length; j++) {
if (files[i].getPath().equals(
fileClasspaths[j].toString())) {
classPath.append(sep);
classPath.append(localFiles[i].toString());
}
}
}
}
}

classPath.append(sep);
classPath.append(workDir);
// Build exec child jmv args.
Vector&lt;String&gt; vargs = new Vector&lt;String&gt;(8);
File jvm = // use same jvm as parent
new File(new File(System.getProperty(&quot;java.home&quot;), &quot;bin&quot;), &quot;java&quot;);

vargs.add(jvm.toString());

// Add child (task) java-vm options.
//
// The following symbols if present in mapred.child.java.opts value are
// replaced:
// + @taskid@ is interpolated with value of TaskID.
// Other occurrences of @ will not be altered.
//
// Example with multiple arguments and substitutions, showing
// jvm GC logging, and start of a passwordless JVM JMX agent so can
// connect with jconsole and the likes to watch child memory, threads
// and get thread dumps.
//
// &lt;property&gt;
// &lt;name&gt;mapred.child.java.opts&lt;/name&gt;
// &lt;value&gt;-verbose:gc -Xloggc:/tmp/@taskid@.gc \
// -Dcom.sun.management.jmxremote.authenticate=false \
// -Dcom.sun.management.jmxremote.ssl=false \
// &lt;/value&gt;
// &lt;/property&gt;
//
String javaOpts = conf.get(&quot;mapred.child.java.opts&quot;, &quot;-Xmx200m&quot;);
javaOpts = javaOpts.replace(&quot;@taskid@&quot;, taskid.toString());
String [] javaOptsSplit = javaOpts.split(&quot; &quot;);

// Add java.library.path; necessary for loading native libraries.
//
// 1. To support native-hadoop library i.e. libhadoop.so, we add the
// parent processes&apos; java.library.path to the child.
// 2. We also add the &apos;cwd&apos; of the task to it&apos;s java.library.path to help
// users distribute native libraries via the DistributedCache.
// 3. The user can also specify extra paths to be added to the
// java.library.path via mapred.child.java.opts.
//
String libraryPath = System.getProperty(&quot;java.library.path&quot;);
if (libraryPath == null) {
libraryPath = workDir.getAbsolutePath();
} else {
libraryPath += sep + workDir;
}
boolean hasUserLDPath = false;
for(int i=0; i&lt;javaOptsSplit.length ;i++) {
if(javaOptsSplit[i].startsWith(&quot;-Djava.library.path=&quot;)) {
javaOptsSplit[i] += sep + libraryPath;
hasUserLDPath = true;
break;
}
}
if(!hasUserLDPath) {
vargs.add(&quot;-Djava.library.path=&quot; + libraryPath);
}
for (int i = 0; i &lt; javaOptsSplit.length; i++) {
vargs.add(javaOptsSplit[i]);
}

// add java.io.tmpdir given by mapred.child.tmp
String tmp = conf.get(&quot;mapred.child.tmp&quot;, &quot;./tmp&quot;);
Path tmpDir = new Path(tmp);

// if temp directory path is not absolute
// prepend it with workDir.
if (!tmpDir.isAbsolute()) {
tmpDir = new Path(workDir.toString(), tmp);
}
FileSystem localFs = FileSystem.getLocal(conf);
if (!localFs.mkdirs(tmpDir) &amp;&amp; !localFs.getFileStatus(tmpDir).isDir()) {
throw new IOException(&quot;Mkdirs failed to create &quot; + tmpDir.toString());
}
vargs.add(&quot;-Djava.io.tmpdir=&quot; + tmpDir.toString());

// Add classpath.
vargs.add(&quot;-classpath&quot;);
vargs.add(classPath.toString());

// Setup the log4j prop
long logSize = TaskLog.getTaskLogLength(conf);
vargs.add(&quot;-Dhadoop.log.dir=&quot; +
new File(System.getProperty(&quot;hadoop.log.dir&quot;)
).getAbsolutePath());
vargs.add(&quot;-Dhadoop.root.logger=INFO,TLA&quot;);
vargs.add(&quot;-Dhadoop.tasklog.taskid=&quot; + taskid);
vargs.add(&quot;-Dhadoop.tasklog.totalLogFileSize=&quot; + logSize);

if (conf.getProfileEnabled()) {
if (conf.getProfileTaskRange(t.isMapTask()
).isIncluded(t.getPartition())) {
File prof = TaskLog.getTaskLogFile(taskid, TaskLog.LogName.PROFILE);
vargs.add(String.format(conf.getProfileParams(), prof.toString()));
}
}

// Add main class and its arguments
vargs.add(Child.class.getName()); // main of Child
// pass umbilical address
InetSocketAddress address = tracker.getTaskTrackerReportAddress();
vargs.add(address.getAddress().getHostAddress());
vargs.add(Integer.toString(address.getPort()));
vargs.add(taskid.toString()); // pass task identifier

String pidFile = lDirAlloc.getLocalPathForWrite(
(TaskTracker.getPidFile(t.getJobID().toString(),
taskid.toString(), t.isTaskCleanupTask())),
this.conf).toString();
t.setPidFile(pidFile);
tracker.addToMemoryManager(t.getTaskID(), t.isMapTask(), conf, pidFile);

// set memory limit using ulimit if feasible and necessary ...
String[] ulimitCmd = Shell.getUlimitMemoryCommand(conf);
List&lt;String&gt; setup = null;
if (ulimitCmd != null) {
setup = new ArrayList&lt;String&gt;();
for (String arg : ulimitCmd) {
setup.add(arg);
}
}

// Set up the redirection of the task&apos;s stdout and stderr streams
File stdout = TaskLog.getTaskLogFile(taskid, TaskLog.LogName.STDOUT);
File stderr = TaskLog.getTaskLogFile(taskid, TaskLog.LogName.STDERR);
stdout.getParentFile().mkdirs();
tracker.getTaskTrackerInstrumentation().reportTaskLaunch(taskid, stdout, stderr);

Map&lt;String, String&gt; env = new HashMap&lt;String, String&gt;();
StringBuffer ldLibraryPath = new StringBuffer();
ldLibraryPath.append(workDir.toString());
String oldLdLibraryPath = null;
oldLdLibraryPath = System.getenv(&quot;LD_LIBRARY_PATH&quot;);
if (oldLdLibraryPath != null) {
ldLibraryPath.append(sep);
ldLibraryPath.append(oldLdLibraryPath);
}
env.put(&quot;LD_LIBRARY_PATH&quot;, ldLibraryPath.toString());
jvmManager.launchJvm(this,
jvmManager.constructJvmEnv(setup,vargs,stdout,stderr,logSize,
workDir, env, pidFile, conf));
synchronized (lock) {
while (!done) {
lock.wait();
}
}
tracker.getTaskTrackerInstrumentation().reportTaskEnd(t.getTaskID());
if (exitCodeSet) {
if (!killed &amp;&amp; exitCode != 0) {
if (exitCode == 65) {
tracker.getTaskTrackerInstrumentation().taskFailedPing(t.getTaskID());
}
throw new IOException(&quot;Task process exit with nonzero status of &quot; +
exitCode + &quot;.&quot;);
}
}
} catch (FSError e) {
LOG.fatal(&quot;FSError&quot;, e);
try {
tracker.fsError(t.getTaskID(), e.getMessage());
} catch (IOException ie) {
LOG.fatal(t.getTaskID()+&quot; reporting FSError&quot;, ie);
}
} catch (Throwable throwable) {
LOG.warn(t.getTaskID()+&quot; Child Error&quot;, throwable);
ByteArrayOutputStream baos = new ByteArrayOutputStream();
throwable.printStackTrace(new PrintStream(baos));
try {
tracker.reportDiagnosticInfo(t.getTaskID(), baos.toString());
} catch (IOException e) {
LOG.warn(t.getTaskID()+&quot; Reporting Diagnostics&quot;, e);
}
} finally {
try{
URI[] archives = DistributedCache.getCacheArchives(conf);
URI[] files = DistributedCache.getCacheFiles(conf);
if (archives != null){
for (int i = 0; i &lt; archives.length; i++){
DistributedCache.releaseCache(archives[i], conf);
}
}
if (files != null){
for(int i = 0; i &lt; files.length; i++){
DistributedCache.releaseCache(files[i], conf);
}
}
}catch(IOException ie){
LOG.warn(&quot;Error releasing caches : Cache files might not have been cleaned up&quot;);
}
tip.reportTaskFinished();
}
}
public void launchJvm(TaskRunner t, JvmEnv env) {
if (t.getTask().isMapTask()) {
mapJvmManager.reapJvm(t, env);
} else {
reduceJvmManager.reapJvm(t, env);
}
}
private synchronized void reapJvm(
TaskRunner t, JvmEnv env) {
if (t.getTaskInProgress().wasKilled()) {
//the task was killed in-flight
//no need to do the rest of the operations
return;
}
boolean spawnNewJvm = false;
JobID jobId = t.getTask().getJobID();
//Check whether there is a free slot to start a new JVM.
//,or, Kill a (idle) JVM and launch a new one
//When this method is called, we *must*
// (1) spawn a new JVM (if we are below the max)
// (2) find an idle JVM (that belongs to the same job), or,
// (3) kill an idle JVM (from a different job)
// (the order of return is in the order above)
int numJvmsSpawned = jvmIdToRunner.size();
JvmRunner runnerToKill = null;
if (numJvmsSpawned &gt;= maxJvms) {
//go through the list of JVMs for all jobs.
Iterator&lt;Map.Entry&lt;JVMId, JvmRunner&gt;&gt; jvmIter =
jvmIdToRunner.entrySet().iterator();

while (jvmIter.hasNext()) {
JvmRunner jvmRunner = jvmIter.next().getValue();
JobID jId = jvmRunner.jvmId.getJobId();
//look for a free JVM for this job; if one exists then just break
if (jId.equals(jobId) &amp;&amp; !jvmRunner.isBusy() &amp;&amp; !jvmRunner.ranAll()){
setRunningTaskForJvm(jvmRunner.jvmId, t); //reserve the JVM
LOG.info(&quot;No new JVM spawned for jobId/taskid: &quot; +
jobId+&quot;/&quot;+t.getTask().getTaskID() +
&quot;. Attempting to reuse: &quot; + jvmRunner.jvmId);
return;
}
//Cases when a JVM is killed:
// (1) the JVM under consideration belongs to the same job
// (passed in the argument). In this case, kill only when
// the JVM ran all the tasks it was scheduled to run (in terms
// of count).
// (2) the JVM under consideration belongs to a different job and is
// currently not busy
//But in both the above cases, we see if we can assign the current
//task to an idle JVM (hence we continue the loop even on a match)
if ((jId.equals(jobId) &amp;&amp; jvmRunner.ranAll()) ||
(!jId.equals(jobId) &amp;&amp; !jvmRunner.isBusy())) {
runnerToKill = jvmRunner;
spawnNewJvm = true;
}
}
} else {
spawnNewJvm = true;
}

if (spawnNewJvm) {
if (runnerToKill != null) {
LOG.info(&quot;Killing JVM: &quot; + runnerToKill.jvmId);
runnerToKill.kill();
}
spawnNewJvm(jobId, env, t);
return;
}
//*MUST* never reach this
throw new RuntimeException(&quot;Inconsistent state!!! &quot; +
&quot;JVM Manager reached an unstable state &quot; +
&quot;while reaping a JVM for task: &quot; + t.getTask().getTaskID()+
&quot; &quot; + getDetails());
}
private void spawnNewJvm(JobID jobId, JvmEnv env,
TaskRunner t) {
JvmRunner jvmRunner = new JvmRunner(env,jobId);
jvmIdToRunner.put(jvmRunner.jvmId, jvmRunner);
//spawn the JVM in a new thread. Note that there will be very little
//extra overhead of launching the new thread for a new JVM since
//most of the cost is involved in launching the process. Moreover,
//since we are going to be using the JVM for running many tasks,
//the thread launch cost becomes trivial when amortized over all
//tasks. Doing it this way also keeps code simple.
jvmRunner.setDaemon(true);
jvmRunner.setName(&quot;JVM Runner &quot; + jvmRunner.jvmId + &quot; spawned.&quot;);
setRunningTaskForJvm(jvmRunner.jvmId, t);
LOG.info(jvmRunner.getName());
jvmRunner.start();
}
private class JvmRunner extends Thread {
JvmEnv env;
volatile boolean killed = false;
volatile int numTasksRan;
final int numTasksToRun;
JVMId jvmId;
volatile boolean busy = true;
private ShellCommandExecutor shexec; // shell terminal for running the task
public JvmRunner(JvmEnv env, JobID jobId) {
this.env = env;
this.jvmId = new JVMId(jobId, isMap, rand.nextInt());
this.numTasksToRun = env.conf.getNumTasksToExecutePerJvm();
LOG.info(&quot;In JvmRunner constructed JVM ID: &quot; + jvmId);
}
public void run() {
runChild(env);
}

public void runChild(JvmEnv env) {
try {
env.vargs.add(Integer.toString(jvmId.getId()));
List&lt;String&gt; wrappedCommand =
TaskLog.captureOutAndError(env.setup, env.vargs, env.stdout, env.stderr,
env.logSize, env.pidFile);
shexec = new ShellCommandExecutor(wrappedCommand.toArray(new String[0]),
env.workDir, env.env);
shexec.execute();
} catch (IOException ioe) {
// do nothing
// error and output are appropriately redirected
} finally { // handle the exit code
if (shexec == null) {
return;
}
int exitCode = shexec.getExitCode();
updateOnJvmExit(jvmId, exitCode, killed);
LOG.info(&quot;JVM : &quot; + jvmId +&quot; exited. Number of tasks it ran: &quot; +
numTasksRan);
try {
// In case of jvm-reuse,
//the task jvm cleans up the common workdir for every
//task at the beginning of each task in the task JVM.
//For the last task, we do it here.
if (env.conf.getNumTasksToExecutePerJvm() != 1) {
FileUtil.fullyDelete(env.workDir);
}
} catch (IOException ie){}
}
}
public void execute() throws IOException {
this.run();
}
/** check to see if a command needs to be executed and execute if needed */
protected void run() throws IOException {
if (lastTime + interval &gt; System.currentTimeMillis())
return;
exitCode = 0; // reset for next run
runCommand();
}

/** Run a command */
private void runCommand() throws IOException {
ProcessBuilder builder = new ProcessBuilder(getExecString());
boolean completed = false;

if (environment != null) {
builder.environment().putAll(this.environment);
}
if (dir != null) {
builder.directory(this.dir);
}

process = builder.start();
final BufferedReader errReader =
new BufferedReader(new InputStreamReader(process
.getErrorStream()));
BufferedReader inReader =
new BufferedReader(new InputStreamReader(process
.getInputStream()));
final StringBuffer errMsg = new StringBuffer();

// read error and input streams as this would free up the buffers
// free the error stream buffer
Thread errThread = new Thread() {
@Override
public void run() {
try {
String line = errReader.readLine();
while((line != null) &amp;&amp; !isInterrupted()) {
errMsg.append(line);
errMsg.append(System.getProperty(&quot;line.separator&quot;));
line = errReader.readLine();
}
} catch(IOException ioe) {
LOG.warn(&quot;Error reading the error stream&quot;, ioe);
}
}
};
try {
errThread.start();
} catch (IllegalStateException ise) { }
try {
parseExecResult(inReader); // parse the output
// clear the input stream buffer
String line = inReader.readLine();
while(line != null) {
line = inReader.readLine();
}
// wait for the process to finish and check the exit code
exitCode = process.waitFor();
try {
// make sure that the error thread exits
errThread.join();
} catch (InterruptedException ie) {
LOG.warn(&quot;Interrupted while reading the error stream&quot;, ie);
}
completed = true;
if (exitCode != 0) {
throw new ExitCodeException(exitCode, errMsg.toString());
}
} catch (InterruptedException ie) {
throw new IOException(ie.toString());
} finally {
// close the input stream
try {
inReader.close();
} catch (IOException ioe) {
LOG.warn(&quot;Error while closing the input stream&quot;, ioe);
}
if (!completed) {
errThread.interrupt();
}
try {
errReader.close();
} catch (IOException ioe) {
LOG.warn(&quot;Error while closing the error stream&quot;, ioe);
}
process.destroy();
lastTime = System.currentTimeMillis();
}
}
// Create the splits for the job
LOG.debug(&quot;Creating splits at &quot; + fs.makeQualified(submitSplitFile));
int maps;
if (job.getUseNewMapper()) {
maps = writeNewSplits(context, submitSplitFile);
} else {
maps = writeOldSplits(job, submitSplitFile);
}
job.set(&quot;mapred.job.split.file&quot;, submitSplitFile.toString());
job.setNumMapTasks(maps);
int writeNewSplits(JobContext job, Path submitSplitFile
) throws IOException, InterruptedException,
ClassNotFoundException {
JobConf conf = job.getJobConf();
org.apache.hadoop.mapreduce.InputFormat&lt;?,?&gt; input =
ReflectionUtils.newInstance(job.getInputFormatClass(), job.getJobConf());

List&lt;org.apache.hadoop.mapreduce.InputSplit&gt; splits = input.getSplits(job);
T[] array = (T[])
splits.toArray(new org.apache.hadoop.mapreduce.InputSplit[splits.size()]);

// sort the splits into order based on size, so that the biggest
// go first
Arrays.sort(array, new NewSplitComparator());
DataOutputStream out = writeSplitsFileHeader(conf, submitSplitFile,
array.length);
try {
if (array.length != 0) {
DataOutputBuffer buffer = new DataOutputBuffer();
RawSplit rawSplit = new RawSplit();
SerializationFactory factory = new SerializationFactory(conf);
Serializer&lt;T&gt; serializer =
factory.getSerializer((Class&lt;T&gt;) array[0].getClass());
serializer.open(buffer);
for(T split: array) {
rawSplit.setClassName(split.getClass().getName());
buffer.reset();
serializer.serialize(split);
rawSplit.setDataLength(split.getLength());
rawSplit.setBytes(buffer.getData(), 0, buffer.getLength());
rawSplit.setLocations(split.getLocations());
rawSplit.write(out);
}
serializer.close();
}
} finally {
out.close();
}
return array.length;
}
org.apache.hadoop.mapreduce.InputFormat&lt;?,?&gt; input =
ReflectionUtils.newInstance(job.getInputFormatClass(), job.getJobConf());

List&lt;org.apache.hadoop.mapreduce.InputSplit&gt; splits = input.getSplits(job);
public InputSplit[] getSplits(JobConf job, int numSplits)
throws IOException {
FileStatus[] files = listStatus(job);

long totalSize = 0; // compute total size
for (FileStatus file: files) { // check we have valid files
if (file.isDir()) {
throw new IOException(&quot;Not a file: &quot;+ file.getPath());
}
totalSize += file.getLen();
}

long goalSize = totalSize / (numSplits == 0 ? 1 : numSplits);
long minSize = Math.max(job.getLong(&quot;mapred.min.split.size&quot;, 1),
minSplitSize);

// generate splits
ArrayList&lt;FileSplit&gt; splits = new ArrayList&lt;FileSplit&gt;(numSplits);
NetworkTopology clusterMap = new NetworkTopology();
for (FileStatus file: files) {
Path path = file.getPath();
FileSystem fs = path.getFileSystem(job);
long length = file.getLen();
BlockLocation[] blkLocations = fs.getFileBlockLocations(file, 0, length);
if ((length != 0) &amp;&amp; isSplitable(fs, path)) {
long blockSize = file.getBlockSize();
long splitSize = computeSplitSize(goalSize, minSize, blockSize);

long bytesRemaining = length;
while (((double) bytesRemaining)/splitSize &gt; SPLIT_SLOP) {
String[] splitHosts = getSplitHosts(blkLocations,
length-bytesRemaining, splitSize, clusterMap);
splits.add(new FileSplit(path, length-bytesRemaining, splitSize,
splitHosts));
bytesRemaining -= splitSize;
}

if (bytesRemaining != 0) {
splits.add(new FileSplit(path, length-bytesRemaining, bytesRemaining,
blkLocations[blkLocations.length-1].getHosts()));
}
} else if (length != 0) {
String[] splitHosts = getSplitHosts(blkLocations,0,length,clusterMap);
splits.add(new FileSplit(path, 0, length, splitHosts));
} else {
//Create empty hosts array for zero length files
splits.add(new FileSplit(path, 0, length, new String[0]));
}
}
LOG.debug(&quot;Total # of splits: &quot; + splits.size());
return splits.toArray(new FileSplit[splits.size()]);
}
rawSplit.setBytes(buffer.getData(), 0, buffer.getLength());
public void setBytes(byte[] data, int offset, int length) {
bytes.set(data, offset, length);
}
public void set(byte[] newData, int offset, int length) {
setSize(0);
setSize(length);
System.arraycopy(newData, offset, bytes, 0, size);
}
&lt;pre class=&quot;java&quot; name=&quot;code&quot;&gt; //
// read input splits and create a map per a split
//
String jobFile = profile.getJobFile();

Path sysDir = new Path(this.jobtracker.getSystemDir());
FileSystem fs = sysDir.getFileSystem(conf);
DataInputStream splitFile =
fs.open(new Path(conf.get(&quot;mapred.job.split.file&quot;)));
JobClient.RawSplit[] splits;
try {
splits = JobClient.readSplitFile(splitFile);
} finally {
splitFile.close();
}
numMapTasks = splits.length;
static RawSplit[] readSplitFile(DataInput in) throws IOException {
byte[] header = new byte[SPLIT_FILE_HEADER.length];
in.readFully(header);
if (!Arrays.equals(SPLIT_FILE_HEADER, header)) {
throw new IOException(&quot;Invalid header on split file&quot;);
}
int vers = WritableUtils.readVInt(in);
if (vers != CURRENT_SPLIT_FILE_VERSION) {
throw new IOException(&quot;Unsupported split version &quot; + vers);
}
int len = WritableUtils.readVInt(in);
RawSplit[] result = new RawSplit[len];
for(int i=0; i &lt; len; ++i) {
result[i] = new RawSplit();
result[i].readFields(in);
}
return result;
}
maps = new TaskInProgress[numMapTasks];
for(int i=0; i &lt; numMapTasks; ++i) {
inputLength += splits[i].getDataLength();
maps[i] = new TaskInProgress(jobId, jobFile,
splits[i],
jobtracker, conf, this, i);
}
public class WordCount {

public static class TokenizerMapper extends
Mapper&lt;Object, Text, Text, IntWritable&gt; {

private final static IntWritable one = new IntWritable(1);
private Text word = new Text();

public void map(Object key, Text value, Context context)
throws IOException, InterruptedException {
// StringTokenizer itr = new StringTokenizer(value.toString());
String line = value.toString();
String[] line1 = line.split(&quot;\\W&quot;);
for (String line2 : line1) {
String[] words = line2.split(&quot; &quot;);
for (String wordend : words) {
word.set(wordend);
context.write(word, one);
}
}
// while (itr.hasMoreTokens()) {
// word.set(itr.nextToken());
// context.write(word, one);
// }
}
}

public static class IntSumReducer extends
Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {
private IntWritable result = new IntWritable();

public void reduce(Text key, Iterable&lt;IntWritable&gt; values,
Context context) throws IOException, InterruptedException {
int sum = 0;
for (IntWritable val : values) {
sum += val.get();
}
result.set(sum);
context.write(key, result);
}
}

public static void main(String[] args) throws Exception {
try {
Configuration conf = new Configuration();
String[] otherArgs = new GenericOptionsParser(conf, args)
.getRemainingArgs();
if (otherArgs.length != 2) {
System.err.println(&quot;Usage: wordcount &lt;in&gt; &lt;out&gt;&quot;);
System.exit(2);
}
Job job = new Job(conf, &quot;word count&quot;);
job.setJarByClass(WordCount.class);
job.setMapperClass(TokenizerMapper.class);
job.setCombinerClass(IntSumReducer.class);
job.setReducerClass(IntSumReducer.class);
job.setOutputKeyClass(Text.class);
job.setOutputValueClass(IntWritable.class);
FileInputFormat.addInputPath(job, new Path(otherArgs[0]));
FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));
System.out.println(&quot;job start!&quot;);
System.exit(job.waitForCompletion(true) ? 0 : 1);
System.out.println(&quot;completed!&quot;);
} catch (Exception e) {
e.printStackTrace();
}

}
}
&lt;p&gt; &lt;/p&gt;&lt;h3 class=&quot;java&quot; name=&quot;code&quot;&gt;1 Job.waitForCompletion&lt;/h3&gt;&lt;p&gt;在配置好作业后，我们通过job.waitForCompletion提交作业，从这开始&lt;/p&gt;&lt;pre class=&quot;java&quot; name=&quot;code&quot;&gt; public boolean waitForCompletion(boolean verbose
) throws IOException, InterruptedException,
ClassNotFoundException {
if (state == JobState.DEFINE) {
submit();
}
if (verbose) {
jobClient.monitorAndPrintJob(conf, info);
} else {
info.waitForCompletion();
}
return isSuccessful();
}
public void submit() throws IOException, InterruptedException,
ClassNotFoundException {
ensureState(JobState.DEFINE);
setUseNewAPI();
info = jobClient.submitJobInternal(conf);
super.setJobID(info.getID());
state = JobState.RUNNING;
}
public Job(Configuration conf) throws IOException {
super(conf, null);
jobClient = new JobClient((JobConf) getConfiguration());
}
public
RunningJob submitJobInternal(JobConf job
) throws FileNotFoundException,
ClassNotFoundException,
InterruptedException,
IOException {
/*
* configure the command line options correctly on the submitting dfs
*/

JobID jobId = jobSubmitClient.getNewJobId();
Path submitJobDir = new Path(getSystemDir(), jobId.toString());
Path submitJarFile = new Path(submitJobDir, &quot;job.jar&quot;);
Path submitSplitFile = new Path(submitJobDir, &quot;job.split&quot;);
configureCommandLineOptions(job, submitJobDir, submitJarFile);
Path submitJobFile = new Path(submitJobDir, &quot;job.xml&quot;);
int reduces = job.getNumReduceTasks();
JobContext context = new JobContext(job, jobId);

// Check the output specification
if (reduces == 0 ? job.getUseNewMapper() : job.getUseNewReducer()) {
org.apache.hadoop.mapreduce.OutputFormat&lt;?,?&gt; output =
ReflectionUtils.newInstance(context.getOutputFormatClass(), job);
output.checkOutputSpecs(context);
} else {
job.getOutputFormat().checkOutputSpecs(fs, job);
}

// Create the splits for the job
LOG.debug(&quot;Creating splits at &quot; + fs.makeQualified(submitSplitFile));
int maps;
if (job.getUseNewMapper()) {
maps = writeNewSplits(context, submitSplitFile);
} else {
maps = writeOldSplits(job, submitSplitFile);
}
job.set(&quot;mapred.job.split.file&quot;, submitSplitFile.toString());
job.setNumMapTasks(maps);

// Write job file to JobTracker&apos;s fs
FSDataOutputStream out =
FileSystem.create(fs, submitJobFile,
new FsPermission(JOB_FILE_PERMISSION));

try {
job.writeXml(out);
} finally {
out.close();
}

//
// Now, actually submit the job (using the submit name)
//
JobStatus status = jobSubmitClient.submitJob(jobId);
if (status != null) {
return new NetworkedJob(status);
} else {
throw new IOException(&quot;Could not launch job&quot;);
}
}
configureCommandLineOptions(job, submitJobDir, submitJarFile);
private JobSubmissionProtocol createRPCProxy(InetSocketAddress addr,
Configuration conf) throws IOException {
return (JobSubmissionProtocol) RPC.getProxy(JobSubmissionProtocol.class,
JobSubmissionProtocol.versionID, addr, getUGI(conf), conf,
NetUtils.getSocketFactory(conf, JobSubmissionProtocol.class));
}
public static void main(String argv[]
) throws IOException, InterruptedException {
StringUtils.startupShutdownMessage(JobTracker.class, argv, LOG);
if (argv.length != 0) {
System.out.println(&quot;usage: JobTracker&quot;);
System.exit(-1);
}

try {
JobTracker tracker = startTracker(new JobConf());
tracker.offerService();
} catch (Throwable e) {
LOG.fatal(StringUtils.stringifyException(e));
System.exit(-1);
}
}
public static JobTracker startTracker(JobConf conf, String identifier)
throws IOException, InterruptedException {
JobTracker result = null;
while (true) {
try {
result = new JobTracker(conf, identifier);
result.taskScheduler.setTaskTrackerManager(result);
break;
} catch (VersionMismatch e) {
throw e;
} catch (BindException e) {
throw e;
} catch (UnknownHostException e) {
throw e;
} catch (AccessControlException ace) {
// in case of jobtracker not having right access
// bail out
throw ace;
} catch (IOException e) {
LOG.warn(&quot;Error starting tracker: &quot; +
StringUtils.stringifyException(e));
}
Thread.sleep(1000);
}
if (result != null) {
JobEndNotifier.startNotifier();
}
return result;
}
Class&lt;? extends TaskScheduler&gt; schedulerClass
= conf.getClass(&quot;mapred.jobtracker.taskScheduler&quot;,
JobQueueTaskScheduler.class, TaskScheduler.class);
taskScheduler = (TaskScheduler) ReflectionUtils.newInstance(schedulerClass, conf);
public void offerService() throws InterruptedException, IOException {
// Prepare for recovery. This is done irrespective of the status of restart
// flag.
while (true) {
try {
recoveryManager.updateRestartCount();
break;
} catch (IOException ioe) {
LOG.warn(&quot;Failed to initialize recovery manager. &quot;, ioe);
// wait for some time
Thread.sleep(FS_ACCESS_RETRY_PERIOD);
LOG.warn(&quot;Retrying...&quot;);
}
}

taskScheduler.start();

// Start the recovery after starting the scheduler
try {
recoveryManager.recover();
} catch (Throwable t) {
LOG.warn(&quot;Recovery manager crashed! Ignoring.&quot;, t);
}

this.expireTrackersThread = new Thread(this.expireTrackers,
&quot;expireTrackers&quot;);
this.expireTrackersThread.start();
this.retireJobsThread = new Thread(this.retireJobs, &quot;retireJobs&quot;);
this.retireJobsThread.start();
expireLaunchingTaskThread.start();

if (completedJobStatusStore.isActive()) {
completedJobsStoreThread = new Thread(completedJobStatusStore,
&quot;completedjobsStore-housekeeper&quot;);
completedJobsStoreThread.start();
}

// start the inter-tracker server once the jt is ready
this.interTrackerServer.start();

synchronized (this) {
state = State.RUNNING;
}
LOG.info(&quot;Starting RUNNING&quot;);

this.interTrackerServer.join();
LOG.info(&quot;Stopped interTrackerServer&quot;);
}
public synchronized void start() throws IOException {
super.start();
taskTrackerManager.addJobInProgressListener(jobQueueJobInProgressListener);
eagerTaskInitializationListener.setTaskTrackerManager(taskTrackerManager);
eagerTaskInitializationListener.start();
taskTrackerManager.addJobInProgressListener(
eagerTaskInitializationListener);
}
public void start() throws IOException {
this.jobInitManagerThread = new Thread(jobInitManager, &quot;jobInitManager&quot;);
jobInitManagerThread.setDaemon(true);
this.jobInitManagerThread.start();
}
class JobInitManager implements Runnable {

public void run() {
JobInProgress job = null;
while (true) {
try {
synchronized (jobInitQueue) {
while (jobInitQueue.isEmpty()) {
jobInitQueue.wait();
}
job = jobInitQueue.remove(0);
}
threadPool.execute(new InitJob(job));
} catch (InterruptedException t) {
LOG.info(&quot;JobInitManagerThread interrupted.&quot;);
break;
}
}
LOG.info(&quot;Shutting down thread pool&quot;);
threadPool.shutdownNow();
}
}
class InitJob implements Runnable {

private JobInProgress job;

public InitJob(JobInProgress job) {
this.job = job;
}

public void run() {
ttm.initJob(job);
}
}
public void setTaskTrackerManager(TaskTrackerManager ttm) {
this.ttm = ttm;
}
result.taskScheduler.setTaskTrackerManager(result);
public void initJob(JobInProgress job) {
if (null == job) {
LOG.info(&quot;Init on null job is not valid&quot;);
return;
}

try {
JobStatus prevStatus = (JobStatus)job.getStatus().clone();
LOG.info(&quot;Initializing &quot; + job.getJobID());
job.initTasks();
// Inform the listeners if the job state has changed
// Note : that the job will be in PREP state.
JobStatus newStatus = (JobStatus)job.getStatus().clone();
if (prevStatus.getRunState() != newStatus.getRunState()) {
JobStatusChangeEvent event =
new JobStatusChangeEvent(job, EventType.RUN_STATE_CHANGED, prevStatus,
newStatus);
synchronized (JobTracker.this) {
updateJobInProgressListeners(event);
}
}
} catch (KillInterruptedException kie) {
// If job was killed during initialization, job state will be KILLED
LOG.error(&quot;Job initialization interrupted:\n&quot; +
StringUtils.stringifyException(kie));
killJob(job);
} catch (Throwable t) {
// If the job initialization is failed, job state will be FAILED
LOG.error(&quot;Job initialization failed:\n&quot; +
StringUtils.stringifyException(t));
failJob(job);
}
}
/**
* Construct the splits, etc. This is invoked from an async
* thread so that split-computation doesn&apos;t block anyone.
*/
public synchronized void initTasks()
throws IOException, KillInterruptedException {
if (tasksInited.get() || isComplete()) {
return;
}
synchronized(jobInitKillStatus){
if(jobInitKillStatus.killed || jobInitKillStatus.initStarted) {
return;
}
jobInitKillStatus.initStarted = true;
}

LOG.info(&quot;Initializing &quot; + jobId);

// log job info
JobHistory.JobInfo.logSubmitted(getJobID(), conf, jobFile.toString(),
this.startTime, hasRestarted());
// log the job priority
setPriority(this.priority);

//
// read input splits and create a map per a split
//
String jobFile = profile.getJobFile();

Path sysDir = new Path(this.jobtracker.getSystemDir());
FileSystem fs = sysDir.getFileSystem(conf);
DataInputStream splitFile =
fs.open(new Path(conf.get(&quot;mapred.job.split.file&quot;)));
JobClient.RawSplit[] splits;
try {
splits = JobClient.readSplitFile(splitFile);
} finally {
splitFile.close();
}
numMapTasks = splits.length;


// if the number of splits is larger than a configured value
// then fail the job.
int maxTasks = jobtracker.getMaxTasksPerJob();
if (maxTasks &gt; 0 &amp;&amp; numMapTasks + numReduceTasks &gt; maxTasks) {
throw new IOException(
&quot;The number of tasks for this job &quot; +
(numMapTasks + numReduceTasks) +
&quot; exceeds the configured limit &quot; + maxTasks);
}
jobtracker.getInstrumentation().addWaiting(
getJobID(), numMapTasks + numReduceTasks);

maps = new TaskInProgress[numMapTasks];
for(int i=0; i &lt; numMapTasks; ++i) {
inputLength += splits[i].getDataLength();
maps[i] = new TaskInProgress(jobId, jobFile,
splits[i],
jobtracker, conf, this, i);
}
LOG.info(&quot;Input size for job &quot; + jobId + &quot; = &quot; + inputLength
+ &quot;. Number of splits = &quot; + splits.length);
if (numMapTasks &gt; 0) {
nonRunningMapCache = createCache(splits, maxLevel);
}

// set the launch time
this.launchTime = System.currentTimeMillis();

//
// Create reduce tasks
//
this.reduces = new TaskInProgress[numReduceTasks];
for (int i = 0; i &lt; numReduceTasks; i++) {
reduces[i] = new TaskInProgress(jobId, jobFile,
numMapTasks, i,
jobtracker, conf, this);
nonRunningReduces.add(reduces[i]);
}

// Calculate the minimum number of maps to be complete before
// we should start scheduling reduces
completedMapsForReduceSlowstart =
(int)Math.ceil(
(conf.getFloat(&quot;mapred.reduce.slowstart.completed.maps&quot;,
DEFAULT_COMPLETED_MAPS_PERCENT_FOR_REDUCE_SLOWSTART) *
numMapTasks));

// create cleanup two cleanup tips, one map and one reduce.
cleanup = new TaskInProgress[2];

// cleanup map tip. This map doesn&apos;t use any splits. Just assign an empty
// split.
JobClient.RawSplit emptySplit = new JobClient.RawSplit();
cleanup[0] = new TaskInProgress(jobId, jobFile, emptySplit,
jobtracker, conf, this, numMapTasks);
cleanup[0].setJobCleanupTask();

// cleanup reduce tip.
cleanup[1] = new TaskInProgress(jobId, jobFile, numMapTasks,
numReduceTasks, jobtracker, conf, this);
cleanup[1].setJobCleanupTask();

// create two setup tips, one map and one reduce.
setup = new TaskInProgress[2];

// setup map tip. This map doesn&apos;t use any split. Just assign an empty
// split.
setup[0] = new TaskInProgress(jobId, jobFile, emptySplit,
jobtracker, conf, this, numMapTasks + 1 );
setup[0].setJobSetupTask();

// setup reduce tip.
setup[1] = new TaskInProgress(jobId, jobFile, numMapTasks,
numReduceTasks + 1, jobtracker, conf, this);
setup[1].setJobSetupTask();

synchronized(jobInitKillStatus){
jobInitKillStatus.initDone = true;
if(jobInitKillStatus.killed) {
throw new KillInterruptedException(&quot;Job &quot; + jobId + &quot; killed in init&quot;);
}
}

tasksInited.set(true);
JobHistory.JobInfo.logInited(profile.getJobID(), this.launchTime,
numMapTasks, numReduceTasks);
}
this.interTrackerServer = RPC.getServer(this, addr.getHostName(), addr.getPort(), handlerCount, false, conf);
this.interTrackerServer.start();
this.jobClient = (InterTrackerProtocol)
RPC.waitForProxy(InterTrackerProtocol.class,
InterTrackerProtocol.versionID,
jobTrackAddr, this.fConf);
public static void main(String argv[]) throws Exception {
StringUtils.startupShutdownMessage(TaskTracker.class, argv, LOG);
if (argv.length != 0) {
System.out.println(&quot;usage: TaskTracker&quot;);
System.exit(-1);
}
try {
JobConf conf=new JobConf();
// enable the server to track time spent waiting on locks
ReflectionUtils.setContentionTracing
(conf.getBoolean(&quot;tasktracker.contention.tracking&quot;, false));
new TaskTracker(conf).run();
} catch (Throwable e) {
LOG.error(&quot;Can not start task tracker because &quot;+
StringUtils.stringifyException(e));
System.exit(-1);
}
}
public void run() {
try {
startCleanupThreads();
boolean denied = false;
while (running &amp;&amp; !shuttingDown &amp;&amp; !denied) {
boolean staleState = false;
try {
// This while-loop attempts reconnects if we get network errors
while (running &amp;&amp; !staleState &amp;&amp; !shuttingDown &amp;&amp; !denied) {
try {
State osState = offerService();
if (osState == State.STALE) {
staleState = true;
} else if (osState == State.DENIED) {
denied = true;
}
} catch (Exception ex) {
if (!shuttingDown) {
LOG.info(&quot;Lost connection to JobTracker [&quot; +
jobTrackAddr + &quot;]. Retrying...&quot;, ex);
try {
Thread.sleep(5000);
} catch (InterruptedException ie) {
}
}
}
}
} finally {
close();
}
if (shuttingDown) { return; }
LOG.warn(&quot;Reinitializing local state&quot;);
initialize();
}
if (denied) {
shutdown();
}
} catch (IOException iex) {
LOG.error(&quot;Got fatal exception while reinitializing TaskTracker: &quot; +
StringUtils.stringifyException(iex));
return;
}
}
State offerService() throws Exception {
long lastHeartbeat = 0;

while (running &amp;&amp; !shuttingDown) {
try {
long now = System.currentTimeMillis();

long waitTime = heartbeatInterval - (now - lastHeartbeat);
if (waitTime &gt; 0) {
// sleeps for the wait time
Thread.sleep(waitTime);
}

// If the TaskTracker is just starting up:
// 1. Verify the buildVersion
// 2. Get the system directory &amp; filesystem
if(justInited) {
String jobTrackerBV = jobClient.getBuildVersion();
if(!VersionInfo.getBuildVersion().equals(jobTrackerBV)) {
String msg = &quot;Shutting down. Incompatible buildVersion.&quot; +
&quot;\nJobTracker&apos;s: &quot; + jobTrackerBV +
&quot;\nTaskTracker&apos;s: &quot;+ VersionInfo.getBuildVersion();
LOG.error(msg);
try {
jobClient.reportTaskTrackerError(taskTrackerName, null, msg);
} catch(Exception e ) {
LOG.info(&quot;Problem reporting to jobtracker: &quot; + e);
}
return State.DENIED;
}

String dir = jobClient.getSystemDir();
if (dir == null) {
throw new IOException(&quot;Failed to get system directory&quot;);
}
systemDirectory = new Path(dir);
systemFS = systemDirectory.getFileSystem(fConf);
}

// Send the heartbeat and process the jobtracker&apos;s directives
HeartbeatResponse heartbeatResponse = transmitHeartBeat(now);

// Note the time when the heartbeat returned, use this to decide when to send the
// next heartbeat
lastHeartbeat = System.currentTimeMillis();


// Check if the map-event list needs purging
Set&lt;JobID&gt; jobs = heartbeatResponse.getRecoveredJobs();
if (jobs.size() &gt; 0) {
synchronized (this) {
// purge the local map events list
for (JobID job : jobs) {
RunningJob rjob;
synchronized (runningJobs) {
rjob = runningJobs.get(job);
if (rjob != null) {
synchronized (rjob) {
FetchStatus f = rjob.getFetchStatus();
if (f != null) {
f.reset();
}
}
}
}
}

// Mark the reducers in shuffle for rollback
synchronized (shouldReset) {
for (Map.Entry&lt;TaskAttemptID, TaskInProgress&gt; entry
: runningTasks.entrySet()) {
if (entry.getValue().getStatus().getPhase() == Phase.SHUFFLE) {
this.shouldReset.add(entry.getKey());
}
}
}
}
}

TaskTrackerAction[] actions = heartbeatResponse.getActions();
if(LOG.isDebugEnabled()) {
LOG.debug(&quot;Got heartbeatResponse from JobTracker with responseId: &quot; +
heartbeatResponse.getResponseId() + &quot; and &quot; +
((actions != null) ? actions.length : 0) + &quot; actions&quot;);
}
if (reinitTaskTracker(actions)) {
return State.STALE;
}

// resetting heartbeat interval from the response.
heartbeatInterval = heartbeatResponse.getHeartbeatInterval();
justStarted = false;
justInited = false;
if (actions != null){
for(TaskTrackerAction action: actions) {
if (action instanceof LaunchTaskAction) {
addToTaskQueue((LaunchTaskAction)action);
} else if (action instanceof CommitTaskAction) {
CommitTaskAction commitAction = (CommitTaskAction)action;
if (!commitResponses.contains(commitAction.getTaskID())) {
LOG.info(&quot;Received commit task action for &quot; +
commitAction.getTaskID());
commitResponses.add(commitAction.getTaskID());
}
} else {
tasksToCleanup.put(action);
}
}
}
markUnresponsiveTasks();
killOverflowingTasks();

//we&apos;ve cleaned up, resume normal operation
if (!acceptNewTasks &amp;&amp; isIdle()) {
acceptNewTasks=true;
}
//The check below may not be required every iteration but we are
//erring on the side of caution here. We have seen many cases where
//the call to jetty&apos;s getLocalPort() returns different values at
//different times. Being a real paranoid here.
checkJettyPort(server.getPort());
} catch (InterruptedException ie) {
LOG.info(&quot;Interrupted. Closing down.&quot;);
return State.INTERRUPTED;
} catch (DiskErrorException de) {
String msg = &quot;Exiting task tracker for disk error:\n&quot; +
StringUtils.stringifyException(de);
LOG.error(msg);
synchronized (this) {
jobClient.reportTaskTrackerError(taskTrackerName,
&quot;DiskErrorException&quot;, msg);
}
return State.STALE;
} catch (RemoteException re) {
String reClass = re.getClassName();
if (DisallowedTaskTrackerException.class.getName().equals(reClass)) {
LOG.info(&quot;Tasktracker disallowed by JobTracker.&quot;);
return State.DENIED;
}
} catch (Exception except) {
String msg = &quot;Caught exception: &quot; +
StringUtils.stringifyException(except);
LOG.error(msg);
}
}

return State.NORMAL;
}
private void addToTaskQueue(LaunchTaskAction action) {
if (action.getTask().isMapTask()) {
mapLauncher.addToTaskQueue(action);
} else {
reduceLauncher.addToTaskQueue(action);
}
}
public void addToTaskQueue(LaunchTaskAction action) {
synchronized (tasksToLaunch) {
TaskInProgress tip = registerTask(action, this);
tasksToLaunch.add(tip);
tasksToLaunch.notifyAll();
}
}
private TaskInProgress registerTask(LaunchTaskAction action,
TaskLauncher launcher) {
Task t = action.getTask();
LOG.info(&quot;LaunchTaskAction (registerTask): &quot; + t.getTaskID() +
&quot; task&apos;s state:&quot; + t.getState());
TaskInProgress tip = new TaskInProgress(t, this.fConf, launcher);
synchronized (this) {
tasks.put(t.getTaskID(), tip);
runningTasks.put(t.getTaskID(), tip);
boolean isMap = t.isMapTask();
if (isMap) {
mapTotal++;
} else {
reduceTotal++;
}
}
return tip;
}
private HeartbeatResponse transmitHeartBeat(long now) throws IOException {
// Send Counters in the status once every COUNTER_UPDATE_INTERVAL
boolean sendCounters;
if (now &gt; (previousUpdate + COUNTER_UPDATE_INTERVAL)) {
sendCounters = true;
previousUpdate = now;
}
else {
sendCounters = false;
}

//
// Check if the last heartbeat got through...
// if so then build the heartbeat information for the JobTracker;
// else resend the previous status information.
//
if (status == null) {
synchronized (this) {
status = new TaskTrackerStatus(taskTrackerName, localHostname,
httpPort,
cloneAndResetRunningTaskStatuses(
sendCounters),
failures,
maxCurrentMapTasks,
maxCurrentReduceTasks);
}
} else {
LOG.info(&quot;Resending &apos;status&apos; to &apos;&quot; + jobTrackAddr.getHostName() +
&quot;&apos; with reponseId &apos;&quot; + heartbeatResponseId);
}

//
// Check if we should ask for a new Task
//
boolean askForNewTask;
long localMinSpaceStart;
synchronized (this) {
askForNewTask = (status.countMapTasks() &lt; maxCurrentMapTasks ||
status.countReduceTasks() &lt; maxCurrentReduceTasks) &amp;&amp;
acceptNewTasks;
localMinSpaceStart = minSpaceStart;
}
if (askForNewTask) {
checkLocalDirs(fConf.getLocalDirs());
askForNewTask = enoughFreeSpace(localMinSpaceStart);
long freeDiskSpace = getFreeSpace();
long totVmem = getTotalVirtualMemoryOnTT();
long totPmem = getTotalPhysicalMemoryOnTT();

status.getResourceStatus().setAvailableSpace(freeDiskSpace);
status.getResourceStatus().setTotalVirtualMemory(totVmem);
status.getResourceStatus().setTotalPhysicalMemory(totPmem);
status.getResourceStatus().setMapSlotMemorySizeOnTT(
mapSlotMemorySizeOnTT);
status.getResourceStatus().setReduceSlotMemorySizeOnTT(
reduceSlotSizeMemoryOnTT);
}

//
// Xmit the heartbeat
//
HeartbeatResponse heartbeatResponse = jobClient.heartbeat(status,
justStarted,
justInited,
askForNewTask,
heartbeatResponseId);

//
// The heartbeat got through successfully!
//
heartbeatResponseId = heartbeatResponse.getResponseId();

synchronized (this) {
for (TaskStatus taskStatus : status.getTaskReports()) {
if (taskStatus.getRunState() != TaskStatus.State.RUNNING &amp;&amp;
taskStatus.getRunState() != TaskStatus.State.UNASSIGNED &amp;&amp;
taskStatus.getRunState() != TaskStatus.State.COMMIT_PENDING &amp;&amp;
!taskStatus.inTaskCleanupPhase()) {
if (taskStatus.getIsMap()) {
mapTotal--;
} else {
reduceTotal--;
}
try {
myInstrumentation.completeTask(taskStatus.getTaskID());
} catch (MetricsException me) {
LOG.warn(&quot;Caught: &quot; + StringUtils.stringifyException(me));
}
runningTasks.remove(taskStatus.getTaskID());
}
}

// Clear transient status information which should only
// be sent once to the JobTracker
for (TaskInProgress tip: runningTasks.values()) {
tip.getStatus().clearStatus();
}
}

// Force a rebuild of &apos;status&apos; on the next iteration
status = null;

return heartbeatResponse;
}
public synchronized HeartbeatResponse heartbeat(TaskTrackerStatus status,
boolean restarted,
boolean initialContact,
boolean acceptNewTasks,
short responseId)
throws IOException {
LOG.debug(&quot;Got heartbeat from: &quot; + status.getTrackerName() +
&quot; (restarted: &quot; + restarted +
&quot; initialContact: &quot; + initialContact +
&quot; acceptNewTasks: &quot; + acceptNewTasks + &quot;)&quot; +
&quot; with responseId: &quot; + responseId);

// Make sure heartbeat is from a tasktracker allowed by the jobtracker.
if (!acceptTaskTracker(status)) {
throw new DisallowedTaskTrackerException(status);
}

// First check if the last heartbeat response got through
String trackerName = status.getTrackerName();
long now = System.currentTimeMillis();
boolean isBlacklisted = false;
if (restarted) {
faultyTrackers.markTrackerHealthy(status.getHost());
} else {
isBlacklisted =
faultyTrackers.shouldAssignTasksToTracker(status.getHost(), now);
}

HeartbeatResponse prevHeartbeatResponse =
trackerToHeartbeatResponseMap.get(trackerName);
boolean addRestartInfo = false;

if (initialContact != true) {
// If this isn&apos;t the &apos;initial contact&apos; from the tasktracker,
// there is something seriously wrong if the JobTracker has
// no record of the &apos;previous heartbeat&apos;; if so, ask the
// tasktracker to re-initialize itself.
if (prevHeartbeatResponse == null) {
// This is the first heartbeat from the old tracker to the newly
// started JobTracker
if (hasRestarted()) {
addRestartInfo = true;
// inform the recovery manager about this tracker joining back
recoveryManager.unMarkTracker(trackerName);
} else {
// Jobtracker might have restarted but no recovery is needed
// otherwise this code should not be reached
LOG.warn(&quot;Serious problem, cannot find record of &apos;previous&apos; &quot; +
&quot;heartbeat for &apos;&quot; + trackerName +
&quot;&apos;; reinitializing the tasktracker&quot;);
return new HeartbeatResponse(responseId,
new TaskTrackerAction[] {new ReinitTrackerAction()});
}

} else {

// It is completely safe to not process a &apos;duplicate&apos; heartbeat from a
// {@link TaskTracker} since it resends the heartbeat when rpcs are
// lost see {@link TaskTracker.transmitHeartbeat()};
// acknowledge it by re-sending the previous response to let the
// {@link TaskTracker} go forward.
if (prevHeartbeatResponse.getResponseId() != responseId) {
LOG.info(&quot;Ignoring &apos;duplicate&apos; heartbeat from &apos;&quot; +
trackerName + &quot;&apos;; resending the previous &apos;lost&apos; response&quot;);
return prevHeartbeatResponse;
}
}
}

// Process this heartbeat
short newResponseId = (short)(responseId + 1);
status.setLastSeen(now);
if (!processHeartbeat(status, initialContact)) {
if (prevHeartbeatResponse != null) {
trackerToHeartbeatResponseMap.remove(trackerName);
}
return new HeartbeatResponse(newResponseId,
new TaskTrackerAction[] {new ReinitTrackerAction()});
}

// Initialize the response to be sent for the heartbeat
HeartbeatResponse response = new HeartbeatResponse(newResponseId, null);
List&lt;TaskTrackerAction&gt; actions = new ArrayList&lt;TaskTrackerAction&gt;();

// Check for new tasks to be executed on the tasktracker
if (recoveryManager.shouldSchedule() &amp;&amp; acceptNewTasks &amp;&amp; !isBlacklisted) {
TaskTrackerStatus taskTrackerStatus = getTaskTracker(trackerName);
if (taskTrackerStatus == null) {
LOG.warn(&quot;Unknown task tracker polling; ignoring: &quot; + trackerName);
} else {
List&lt;Task&gt; tasks = getSetupAndCleanupTasks(taskTrackerStatus);
if (tasks == null ) {
tasks = taskScheduler.assignTasks(taskTrackerStatus);
}
if (tasks != null) {
for (Task task : tasks) {
expireLaunchingTasks.addNewTask(task.getTaskID());
LOG.debug(trackerName + &quot; -&gt; LaunchTask: &quot; + task.getTaskID());
actions.add(new LaunchTaskAction(task));
}
}
}
}

// Check for tasks to be killed
List&lt;TaskTrackerAction&gt; killTasksList = getTasksToKill(trackerName);
if (killTasksList != null) {
actions.addAll(killTasksList);
}

// Check for jobs to be killed/cleanedup
List&lt;TaskTrackerAction&gt; killJobsList = getJobsForCleanup(trackerName);
if (killJobsList != null) {
actions.addAll(killJobsList);
}

// Check for tasks whose outputs can be saved
List&lt;TaskTrackerAction&gt; commitTasksList = getTasksToSave(status);
if (commitTasksList != null) {
actions.addAll(commitTasksList);
}

// calculate next heartbeat interval and put in heartbeat response
int nextInterval = getNextHeartbeatInterval();
response.setHeartbeatInterval(nextInterval);
response.setActions(
actions.toArray(new TaskTrackerAction[actions.size()]));

// check if the restart info is req
if (addRestartInfo) {
response.setRecoveredJobs(recoveryManager.getJobsToRecover());
}

// Update the trackerToHeartbeatResponseMap
trackerToHeartbeatResponseMap.put(trackerName, response);

// Done processing the hearbeat, now remove &apos;marked&apos; tasks
removeMarkedTasks(trackerName);

return response;
}
public synchronized List&lt;Task&gt; assignTasks(TaskTrackerStatus taskTracker)
throws IOException {

ClusterStatus clusterStatus = taskTrackerManager.getClusterStatus();
final int numTaskTrackers = clusterStatus.getTaskTrackers();
final int clusterMapCapacity = clusterStatus.getMaxMapTasks();
final int clusterReduceCapacity = clusterStatus.getMaxReduceTasks();

Collection&lt;JobInProgress&gt; jobQueue =
jobQueueJobInProgressListener.getJobQueue();

//
// Get map + reduce counts for the current tracker.
//
final int trackerMapCapacity = taskTracker.getMaxMapTasks();
final int trackerReduceCapacity = taskTracker.getMaxReduceTasks();
final int trackerRunningMaps = taskTracker.countMapTasks();
final int trackerRunningReduces = taskTracker.countReduceTasks();

// Assigned tasks
List&lt;Task&gt; assignedTasks = new ArrayList&lt;Task&gt;();

//
// Compute (running + pending) map and reduce task numbers across pool
//
int remainingReduceLoad = 0;
int remainingMapLoad = 0;
synchronized (jobQueue) {
for (JobInProgress job : jobQueue) {
if (job.getStatus().getRunState() == JobStatus.RUNNING) {
remainingMapLoad += (job.desiredMaps() - job.finishedMaps());
if (job.scheduleReduces()) {
remainingReduceLoad +=
(job.desiredReduces() - job.finishedReduces());
}
}
}
}

// Compute the &apos;load factor&apos; for maps and reduces
double mapLoadFactor = 0.0;
if (clusterMapCapacity &gt; 0) {
mapLoadFactor = (double)remainingMapLoad / clusterMapCapacity;
}
double reduceLoadFactor = 0.0;
if (clusterReduceCapacity &gt; 0) {
reduceLoadFactor = (double)remainingReduceLoad / clusterReduceCapacity;
}

//
// In the below steps, we allocate first map tasks (if appropriate),
// and then reduce tasks if appropriate. We go through all jobs
// in order of job arrival; jobs only get serviced if their
// predecessors are serviced, too.
//

//
// We assign tasks to the current taskTracker if the given machine
// has a workload that&apos;s less than the maximum load of that kind of
// task.
// However, if the cluster is close to getting loaded i.e. we don&apos;t
// have enough _padding_ for speculative executions etc., we only
// schedule the &quot;highest priority&quot; task i.e. the task from the job
// with the highest priority.
//

final int trackerCurrentMapCapacity =
Math.min((int)Math.ceil(mapLoadFactor * trackerMapCapacity),
trackerMapCapacity);
int availableMapSlots = trackerCurrentMapCapacity - trackerRunningMaps;
boolean exceededMapPadding = false;
if (availableMapSlots &gt; 0) {
exceededMapPadding =
exceededPadding(true, clusterStatus, trackerMapCapacity);
}

int numLocalMaps = 0;
int numNonLocalMaps = 0;
scheduleMaps:
for (int i=0; i &lt; availableMapSlots; ++i) {
synchronized (jobQueue) {
for (JobInProgress job : jobQueue) {
if (job.getStatus().getRunState() != JobStatus.RUNNING) {
continue;
}

Task t = null;

// Try to schedule a node-local or rack-local Map task
t =
job.obtainNewLocalMapTask(taskTracker, numTaskTrackers,
taskTrackerManager.getNumberOfUniqueHosts());
if (t != null) {
assignedTasks.add(t);
++numLocalMaps;

// Don&apos;t assign map tasks to the hilt!
// Leave some free slots in the cluster for future task-failures,
// speculative tasks etc. beyond the highest priority job
if (exceededMapPadding) {
break scheduleMaps;
}

// Try all jobs again for the next Map task
break;
}

// Try to schedule a node-local or rack-local Map task
t =
job.obtainNewNonLocalMapTask(taskTracker, numTaskTrackers,
taskTrackerManager.getNumberOfUniqueHosts());

if (t != null) {
assignedTasks.add(t);
++numNonLocalMaps;

// We assign at most 1 off-switch or speculative task
// This is to prevent TaskTrackers from stealing local-tasks
// from other TaskTrackers.
break scheduleMaps;
}
}
}
}
int assignedMaps = assignedTasks.size();

//
// Same thing, but for reduce tasks
// However we _never_ assign more than 1 reduce task per heartbeat
//
final int trackerCurrentReduceCapacity =
Math.min((int)Math.ceil(reduceLoadFactor * trackerReduceCapacity),
trackerReduceCapacity);
final int availableReduceSlots =
Math.min((trackerCurrentReduceCapacity - trackerRunningReduces), 1);
boolean exceededReducePadding = false;
if (availableReduceSlots &gt; 0) {
exceededReducePadding = exceededPadding(false, clusterStatus,
trackerReduceCapacity);
synchronized (jobQueue) {
for (JobInProgress job : jobQueue) {
if (job.getStatus().getRunState() != JobStatus.RUNNING ||
job.numReduceTasks == 0) {
continue;
}

Task t =
job.obtainNewReduceTask(taskTracker, numTaskTrackers,
taskTrackerManager.getNumberOfUniqueHosts()
);
if (t != null) {
assignedTasks.add(t);
break;
}

// Don&apos;t assign reduce tasks to the hilt!
// Leave some free slots in the cluster for future task-failures,
// speculative tasks etc. beyond the highest priority job
if (exceededReducePadding) {
break;
}
}
}
}

if (LOG.isDebugEnabled()) {
LOG.debug(&quot;Task assignments for &quot; + taskTracker.getTrackerName() + &quot; --&gt; &quot; +
&quot;[&quot; + mapLoadFactor + &quot;, &quot; + trackerMapCapacity + &quot;, &quot; +
trackerCurrentMapCapacity + &quot;, &quot; + trackerRunningMaps + &quot;] -&gt; [&quot; +
(trackerCurrentMapCapacity - trackerRunningMaps) + &quot;, &quot; +
assignedMaps + &quot; (&quot; + numLocalMaps + &quot;, &quot; + numNonLocalMaps +
&quot;)] [&quot; + reduceLoadFactor + &quot;, &quot; + trackerReduceCapacity + &quot;, &quot; +
trackerCurrentReduceCapacity + &quot;,&quot; + trackerRunningReduces +
&quot;] -&gt; [&quot; + (trackerCurrentReduceCapacity - trackerRunningReduces) +
&quot;, &quot; + (assignedTasks.size()-assignedMaps) + &quot;]&quot;);
}

return assignedTasks;
}
public TaskTracker(JobConf conf) throws IOException {
originalConf = conf;
maxCurrentMapTasks = conf.getInt(
&quot;mapred.tasktracker.map.tasks.maximum&quot;, 2);
maxCurrentReduceTasks = conf.getInt(
&quot;mapred.tasktracker.reduce.tasks.maximum&quot;, 2);
this.jobTrackAddr = JobTracker.getAddress(conf);
String infoAddr =
NetUtils.getServerAddress(conf,
&quot;tasktracker.http.bindAddress&quot;,
&quot;tasktracker.http.port&quot;,
&quot;mapred.task.tracker.http.address&quot;);
InetSocketAddress infoSocAddr = NetUtils.createSocketAddr(infoAddr);
String httpBindAddress = infoSocAddr.getHostName();
int httpPort = infoSocAddr.getPort();
this.server = new HttpServer(&quot;task&quot;, httpBindAddress, httpPort,
httpPort == 0, conf);
workerThreads = conf.getInt(&quot;tasktracker.http.threads&quot;, 40);
this.shuffleServerMetrics = new ShuffleServerMetrics(conf);
server.setThreads(1, workerThreads);
// let the jsp pages get to the task tracker, config, and other relevant
// objects
FileSystem local = FileSystem.getLocal(conf);
this.localDirAllocator = new LocalDirAllocator(&quot;mapred.local.dir&quot;);
server.setAttribute(&quot;task.tracker&quot;, this);
server.setAttribute(&quot;local.file.system&quot;, local);
server.setAttribute(&quot;conf&quot;, conf);
server.setAttribute(&quot;log&quot;, LOG);
server.setAttribute(&quot;localDirAllocator&quot;, localDirAllocator);
server.setAttribute(&quot;shuffleServerMetrics&quot;, shuffleServerMetrics);
server.addInternalServlet(&quot;mapOutput&quot;, &quot;/mapOutput&quot;, MapOutputServlet.class);
server.addInternalServlet(&quot;taskLog&quot;, &quot;/tasklog&quot;, TaskLogServlet.class);
server.start();
this.httpPort = server.getPort();
checkJettyPort(httpPort);
initialize();
}
synchronized void initialize() throws IOException {
// use configured nameserver &amp; interface to get local hostname
this.fConf = new JobConf(originalConf);
if (fConf.get(&quot;slave.host.name&quot;) != null) {
this.localHostname = fConf.get(&quot;slave.host.name&quot;);
}
if (localHostname == null) {
this.localHostname =
DNS.getDefaultHost
(fConf.get(&quot;mapred.tasktracker.dns.interface&quot;,&quot;default&quot;),
fConf.get(&quot;mapred.tasktracker.dns.nameserver&quot;,&quot;default&quot;));
}

//check local disk
checkLocalDirs(this.fConf.getLocalDirs());
fConf.deleteLocalFiles(SUBDIR);

// Clear out state tables
this.tasks.clear();
this.runningTasks = new LinkedHashMap&lt;TaskAttemptID, TaskInProgress&gt;();
this.runningJobs = new TreeMap&lt;JobID, RunningJob&gt;();
this.mapTotal = 0;
this.reduceTotal = 0;
this.acceptNewTasks = true;
this.status = null;

this.minSpaceStart = this.fConf.getLong(&quot;mapred.local.dir.minspacestart&quot;, 0L);
this.minSpaceKill = this.fConf.getLong(&quot;mapred.local.dir.minspacekill&quot;, 0L);
//tweak the probe sample size (make it a function of numCopiers)
probe_sample_size = this.fConf.getInt(&quot;mapred.tasktracker.events.batchsize&quot;, 500);

Class&lt;? extends TaskTrackerInstrumentation&gt; metricsInst = getInstrumentationClass(fConf);
try {
java.lang.reflect.Constructor&lt;? extends TaskTrackerInstrumentation&gt; c =
metricsInst.getConstructor(new Class[] {TaskTracker.class} );
this.myInstrumentation = c.newInstance(this);
} catch(Exception e) {
//Reflection can throw lots of exceptions -- handle them all by
//falling back on the default.
LOG.error(&quot;failed to initialize taskTracker metrics&quot;, e);
this.myInstrumentation = new TaskTrackerMetricsInst(this);
}

// bind address
String address =
NetUtils.getServerAddress(fConf,
&quot;mapred.task.tracker.report.bindAddress&quot;,
&quot;mapred.task.tracker.report.port&quot;,
&quot;mapred.task.tracker.report.address&quot;);
InetSocketAddress socAddr = NetUtils.createSocketAddr(address);
String bindAddress = socAddr.getHostName();
int tmpPort = socAddr.getPort();

this.jvmManager = new JvmManager(this);

// Set service-level authorization security policy
if (this.fConf.getBoolean(
ServiceAuthorizationManager.SERVICE_AUTHORIZATION_CONFIG, false)) {
PolicyProvider policyProvider =
(PolicyProvider)(ReflectionUtils.newInstance(
this.fConf.getClass(PolicyProvider.POLICY_PROVIDER_CONFIG,
MapReducePolicyProvider.class, PolicyProvider.class),
this.fConf));
SecurityUtil.setPolicy(new ConfiguredPolicy(this.fConf, policyProvider));
}

// RPC initialization
int max = maxCurrentMapTasks &gt; maxCurrentReduceTasks ?
maxCurrentMapTasks : maxCurrentReduceTasks;
//set the num handlers to max*2 since canCommit may wait for the duration
//of a heartbeat RPC
this.taskReportServer =
RPC.getServer(this, bindAddress, tmpPort, 2 * max, false, this.fConf);
this.taskReportServer.start();

// get the assigned address
this.taskReportAddress = taskReportServer.getListenerAddress();
this.fConf.set(&quot;mapred.task.tracker.report.address&quot;,
taskReportAddress.getHostName() + &quot;:&quot; + taskReportAddress.getPort());
LOG.info(&quot;TaskTracker up at: &quot; + this.taskReportAddress);

this.taskTrackerName = &quot;tracker_&quot; + localHostname + &quot;:&quot; + taskReportAddress;
LOG.info(&quot;Starting tracker &quot; + taskTrackerName);

// Clear out temporary files that might be lying around
DistributedCache.purgeCache(this.fConf);
cleanupStorage();

this.jobClient = (InterTrackerProtocol)
RPC.waitForProxy(InterTrackerProtocol.class,
InterTrackerProtocol.versionID,
jobTrackAddr, this.fConf);
this.justInited = true;
this.running = true;
// start the thread that will fetch map task completion events
this.mapEventsFetcher = new MapEventsFetcherThread();
mapEventsFetcher.setDaemon(true);
mapEventsFetcher.setName(
&quot;Map-events fetcher for all reduce tasks &quot; + &quot;on &quot; +
taskTrackerName);
mapEventsFetcher.start();

initializeMemoryManagement();

this.indexCache = new IndexCache(this.fConf);

mapLauncher = new TaskLauncher(maxCurrentMapTasks);
reduceLauncher = new TaskLauncher(maxCurrentReduceTasks);
mapLauncher.start();
reduceLauncher.start();
}
public void run() {
while (!Thread.interrupted()) {
try {
TaskInProgress tip;
synchronized (tasksToLaunch) {
while (tasksToLaunch.isEmpty()) {
tasksToLaunch.wait();
}
//get the TIP
tip = tasksToLaunch.remove(0);
LOG.info(&quot;Trying to launch : &quot; + tip.getTask().getTaskID());
}
//wait for a slot to run
synchronized (numFreeSlots) {
while (numFreeSlots.get() == 0) {
numFreeSlots.wait();
}
LOG.info(&quot;In TaskLauncher, current free slots : &quot; + numFreeSlots.get()+
&quot; and trying to launch &quot;+tip.getTask().getTaskID());
numFreeSlots.set(numFreeSlots.get() - 1);
assert (numFreeSlots.get() &gt;= 0);
}
synchronized (tip) {
//to make sure that there is no kill task action for this
if (tip.getRunState() != TaskStatus.State.UNASSIGNED &amp;&amp;
tip.getRunState() != TaskStatus.State.FAILED_UNCLEAN &amp;&amp;
tip.getRunState() != TaskStatus.State.KILLED_UNCLEAN) {
//got killed externally while still in the launcher queue
addFreeSlot();
continue;
}
tip.slotTaken = true;
}
//got a free slot. launch the task
startNewTask(tip);
} catch (InterruptedException e) {
return; // ALL DONE
} catch (Throwable th) {
LOG.error(&quot;TaskLauncher error &quot; +
StringUtils.stringifyException(th));
}
}
}
}
private void startNewTask(TaskInProgress tip) {
try {
localizeJob(tip);
} catch (Throwable e) {
String msg = (&quot;Error initializing &quot; + tip.getTask().getTaskID() +
&quot;:\n&quot; + StringUtils.stringifyException(e));
LOG.warn(msg);
tip.reportDiagnosticInfo(msg);
try {
tip.kill(true);
tip.cleanup(true);
} catch (IOException ie2) {
LOG.info(&quot;Error cleaning up &quot; + tip.getTask().getTaskID() + &quot;:\n&quot; +
StringUtils.stringifyException(ie2));
}

// Careful!
// This might not be an &apos;Exception&apos; - don&apos;t handle &apos;Error&apos; here!
if (e instanceof Error) {
throw ((Error) e);
}
}
}

private void localizeJob(TaskInProgress tip) throws IOException {
Path localJarFile = null;
Task t = tip.getTask();
JobID jobId = t.getJobID();
Path jobFile = new Path(t.getJobFile());
// Get sizes of JobFile and JarFile
// sizes are -1 if they are not present.
FileStatus status = null;
long jobFileSize = -1;
try {
status = systemFS.getFileStatus(jobFile);
jobFileSize = status.getLen();
} catch(FileNotFoundException fe) {
jobFileSize = -1;
}
Path localJobFile = lDirAlloc.getLocalPathForWrite(
getLocalJobDir(jobId.toString())
+ Path.SEPARATOR + &quot;job.xml&quot;,
jobFileSize, fConf);
RunningJob rjob = addTaskToJob(jobId, tip);
synchronized (rjob) {
if (!rjob.localized) {

FileSystem localFs = FileSystem.getLocal(fConf);
// this will happen on a partial execution of localizeJob.
// Sometimes the job.xml gets copied but copying job.jar
// might throw out an exception
// we should clean up and then try again
Path jobDir = localJobFile.getParent();
if (localFs.exists(jobDir)){
localFs.delete(jobDir, true);
boolean b = localFs.mkdirs(jobDir);
if (!b)
throw new IOException(&quot;Not able to create job directory &quot;
+ jobDir.toString());
}
systemFS.copyToLocalFile(jobFile, localJobFile);
JobConf localJobConf = new JobConf(localJobFile);

// create the &apos;work&apos; directory
// job-specific shared directory for use as scratch space
Path workDir = lDirAlloc.getLocalPathForWrite(
(getLocalJobDir(jobId.toString())
+ Path.SEPARATOR + &quot;work&quot;), fConf);
if (!localFs.mkdirs(workDir)) {
throw new IOException(&quot;Mkdirs failed to create &quot;
+ workDir.toString());
}
System.setProperty(&quot;job.local.dir&quot;, workDir.toString());
localJobConf.set(&quot;job.local.dir&quot;, workDir.toString());

// copy Jar file to the local FS and unjar it.
String jarFile = localJobConf.getJar();
long jarFileSize = -1;
if (jarFile != null) {
Path jarFilePath = new Path(jarFile);
try {
status = systemFS.getFileStatus(jarFilePath);
jarFileSize = status.getLen();
} catch(FileNotFoundException fe) {
jarFileSize = -1;
}
// Here we check for and we check five times the size of jarFileSize
// to accommodate for unjarring the jar file in work directory
localJarFile = new Path(lDirAlloc.getLocalPathForWrite(
getLocalJobDir(jobId.toString())
+ Path.SEPARATOR + &quot;jars&quot;,
5 * jarFileSize, fConf), &quot;job.jar&quot;);
if (!localFs.mkdirs(localJarFile.getParent())) {
throw new IOException(&quot;Mkdirs failed to create jars directory &quot;);
}
systemFS.copyToLocalFile(jarFilePath, localJarFile);
localJobConf.setJar(localJarFile.toString());
OutputStream out = localFs.create(localJobFile);
try {
localJobConf.writeXml(out);
} finally {
out.close();
}
// also unjar the job.jar files
RunJar.unJar(new File(localJarFile.toString()),
new File(localJarFile.getParent().toString()));
}
rjob.keepJobFiles = ((localJobConf.getKeepTaskFilesPattern() != null) ||
localJobConf.getKeepFailedTaskFiles());
rjob.localized = true;
rjob.jobConf = localJobConf;
}
}
launchTaskForJob(tip, new JobConf(rjob.jobConf));
}
private void launchTaskForJob(TaskInProgress tip, JobConf jobConf) throws IOException{
synchronized (tip) {
tip.setJobConf(jobConf);
tip.launchTask();
}
}
public synchronized void launchTask() throws IOException {
if (this.taskStatus.getRunState() == TaskStatus.State.UNASSIGNED ||
this.taskStatus.getRunState() == TaskStatus.State.FAILED_UNCLEAN ||
this.taskStatus.getRunState() == TaskStatus.State.KILLED_UNCLEAN) {
localizeTask(task);
if (this.taskStatus.getRunState() == TaskStatus.State.UNASSIGNED) {
this.taskStatus.setRunState(TaskStatus.State.RUNNING);
}
this.runner = task.createRunner(TaskTracker.this, this);
this.runner.start();
this.taskStatus.setStartTime(System.currentTimeMillis());
} else {
LOG.info(&quot;Not launching task: &quot; + task.getTaskID() +
&quot; since it&apos;s state is &quot; + this.taskStatus.getRunState());
}
}
public final void run() {
try {

//before preparing the job localize
//all the archives
TaskAttemptID taskid = t.getTaskID();
LocalDirAllocator lDirAlloc = new LocalDirAllocator(&quot;mapred.local.dir&quot;);
File jobCacheDir = null;
if (conf.getJar() != null) {
jobCacheDir = new File(
new Path(conf.getJar()).getParent().toString());
}
File workDir = new File(lDirAlloc.getLocalPathToRead(
TaskTracker.getLocalTaskDir(
t.getJobID().toString(),
t.getTaskID().toString(),
t.isTaskCleanupTask())
+ Path.SEPARATOR + MRConstants.WORKDIR,
conf). toString());

URI[] archives = DistributedCache.getCacheArchives(conf);
URI[] files = DistributedCache.getCacheFiles(conf);
FileStatus fileStatus;
FileSystem fileSystem;
Path localPath;
String baseDir;

if ((archives != null) || (files != null)) {
if (archives != null) {
String[] archivesTimestamps =
DistributedCache.getArchiveTimestamps(conf);
Path[] p = new Path[archives.length];
for (int i = 0; i &lt; archives.length;i++){
fileSystem = FileSystem.get(archives[i], conf);
fileStatus = fileSystem.getFileStatus(
new Path(archives[i].getPath()));
String cacheId = DistributedCache.makeRelative(archives[i],conf);
String cachePath = TaskTracker.getCacheSubdir() +
Path.SEPARATOR + cacheId;

localPath = lDirAlloc.getLocalPathForWrite(cachePath,
fileStatus.getLen(), conf);
baseDir = localPath.toString().replace(cacheId, &quot;&quot;);
p[i] = DistributedCache.getLocalCache(archives[i], conf,
new Path(baseDir),
fileStatus,
true, Long.parseLong(
archivesTimestamps[i]),
new Path(workDir.
getAbsolutePath()),
false);

}
DistributedCache.setLocalArchives(conf, stringifyPathArray(p));
}
if ((files != null)) {
String[] fileTimestamps = DistributedCache.getFileTimestamps(conf);
Path[] p = new Path[files.length];
for (int i = 0; i &lt; files.length;i++){
fileSystem = FileSystem.get(files[i], conf);
fileStatus = fileSystem.getFileStatus(
new Path(files[i].getPath()));
String cacheId = DistributedCache.makeRelative(files[i], conf);
String cachePath = TaskTracker.getCacheSubdir() +
Path.SEPARATOR + cacheId;

localPath = lDirAlloc.getLocalPathForWrite(cachePath,
fileStatus.getLen(), conf);
baseDir = localPath.toString().replace(cacheId, &quot;&quot;);
p[i] = DistributedCache.getLocalCache(files[i], conf,
new Path(baseDir),
fileStatus,
false, Long.parseLong(
fileTimestamps[i]),
new Path(workDir.
getAbsolutePath()),
false);
}
DistributedCache.setLocalFiles(conf, stringifyPathArray(p));
}
Path localTaskFile = new Path(t.getJobFile());
FileSystem localFs = FileSystem.getLocal(conf);
localFs.delete(localTaskFile, true);
OutputStream out = localFs.create(localTaskFile);
try {
conf.writeXml(out);
} finally {
out.close();
}
}

if (!prepare()) {
return;
}

String sep = System.getProperty(&quot;path.separator&quot;);
StringBuffer classPath = new StringBuffer();
// start with same classpath as parent process
classPath.append(System.getProperty(&quot;java.class.path&quot;));
classPath.append(sep);
if (!workDir.mkdirs()) {
if (!workDir.isDirectory()) {
LOG.fatal(&quot;Mkdirs failed to create &quot; + workDir.toString());
}
}

String jar = conf.getJar();
if (jar != null) {
// if jar exists, it into workDir
File[] libs = new File(jobCacheDir, &quot;lib&quot;).listFiles();
if (libs != null) {
for (int i = 0; i &lt; libs.length; i++) {
classPath.append(sep); // add libs from jar to classpath
classPath.append(libs[i]);
}
}
classPath.append(sep);
classPath.append(new File(jobCacheDir, &quot;classes&quot;));
classPath.append(sep);
classPath.append(jobCacheDir);

}

// include the user specified classpath

//archive paths
Path[] archiveClasspaths = DistributedCache.getArchiveClassPaths(conf);
if (archiveClasspaths != null &amp;&amp; archives != null) {
Path[] localArchives = DistributedCache
.getLocalCacheArchives(conf);
if (localArchives != null){
for (int i=0;i&lt;archives.length;i++){
for(int j=0;j&lt;archiveClasspaths.length;j++){
if (archives[i].getPath().equals(
archiveClasspaths[j].toString())){
classPath.append(sep);
classPath.append(localArchives[i]
.toString());
}
}
}
}
}
//file paths
Path[] fileClasspaths = DistributedCache.getFileClassPaths(conf);
if (fileClasspaths!=null &amp;&amp; files != null) {
Path[] localFiles = DistributedCache
.getLocalCacheFiles(conf);
if (localFiles != null) {
for (int i = 0; i &lt; files.length; i++) {
for (int j = 0; j &lt; fileClasspaths.length; j++) {
if (files[i].getPath().equals(
fileClasspaths[j].toString())) {
classPath.append(sep);
classPath.append(localFiles[i].toString());
}
}
}
}
}

classPath.append(sep);
classPath.append(workDir);
// Build exec child jmv args.
Vector&lt;String&gt; vargs = new Vector&lt;String&gt;(8);
File jvm = // use same jvm as parent
new File(new File(System.getProperty(&quot;java.home&quot;), &quot;bin&quot;), &quot;java&quot;);

vargs.add(jvm.toString());

// Add child (task) java-vm options.
//
// The following symbols if present in mapred.child.java.opts value are
// replaced:
// + @taskid@ is interpolated with value of TaskID.
// Other occurrences of @ will not be altered.
//
// Example with multiple arguments and substitutions, showing
// jvm GC logging, and start of a passwordless JVM JMX agent so can
// connect with jconsole and the likes to watch child memory, threads
// and get thread dumps.
//
// &lt;property&gt;
// &lt;name&gt;mapred.child.java.opts&lt;/name&gt;
// &lt;value&gt;-verbose:gc -Xloggc:/tmp/@taskid@.gc \
// -Dcom.sun.management.jmxremote.authenticate=false \
// -Dcom.sun.management.jmxremote.ssl=false \
// &lt;/value&gt;
// &lt;/property&gt;
//
String javaOpts = conf.get(&quot;mapred.child.java.opts&quot;, &quot;-Xmx200m&quot;);
javaOpts = javaOpts.replace(&quot;@taskid@&quot;, taskid.toString());
String [] javaOptsSplit = javaOpts.split(&quot; &quot;);

// Add java.library.path; necessary for loading native libraries.
//
// 1. To support native-hadoop library i.e. libhadoop.so, we add the
// parent processes&apos; java.library.path to the child.
// 2. We also add the &apos;cwd&apos; of the task to it&apos;s java.library.path to help
// users distribute native libraries via the DistributedCache.
// 3. The user can also specify extra paths to be added to the
// java.library.path via mapred.child.java.opts.
//
String libraryPath = System.getProperty(&quot;java.library.path&quot;);
if (libraryPath == null) {
libraryPath = workDir.getAbsolutePath();
} else {
libraryPath += sep + workDir;
}
boolean hasUserLDPath = false;
for(int i=0; i&lt;javaOptsSplit.length ;i++) {
if(javaOptsSplit[i].startsWith(&quot;-Djava.library.path=&quot;)) {
javaOptsSplit[i] += sep + libraryPath;
hasUserLDPath = true;
break;
}
}
if(!hasUserLDPath) {
vargs.add(&quot;-Djava.library.path=&quot; + libraryPath);
}
for (int i = 0; i &lt; javaOptsSplit.length; i++) {
vargs.add(javaOptsSplit[i]);
}

// add java.io.tmpdir given by mapred.child.tmp
String tmp = conf.get(&quot;mapred.child.tmp&quot;, &quot;./tmp&quot;);
Path tmpDir = new Path(tmp);

// if temp directory path is not absolute
// prepend it with workDir.
if (!tmpDir.isAbsolute()) {
tmpDir = new Path(workDir.toString(), tmp);
}
FileSystem localFs = FileSystem.getLocal(conf);
if (!localFs.mkdirs(tmpDir) &amp;&amp; !localFs.getFileStatus(tmpDir).isDir()) {
throw new IOException(&quot;Mkdirs failed to create &quot; + tmpDir.toString());
}
vargs.add(&quot;-Djava.io.tmpdir=&quot; + tmpDir.toString());

// Add classpath.
vargs.add(&quot;-classpath&quot;);
vargs.add(classPath.toString());

// Setup the log4j prop
long logSize = TaskLog.getTaskLogLength(conf);
vargs.add(&quot;-Dhadoop.log.dir=&quot; +
new File(System.getProperty(&quot;hadoop.log.dir&quot;)
).getAbsolutePath());
vargs.add(&quot;-Dhadoop.root.logger=INFO,TLA&quot;);
vargs.add(&quot;-Dhadoop.tasklog.taskid=&quot; + taskid);
vargs.add(&quot;-Dhadoop.tasklog.totalLogFileSize=&quot; + logSize);

if (conf.getProfileEnabled()) {
if (conf.getProfileTaskRange(t.isMapTask()
).isIncluded(t.getPartition())) {
File prof = TaskLog.getTaskLogFile(taskid, TaskLog.LogName.PROFILE);
vargs.add(String.format(conf.getProfileParams(), prof.toString()));
}
}

// Add main class and its arguments
vargs.add(Child.class.getName()); // main of Child
// pass umbilical address
InetSocketAddress address = tracker.getTaskTrackerReportAddress();
vargs.add(address.getAddress().getHostAddress());
vargs.add(Integer.toString(address.getPort()));
vargs.add(taskid.toString()); // pass task identifier

String pidFile = lDirAlloc.getLocalPathForWrite(
(TaskTracker.getPidFile(t.getJobID().toString(),
taskid.toString(), t.isTaskCleanupTask())),
this.conf).toString();
t.setPidFile(pidFile);
tracker.addToMemoryManager(t.getTaskID(), t.isMapTask(), conf, pidFile);

// set memory limit using ulimit if feasible and necessary ...
String[] ulimitCmd = Shell.getUlimitMemoryCommand(conf);
List&lt;String&gt; setup = null;
if (ulimitCmd != null) {
setup = new ArrayList&lt;String&gt;();
for (String arg : ulimitCmd) {
setup.add(arg);
}
}

// Set up the redirection of the task&apos;s stdout and stderr streams
File stdout = TaskLog.getTaskLogFile(taskid, TaskLog.LogName.STDOUT);
File stderr = TaskLog.getTaskLogFile(taskid, TaskLog.LogName.STDERR);
stdout.getParentFile().mkdirs();
tracker.getTaskTrackerInstrumentation().reportTaskLaunch(taskid, stdout, stderr);

Map&lt;String, String&gt; env = new HashMap&lt;String, String&gt;();
StringBuffer ldLibraryPath = new StringBuffer();
ldLibraryPath.append(workDir.toString());
String oldLdLibraryPath = null;
oldLdLibraryPath = System.getenv(&quot;LD_LIBRARY_PATH&quot;);
if (oldLdLibraryPath != null) {
ldLibraryPath.append(sep);
ldLibraryPath.append(oldLdLibraryPath);
}
env.put(&quot;LD_LIBRARY_PATH&quot;, ldLibraryPath.toString());
jvmManager.launchJvm(this,
jvmManager.constructJvmEnv(setup,vargs,stdout,stderr,logSize,
workDir, env, pidFile, conf));
synchronized (lock) {
while (!done) {
lock.wait();
}
}
tracker.getTaskTrackerInstrumentation().reportTaskEnd(t.getTaskID());
if (exitCodeSet) {
if (!killed &amp;&amp; exitCode != 0) {
if (exitCode == 65) {
tracker.getTaskTrackerInstrumentation().taskFailedPing(t.getTaskID());
}
throw new IOException(&quot;Task process exit with nonzero status of &quot; +
exitCode + &quot;.&quot;);
}
}
} catch (FSError e) {
LOG.fatal(&quot;FSError&quot;, e);
try {
tracker.fsError(t.getTaskID(), e.getMessage());
} catch (IOException ie) {
LOG.fatal(t.getTaskID()+&quot; reporting FSError&quot;, ie);
}
} catch (Throwable throwable) {
LOG.warn(t.getTaskID()+&quot; Child Error&quot;, throwable);
ByteArrayOutputStream baos = new ByteArrayOutputStream();
throwable.printStackTrace(new PrintStream(baos));
try {
tracker.reportDiagnosticInfo(t.getTaskID(), baos.toString());
} catch (IOException e) {
LOG.warn(t.getTaskID()+&quot; Reporting Diagnostics&quot;, e);
}
} finally {
try{
URI[] archives = DistributedCache.getCacheArchives(conf);
URI[] files = DistributedCache.getCacheFiles(conf);
if (archives != null){
for (int i = 0; i &lt; archives.length; i++){
DistributedCache.releaseCache(archives[i], conf);
}
}
if (files != null){
for(int i = 0; i &lt; files.length; i++){
DistributedCache.releaseCache(files[i], conf);
}
}
}catch(IOException ie){
LOG.warn(&quot;Error releasing caches : Cache files might not have been cleaned up&quot;);
}
tip.reportTaskFinished();
}
}
public void launchJvm(TaskRunner t, JvmEnv env) {
if (t.getTask().isMapTask()) {
mapJvmManager.reapJvm(t, env);
} else {
reduceJvmManager.reapJvm(t, env);
}
}
private synchronized void reapJvm(
TaskRunner t, JvmEnv env) {
if (t.getTaskInProgress().wasKilled()) {
//the task was killed in-flight
//no need to do the rest of the operations
return;
}
boolean spawnNewJvm = false;
JobID jobId = t.getTask().getJobID();
//Check whether there is a free slot to start a new JVM.
//,or, Kill a (idle) JVM and launch a new one
//When this method is called, we *must*
// (1) spawn a new JVM (if we are below the max)
// (2) find an idle JVM (that belongs to the same job), or,
// (3) kill an idle JVM (from a different job)
// (the order of return is in the order above)
int numJvmsSpawned = jvmIdToRunner.size();
JvmRunner runnerToKill = null;
if (numJvmsSpawned &gt;= maxJvms) {
//go through the list of JVMs for all jobs.
Iterator&lt;Map.Entry&lt;JVMId, JvmRunner&gt;&gt; jvmIter =
jvmIdToRunner.entrySet().iterator();

while (jvmIter.hasNext()) {
JvmRunner jvmRunner = jvmIter.next().getValue();
JobID jId = jvmRunner.jvmId.getJobId();
//look for a free JVM for this job; if one exists then just break
if (jId.equals(jobId) &amp;&amp; !jvmRunner.isBusy() &amp;&amp; !jvmRunner.ranAll()){
setRunningTaskForJvm(jvmRunner.jvmId, t); //reserve the JVM
LOG.info(&quot;No new JVM spawned for jobId/taskid: &quot; +
jobId+&quot;/&quot;+t.getTask().getTaskID() +
&quot;. Attempting to reuse: &quot; + jvmRunner.jvmId);
return;
}
//Cases when a JVM is killed:
// (1) the JVM under consideration belongs to the same job
// (passed in the argument). In this case, kill only when
// the JVM ran all the tasks it was scheduled to run (in terms
// of count).
// (2) the JVM under consideration belongs to a different job and is
// currently not busy
//But in both the above cases, we see if we can assign the current
//task to an idle JVM (hence we continue the loop even on a match)
if ((jId.equals(jobId) &amp;&amp; jvmRunner.ranAll()) ||
(!jId.equals(jobId) &amp;&amp; !jvmRunner.isBusy())) {
runnerToKill = jvmRunner;
spawnNewJvm = true;
}
}
} else {
spawnNewJvm = true;
}

if (spawnNewJvm) {
if (runnerToKill != null) {
LOG.info(&quot;Killing JVM: &quot; + runnerToKill.jvmId);
runnerToKill.kill();
}
spawnNewJvm(jobId, env, t);
return;
}
//*MUST* never reach this
throw new RuntimeException(&quot;Inconsistent state!!! &quot; +
&quot;JVM Manager reached an unstable state &quot; +
&quot;while reaping a JVM for task: &quot; + t.getTask().getTaskID()+
&quot; &quot; + getDetails());
}
private void spawnNewJvm(JobID jobId, JvmEnv env,
TaskRunner t) {
JvmRunner jvmRunner = new JvmRunner(env,jobId);
jvmIdToRunner.put(jvmRunner.jvmId, jvmRunner);
//spawn the JVM in a new thread. Note that there will be very little
//extra overhead of launching the new thread for a new JVM since
//most of the cost is involved in launching the process. Moreover,
//since we are going to be using the JVM for running many tasks,
//the thread launch cost becomes trivial when amortized over all
//tasks. Doing it this way also keeps code simple.
jvmRunner.setDaemon(true);
jvmRunner.setName(&quot;JVM Runner &quot; + jvmRunner.jvmId + &quot; spawned.&quot;);
setRunningTaskForJvm(jvmRunner.jvmId, t);
LOG.info(jvmRunner.getName());
jvmRunner.start();
}
private class JvmRunner extends Thread {
JvmEnv env;
volatile boolean killed = false;
volatile int numTasksRan;
final int numTasksToRun;
JVMId jvmId;
volatile boolean busy = true;
private ShellCommandExecutor shexec; // shell terminal for running the task
public JvmRunner(JvmEnv env, JobID jobId) {
this.env = env;
this.jvmId = new JVMId(jobId, isMap, rand.nextInt());
this.numTasksToRun = env.conf.getNumTasksToExecutePerJvm();
LOG.info(&quot;In JvmRunner constructed JVM ID: &quot; + jvmId);
}
public void run() {
runChild(env);
}

public void runChild(JvmEnv env) {
try {
env.vargs.add(Integer.toString(jvmId.getId()));
List&lt;String&gt; wrappedCommand =
TaskLog.captureOutAndError(env.setup, env.vargs, env.stdout, env.stderr,
env.logSize, env.pidFile);
shexec = new ShellCommandExecutor(wrappedCommand.toArray(new String[0]),
env.workDir, env.env);
shexec.execute();
} catch (IOException ioe) {
// do nothing
// error and output are appropriately redirected
} finally { // handle the exit code
if (shexec == null) {
return;
}
int exitCode = shexec.getExitCode();
updateOnJvmExit(jvmId, exitCode, killed);
LOG.info(&quot;JVM : &quot; + jvmId +&quot; exited. Number of tasks it ran: &quot; +
numTasksRan);
try {
// In case of jvm-reuse,
//the task jvm cleans up the common workdir for every
//task at the beginning of each task in the task JVM.
//For the last task, we do it here.
if (env.conf.getNumTasksToExecutePerJvm() != 1) {
FileUtil.fullyDelete(env.workDir);
}
} catch (IOException ie){}
}
}
public void execute() throws IOException {
this.run();
}
/** check to see if a command needs to be executed and execute if needed */
protected void run() throws IOException {
if (lastTime + interval &gt; System.currentTimeMillis())
return;
exitCode = 0; // reset for next run
runCommand();
}

/** Run a command */
private void runCommand() throws IOException {
ProcessBuilder builder = new ProcessBuilder(getExecString());
boolean completed = false;

if (environment != null) {
builder.environment().putAll(this.environment);
}
if (dir != null) {
builder.directory(this.dir);
}

process = builder.start();
final BufferedReader errReader =
new BufferedReader(new InputStreamReader(process
.getErrorStream()));
BufferedReader inReader =
new BufferedReader(new InputStreamReader(process
.getInputStream()));
final StringBuffer errMsg = new StringBuffer();

// read error and input streams as this would free up the buffers
// free the error stream buffer
Thread errThread = new Thread() {
@Override
public void run() {
try {
String line = errReader.readLine();
while((line != null) &amp;&amp; !isInterrupted()) {
errMsg.append(line);
errMsg.append(System.getProperty(&quot;line.separator&quot;));
line = errReader.readLine();
}
} catch(IOException ioe) {
LOG.warn(&quot;Error reading the error stream&quot;, ioe);
}
}
};
try {
errThread.start();
} catch (IllegalStateException ise) { }
try {
parseExecResult(inReader); // parse the output
// clear the input stream buffer
String line = inReader.readLine();
while(line != null) {
line = inReader.readLine();
}
// wait for the process to finish and check the exit code
exitCode = process.waitFor();
try {
// make sure that the error thread exits
errThread.join();
} catch (InterruptedException ie) {
LOG.warn(&quot;Interrupted while reading the error stream&quot;, ie);
}
completed = true;
if (exitCode != 0) {
throw new ExitCodeException(exitCode, errMsg.toString());
}
} catch (InterruptedException ie) {
throw new IOException(ie.toString());
} finally {
// close the input stream
try {
inReader.close();
} catch (IOException ioe) {
LOG.warn(&quot;Error while closing the input stream&quot;, ioe);
}
if (!completed) {
errThread.interrupt();
}
try {
errReader.close();
} catch (IOException ioe) {
LOG.warn(&quot;Error while closing the error stream&quot;, ioe);
}
process.destroy();
lastTime = System.currentTimeMillis();
}
}
// Create the splits for the job
LOG.debug(&quot;Creating splits at &quot; + fs.makeQualified(submitSplitFile));
int maps;
if (job.getUseNewMapper()) {
maps = writeNewSplits(context, submitSplitFile);
} else {
maps = writeOldSplits(job, submitSplitFile);
}
job.set(&quot;mapred.job.split.file&quot;, submitSplitFile.toString());
job.setNumMapTasks(maps);
int writeNewSplits(JobContext job, Path submitSplitFile
) throws IOException, InterruptedException,
ClassNotFoundException {
JobConf conf = job.getJobConf();
org.apache.hadoop.mapreduce.InputFormat&lt;?,?&gt; input =
ReflectionUtils.newInstance(job.getInputFormatClass(), job.getJobConf());

List&lt;org.apache.hadoop.mapreduce.InputSplit&gt; splits = input.getSplits(job);
T[] array = (T[])
splits.toArray(new org.apache.hadoop.mapreduce.InputSplit[splits.size()]);

// sort the splits into order based on size, so that the biggest
// go first
Arrays.sort(array, new NewSplitComparator());
DataOutputStream out = writeSplitsFileHeader(conf, submitSplitFile,
array.length);
try {
if (array.length != 0) {
DataOutputBuffer buffer = new DataOutputBuffer();
RawSplit rawSplit = new RawSplit();
SerializationFactory factory = new SerializationFactory(conf);
Serializer&lt;T&gt; serializer =
factory.getSerializer((Class&lt;T&gt;) array[0].getClass());
serializer.open(buffer);
for(T split: array) {
rawSplit.setClassName(split.getClass().getName());
buffer.reset();
serializer.serialize(split);
rawSplit.setDataLength(split.getLength());
rawSplit.setBytes(buffer.getData(), 0, buffer.getLength());
rawSplit.setLocations(split.getLocations());
rawSplit.write(out);
}
serializer.close();
}
} finally {
out.close();
}
return array.length;
}
org.apache.hadoop.mapreduce.InputFormat&lt;?,?&gt; input =
ReflectionUtils.newInstance(job.getInputFormatClass(), job.getJobConf());

List&lt;org.apache.hadoop.mapreduce.InputSplit&gt; splits = input.getSplits(job);
public InputSplit[] getSplits(JobConf job, int numSplits)
throws IOException {
FileStatus[] files = listStatus(job);

long totalSize = 0; // compute total size
for (FileStatus file: files) { // check we have valid files
if (file.isDir()) {
throw new IOException(&quot;Not a file: &quot;+ file.getPath());
}
totalSize += file.getLen();
}

long goalSize = totalSize / (numSplits == 0 ? 1 : numSplits);
long minSize = Math.max(job.getLong(&quot;mapred.min.split.size&quot;, 1),
minSplitSize);

// generate splits
ArrayList&lt;FileSplit&gt; splits = new ArrayList&lt;FileSplit&gt;(numSplits);
NetworkTopology clusterMap = new NetworkTopology();
for (FileStatus file: files) {
Path path = file.getPath();
FileSystem fs = path.getFileSystem(job);
long length = file.getLen();
BlockLocation[] blkLocations = fs.getFileBlockLocations(file, 0, length);
if ((length != 0) &amp;&amp; isSplitable(fs, path)) {
long blockSize = file.getBlockSize();
long splitSize = computeSplitSize(goalSize, minSize, blockSize);

long bytesRemaining = length;
while (((double) bytesRemaining)/splitSize &gt; SPLIT_SLOP) {
String[] splitHosts = getSplitHosts(blkLocations,
length-bytesRemaining, splitSize, clusterMap);
splits.add(new FileSplit(path, length-bytesRemaining, splitSize,
splitHosts));
bytesRemaining -= splitSize;
}

if (bytesRemaining != 0) {
splits.add(new FileSplit(path, length-bytesRemaining, bytesRemaining,
blkLocations[blkLocations.length-1].getHosts()));
}
} else if (length != 0) {
String[] splitHosts = getSplitHosts(blkLocations,0,length,clusterMap);
splits.add(new FileSplit(path, 0, length, splitHosts));
} else {
//Create empty hosts array for zero length files
splits.add(new FileSplit(path, 0, length, new String[0]));
}
}
LOG.debug(&quot;Total # of splits: &quot; + splits.size());
return splits.toArray(new FileSplit[splits.size()]);
}
rawSplit.setBytes(buffer.getData(), 0, buffer.getLength());
public void setBytes(byte[] data, int offset, int length) {
bytes.set(data, offset, length);
}
public void set(byte[] newData, int offset, int length) {
setSize(0);
setSize(length);
System.arraycopy(newData, offset, bytes, 0, size);
}
//
// read input splits and create a map per a split
//
String jobFile = profile.getJobFile();

Path sysDir = new Path(this.jobtracker.getSystemDir());
FileSystem fs = sysDir.getFileSystem(conf);
DataInputStream splitFile =
fs.open(new Path(conf.get(&quot;mapred.job.split.file&quot;)));
JobClient.RawSplit[] splits;
try {
splits = JobClient.readSplitFile(splitFile);
} finally {
splitFile.close();
}
numMapTasks = splits.length;
static RawSplit[] readSplitFile(DataInput in) throws IOException {
byte[] header = new byte[SPLIT_FILE_HEADER.length];
in.readFully(header);
if (!Arrays.equals(SPLIT_FILE_HEADER, header)) {
throw new IOException(&quot;Invalid header on split file&quot;);
}
int vers = WritableUtils.readVInt(in);
if (vers != CURRENT_SPLIT_FILE_VERSION) {
throw new IOException(&quot;Unsupported split version &quot; + vers);
}
int len = WritableUtils.readVInt(in);
RawSplit[] result = new RawSplit[len];
for(int i=0; i &lt; len; ++i) {
result[i] = new RawSplit();
result[i].readFields(in);
}
return result;
}
maps = new TaskInProgress[numMapTasks];
for(int i=0; i &lt; numMapTasks; ++i) {
inputLength += splits[i].getDataLength();
maps[i] = new TaskInProgress(jobId, jobFile,
splits[i],
jobtracker, conf, this, i);
}
</code>
</RECORD>
<RECORD>
<snippet_key>155397</snippet_key>
<tag>url io流 stringbuilder http协议 HttpURLConnection</tag>
<comment>来自CSDN博客：HttpURLConnection 断点下载  http://blog.csdn.net/Leewuyang_520/article/details/18239561#</comment>
<code>File file = new File(path);
long length = file.length();
/**
* 断点下载
* @throws InterruptedException
*/
@Test public void testDebugDownload() throws IOException, InterruptedException{
//创建URL对象
URL url = new URL(&quot;http://localhost:8080/****/resource/kiss.avi&quot;);
//使用url获取HttpURLConnection对象
HttpURLConnection conn = (HttpURLConnection)url.openConnection();
//客户端的请求方式
conn.setRequestMethod(&quot;GET&quot;);
//已经下载的字节数
long alreadySize = 0;
//将文件写到d:\kiss.avi中
File file = new File(&quot;d:\\kiss.avi&quot;);
//如果存在，说明原来下载过，不过可能没有下载完
if(file.exists()){
//如果文件存在，就获取当前文件的大小
alreadySize = file.length();
}
/**
* Range头域可以请求实体的一个或者多个子范围。
* 例如: 表示头500个字节：bytes=0-499 
* 表示第二个500字节：bytes=500-999 
* 表示最后500个字节：bytes=-500 
* 表示500字节以后的范围：bytes=500- 
* 第一个和最后一个字节：bytes=0-0,-1 
* 同时指定几个范围：bytes=500-600,601-999 
* 但是服务器可以忽略此请求头，如果无条件GET包含Range请求头，响应会以状态码206（PartialContent）返回而不是以200 （OK）。
*/
conn.addRequestProperty(&quot;range&quot;, &quot;bytes=&quot; + alreadySize + &quot;-&quot;);
conn.connect();

//206,一般表示断点续传
//获取服务器回馈的状态码
int code = conn.getResponseCode();
// 如果响应成功，因为使用了range请求头，那么响应成功的状态码为206，而不是200
if(code == 206){
//获取未下载的文件的大小
// 本方法用来获取响应正文的大小，但因为设置了range请求头，那么这个方法返回的就是剩余的大小
long unfinishedSize = conn.getContentLength();
//文件的大小
long size = alreadySize + unfinishedSize;

//获取输入流
InputStream in = conn.getInputStream();
//获取输出对象,参数一：目标文件，参数2表示在原来的文件中追加
OutputStream out = new BufferedOutputStream(new FileOutputStream(file,true));

//开始下载
byte[] buff = new byte[2048];
int len;
StringBuilder sb = new StringBuilder();
while((len = in.read(buff)) != -1){
out.write(buff, 0, len);
//将下载的累加到alreadSize中
alreadySize += len;
//下载进度
System.out.printf(&quot;%.2f%%\n&quot;, alreadySize * 1.0 / size * 100);
//由于文件大小可以看得到，那么我们这里使用阻塞
Thread.sleep(2);
}
out.close();
System.out.println(&quot;下载完成！！！&quot;);
}else{
System.out.println(&quot;下载失败！！！&quot;);
}

//断开连接
conn.disconnect();
}
</code>
</RECORD>
<RECORD>
<snippet_key>417541</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：打印出大小为n的数组（可能有重复元素）里所有可能的组合 http://blog.csdn.net/hellobinfeng/article/details/37030615#</comment>
<code>package recursion;

import java.util.ArrayList;
import java.util.Collections;

public class Print_all_possible_combinations_of_r_elements_in_a_given_array_of_size_n {

/*
Input:
{1, 2, 3, 4}, r=2
Output:
{1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4} and {3, 4}.

*/
public static void main(String[] args) {
int[] s1 = {1, 2, 3, 4};
ArrayList&lt;Integer&gt; set1 = new ArrayList&lt;Integer&gt;();
for (int i : s1) {
set1.add(i);
}
int r1 = 2;
ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret1 = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
rec2(set1, r1, 0, ret1, new ArrayList&lt;Integer&gt;());
System.out.println(ret1);

int[] s2 = {1, 2, 1, 3, 2};
ArrayList&lt;Integer&gt; set2 = new ArrayList&lt;Integer&gt;();
for (int i : s2) {
set2.add(i);
}
int r2 = 2;
ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret2 = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();

Collections.sort(set2);
rec(set2, r2, 0, ret2, new ArrayList&lt;Integer&gt;());
System.out.println(ret2);
}

// 解法一：分析：观察output可得，先循环选定添加到al的第一个元素，然后缩小子区间，递归处理子问题
// first是当前处理子区间的第一个元素
public static void rec(ArrayList&lt;Integer&gt; set, int r, int first, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret, ArrayList&lt;Integer&gt; al) {
if(al.size() == r) { // 退出条件：当al里的数量达到r时即可退出
ret.add(new ArrayList&lt;Integer&gt;(al));
return;
}

for(int i=first; i&lt;set.size(); i++) { // 从子区间的第一个元素到最后一个元素都有机会被添加到al中
if(i+1&lt;set.size() &amp;&amp; set.get(i+1) == set.get(i)) { // 跳过重复元素，但要检查是否越界
continue;
}
al.add(set.get(i)); // 注意在for循环内，用到的参数是i而不是first
rec(set, r, i+1, ret, al); // 缩短子区间1个距离
al.remove(al.size()-1);
}
}

// 解法二：选择或者不选择某个元素
public static void rec2(ArrayList&lt;Integer&gt; set, int r, int first, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret, ArrayList&lt;Integer&gt; al) {
if(r == al.size()) { // 退出条件：当al里的数量达到r时即可退出
ret.add(new ArrayList&lt;Integer&gt;(al));
return;
}

if(first &gt;= set.size()) { // 当first遍历超过set容量时也要返回
return;
}

rec2(set, r, first+1, ret, al); // 不选择当前元素

al.add(set.get(first)); // 选择当前元素
rec2(set, r, first+1, ret, al);
al.remove(al.size()-1);
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>286725</snippet_key>
<tag>457</tag>
<comment>hashmap 来自CSDN博客：统计一个字母串每个字母出现的个数 http://blog.csdn.net/ssjjy/article/details/23446737#</comment>
<code>public class StringTest {

public void getFrequency(String str) {
Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();

for(int i = 0,j=1;i&lt;str.length();i++,j++){
if(map.get(str.substring(i,j))==null){
map.put(str.substring(i,j), 1);
}else{
Integer value = map.get(str.substring(i,j));
value = value + 1;
map.put(str.substring(i,j), value);
}
}
System.out.print(map);

}

public static void main(String args[]) {
String s = &quot;abcacffrgbxb&quot;;

StringTest st = new StringTest();
st.getFrequency(s);
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>286981</snippet_key>
<tag>457</tag>
<comment>来自CSDN博客：【JAVA】 hashcode相关  http://blog.csdn.net/gadbee5/article/details/23456589#</comment>
<code>public int hashCode() {
int h = hash;
if (h == 0) {
int off = offset;
char val[] = value;
int len = count;

for (int i = 0; i &lt; len; i++) {
h = 31*h + val[off++];
}
hash = h;
}
return h;
}
public static void main(String args[]){
String s1=new String(&quot;zhaoxudong&quot;);
String s2=new String(&quot;zhaoxudong&quot;);
System.out.println(s1==s2);//false
System.out.println(s1.equals(s2));//true
System.out.println(s1.hashCode());//s1.hashcode()ç­äşs2.hashcode()
System.out.println(s2.hashCode());
Set hashset=new HashSet();
hashset.add(s1);
hashset.add(s2);

Iterator it=hashset.iterator();
while(it.hasNext())
{
System.out.println(it.next());
}
import java.util.*;
public class HashSetTest
{
public static void main(String[] args)
{
HashSet hs=new HashSet();
hs.add(new Student(1,&quot;zhangsan&quot;));
hs.add(new Student(2,&quot;lisi&quot;));
hs.add(new Student(3,&quot;wangwu&quot;));
hs.add(new Student(1,&quot;zhangsan&quot;));

Iterator it=hs.iterator();
while(it.hasNext())
{
System.out.println(it.next());
}
}
}
class Student
{
int num;
String name;
Student(int num,String name)
{
this.num=num;
this.name=name;
}
public String toString()
{
return num+&quot;:&quot;+name;
}
}
class Student
{
int num;
String name;
Student(int num,String name)
{
this.num=num;
this.name=name;
}
public int hashCode()
{
return num*name.hashCode();
}
public boolean equals(Object o)
{
Student s=(Student)o;
return num==s.num &amp;&amp; name.equals(s.name);
}
public String toString()
{
return num+&quot;:&quot;+name;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>156165</snippet_key>
<tag>android studio assets</tag>
<comment>来自CSDN博客：Android Studio下添加assets目录  http://blog.csdn.net/Caesardadi/article/details/14231293#</comment>
<code>XXX\src\main\assets
&lt;option name=&quot;ASSETS_FOLDER_RELATIVE_PATH&quot; value=&quot;/src/main/assets&quot; /&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>140558</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Two Sum http://blog.csdn.net/lijunusa/article/details/17790553#</comment>
<code>public class Solution {
public int[] twoSum(int[] numbers, int target) {
// Start typing your Java solution below
// DO NOT write main() function
int[] result = new int[2];
HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();

for(int i = 0; i &lt; numbers.length; i++) {
int tmp = numbers[i];
if (map.containsKey(tmp)){
result[0] = map.get(tmp) + 1;
result[1] = i + 1;

return result;
}
else{
map.put(target - tmp, i);
}
}

return result;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>206094</snippet_key>
<tag>471</tag>
<comment>来自CSDN博客：快速排序、归并排序  http://blog.csdn.net/ruishenh/article/details/19982561#</comment>
<code>package com.ruishenh.algoritmic;


public class Sort {

public static void main(String[] args) {
// 冒泡排序
int[] arrs=getRandomArrs(20000);
// printMsg(arrs);
long start = System.currentTimeMillis();
bubblingSort(arrs);
long end = System.currentTimeMillis();
// printMsg(arrs);
System.out.println(&quot;冒泡结果：&quot;+(end - start));
System.out.println(&quot;----------------------&quot;);

// 归并排序
arrs = getRandomArrs(5000000);
start = System.currentTimeMillis();
mergerSort(arrs);
end = System.currentTimeMillis();
System.out.println(&quot;归并结果：&quot;+(end - start));
System.out.println(&quot;----------------------&quot;);


// 快排排序
arrs = getRandomArrs(5000000);
start = System.currentTimeMillis();
quickSort(arrs,0,arrs.length-1);
end = System.currentTimeMillis();
System.out.println(&quot;快排结果：&quot;+(end - start));
System.out.println(&quot;----------------------&quot;);


}
static void printMsg(int [] arrs){
for (int i : arrs) {
System.out.print(i);
System.out.print(&quot;,&quot;);
}
System.out.println();

}
static int [] getRandomArrs(int num){
int [] ret=new int[num];
for (int i = 0; i &lt; num; i++) {
ret[i]=(int) Math.floor(Math.random()*num);
}
return ret;

};
/**
* 冒泡排序
* @param arrs
*/
static void bubblingSort(int [] arrs){
for (int i = 0; i &lt; arrs.length; i++) {
for (int j = 0; j &lt; arrs.length-1-i; j++) {
if (arrs[j]&gt;arrs[j+1]) {
int tmp=arrs[j];
arrs[j]=arrs[j+1];
arrs[j+1]=tmp;
}
}
}
}
/**
* 归并排序
* @param arrs
*/
static void mergerSort(int [] arrs){
mergerSort_split(arrs, 0, arrs.length-1, new int[arrs.length]);
}
static void mergerSort_merge(int [] a,int first,int mid,int last, int [] temp){
{
int i = first, j = mid + 1;
int m = mid, n = last;
int k = 0;

while (i &lt;= m &amp;&amp; j &lt;= n)
{
if (a[i] &lt;= a[j])
temp[k++] = a[i++];
else
temp[k++] = a[j++];
}

while (i &lt;= m)
temp[k++] = a[i++];

while (j &lt;= n)
temp[k++] = a[j++];

for (i = 0; i &lt; k; i++)
a[first + i] = temp[i];
}
}
static void mergerSort_split(int [] arrs,int first,int last, int [] temp){
if (first &lt; last)
{
int mid = (first + last) / 2;
//递归循环调用执行对半合并
mergerSort_split(arrs, first, mid, temp); //左边有序
mergerSort_split(arrs, mid + 1, last, temp); //右边有序
mergerSort_merge(arrs, first, mid, last, temp); //再将二个有序数列合并
}
}


/**
* 快速排序
* @param list
* @param low
* @param high
* @return
*/
private static int[] quickSort(int [] list,int low ,int high){
if(low&lt;high){
int middle=getMiddle(list, low, high); //将list数组进行一分为二
quickSort(list, low, middle-1); //对比key小的进行递归排序
quickSort(list, middle+1, high); //对比key大的进行递归排序
}
return list;
}
private static int getMiddle(int [] list,int low,int high){
int tmp=list[low]; //数组第一个作为key
while(low&lt;high){
while(low&lt;high&amp;&amp;list[high]&gt;=tmp){
high--;
}
list[low]=list[high]; //比key小的纪录移到低端
while(low&lt;high&amp;&amp;list[low]&lt;=tmp){
low++;
}
list[high]=list[low]; //比key大的纪录移到高端
}
list[low]=tmp; //key纪录到末尾
return low; //返回key的位置
}


}
冒泡结果：679
----------------------
归并结果：840
----------------------
快排结果：504
----------------------
</code>
</RECORD>
<RECORD>
<snippet_key>140814</snippet_key>
<tag></tag>
<comment>来自CSDN博客：子类中方法与父类中形成重写关系，可以在构造方法中用super来调用父类中的该方法 http://blog.csdn.net/u012575573/article/details/17794585#</comment>
<code>public class ReloadTest extends Reload
{
void write (int x)
{
this.age=x/2;
}
public ReloadTest()
{
super.write(10);
}
public static void main(String args[])
{
ReloadTest rew=new ReloadTest();
rew.write(10);
System.out.println(rew.age);
}
}
class Reload
{
String name;
int age;
void write(int x)
{
this.age=x%2+1;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>287493</snippet_key>
<tag></tag>
<comment>来自CSDN博客：使用jersey客户端访问rest接口 http://blog.csdn.net/z69183787/article/details/9189235#</comment>
<code>public static void main(String[] args) {
// TODO Auto-generated method stub
Client c = Client.create();
WebResource r=c.resource(&quot;http://10.1.41.252:8080/workflowController/service/todo/stat&quot;);
MultivaluedMap formData = new MultivaluedMapImpl();
formData.add(&quot;data&quot;, &quot;ST/G001000001612549&quot;);
String response = r.type(&quot;application/x-www-form-urlencoded&quot;)
.post(String.class, formData);
System.out.println(response.toString());

}
</code>
</RECORD>
<RECORD>
<snippet_key>271886</snippet_key>
<tag>457</tag>
<comment>iterator hashmap 地区选择 来自CSDN博客：地区选择组件  http://blog.csdn.net/pkxutao/article/details/22854257#</comment>
<code>public List&lt;String&gt; getCityList(String province) {

return cityMap.get(province);
}
public String getCode(String city){
return codeMap.get(city);
}
public String getCity(String code){
getProvinceList() ;
String city = (String)keyString(codeMap, code);
return city;
}
public String getProvince(String city){
Iterator&lt;String&gt; it= cityMap.keySet().iterator();
while(it.hasNext()){
String province = it.next();
List&lt;String&gt; cityList = cityMap.get(province);
for (int i = 0; i &lt; cityList.size(); i++) {
if (cityList.get(i).equals(city)) {
return province;
}
}
}
return null;
}
public List&lt;String&gt; getProvinceList() {
List&lt;String&gt; provinceList = new ArrayList&lt;String&gt;();// 省份

String json = getData().toString();
try {
JSONArray data = new JSONArray(json);
for (int i = 0; i &lt; data.length(); i++) {
JSONObject provinceObj = data.getJSONObject(i);
String province = provinceObj.getString(&quot;name&quot;);//获取省份
provinceList.add(province);//存入省份list里面
JSONArray citys = provinceObj.getJSONArray(&quot;citys&quot;);
List&lt;String&gt; cityList = new ArrayList&lt;String&gt;();// 相应的城市列表
for (int j = 0; j &lt; citys.length(); j++) {
JSONObject cityObj = citys.getJSONObject(j);
Iterator&lt;String&gt; keys = cityObj.keys();
while(keys.hasNext()){//遍历城市列表
String key = keys.next();
String city = cityObj.getString(key);
cityList.add(city);//存入城市list
codeMap.put(city, key);//存入一个城市为key，code为value的hashmap，这样可以通过城市获取code或者通过code获取城市
}
if (j == citys.length()-1) {
cityMap.put(province, cityList);//如果这个省的城市列表解析完成，就放入到一个省份为key，城市列表为value的hashmap中
}
}
}
} catch (JSONException e) {
e.printStackTrace();
}
return provinceList;
}
</code>
</RECORD>
<RECORD>
<snippet_key>287749</snippet_key>
<tag></tag>
<comment>来自CSDN博客：【程序1】 TestRabbit.java 题目：古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子， //假如兔子都不死，问每个月的兔子总数为多少？ http://blog.csdn.net/u014657292/article/details/23509863#</comment>
<code>//【程序1】 TestRabbit.java 题目：古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，
//假如兔子都不死，问每个月的兔子总数为多少？ 1.程序分析： 兔子的规律为数列1,1,2,3,5,8,13,21....(又称斐波那契数列或黄金分割数列)
//问题你要保证每次生的兔子都是一个雌一个雄，而且只能使他们一块出生的才能交配。
//间隔不同的月份兔子规律也不一样，如从第2个月起每个月都生一对兔子，则规律为：1,2,4,8,....;
//如从第4个月起每个月都生一对兔子，则规律为1,1,1,2,3,4,6,9,13..........;
public class TestRabbitApp {

/**
* @param args
*/
public static void main(String[] args) {
// TODO Auto-generated method stub

TestRabbit tr=new TestRabbit();
tr.printCount2(20);//递归方法
//tr.printCount(20);//赋值方法
}

}
class TestRabbit{
int a1,a2;
TestRabbit(){
a1=1;a2=1;
}
public void printCount(int month){
int i=1,sum=0;int t;
for(;i&lt;=month;i++){
if(i==1||i==2)
sum=1;
else sum=a1+a2;
System.out.println(&quot;第&quot;+i+&quot;个月时兔子总数为： &quot;+sum+&quot;对&quot;);
if(i&gt;2){
t=a2;
a2=a1+a2;
a1=t;
}
}
}
public int fun(int month){
if(month==1||month==2)
return 1;
else
return fun(month-1)+fun(month-2);
}
public void printCount2(int month){
for(int i=1;i&lt;=month;i++){
System.out.println(&quot;第&quot;+month+&quot;月时，兔子总数为： &quot;+fun(i)+&quot;对&quot;);
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>418821</snippet_key>
<tag>327</tag>
<comment>来自CSDN博客：(集合)JAVA文件操作--复制、粘贴、删除、剪切 http://blog.csdn.net/u013571487/article/details/37329715#</comment>
<code>package com.file;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/*
* Java实现文件复制、剪切、删除操作
* 文件指文件或文件夹
* 文件分割符统一用&quot;//&quot;
*/

public class FileOperateDemo {

/**
* 复制文件或文件夹
*
* @param srcPath
* @param destDir
* 目标文件所在的目录
* @return
*/
public static boolean copyGeneralFile(String srcPath, String destDir) {
boolean flag = false;
File file = new File(srcPath);
if (!file.exists()) {
System.out.println(&quot;源文件或源文件夹不存在!&quot;);
return false;
}
if (file.isFile()) { // 源文件
System.out.println(&quot;下面进行文件复制!&quot;);
flag = copyFile(srcPath, destDir);
} else if (file.isDirectory()) {
System.out.println(&quot;下面进行文件夹复制!&quot;);
flag = copyDirectory(srcPath, destDir);
}

return flag;
}

/**
* 复制文件
*
* @param srcPath
* 源文件绝对路径
* @param destDir
* 目标文件所在目录
* @return boolean
*/
private static boolean copyFile(String srcPath, String destDir) {
boolean flag = false;

File srcFile = new File(srcPath);
if (!srcFile.exists()) { // 源文件不存在
System.out.println(&quot;源文件不存在&quot;);
return false;
}
// 获取待复制文件的文件名
String fileName = srcPath
.substring(srcPath.lastIndexOf(File.separator));
String destPath = destDir + fileName;
if (destPath.equals(srcPath)) { // 源文件路径和目标文件路径重复
System.out.println(&quot;源文件路径和目标文件路径重复!&quot;);
return false;
}
File destFile = new File(destPath);
if (destFile.exists() &amp;&amp; destFile.isFile()) { // 该路径下已经有一个同名文件
System.out.println(&quot;目标目录下已有同名文件!&quot;);
return false;
}

File destFileDir = new File(destDir);
destFileDir.mkdirs();
try {
FileInputStream fis = new FileInputStream(srcPath);
FileOutputStream fos = new FileOutputStream(destFile);
byte[] buf = new byte[1024];
int c;
while ((c = fis.read(buf)) != -1) {
fos.write(buf, 0, c);
}
fis.close();
fos.close();

flag = true;
} catch (IOException e) {
//
}

if (flag) {
System.out.println(&quot;复制文件成功!&quot;);
}

return flag;
}

/**
*
* @param srcPath
* 源文件夹路径
* @param destPath
* 目标文件夹所在目录
* @return
*/
private static boolean copyDirectory(String srcPath, String destDir) {
System.out.println(&quot;复制文件夹开始!&quot;);
boolean flag = false;

File srcFile = new File(srcPath);
if (!srcFile.exists()) { // 源文件夹不存在
System.out.println(&quot;源文件夹不存在&quot;);
return false;
}
// 获得待复制的文件夹的名字，比如待复制的文件夹为&quot;E://dir&quot;则获取的名字为&quot;dir&quot;
String dirName = getDirName(srcPath);
// 目标文件夹的完整路径
String destPath = destDir + File.separator + dirName;
// System.out.println(&quot;目标文件夹的完整路径为：&quot; + destPath);

if (destPath.equals(srcPath)) {
System.out.println(&quot;目标文件夹与源文件夹重复&quot;);
return false;
}
File destDirFile = new File(destPath);
if (destDirFile.exists()) { // 目标位置有一个同名文件夹
System.out.println(&quot;目标位置已有同名文件夹!&quot;);
return false;
}
destDirFile.mkdirs(); // 生成目录

File[] fileList = srcFile.listFiles(); // 获取源文件夹下的子文件和子文件夹
if (fileList.length == 0) { // 如果源文件夹为空目录则直接设置flag为true，这一步非常隐蔽，debug了很久
flag = true;
} else {
for (File temp : fileList) {
if (temp.isFile()) { // 文件
flag = copyFile(temp.getAbsolutePath(), destPath);
} else if (temp.isDirectory()) { // 文件夹
flag = copyDirectory(temp.getAbsolutePath(), destPath);
}
if (!flag) {
break;
}
}
}

if (flag) {
System.out.println(&quot;复制文件夹成功!&quot;);
}

return flag;
}

/**
* 获取待复制文件夹的文件夹名
*
* @param dir
* @return String
*/
private static String getDirName(String dir) {
if (dir.endsWith(File.separator)) { // 如果文件夹路径以&quot;//&quot;结尾，则先去除末尾的&quot;//&quot;
dir = dir.substring(0, dir.lastIndexOf(File.separator));
}
return dir.substring(dir.lastIndexOf(File.separator) + 1);
}

/**
* 删除文件或文件夹
*
* @param path
* 待删除的文件的绝对路径
* @return boolean
*/
public static boolean deleteGeneralFile(String path) {
boolean flag = false;

File file = new File(path);
if (!file.exists()) { // 文件不存在
System.out.println(&quot;要删除的文件不存在！&quot;);
}

if (file.isDirectory()) { // 如果是目录，则单独处理
flag = deleteDirectory(file.getAbsolutePath());
} else if (file.isFile()) {
flag = deleteFile(file);
}

if (flag) {
System.out.println(&quot;删除文件或文件夹成功!&quot;);
}

return flag;
}

/**
* 删除文件
*
* @param file
* @return boolean
*/
private static boolean deleteFile(File file) {
return file.delete();
}

/**
* 删除目录及其下面的所有子文件和子文件夹，注意一个目录下如果还有其他文件或文件夹
* 则直接调用delete方法是不行的，必须待其子文件和子文件夹完全删除了才能够调用delete
*
* @param path
* path为该目录的路径
*/
private static boolean deleteDirectory(String path) {
boolean flag = true;
File dirFile = new File(path);
if (!dirFile.isDirectory()) {
return flag;
}
File[] files = dirFile.listFiles();
for (File file : files) { // 删除该文件夹下的文件和文件夹
// Delete file.
if (file.isFile()) {
flag = deleteFile(file);
} else if (file.isDirectory()) {// Delete folder
flag = deleteDirectory(file.getAbsolutePath());
}
if (!flag) { // 只要有一个失败就立刻不再继续
break;
}
}
flag = dirFile.delete(); // 删除空目录
return flag;
}

/**
* 由上面方法延伸出剪切方法：复制+删除
*
* @param destDir
* 同上
*/
public static boolean cutGeneralFile(String srcPath, String destDir) {
if (!copyGeneralFile(srcPath, destDir)) {
System.out.println(&quot;复制失败导致剪切失败!&quot;);
return false;
}
if (!deleteGeneralFile(srcPath)) {
System.out.println(&quot;删除源文件(文件夹)失败导致剪切失败!&quot;);
return false;
}

System.out.println(&quot;剪切成功!&quot;);
return true;
}

public static void main(String[] args) {
copyGeneralFile(&quot;E://Assemble.txt&quot;, &quot;E://New.txt&quot;); // 复制文件
copyGeneralFile(&quot;E://hello&quot;, &quot;E://world&quot;); // 复制文件夹
deleteGeneralFile(&quot;E://onlinestockdb.sql&quot;); // 删除文件
deleteGeneralFile(&quot;E://woman&quot;); // 删除文件夹
cutGeneralFile(&quot;E://hello&quot;, &quot;E://world&quot;); // 剪切文件夹
cutGeneralFile(&quot;E://Difficult.java&quot;, &quot;E://Cow//&quot;); // 剪切文件
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>206606</snippet_key>
<tag>477</tag>
<comment>来自CSDN博客：算法导论之堆排序  http://blog.csdn.net/fkyyly/article/details/19994801#</comment>
<code>//每次直接改变了数组elements
//其实堆就是用数组表示的
//从零开始是左孩子是i* 2 + 1，右孩子是i* 2 + 2
public class HeapSort {

public static void heapSortfunction( int [] elements){
for ( int i = elements.length- 1 ; i &gt; 0 ; i--){
buildHeap(elements,i); //建堆,建完之后是最大堆，也就是根节点是最大的
swap(elements, 0 ,i); //交换根节点和最后一个节点，就是每次把当前最大的放在最后了
}
}


private static void buildHeap( int [] elements, int lastIndex){//就是把elements【lastindex】变成最大堆
int lastParentIndex = (lastIndex- 1 )/ 2 ; //获得最后一个父节点，以便后面建堆
for ( int i = lastParentIndex; i &gt;= 0 ; i--){
int parent = elements[i];
int leftChild = elements[i* 2 + 1 ]; //左节点肯定存在
int rightChild = leftChild;
if (i* 2 + 2 &lt;=lastIndex){//如果最后一个有右节点，就把对应的右节点赋给它
//从零开始是左海子是i* 2 + 1，右孩子是i* 2 + 2
rightChild = elements[i* 2 + 2 ]; //右节点不一定存在

}
int maxIndex = leftChild&lt;rightChild?i* 2 + 2 :i* 2 + 1 ;//把leftchild和rightchild中大的index给maxindex
//从零开始是左海子是i* 2 + 1，右孩子是i* 2 + 2
if (parent &lt; elements[maxIndex]){//如果parent小于左右孩子中的大的一个，就交换
swap(elements,i,maxIndex);
}

}
}


private static void swap( int [] elements, int firstIndex, int secondIndex){
int temp = elements[firstIndex];
elements[firstIndex] = elements[secondIndex];
elements[secondIndex] = temp;
}



public static void main(String[] args ){
int a[]={2,3,1,5,8,9,3};
heapSortfunction(a);
for(int i=0;i&lt;a.length;i++){
System.out.print(a[i]+&quot; &quot;);
}

}

}
</code>
</RECORD>
<RECORD>
<snippet_key>419077</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：ArrayAdapter Spinner http://blog.csdn.net/u010916821/article/details/25774183# 实现下拉列表派生自深蓝-running/blog_20140514_1_7843385</comment>
<code>import android.os.Bundle;
import android.app.Activity;
import android.widget.ArrayAdapter;
import android.widget.Spinner;

public class SpinnerActivity extends Activity {
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_spinner);

String friends[]={&quot;小艳&quot;,&quot;石头&quot;,&quot;小高&quot;,&quot;小弟&quot;,&quot;邓攀&quot;,&quot;晓雪&quot;};
Spinner spinner=(Spinner) findViewById(R.id.spinner);
ArrayAdapter&lt;String&gt; adapter=new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_1,friends);
//第一个参数表示在哪个Activity上显示，第二个参数是系统下拉框的样式，第三个参数是数组。
spinner.setAdapter(adapter);
}
}
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;
android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;
tools:context=&quot;.SpinnerActivity&quot;
android:orientation=&quot;vertical&quot;&gt;

&lt;TextView
android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot;
android:text=&quot;spinner练习&quot; android:gravity=&quot;center_horizontal&quot;/&gt;

&lt;!-- android:spinnerMode=&quot;dropdown&quot; 下拉
android:spinnerMode=&quot;dialog&quot; 弹框
--&gt;
&lt;Spinner android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;match_parent&quot;
android:id=&quot;@+id/spinner&quot;
android:spinnerMode=&quot;dialog&quot; android:prompt=&quot;@string/My_friends&quot;/&gt;
&lt;/LinearLayout&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>91653</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Java概述  http://blog.csdn.net/Ws11352369/article/details/17066251#</comment>
<code>/**
思路：使用System.out.println();依次输出相应数量符号
*/
public class Triangle
{
public static void main(String[] args)
{
System.out.println(&quot; #&quot;);
System.out.println(&quot; ###&quot;);
System.out.println(&quot; #####&quot;);
System.out.println(&quot; #######&quot;);
System.out.println(&quot;#########&quot;);
}
}
/**
思路：使用System.out.println();输出相应数字相加，相减，相乘，相除的结果
*/
public class Triangle
{
public static void main(String[] args)
{
int a = 20 ;
int b = 4 ;
System.out.println(&quot;a + b = &quot; + (a + b));
System.out.println(&quot;a - b = &quot; + (a - b));
System.out.println(&quot;a * b = &quot; + (a * b));
System.out.println(&quot;a / b = &quot; + (a / b)); }
}
</code>
</RECORD>
<RECORD>
<snippet_key>222725</snippet_key>
<tag></tag>
<comment>来自CSDN博客：javaweb之response refresh响应头控制浏览器刷新（几秒后跳转页面）  http://blog.csdn.net/wuer0520/article/details/20702709#</comment>
<code>package test.response;

import java.io.IOException;
import java.util.Random;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

//控制浏览器定时刷新，这个经常用，比如股票软件
public class ResponseDemo4 extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {
test3(request, response);
}

// 实际开发中实用的，就是用&lt;meta&gt;标签模拟http响应头
private void test3(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {
// 假设是一个处理用户登录的servlet，假设用户已经成功登录，需要三秒后跳转首页
// servlet是不适合做数据展现的，所以要在jsp中输出
String message = &quot;&lt;meta http-equiv=&apos;refresh&apos; content=&apos;3;url=/day06/index.jsp&apos;/&gt;恭喜您登录成功，将在3秒后跳转到首页，如果没有跳转，请点击&lt;a href=&apos;&apos;&gt;超链接&lt;/a&gt;&quot;;
request.setAttribute(&quot;message&quot;, message);
this.getServletContext().getRequestDispatcher(&quot;/message.jsp&quot;)
.forward(request, response);
}

private void test2(HttpServletResponse response) throws IOException {
// 假设是一个处理用户登录的servlet，假设用户已经成功登录，需要三秒后跳转首页
response.setCharacterEncoding(&quot;UTF-8&quot;);
response.setHeader(&quot;Content-type&quot;, &quot;text/html;charset=UTF-8&quot;);
response.setHeader(&quot;refresh&quot;, &quot;3;url=&apos;/day06/index.jsp&apos;&quot;);
response.getWriter().write(
&quot;恭喜您登录成功，将在3秒后跳转到首页，如果没有跳转，请点击&lt;a href=&apos;&apos;&gt;超链接&lt;/a&gt;&quot;);
}

private void test1(HttpServletResponse response) throws IOException {
// 发响应头控制浏览器每隔三秒刷新一次
response.setHeader(&quot;refresh&quot;, &quot;3&quot;);
String data = new Random().nextInt(100000000) + &quot;&quot;;
response.getWriter().write(data);
}

public void doPost(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {
doGet(request, response);
}

}
&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;

&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;%
String message = (String)request.getAttribute(&quot;message&quot;);
out.write(message);
%&gt;
&lt;/body&gt;
&lt;/html&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>141582</snippet_key>
<tag>442</tag>
<comment>来自CSDN博客：[leet code] Binary Tree Preorder Traversal  http://blog.csdn.net/u010500263/article/details/17813081#</comment>
<code>/**
* Definition for binary tree
* public class TreeNode {
* int val;
* TreeNode left;
* TreeNode right;
* TreeNode(int x) { val = x; }
* }
*/
public class Solution {
public ArrayList&lt;Integer&gt; preorderTraversal(TreeNode root) {

// define linklist
ArrayList&lt;Integer&gt; nodeVal = new ArrayList&lt;Integer&gt;();

// root == null
if(root == null) return nodeVal;

//recursive call
pre(nodeVal, root);

// return link list
return nodeVal;
}
//recursive function
public void pre(ArrayList&lt;Integer&gt; nodeVal, TreeNode node){
// add root
nodeVal.add(node.val);

// if left != null recursive call
if(node.left != null) pre(nodeVal, node.left);

// if right != null recursive call
if(node.right != null) pre(nodeVal, node.right);
}
}
/**
* Definition for binary tree
* public class TreeNode {
* int val;
* TreeNode left;
* TreeNode right;
* TreeNode(int x) { val = x; }
* }
*/
public class Solution {
public ArrayList&lt;Integer&gt; preorderTraversal(TreeNode root) {
// define linklist and stack
ArrayList&lt;Integer&gt; nodeVal = new ArrayList&lt;Integer&gt;();
Stack&lt;TreeNode&gt; st = new Stack();

// root == null
if(root == null) return nodeVal;

// for root node
st.push(root);

// use stack to implement the order of node
while (!st.isEmpty()){
TreeNode cur = st.peek();
nodeVal.add(cur.val);
st.pop();

if (cur.right != null) st.push(cur.right);
if (cur.left != null) st.push(cur.left);
}
return nodeVal;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>403726</snippet_key>
<tag></tag>
<comment>来自CSDN博客：编写一个程序，获取10个1至20的随机数，要求随机数不能重复  http://blog.csdn.net/jiewin/article/details/11757853#</comment>
<code>package com.itheima;

import java.util.Random;

/**
* 编写一个程序，获取10个1至20的随机数，要求随机数不能重复。
*
* 整体思路：
* 1、创建一个大小为10的数组arr
* 2、循环生成10个1-20的随机数
* 3、获得的每个随机数都与arr数组中的元素比较，如果这个随机数不存在数组中，那么就添加进数组中。
* 4、最后格式化打印该数组
*/
public class Test08 {
/**
* 方法需求：获取10个1至20的随机数
* 实现思路：
* 1、定义一个数组arr，大小为x=10，再定义变量z，作为数组的指针。
* 2、用for循环生成1-20的随机数，
* 3、如果数组的长度&gt;=10，就跳出循环，否则调用chenkIn()方法，如果返回结果非true，就把随机数存入数组。
* 4、循环结束，返回数组
* @param x 需要的随机数个数
* @param y 随机数的取值范围
* @return 由随机数组成的数组
*/
private static int[] getRandom(int x,int y){
int[] arr = new int[x];
int z = 0;
for(int i=0; i&lt;y; i++){
int num = new Random().nextInt(y)+1;
if(z &gt;= x){
break;
}else if(!chenkIn(num,arr)){
arr[z++] = num;
}
}
return arr;
}

/**
* 方法需求：判断某个数是否在数组中存在
* 实现思路：
* 1、该方法接收num(随机数)，和arr(数组)
* 2、定义一个标记flag，默认为false。
* 3、循环判断num是否与arr中的元素相同，如果相同，就把标记改为true,并跳出循环，结束时间。
* 4、返回标记flag。
* @param num 一个数
* @param arr 数组
* @return
*/
private static boolean chenkIn(int num,int[] arr){
boolean flag = false;
for(int x=0; x&lt;arr.length; x++){
if(num==arr[x]){
flag = true;
break;
}
}
return flag;
}

/**
* 方法需求：格式化打印数组
* @param arr 需要打印的数组
*/
private static void printArr(int[] arr){
System.out.print(&quot;[&quot;);
for(int x=0; x&lt;arr.length; x++){
if(x&lt;arr.length-1){
System.out.print(arr[x]+&quot;,&quot;);
}else{
System.out.print(arr[x]+&quot;]&quot;);
}
}
}

/**
* 主函数测试
* @param args
*/
public static void main(String[] args) {
//getRandom方法获取一个由10个1-20的随机数组成的数组，
//printArr方法格式化打印该数组
printArr(getRandom(10,20));
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>92165</snippet_key>
<tag>474</tag>
<comment>来自CSDN博客：Java排序算法之快速排序  http://blog.csdn.net/xiadik/article/details/17071029#</comment>
<code>package test;

public class Main {
int count;

public void quickSort(int[] data, int left, int right) {
int middle, tempDate;
int i, j, subcount = 0;
i = left;
j = right;
middle = data[(i + j) / 2];
do {
// 找出左边比中间值大的数
while (data[i] &lt; middle &amp;&amp; i &lt; right)
i++;
// 找出右边比中间值小的数
while (data[j] &gt; middle &amp;&amp; j &gt; left)
j--;
// 将左边大的数和右边小的数进行替换
if (i &lt;= j) {
tempDate = data[i];
data[i] = data[j];
data[j] = tempDate;
i++;
j--;
}
System.out.println(&quot; 第&quot; + (subcount++) + &quot;次搬动,&quot; + &quot;middle=&quot;
+ middle + &quot;,left=&quot; + left + &quot;,right=&quot; + right + &quot;,本次替换i=&quot;
+ (i - 1) + &quot;,j=&quot; + (j + 1));
for (int a = 0; a &lt; data.length; a++) {
System.out.print(&quot; &quot; + data[a] + &quot; &quot;);
}
System.out.println();
// 当两者交错时停止
} while (i &lt; j);
// 打印数据
System.out.println(&quot;第&quot; + (count++) + &quot;次排序结果,&quot; + &quot;middle=&quot; + middle
+ &quot;,left=&quot; + left + &quot;,right=&quot; + right + &quot;,i=&quot; + i + &quot;,j=&quot; + j);
for (int a = 0; a &lt; data.length; a++) {
System.out.print(data[a] + &quot; &quot;);
}
System.out.println();
if (i &lt; right) {
quickSort(data, i, right);
}
if (j &gt; left) {
quickSort(data, left, j);
}
}

public static void main(String[] args) {
int[] data = new int[] { 14, 69, 23, 0, 10, 75, 88, 38, 95, 17 };
// 打印数据
System.out.println(&quot;原生数据：&quot;);
for (int i = 0; i &lt; data.length; i++) {
System.out.print(data[i] + &quot; &quot;);
}
System.out.println();
Main sort = new Main();
sort.quickSort(data, 0, data.length - 1);
System.out.println(&quot;最后数据：&quot;);
for (int i = 0; i &lt; data.length; i++) {
System.out.print(data[i] + &quot; &quot;);
}
// 打印数据
System.out.println();
}
}

输出：
原生数据：
14 69 23 0 10 75 88 38 95 17
 第0次搬动,middle=10,left=0,right=9,本次替换i=0,j=4
10 69 23 0 14 75 88 38 95 17
 第1次搬动,middle=10,left=0,right=9,本次替换i=1,j=3
10 0 23 69 14 75 88 38 95 17
第0次排序结果,middle=10,left=0,right=9,i=2,j=2
10 0 23 69 14 75 88 38 95 17
 第0次搬动,middle=75,left=2,right=9,本次替换i=5,j=9
10 0 23 69 14 17 88 38 95 75
 第1次搬动,middle=75,left=2,right=9,本次替换i=6,j=7
10 0 23 69 14 17 38 88 95 75
第1次排序结果,middle=75,left=2,right=9,i=7,j=6
10 0 23 69 14 17 38 88 95 75
 第0次搬动,middle=95,left=7,right=9,本次替换i=8,j=9
10 0 23 69 14 17 38 88 75 95
第2次排序结果,middle=95,left=7,right=9,i=9,j=8
10 0 23 69 14 17 38 88 75 95
 第0次搬动,middle=88,left=7,right=8,本次替换i=7,j=8
10 0 23 69 14 17 38 75 88 95
第3次排序结果,middle=88,left=7,right=8,i=8,j=7
10 0 23 69 14 17 38 75 88 95
 第0次搬动,middle=14,left=2,right=6,本次替换i=2,j=4
10 0 14 69 23 17 38 75 88 95
第4次排序结果,middle=14,left=2,right=6,i=3,j=3
10 0 14 69 23 17 38 75 88 95
 第0次搬动,middle=23,left=3,right=6,本次替换i=3,j=5
10 0 14 17 23 69 38 75 88 95
第5次排序结果,middle=23,left=3,right=6,i=4,j=4
10 0 14 17 23 69 38 75 88 95
 第0次搬动,middle=69,left=4,right=6,本次替换i=5,j=6
10 0 14 17 23 38 69 75 88 95
第6次排序结果,middle=69,left=4,right=6,i=6,j=5
10 0 14 17 23 38 69 75 88 95
 第0次搬动,middle=23,left=4,right=5,本次替换i=4,j=4
10 0 14 17 23 38 69 75 88 95
第7次排序结果,middle=23,left=4,right=5,i=5,j=3
10 0 14 17 23 38 69 75 88 95
 第0次搬动,middle=17,left=3,right=4,本次替换i=3,j=3
10 0 14 17 23 38 69 75 88 95
第8次排序结果,middle=17,left=3,right=4,i=4,j=2
10 0 14 17 23 38 69 75 88 95
 第0次搬动,middle=14,left=2,right=3,本次替换i=2,j=2
10 0 14 17 23 38 69 75 88 95
第9次排序结果,middle=14,left=2,right=3,i=3,j=1
10 0 14 17 23 38 69 75 88 95
 第0次搬动,middle=0,left=0,right=2,本次替换i=0,j=1
0 10 14 17 23 38 69 75 88 95
第10次排序结果,middle=0,left=0,right=2,i=1,j=0
0 10 14 17 23 38 69 75 88 95
 第0次搬动,middle=10,left=1,right=2,本次替换i=1,j=1
0 10 14 17 23 38 69 75 88 95
第11次排序结果,middle=10,left=1,right=2,i=2,j=0
0 10 14 17 23 38 69 75 88 95
最后数据：
0 10 14 17 23 38 69 75 88 95
</code>
</RECORD>
<RECORD>
<snippet_key>288773</snippet_key>
<tag>微软 实习生 技术类 在线编程题目</tag>
<comment>来自CSDN博客：微软2014实习生及秋令营技术类职位在线测试返回比赛列表  http://blog.csdn.net/u014657292/article/details/23555167#</comment>
<code>&lt;div style=&quot;box-sizing: border-box; color: rgb(51, 51, 51); font-family: &apos;Helvetica Neue&apos;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; &quot;&gt;&lt;h3 style=&quot;box-sizing: border-box; font-weight: 500; line-height: 1.1; color: inherit; margin-top: 20px; margin-bottom: 10px; font-size: 24px; &quot;&gt;&lt;/h3&gt;&lt;h3 class=&quot;panel-title&quot; style=&quot;box-sizing: border-box; font-family: &apos;Helvetica Neue&apos;, Helvetica, Arial, sans-serif; font-weight: 500; line-height: 1.1; color: rgb(51, 51, 51); margin-top: 0px; margin-bottom: 0px; font-size: 16px; &quot;&gt;题目1 : String reorder&lt;/h3&gt;Description&lt;p style=&quot;box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; &quot;&gt;For this question, your program is required to process an input string containing only ASCII characters between ‘0’ and ‘9’, or between ‘a’ and ‘z’ (including ‘0’, ‘9’, ‘a’, ‘z’).&lt;/p&gt;&lt;p style=&quot;box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; &quot;&gt;Your program should reorder and split all input string characters into multiple segments, and output all segments as one concatenated string. The following requirements should also be met,&lt;br style=&quot;box-sizing: border-box; &quot; /&gt;1. Characters in each segment should be in strictly increasing order. For ordering, ‘9’ is larger than ‘0’, ‘a’ is larger than ‘9’, and ‘z’ is larger than ‘a’ (basically following ASCII character order).&lt;br style=&quot;box-sizing: border-box; &quot; /&gt;2. Characters in the second segment must be the same as or a subset of the first segment; and every following segment must be the same as or a subset of its previous segment.&lt;/p&gt;&lt;p style=&quot;box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; &quot;&gt;Your program should output string “&lt;invalid input string&gt;” when the input contains any invalid characters (i.e., outside the &apos;0&apos;-&apos;9&apos; and &apos;a&apos;-&apos;z&apos; range).&lt;/p&gt;&lt;p style=&quot;box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; &quot;&gt;&lt;br style=&quot;box-sizing: border-box; &quot; /&gt;&lt;/p&gt;&lt;h3 style=&quot;box-sizing: border-box; font-weight: 500; line-height: 1.1; color: inherit; margin-top: 20px; margin-bottom: 10px; font-size: 24px; &quot;&gt;Input&lt;/h3&gt;&lt;p style=&quot;box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; &quot;&gt;&lt;br style=&quot;box-sizing: border-box; &quot; /&gt;Input consists of multiple cases, one case per line. Each case is one string consisting of ASCII characters.&lt;/p&gt;&lt;h3 style=&quot;box-sizing: border-box; font-weight: 500; line-height: 1.1; color: inherit; margin-top: 20px; margin-bottom: 10px; font-size: 24px; &quot;&gt;Output&lt;/h3&gt;&lt;p style=&quot;box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; &quot;&gt;&lt;br style=&quot;box-sizing: border-box; &quot; /&gt;For each case, print exactly one line with the reordered string based on the criteria above.&lt;/p&gt;&lt;h3 style=&quot;box-sizing: border-box; font-weight: 500; line-height: 1.1; color: inherit; margin-top: 20px; margin-bottom: 10px; font-size: 24px; &quot;&gt;&lt;br style=&quot;box-sizing: border-box; &quot; /&gt;&lt;/h3&gt;&lt;/div&gt;&lt;dt style=&quot;box-sizing: border-box; line-height: 1.428571429; font-weight: bold; font-size: 18px; margin: 10px 0px; color: rgb(51, 51, 51); font-family: &apos;Helvetica Neue&apos;, Helvetica, Arial, sans-serif; &quot;&gt;样例输入&lt;/dt&gt;&lt;dd style=&quot;box-sizing: border-box; line-height: 20px; margin: 10px; color: rgb(51, 51, 51); font-family: &apos;Helvetica Neue&apos;, Helvetica, Arial, sans-serif; font-size: 14px; &quot;&gt;&lt;pre code_snippet_id=&quot;288773&quot; snippet_file_name=&quot;blog_20140412_1_9117733&quot; style=&quot;box-sizing: border-box; font-family: Menlo, Monaco, Consolas, &apos;Courier New&apos;, monospace; font-size: 13px; white-space: pre-wrap; padding: 9.5px; margin-top: 0px; margin-bottom: 10px; line-height: 1.428571429; word-break: break-all; word-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; &quot;&gt;aabbccdd
007799aabbccddeeff113355zz
1234.89898
abcdefabcdefabcdefaaaaaaaaaaaaaabbbbbbbddddddee
//下面是我根据此题写的程序，运行通过。。。感觉好繁琐的。。
import java.io.*;
public class Main1{


public static void main(String[] args) throws IOException{
// TODO Auto-generated method stub

func1 fun=new func1();
fun.doSomething();

}


}
class func1{
int items;
String[] array;
String s;
func1(){
items=0;
array=new String[20];
}
public void input() throws IOException{
while(true){
s=getString();
if(s.equals(&quot;&quot;))
break;
array[items]=s;
items++;
}

}
public static String getString() throws IOException{
InputStreamReader isr=new InputStreamReader(System.in);
BufferedReader br=new BufferedReader(isr);
return br.readLine();
}
public boolean before(String k){
for(int i=0;i&lt;k.length();i++){
char c=k.charAt(i);
if((c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;)||(&apos;a&apos;&lt;=c&amp;&amp;c&lt;=&apos;z&apos;)){
continue;
}
else{
return false;
}
}
return true;
}
public void doSomething() throws IOException{
input();
for(int m=0;m&lt;items;m++){
String p=array[m];
String [] temp=array[m].split(&quot;&quot;);
for(int i=0;i&lt;temp.length-1;i++){
temp[i]=temp[i+1];
}
int num=temp.length-1;
if(!before(p)){
System.out.println(&quot;&lt;invalid input string&gt;&quot;);
continue;
}
while(num!=0){

for(char j=&apos;0&apos;;j&lt;=&apos;9&apos;;j++){
for(int n=0;n&lt;num;n++){
if(temp[n].equals(j+&quot;&quot;)){
System.out.print(temp[n]);
for(int k=n;k&lt;num-1;k++){
temp[k]=temp[k+1];
}
num--;
}

}
}
for(char t=&apos;a&apos;;t&lt;=&apos;z&apos;;t++){
for(int n=0;n&lt;num;n++){
if(temp[n].equals(t+&quot;&quot;)){

System.out.print(temp[n]);
for(int k=n;k&lt;num-1;k++){
temp[k]=temp[k+1];
}
num--;
}

}
}


}
System.out.println();


}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>403982</snippet_key>
<tag></tag>
<comment>来自CSDN博客：初始内省Introspection  http://blog.csdn.net/clydezhou/article/details/34082991#</comment>
<code>package introspection;

public class Introspection {
private int x;
private int y;

public int getX() {
return x;
}

public void setX(int x) {
this.x = x;
}

public int getY() {
return this.y;
}

public void setY(int y) {
this.y = y;
}

public Introspection(int x, int y) {
this.x = x;
this.y = y;
}
}
package introspection;

import java.beans.*;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class TestNeixing {
public static void main(String[] args) throws IntrospectionException, IllegalArgumentException, IllegalAccessException,
InvocationTargetException {
Introspection introspection = new Introspection(45, 34);
String propertyName = &quot;x&quot;;
PropertyDescriptor pd = new PropertyDescriptor(propertyName, introspection.getClass());
Method methodGetX = pd.getReadMethod();
Object obj = methodGetX.invoke(introspection);
System.out.println(obj);

Method methodSetX = pd.getWriteMethod();
methodSetX.invoke(introspection, 7);
System.out.println(introspection.getX());
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>76558</snippet_key>
<tag>android blog 图片 csdn博客</tag>
<comment>来自CSDN博客：Android基础学习__第7天__图片的各种处理  http://blog.csdn.net/a_519273266/article/details/16848821#</comment>
<code>BitmapFactory.Options bmpFactoryOptions = new BitmapFactory.Options();
bmpFactoryOptions.inSampleSize = 8;
Bitmap bmp = BitmapFactory.decodeFile(imageFilePath, bmpFactoryOptions);
imv.setImageBitmap(bmp);
//得到手机屏幕的宽高.
WindowManager wm = (WindowManager) getSystemService(WINDOW_SERVICE);
windowheight = wm.getDefaultDisplay().getHeight();
windowwidth= wm.getDefaultDisplay().getWidth();

BitmapFactory.Options opts = new Options();
//不去真的解析图片 只是获取图片的头部信息 宽高
opts.inJustDecodeBounds = true;
BitmapFactory.decodeFile(&quot;/sdcard/a.jpg&quot;, opts);
int imageHeight = opts.outHeight ;
int imageWidth = opts.outWidth;
System.out.println(&quot;图片宽:&quot;+imageWidth);
System.out.println(&quot;图片高:&quot;+imageHeight);

//计算缩放比例
int scaleX = imageWidth/windowwidth;
int scaleY = imageHeight /windowheight;
int scale = 1;
if(scaleX &gt; scaleY &amp; scaleY &gt;=1){
scale = scaleX;
}
if(scaleY &gt; scaleX &amp; scaleX &gt;=1){
scale = scaleY;
}
//真的解析图片
opts.inJustDecodeBounds = false;
//采样率
opts.inSampleSize = scale;
Bitmap bitmap = BitmapFactory.decodeFile(&quot;/sdcard/a.jpg&quot;, opts);
iv.setImageBitmap(bitmap);
ExifInterface exif = new ExifInterface(&quot;/sdcard/a.jpg&quot;);
String time = exif.getAttribute(ExifInterface.TAG_DATETIME);
System.out.println(time);
//得到拍摄设备型号
String model = exif.getAttribute(ExifInterface.TAG_MODEL);
System.out.println(&quot;model:&quot;+model);

//把exif信息写到文件:
exif.setAttribute(&quot;ImageDescription&quot;,&quot;Something New&quot;);
public void selectImage(View view) {
// 激活系统的图库应用 选择一张照片
Intent intent = new Intent();
intent.setAction(Intent.ACTION_PICK);
intent.setType(&quot;image/*&quot;);
startActivityForResult(intent, 0);
}

@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
try {
if (data != null) {
Uri uri = data.getData(); // 图片的uri 路径
iv.setImageURI(uri);//注意，如果图片过大，会异常
}
} catch (Exception e) {
e.printStackTrace();
}
super.onActivityResult(requestCode, resultCode, data);
}
// 注册imagview的触摸事件
iv.setOnTouchListener(new OnTouchListener() {
int startX = 0;
int startY = 0;

@Override
public boolean onTouch(View v, MotionEvent event) {
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
System.out.println(&quot;手指按下&quot;);
startX = (int) event.getX();
startY = (int) event.getY();
break;

case MotionEvent.ACTION_MOVE:
System.out.println(&quot;手指移动&quot;);
int newX = (int) event.getX();
int newY = (int) event.getY();
System.out.println(&quot;开始画线:起点坐标:(&quot;+startX+&quot;,&quot;+startY+&quot;), ---&gt;&quot;+&quot;(&quot;+newX+&quot;,&quot;+newY+&quot;)&quot;);
canvas.drawLine(startX, startY, newX, newY, paint);
iv.setImageBitmap(alterBitmap);
//更新新的位置
startX = (int) event.getX();
startY = (int) event.getY();
break;

case MotionEvent.ACTION_UP:

System.out.println(&quot;手指离开&quot;);
break;
}
return true;
}
});




//处理返回回来的数据。
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
try {
if (data != null) {
Uri uri = data.getData(); // 图片的uri 路径
InputStream is = getContentResolver().openInputStream(uri);
//一个不可以被修改的bitmap 只读的bitmap
Options opts = new Options();
opts.inSampleSize = 2;
Bitmap bitmap = BitmapFactory.decodeStream(is, new Rect(), opts);
//创建一个空白可以被修改的bitmap 宽度 和高度 跟原图一样.
alterBitmap = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());


//初始化 画布 用什么bitmap 作为背景 创建一个一个画布
canvas = new Canvas(alterBitmap);
canvas.drawBitmap(bitmap, new Matrix(), paint);
//初始化 画笔
paint = new Paint();
paint.setColor(Color.GREEN);
paint.setStrokeWidth(6);
// 缩略图Bitmap bitmap = data.getParcelableExtra(&quot;data&quot;);

iv.setImageBitmap(alterBitmap);
}
} catch (Exception e) {
e.printStackTrace();
}
super.onActivityResult(requestCode, resultCode, data);
}
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
iv1 = (ImageView) findViewById(R.id.iv_1);
iv2 = (ImageView) findViewById(R.id.iv_2);

Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher);
iv1.setImageBitmap(bitmap1);

Bitmap alterBitmap = Bitmap.createBitmap(bitmap1.getWidth()*2, bitmap1.getHeight(), bitmap1.getConfig());
Canvas canvas = new Canvas(alterBitmap);
Paint paint = new Paint();
paint.setColor(Color.BLACK);
//矩阵
Matrix matrix = new Matrix();
/* matrix.setValues(new float[] {
2.0f, 0, 0,
0, 1, 0,
0, 0, 1
});*/

--------
//缩放效果
matrix.setScale(2.0f, 1);//缩放
--------
//旋转效果
matrix.setRotate(15,bitmap1.getWidth()/2,bitmap1.getHeight()/2);//旋转
paint.setAntiAlias(true);//消除锯齿
--------
//镜面效果
matrix.setScale(-1, 1);
matrix.postTranslate(bitmap1.getWidth(), 0);*/
--------
//倒影效果
matrix.setScale(1, -1);
matrix.postTranslate(0, bitmap1.getHeight());
--------
canvas.drawBitmap(bitmap1, matrix, paint);

iv2.setImageBitmap(alterBitmap);
}
public class MainActivity extends Activity {

private ImageView iv1;
private SeekBar sb1, sb2, sb3,sb4;
private Bitmap alterBitmap;
private Canvas canvas;
private Paint paint;

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
iv1 = (ImageView) findViewById(R.id.iv);

final Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(),
R.drawable.ic_launcher);

alterBitmap = Bitmap.createBitmap(bitmap1.getWidth(),
bitmap1.getHeight(), bitmap1.getConfig());
canvas = new Canvas(alterBitmap);
paint = new Paint();
paint.setColor(Color.BLACK);
final Matrix matrix = new Matrix();
final ColorMatrix cm = new ColorMatrix();
paint.setColorFilter(new ColorMatrixColorFilter(cm));

paint.setAntiAlias(true);
canvas.drawBitmap(bitmap1, matrix, paint);

iv1.setImageBitmap(alterBitmap);

sb1 = (SeekBar) findViewById(R.id.sb1);
sb2 = (SeekBar) findViewById(R.id.sb2);
sb3 = (SeekBar) findViewById(R.id.sb3);
sb4 = (SeekBar) findViewById(R.id.sb4);
sb1.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {

@Override
public void onStopTrackingTouch(SeekBar seekBar) {
int progress = seekBar.getProgress();
cm.set(new float[] {
progress/128.0f, 0, 0, 0, 0,
0, 1, 0, 0, 0,
0, 0, 1, 0, 0,
0, 0, 0, 1, 0
});
paint.setColorFilter(new ColorMatrixColorFilter(cm));
canvas.drawBitmap(bitmap1, matrix, paint);

iv1.setImageBitmap(alterBitmap);
}

@Override
public void onStartTrackingTouch(SeekBar seekBar) {

}

@Override
public void onProgressChanged(SeekBar seekBar, int progress,
boolean fromUser) {

}
});

sb2.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {

@Override
public void onStopTrackingTouch(SeekBar seekBar) {
int progress = seekBar.getProgress();
cm.set(new float[] {
1, 0, 0, 0, 0,
0, progress/128.0f, 0, 0, 0,
0, 0, 1, 0, 0,
0, 0, 0, 1, 0
});
paint.setColorFilter(new ColorMatrixColorFilter(cm));
canvas.drawBitmap(bitmap1, matrix, paint);

iv1.setImageBitmap(alterBitmap);
}

@Override
public void onStartTrackingTouch(SeekBar seekBar) {

}

@Override
public void onProgressChanged(SeekBar seekBar, int progress,
boolean fromUser) {

}
});
sb3.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {

@Override
public void onStopTrackingTouch(SeekBar seekBar) {
int progress = seekBar.getProgress();
cm.set(new float[] {
1, 0, 0, 0, 0,
0, 1, 0, 0, 0,
0, 0, progress/128.0f, 0, 0,
0, 0, 0, 1, 0
});
paint.setColorFilter(new ColorMatrixColorFilter(cm));
canvas.drawBitmap(bitmap1, matrix, paint);

iv1.setImageBitmap(alterBitmap);
}

@Override
public void onStartTrackingTouch(SeekBar seekBar) {

}

@Override
public void onProgressChanged(SeekBar seekBar, int progress,
boolean fromUser) {

}
});

sb4.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {

@Override
public void onStopTrackingTouch(SeekBar seekBar) {
int progress = seekBar.getProgress();
cm.set(new float[] {
progress/128.0f, 0, 0, 0, 0,
0, progress/128.0f, 0, 0, 0,
0, 0, progress/128.0f, 0, 0,
0, 0, 0, 1, 0
});
paint.setColorFilter(new ColorMatrixColorFilter(cm));
canvas.drawBitmap(bitmap1, matrix, paint);

iv1.setImageBitmap(alterBitmap);

}

@Override
public void onStartTrackingTouch(SeekBar seekBar) {
// TODO Auto-generated method stub

}

@Override
public void onProgressChanged(SeekBar seekBar, int progress,
boolean fromUser) {
// TODO Auto-generated method stub

}
});
}
}
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
Bitmap faceBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.aa);
FaceDetector detector = new FaceDetector(faceBitmap.getWidth(),
faceBitmap.getHeight(), 1); // 创建识别器
Face[] mFaces = new Face[1];
int mNumFaces = detector.findFaces(faceBitmap, mFaces);
// 识别
if (mNumFaces &gt; 0) {
for (int i = 0; i &lt; mNumFaces; i++) {
System.out.println(&quot;找到了脸&quot;);
PointF point = new PointF();
mFaces[i].getMidPoint(point);
System.out.println(&quot;脸的中心坐标:&quot;+point.x+&quot;,&quot;+point.y);
}
}else{
System.out.println(&quot;没找到了脸&quot;);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>273166</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Spring AOP 之编译期织入、装载期织入、运行时织入  http://blog.csdn.net/wenzhibinbin_pt/article/details/22888619#</comment>
<code>public static void main(String[] args) {
XmlBeanFactory factory = new XmlBeanFactory(new
ClassPathResource(&quot;config.xml&quot;));
System.out.println(factory.getBean(&quot;random&quot;).toString());
//StaticFactoryBean sfb =
(StaticFactoryBean)factory.getBean(&quot;random&quot;);
//System.out.println(sfb.createRandom().toString());

//調用getBean()時,返回隨機數.如果沒有指定factory-method,會返回StaticFactoryBean的實例,即返回工廠Bean的實例
}
import java.text.SimpleDateFormat;
import java.util.Date;
public class InstanceFactoryBean {
private String format = &quot;yy-MM-dd HH:mm:ss&quot;;
public void setFormat(String format) {
this.format = format;
} public String createTime() {
return new SimpleDateFormat(format).format(new Date());
}
}
&lt;bean id=&quot;instanceFactoryBean&quot; class=&quot;example.chapter3.InstanceFactoryBean&quot;&gt;
&lt;property name=&quot;format&quot; value=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;
&lt;/bean&gt;
&lt;bean id=&quot;currentTime&quot; factory-bean=&quot;instanceFactoryBean&quot; factory-method=&quot;createTime&quot;/&gt;
public static void main(String[] args) {
XmlBeanFactory factory = new XmlBeanFactory(new
ClassPathResource(&quot;config.xml&quot;));
System.out.println(factory.getBean(&quot;currentTime&quot;));
}
public class PiFactoryBean implements FactoryBean {
public Object getObject() throws Exception {
return new Double(3.14159265358979);
} public Class getObjectType() {
return Double.class;
} public boolean isSingleton() {
return true;
} }
&lt;bean id=&quot;pi&quot;class=&quot;example.chapter3.PiFactoryBean&quot;/&gt;
public static void main(String[] args) throws Exception {
XmlBeanFactory factory = new XmlBeanFactory(new
ClassPathResource(&quot;config.xml&quot;));
System.out.println(factory.getBean(&quot;pi&quot;));//返回PiFactoryBean
的工廠方法getObject返回的Double對象實例
//PiFactoryBean p =
(PiFactoryBean)factory.getBean(&quot;&amp;pi&quot;);
//加&quot;&amp;&quot;返回工廠Bean的實例.
//System.out.println(p.getObject());
}
import java.util.Random;
public class Static FactoryBean{
public static
Integer createRandom() {
return new
Integer(new Random().nextInt());
}
}
&lt;pre code_snippet_id=&quot;273166&quot; snippet_file_name=&quot;blog_20140416_2_2708952&quot; name=&quot;code&quot; class=&quot;java&quot;&gt;&lt;bean id=&quot;random&quot;
class=&quot;example.chapter3.StaticFactoryBean&quot;
factory-method=&quot;createRandom&quot;//createRandom方法必須是static的,才能找到
scope=&quot;prototype&quot;
/&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>338702</snippet_key>
<tag>遍历 path apk 删除apk</tag>
<comment>来自CSDN博客：apk安装后删除sb卡里的apk安装包 http://blog.csdn.net/u012005241/article/details/25533173#</comment>
<code>&lt;span style=&quot;white-space:pre&quot;&gt;  new Thread(){
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;@Override
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;public void run() {  
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;try {  
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt; &lt;/span&gt; &lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;&lt;span&gt;  &lt;/span&gt; &lt;span&gt;fileName = &quot;.apk&quot;;
&lt;span&gt; &lt;/span&gt;  FileHelper fileHelper = new FileHelper();
&lt;span&gt; &lt;/span&gt;  List&lt;File&gt; fileList =  fileHelper.findFile(fileName);  //file为APK整条路径
&lt;span&gt; &lt;/span&gt;  
&lt;span&gt; &lt;/span&gt;  Context con=Update.this;
&lt;span&gt; &lt;/span&gt;      &lt;/span&gt; &lt;span&gt;PackageInfo info = Update.this.getPackageManager().getPackageInfo(con.getPackageName(), 0);    
&lt;span&gt; &lt;/span&gt;  String packageNames = info.packageName;                  //得到正在运行的APK的包名
&lt;span&gt; &lt;/span&gt;  for (int k=0;k&lt;fileList.size();k++)
&lt;span&gt; &lt;/span&gt;  {
&lt;span&gt; &lt;/span&gt;  File file=fileList.get(k);
&lt;span&gt; &lt;/span&gt;  String spName=getApkPackName(file.getPath());          
&lt;span&gt; &lt;/span&gt;      if(spName!=null &amp;&amp; file!=null &amp;&amp; file.isFile() &amp;&amp; file.exists()){ 
&lt;span&gt; &lt;/span&gt;    &lt;span&gt; &lt;/span&gt;  if(spName.equals(packageNames))
&lt;span&gt; &lt;/span&gt;    &lt;span&gt; &lt;/span&gt;  {
&lt;span&gt; &lt;/span&gt;    &lt;span&gt; &lt;/span&gt;  file.delete();
&lt;span&gt; &lt;/span&gt;    &lt;span&gt; &lt;/span&gt;  }
&lt;span&gt; &lt;/span&gt;  }
&lt;span&gt; &lt;/span&gt;  }&lt;/span&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>469774</snippet_key>
<tag>spring ioc 三层</tag>
<comment>来自CSDN博客：从三层架构到IoC的蜕变  http://blog.csdn.net/quwenzhe/article/details/39318613#</comment>
<code>package com.tgb.spring.dao;

public interface UserDao {

public void addUser(String username,String password);
}
package com.tgb.spring.dao;

public class UserDao4MySqlImpl implements UserDao {

@Override
public void addUser(String username, String password) {
System.out.println(&quot;UserDao4MySqlImpl.addUser()&quot;);
}
}
package com.tgb.spring.manager;

public interface UserManager {
public void addUser(String username, String password);
}
package com.tgb.spring.manager;

import com.tgb.spring.dao.UserDao;
import com.tgb.spring.dao.UserDao4MySqlImpl;

public class UserManagerImpl implements UserManager {

@Override
public void addUser(String username, String password) {
// 由我们的应用程序负责服务(对象)定位
UserDao userDao = new UserDao4MySqlImpl();
userDao.addUser(username, password);
}
}
package com.tgb.spring.client;

import com.tgb.spring.manager.UserManager;
import com.tgb.spring.manager.UserManagerImpl;

public class Client {

public static void main(String[] args) {
// TODO Auto-generated method stub
UserManager userManager = new UserManagerImpl();
userManager.addUser(&quot;屈文哲&quot;, &quot;123&quot;);
}
}
package com.tgb.spring.dao;

public interface UserDao {

public void addUser(String username,String password);
}
package com.tgb.spring.dao;

public class UserDao4MySqlImpl implements UserDao {

@Override
public void addUser(String username, String password) {
System.out.println(&quot;UserDao4MySqlImpl.addUser()&quot;);
}
}
package com.tgb.spring.manager;

public interface UserManager {
public void addUser(String username, String password);
}
package com.tgb.spring.manager;

import com.tgb.spring.dao.UserDao;

public class UserManagerImpl implements UserManager {

private UserDao userDao;

@Override
public void addUser(String username, String password) {
userDao.addUser(username, password);
}

public void setUserDao(UserDao userDao) {
this.userDao = userDao;
}
}
package com.tgb.spring.client;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.tgb.spring.manager.UserManager;

public class Client {

public static void main(String[] args) {
BeanFactory factory = new ClassPathXmlApplicationContext(
&quot;applicationContext.xml&quot;);

UserManager userManager = (UserManager) factory.getBean(&quot;userManager&quot;);

userManager.addUser(&quot;屈文哲&quot;, &quot;123456&quot;);
}
}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd
http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd&quot;&gt;

&lt;bean id=&quot;userDao4Mysql&quot; class=&quot;com.tgb.spring.dao.UserDao4MySqlImpl&quot;&gt;&lt;/bean&gt;

&lt;bean id=&quot;userManager&quot; class=&quot;com.tgb.spring.manager.UserManagerImpl&quot;&gt;
&lt;!-- 构造函数注入 --&gt;
&lt;!--&lt;constructor-arg ref=&quot;userDao4Mysql&quot; /&gt;--&gt;
&lt;!-- &lt;constructor-arg ref=&quot;userDao4Oracle&quot; /&gt;--&gt;

&lt;!-- setter方式注入 --&gt;
&lt;property name=&quot;userDao&quot; ref=&quot;userDao4Mysql&quot; /&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>338958</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Android中通过反射来设置Toast的显示时间  http://blog.csdn.net/jiangwei0910410003/article/details/25540037#</comment>
<code>/**
* Make a standard toast that just contains a text view.
*
* @param context The context to use. Usually your {@link android.app.Application}
* or {@link android.app.Activity} object.
* @param text The text to show. Can be formatted text.
* @param duration How long to display the message. Either {@link #LENGTH_SHORT} or
* {@link #LENGTH_LONG}
*
*/
public static Toast makeText(Context context, CharSequence text, int duration) {
Toast result = new Toast(context);

LayoutInflater inflate = (LayoutInflater)
context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null);
TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message);
tv.setText(text);

result.mNextView = v;
result.mDuration = duration;

return result;
}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!--
/* //device/apps/common/res/layout/transient_notification.xml
**
** Copyright 2006, The Android Open Source Project
**
** Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
** http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/
--&gt;

&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:orientation=&quot;vertical&quot;
android:background=&quot;?android:attr/toastFrameBackground&quot;&gt;

&lt;TextView
android:id=&quot;@android:id/message&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:layout_weight=&quot;1&quot;
android:layout_gravity=&quot;center_horizontal&quot;
android:textAppearance=&quot;@style/TextAppearance.Toast&quot;
android:textColor=&quot;@color/bright_foreground_dark&quot;
android:shadowColor=&quot;#BB000000&quot;
android:shadowRadius=&quot;2.75&quot;
/&gt;

&lt;/LinearLayout&gt;
Toast toast = new Toast(this);
View v = LayoutInflater.from(this).inflate(R.layout.activity_main, null);
toast.setView(v);
toast.show();
/**
* Show the view for the specified duration.
*/
public void show() {
if (mNextView == null) {
throw new RuntimeException(&quot;setView must have been called&quot;);
}

INotificationManager service = getService();
String pkg = mContext.getPackageName();
TN tn = mTN;
tn.mNextView = mNextView;

try {
service.enqueueToast(pkg, tn, mDuration);
} catch (RemoteException e) {
// Empty
}
}
service.enqueueToast(pkg, tn, mDuration);
private static class TN extends ITransientNotification.Stub {
final Runnable mShow = new Runnable() {
@Override
public void run() {
handleShow();
}
};

final Runnable mHide = new Runnable() {
@Override
public void run() {
handleHide();
// Don&apos;t do this in handleHide() because it is also invoked by handleShow()
mNextView = null;
}
};

private final WindowManager.LayoutParams mParams = new WindowManager.LayoutParams();
final Handler mHandler = new Handler();

int mGravity;
int mX, mY;
float mHorizontalMargin;
float mVerticalMargin;


View mView;
View mNextView;

WindowManager mWM;

TN() {
// XXX This should be changed to use a Dialog, with a Theme.Toast
// defined that sets up the layout params appropriately.
final WindowManager.LayoutParams params = mParams;
params.height = WindowManager.LayoutParams.WRAP_CONTENT;
params.width = WindowManager.LayoutParams.WRAP_CONTENT;
params.format = PixelFormat.TRANSLUCENT;
params.windowAnimations = com.android.internal.R.style.Animation_Toast;
params.type = WindowManager.LayoutParams.TYPE_TOAST;
params.setTitle(&quot;Toast&quot;);
params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON
| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
}

/**
* schedule handleShow into the right thread
*/
@Override
public void show() {
if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this);
mHandler.post(mShow);
}

/**
* schedule handleHide into the right thread
*/
@Override
public void hide() {
if (localLOGV) Log.v(TAG, &quot;HIDE: &quot; + this);
mHandler.post(mHide);
}

public void handleShow() {
if (localLOGV) Log.v(TAG, &quot;HANDLE SHOW: &quot; + this + &quot; mView=&quot; + mView
+ &quot; mNextView=&quot; + mNextView);
if (mView != mNextView) {
// remove the old view if necessary
handleHide();
mView = mNextView;
Context context = mView.getContext().getApplicationContext();
if (context == null) {
context = mView.getContext();
}
mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
// We can resolve the Gravity here by using the Locale for getting
// the layout direction
final Configuration config = mView.getContext().getResources().getConfiguration();
final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());
mParams.gravity = gravity;
if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) {
mParams.horizontalWeight = 1.0f;
}
if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) {
mParams.verticalWeight = 1.0f;
}
mParams.x = mX;
mParams.y = mY;
mParams.verticalMargin = mVerticalMargin;
mParams.horizontalMargin = mHorizontalMargin;
if (mView.getParent() != null) {
if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this);
mWM.removeView(mView);
}
if (localLOGV) Log.v(TAG, &quot;ADD! &quot; + mView + &quot; in &quot; + this);
mWM.addView(mView, mParams);
trySendAccessibilityEvent();
}
}

private void trySendAccessibilityEvent() {
AccessibilityManager accessibilityManager =
AccessibilityManager.getInstance(mView.getContext());
if (!accessibilityManager.isEnabled()) {
return;
}
// treat toasts as notifications since they are used to
// announce a transient piece of information to the user
AccessibilityEvent event = AccessibilityEvent.obtain(
AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED);
event.setClassName(getClass().getName());
event.setPackageName(mView.getContext().getPackageName());
mView.dispatchPopulateAccessibilityEvent(event);
accessibilityManager.sendAccessibilityEvent(event);
}

public void handleHide() {
if (localLOGV) Log.v(TAG, &quot;HANDLE HIDE: &quot; + this + &quot; mView=&quot; + mView);
if (mView != null) {
// note: checking parent() just to make sure the view has
// been added... i have seen cases where we get here when
// the view isn&apos;t yet added, so let&apos;s try not to crash.
if (mView.getParent() != null) {
if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this);
mWM.removeView(mView);
}

mView = null;
}
}
}
/* //device/java/android/android/app/ITransientNotification.aidl
**
** Copyright 2007, The Android Open Source Project
**
** Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
** http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/

package android.app;

/** @hide */
oneway interface ITransientNotification {
void show();
void hide();
}
/**
* schedule handleShow into the right thread
*/
@Override
public void show() {
if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this);
mHandler.post(mShow);
}

/**
* schedule handleHide into the right thread
*/
@Override
public void hide() {
if (localLOGV) Log.v(TAG, &quot;HIDE: &quot; + this);
mHandler.post(mHide);
}
final Runnable mShow = new Runnable() {
@Override
public void run() {
handleShow();
}
};

final Runnable mHide = new Runnable() {
@Override
public void run() {
handleHide();
// Don&apos;t do this in handleHide() because it is also invoked by handleShow()
mNextView = null;
}
};
public void handleShow() {
if (localLOGV) Log.v(TAG, &quot;HANDLE SHOW: &quot; + this + &quot; mView=&quot; + mView
+ &quot; mNextView=&quot; + mNextView);
if (mView != mNextView) {
// remove the old view if necessary
handleHide();
mView = mNextView;
Context context = mView.getContext().getApplicationContext();
if (context == null) {
context = mView.getContext();
}
mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
// We can resolve the Gravity here by using the Locale for getting
// the layout direction
final Configuration config = mView.getContext().getResources().getConfiguration();
final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());
mParams.gravity = gravity;
if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) {
mParams.horizontalWeight = 1.0f;
}
if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) {
mParams.verticalWeight = 1.0f;
}
mParams.x = mX;
mParams.y = mY;
mParams.verticalMargin = mVerticalMargin;
mParams.horizontalMargin = mHorizontalMargin;
if (mView.getParent() != null) {
if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this);
mWM.removeView(mView);
}
if (localLOGV) Log.v(TAG, &quot;ADD! &quot; + mView + &quot; in &quot; + this);
mWM.addView(mView, mParams);
trySendAccessibilityEvent();
}
}
TN() {
// XXX This should be changed to use a Dialog, with a Theme.Toast
// defined that sets up the layout params appropriately.
final WindowManager.LayoutParams params = mParams;
params.height = WindowManager.LayoutParams.WRAP_CONTENT;
params.width = WindowManager.LayoutParams.WRAP_CONTENT;
params.format = PixelFormat.TRANSLUCENT;
params.windowAnimations = com.android.internal.R.style.Animation_Toast;
params.type = WindowManager.LayoutParams.TYPE_TOAST;
params.setTitle(&quot;Toast&quot;);
params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON
| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
}
final TN mTN;
package com.weijia.toast;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

import android.content.Context;
import android.view.View;
import android.widget.Toast;

public class ReflectToast {

Context mContext;

private Toast mToast;
private Field field;
private Object obj;
private Method showMethod, hideMethod;

public ReflectToast(Context c, View v) {
this.mContext = c;
mToast = new Toast(mContext);
mToast.setView(v);

reflectionTN();
}

public void show() {
try {
showMethod.invoke(obj, null);
} catch (Exception e) {
e.printStackTrace();
}
}

public void cancel() {
try {
hideMethod.invoke(obj, null);
} catch (Exception e) {
e.printStackTrace();
}
}

private void reflectionTN() {
try {
field = mToast.getClass().getDeclaredField(&quot;mTN&quot;);
field.setAccessible(true);//强暴
obj = field.get(mToast);
showMethod = obj.getClass().getDeclaredMethod(&quot;show&quot;, null);
hideMethod = obj.getClass().getDeclaredMethod(&quot;hide&quot;, null);
} catch (Exception e) {
e.printStackTrace();
}
}
}
package com.weijia.toast;

import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.TextView;

public class MainActivity extends Activity {
ReflectToast toast;
boolean isShown = false;

@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
final TextView tView = new TextView(this);
tView.setText(&quot;ReflectToast !!!&quot;);
toast = new ReflectToast(this, tView);

findViewById(R.id.show_toast).setOnClickListener(new OnClickListener() {
@Override
public void onClick(View v) {
if(isShown){
toast.cancel();
isShown = false;
}else{
toast.show();
isShown = true;
}
}
});

}
}
&lt;span&gt; &lt;/span&gt;INotificationManager service = getService();
String pkg = mContext.getPackageName();
TN tn = mTN;
tn.mNextView = mNextView;

try {
service.enqueueToast(pkg, tn, mDuration);
} catch (RemoteException e) {
// Empty
}
static private INotificationManager getService() {
if (sService != null) {
return sService;
}
sService = INotificationManager.Stub.asInterface(ServiceManager.getService(&quot;notification&quot;));
return sService;
}
/* //device/java/android/android/app/INotificationManager.aidl
**
** Copyright 2007, The Android Open Source Project
**
** Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
** http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
*/

package android.app;

import android.app.ITransientNotification;
import android.service.notification.StatusBarNotification;
import android.app.Notification;
import android.content.ComponentName;
import android.content.Intent;
import android.service.notification.INotificationListener;

/** {@hide} */
interface INotificationManager
{
void cancelAllNotifications(String pkg, int userId);

void enqueueToast(String pkg, ITransientNotification callback, int duration);
void cancelToast(String pkg, ITransientNotification callback);
void enqueueNotificationWithTag(String pkg, String basePkg, String tag, int id,
in Notification notification, inout int[] idReceived, int userId);
void cancelNotificationWithTag(String pkg, String tag, int id, int userId);

void setNotificationsEnabledForPackage(String pkg, int uid, boolean enabled);
boolean areNotificationsEnabledForPackage(String pkg, int uid);

StatusBarNotification[] getActiveNotifications(String callingPkg);
StatusBarNotification[] getHistoricalNotifications(String callingPkg, int count);

void registerListener(in INotificationListener listener, in ComponentName component, int userid);
void unregisterListener(in INotificationListener listener, int userid);

void cancelNotificationFromListener(in INotificationListener token, String pkg, String tag, int id);
void cancelAllNotificationsFromListener(in INotificationListener token);

StatusBarNotification[] getActiveNotificationsFromListener(in INotificationListener token);
}
public void enqueueToast(String pkg, ITransientNotification callback, int duration)
{
if (DBG) Slog.i(TAG, &quot;enqueueToast pkg=&quot; + pkg + &quot; callback=&quot; + callback + &quot; duration=&quot; + duration);

if (pkg == null || callback == null) {
Slog.e(TAG, &quot;Not doing toast. pkg=&quot; + pkg + &quot; callback=&quot; + callback);
return ;
}

//判断是不是系统的包或者是系统的uid,是的话
final boolean isSystemToast = isCallerSystem() || (&quot;android&quot;.equals(pkg));

if (ENABLE_BLOCKED_TOASTS &amp;&amp; !noteNotificationOp(pkg, Binder.getCallingUid())) {
if (!isSystemToast) {
Slog.e(TAG, &quot;Suppressing toast from package &quot; + pkg + &quot; by user request.&quot;);
return;
}
}

//入队列mToastQueue
synchronized (mToastQueue) {
int callingPid = Binder.getCallingPid();//获取当前进程id
long callingId = Binder.clearCallingIdentity();
try {
ToastRecord record;
//查看这个toast是否在当前队列中，有的话就返回索引
int index = indexOfToastLocked(pkg, callback);
//如果这个index大于等于0，说明这个toast已经在这个队列中了，只需要更新显示时间就可以了
//当然这里callback是一个对象，pkg是一个String，所以比较的时候是对象的比较
if (index &gt;= 0) {
record = mToastQueue.get(index);
record.update(duration);
} else {
//非系统的toast
if (!isSystemToast) {
//开始在队列中进行计数，如果队列中有这个toast的总数超过一定值，就不把toast放到队列中了
//这里使用的是通过包名来判断的，所以说一个app应用只能显示一定量的toast
int count = 0;
final int N = mToastQueue.size();
for (int i=0; i&lt;N; i++) {
final ToastRecord r = mToastQueue.get(i);
if (r.pkg.equals(pkg)) {
count++;
if (count &gt;= MAX_PACKAGE_NOTIFICATIONS) {
Slog.e(TAG, &quot;Package has already posted &quot; + count
+ &quot; toasts. Not showing more. Package=&quot; + pkg);
return;
}
}
}
}
//将这个toast封装成ToastRecord对象，放到队列中
record = new ToastRecord(callingPid, pkg, callback, duration);
mToastQueue.add(record);
index = mToastQueue.size() - 1;
keepProcessAliveLocked(callingPid);
}
//如果返回的索引是0，说明当前的这个存在的toast就在对头，直接显示
if (index == 0) {
showNextToastLocked();
}
} finally {
Binder.restoreCallingIdentity(callingId);
}
}
}
final boolean isSystemToast = isCallerSystem() || (&quot;android&quot;.equals(pkg));
// same as isUidSystem(int, int) for the Binder caller&apos;s UID.
boolean isCallerSystem() {
return isUidSystem(Binder.getCallingUid());
}
if (ENABLE_BLOCKED_TOASTS &amp;&amp; !noteNotificationOp(pkg, Binder.getCallingUid())) {
if (!isSystemToast) {
Slog.e(TAG, &quot;Suppressing toast from package &quot; + pkg + &quot; by user request.&quot;);
return;
}
}
int index = indexOfToastLocked(pkg, callback);
// lock on mToastQueue
private int indexOfToastLocked(String pkg, ITransientNotification callback)
{
IBinder cbak = callback.asBinder();
ArrayList&lt;ToastRecord&gt; list = mToastQueue;
int len = list.size();
for (int i=0; i&lt;len; i++) {
ToastRecord r = list.get(i);
if (r.pkg.equals(pkg) &amp;&amp; r.callback.asBinder() == cbak) {
return i;
}
}
return -1;
}
TN tn = mTN;
private static final int MAX_PACKAGE_NOTIFICATIONS = 50;
private void keepProcessAliveLocked(int pid)
{
int toastCount = 0; // toasts from this pid
ArrayList&lt;ToastRecord&gt; list = mToastQueue;
int N = list.size();
for (int i=0; i&lt;N; i++) {
ToastRecord r = list.get(i);
if (r.pid == pid) {
toastCount++;
}
}
try {
mAm.setProcessForeground(mForegroundToken, pid, toastCount &gt; 0);
} catch (RemoteException e) {
// Shouldn&apos;t happen.
}
}
private void showNextToastLocked() {
ToastRecord record = mToastQueue.get(0);
while (record != null) {
if (DBG) Slog.d(TAG, &quot;Show pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback);
try {
record.callback.show();
scheduleTimeoutLocked(record);
return;
} catch (RemoteException e) {
Slog.w(TAG, &quot;Object died trying to show notification &quot; + record.callback
+ &quot; in package &quot; + record.pkg);
// remove it from the list and let the process die
int index = mToastQueue.indexOf(record);
if (index &gt;= 0) {
mToastQueue.remove(index);
}
keepProcessAliveLocked(record.pid);
if (mToastQueue.size() &gt; 0) {
record = mToastQueue.get(0);
} else {
record = null;
}
}
}
}
record.callback.show();
scheduleTimeoutLocked(record);
private void scheduleTimeoutLocked(ToastRecord r)
{
mHandler.removeCallbacksAndMessages(r);
Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r);
long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;
mHandler.sendMessageDelayed(m, delay);
}
private static final int LONG_DELAY = 3500; // 3.5 seconds
private static final int SHORT_DELAY = 2000; // 2 seconds
INotificationManager service = getService();
String pkg = mContext.getPackageName();
TN tn = mTN;
tn.mNextView = mNextView;

try {
service.enqueueToast(pkg, tn, mDuration);
} catch (RemoteException e) {
// Empty
}
</code>
</RECORD>
<RECORD>
<snippet_key>77070</snippet_key>
<tag>blog csdn博客</tag>
<comment>来自CSDN博客：AsyncHttpClient 401权限问题  http://blog.csdn.net/linhui9010/article/details/16879833#</comment>
<code>public class AsyncHttpCilentUtil {

private static AsyncHttpClient client = null;

public synchronized static AsyncHttpClient getInstence(){
if(client ==null){
client = new AsyncHttpClient();
client.setTimeout(1000*10);
}
return client;
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>289541</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Android 图像缩略图及压缩图像  http://blog.csdn.net/echome33/article/details/23595433#</comment>
<code>&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt; String photoPath;
SimpleDateFormat formatter = new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;);
String path = Environment.getExternalStorageDirectory().getPath()+ &quot;/&quot;;
Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
String photoName = formatter.format(new Date()) + &quot;.jpg&quot;;
photoPath = path + photoName;
Uri uri = Uri.fromFile(new File(path, photoName));
intent.putExtra(MediaStore.EXTRA_OUTPUT, uri);
startActivityForResult(intent, requestCode);
&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt; private int getRotationForImage(String path) {
int rotation = 0;
try {
ExifInterface exifInterface = new ExifInterface(path);
int orientation = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION,ExifInterface.ORIENTATION_NORMAL);
switch (orientation) {
case ExifInterface.ORIENTATION_ROTATE_90:
rotation = 90;
break;
case ExifInterface.ORIENTATION_ROTATE_180:
rotation = 180;
break;
case ExifInterface.ORIENTATION_ROTATE_270:
rotation = 270;
break;
default:
rotation = 0;
}
} catch (IOException e) {
e.printStackTrace();
}
return rotation;
}
&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt; public static Bitmap rotaingBitmap(int angle , Bitmap bitmap) {
//旋转图片动作
Matrix matrix = new Matrix();;
matrix.postRotate(angle);
//创建新的图片
Bitmap resizedBitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
return resizedBitmap;
}
&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt; public void saveCompress(Bitmap bitmap, String filepath) {
File file = new File(filepath);
try {
FileOutputStream out = new FileOutputStream(file);
if (bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out)) {
out.flush();
out.close();
}
}catch (Exception e) {

}
}
</code>
</RECORD>
<RECORD>
<snippet_key>355333</snippet_key>
<tag>java Hadoop mapreduce 实例 中位数</tag>
<comment>来自CSDN博客：mapreduce编程实例(4)-求中位数和标准差  http://blog.csdn.net/pan12jian/article/details/26391163#</comment>
<code>package mrdp.ch2;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.Map;

import mrdp.utils.MRDPUtils;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.io.Writable;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.GenericOptionsParser;

public class MedianStdDevDriver {

public static class SOMedianStdDevMapper extends
Mapper&lt;Object, Text, IntWritable, IntWritable&gt; {

private IntWritable outHour = new IntWritable();
private IntWritable outCommentLength = new IntWritable();

private final static SimpleDateFormat frmt = new SimpleDateFormat(
&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SSS&quot;);

@SuppressWarnings(&quot;deprecation&quot;)
@Override
public void map(Object key, Text value, Context context)
throws IOException, InterruptedException {

// Parse the input string into a nice map
Map&lt;String, String&gt; parsed = MRDPUtils.transformXmlToMap(value.toString());

// Grab the &quot;CreationDate&quot; field,
// since it is what we are grouping by
String strDate = parsed.get(&quot;CreationDate&quot;);

// Grab the comment to find the length
String text = parsed.get(&quot;Text&quot;);

// .get will return null if the key is not there
if (strDate == null || text == null) {
// skip this record
return;
}

try {
// get the hour this comment was posted in
Date creationDate = frmt.parse(strDate);
outHour.set(creationDate.getHours());

// get the comment length
outCommentLength.set(text.length());

// write out the user ID with min max dates and count
context.write(outHour, outCommentLength);

} catch (ParseException e) {
System.err.println(e.getMessage());
return;
}
}
}

public static class SOMedianStdDevReducer extends
Reducer&lt;IntWritable, IntWritable, IntWritable, MedianStdDevTuple&gt; {
private MedianStdDevTuple result = new MedianStdDevTuple();
private ArrayList&lt;Float&gt; commentLengths = new ArrayList&lt;Float&gt;();

@Override
public void reduce(IntWritable key, Iterable&lt;IntWritable&gt; values,
Context context) throws IOException, InterruptedException {

float sum = 0;
float count = 0;
commentLengths.clear();
result.setStdDev(0);

// Iterate through all input values for this key
for (IntWritable val : values) {
commentLengths.add((float) val.get());
sum += val.get();
++count;
}

// sort commentLengths to calculate median
Collections.sort(commentLengths);

// if commentLengths is an even value, average middle two elements
if (count % 2 == 0) {
result.setMedian((commentLengths.get((int) count / 2 - 1) + commentLengths
.get((int) count / 2)) / 2.0f);
} else {
// else, set median to middle value
result.setMedian(commentLengths.get((int) count / 2));
}

// calculate standard deviation
float mean = sum / count;

float sumOfSquares = 0.0f;
for (Float f : commentLengths) {
sumOfSquares += (f - mean) * (f - mean);
}

result.setStdDev((float) Math.sqrt(sumOfSquares / (count - 1)));

context.write(key, result);
}
}

public static void main(String[] args) throws Exception {
Configuration conf = new Configuration();
String[] otherArgs = new GenericOptionsParser(conf, args)
.getRemainingArgs();
if (otherArgs.length != 2) {
System.err.println(&quot;Usage: MedianStdDevDriver &lt;in&gt; &lt;out&gt;&quot;);
System.exit(2);
}
Job job = new Job(conf,
&quot;StackOverflow Comment Length Median StdDev By Hour&quot;);
job.setJarByClass(MedianStdDevDriver.class);
job.setMapperClass(SOMedianStdDevMapper.class);
job.setReducerClass(SOMedianStdDevReducer.class);
job.setMapOutputKeyClass(IntWritable.class);
job.setMapOutputValueClass(IntWritable.class);
job.setOutputKeyClass(IntWritable.class);
job.setOutputValueClass(MedianStdDevTuple.class);
FileInputFormat.addInputPath(job, new Path(otherArgs[0]));
FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));
System.exit(job.waitForCompletion(true) ? 0 : 1);
}

public static class MedianStdDevTuple implements Writable {
private float median = 0;
private float stddev = 0f;

public float getMedian() {
return median;
}

public void setMedian(float median) {
this.median = median;
}

public float getStdDev() {
return stddev;
}

public void setStdDev(float stddev) {
this.stddev = stddev;
}

@Override
public void readFields(DataInput in) throws IOException {
median = in.readFloat();
stddev = in.readFloat();
}

@Override
public void write(DataOutput out) throws IOException {
out.writeFloat(median);
out.writeFloat(stddev);
}

@Override
public String toString() {
return median + &quot;\t&quot; + stddev;
}
}
}
jpan@jpan-Beijing:~/Mywork/mapreducepatterns/testdata$ hadoop fs -cat output3/part-r-00000
0 145.5 158.66512
1 218.0 150.04599
2 139.0 148.84734
3 200.0 158.28148
4 139.5 158.62466
5 122.5 167.31377
6 199.5 160.57263
7 238.0 175.86475
8 253.5 164.08226
9 232.0 167.5952
10 200.0 157.11778
11 179.0 144.3936
12 172.0 148.96738
13 229.0 134.17366
14 207.0 147.26193
15 224.0 147.52689
16 143.0 130.6711
17 177.0 158.20508
18 199.0 159.31636
19 175.5 147.4742
20 169.0 138.74756
21 164.0 141.22824
22 152.5 122.51671
23 145.0 160.20476
</code>
</RECORD>
<RECORD>
<snippet_key>486917</snippet_key>
<tag>442</tag>
<comment>来自CSDN博客：Unique Binary Search Trees II http://blog.csdn.net/WuyouJie2008/article/details/40181619#</comment>
<code>/**
* Definition for binary tree
* public class TreeNode {
* int val;
* TreeNode left;
* TreeNode right;
* TreeNode(int x) { val = x; left = null; right = null; }
* }
*/
public class Solution {
public TreeNode copyNode(TreeNode node)
{
if(node==null)
{
return null;
}
TreeNode nodeCopy=new TreeNode(node.val);
List&lt;TreeNode&gt; listOriginal=new LinkedList&lt;TreeNode&gt;();
List&lt;TreeNode&gt; listCopy=new LinkedList&lt;TreeNode&gt;();
listOriginal.add(node);
listCopy.add(nodeCopy);
while(listOriginal.size()&gt;0)
{
TreeNode original=listOriginal.get(0);
TreeNode copy=listCopy.get(0);
if(original.left!=null)
{
copy.left=new TreeNode(original.left.val);
listOriginal.add(original.left);
listCopy.add(copy.left);
}
if(original.right!=null)
{
copy.right=new TreeNode(original.right.val);
listOriginal.add(original.right);
listCopy.add(copy.right);
}
listOriginal.remove(0);
listCopy.remove(0);
}
return nodeCopy;
}
public List&lt;TreeNode&gt; generateTrees(int start,int end)
{
List&lt;TreeNode&gt; result=new LinkedList&lt;TreeNode&gt;();
TreeNode root=null;
if(start&gt;end)
{
result.add(null);
return result;
}
for(int i=start;i&lt;=end;i++)
{

List&lt;TreeNode&gt; listLeft=generateTrees(start,i-1);
List&lt;TreeNode&gt; listRight=generateTrees(i+1,end);
for(TreeNode left:listLeft)
{
for(TreeNode right:listRight)
{
root=new TreeNode(i);
root.left=copyNode(left);
root.right=copyNode(right);
result.add(root);
}
}
}
return result;
}
public List&lt;TreeNode&gt; generateTrees(int n) {
if(n&lt;0)
{
return new LinkedList&lt;TreeNode&gt;();
}
return generateTrees(1,n);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>356101</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Code Hunt 第一章算术篇答案  http://blog.csdn.net/u010571913/article/details/26453033#</comment>
<code>public class Program {
public static int Puzzle(int x) {
return 0-x;
}
}
public class Program {
public static int Puzzle(int x) {
return x-2;
}
}
public class Program {
public static int Puzzle(int x) {
return x*x;
}
}
public class Program {
public static int Puzzle(int x) {
return 3*x;
}
}
public class Program {
public static int Puzzle(int x) {
return x/3;
}
}
public class Program {
public static int Puzzle(int x) {
return 4/x;
}
}
public class Program {
public static int Puzzle(int x, int y) {
return x-y;
}
}
public class Program {
public static int Puzzle(int x, int y) {
return x+2*y;
}
}
public class Program {
public static int Puzzle(int x, int y) {
return x*y;
}
}
public class Program {
public static int Puzzle(int x, int y) {
return (3 * x + y) / 3;
}
}
public class Program {
public static int Puzzle(int x, int y) {
return x/y;
}
}
public class Program {
public static int Puzzle(int x) {
return x%3;
}
}
public class Program {
public static int Puzzle(int x) {
return x%3+1;
}
}
public class Program {
public static int Puzzle(int x) {
return 10%x;
}
}
public class Program {
public static int Puzzle(int x, int y, int z) {
return (x + y + z)/3;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>405518</snippet_key>
<tag>453</tag>
<comment>来自CSDN博客：【Leetcode】Remove Duplicates from Sorted List II  http://blog.csdn.net/yyz20002008/article/details/34431303#</comment>
<code>public class Solution {
public ListNode deleteDuplicates(ListNode head) {
// Start typing your Java solution below
// DO NOT write main() function
ListNode prev = new ListNode(0);
prev.next = head;
head = prev;

ListNode n1=head;
while(n1.next!=null){
ListNode n2=n1.next;
while(n2.next!=null &amp;&amp; n2.next.val==n2.val){
n2=n2.next;
}
if(n2!=n1.next){
n1.next=n2.next;//这句话是为了删除重复元素的最后一个元素，因为上一个while总是会在重复元素的最后一个元素停住，并且如果不是删除了重复元素的话 n2是不会不等于n1.next的，所以让n1.next和现在的n2.next指向一样，就是指向下一个不重复的元素
}else{
n1=n1.next;
}
}
return head.next;
}
}
public class Solution {
public ListNode deleteDuplicates(ListNode head) {
if (head == null || head.next == null)
return head;
ListNode backhead = new ListNode(0);
backhead.next = head;
ListNode pre = backhead;
ListNode cur = head;
ListNode nex = head.next;
boolean delstate = false;
while (nex != null) {
if (nex.val == cur.val) {
delstate = true;
} else {
if (delstate) {
pre.next = nex; //if 循环有一点多，但是是在这一步跳过所有重复元素的
delstate = false;
} else {
pre = cur;
}
}
cur = nex;
nex = nex.next;
}
if(delstate)
pre.next = null; //这应该是在head后所有元素都是重复的时候用到吧
return backhead.next;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>471054</snippet_key>
<tag>编码</tag>
<comment>来自CSDN博客：Java字符编码转换研究  http://blog.csdn.net/zhongwen7710/article/details/39376047#</comment>
<code>publicstatic boolean isValidUtf8(byte[] b,int aMaxCount){
int lLen=b.length,lCharCount=0;
for(int i=0;i&lt;lLen &amp;&amp; lCharCount&lt;aMaxCount;++lCharCount){
byte lByte=b[i++];//to fast operation, ++ now, ready for the following for(;;)
if(lByte&gt;=0) continue;//&gt;=0 is normal ascii
if(lByte&lt;(byte)0xc0 || lByte&gt;(byte)0xfd) return false;
int lCount=lByte&gt;(byte)0xfc?5:lByte&gt;(byte)0xf8?4
:lByte&gt;(byte)0xf0?3:lByte&gt;(byte)0xe0?2:1;
if(i+lCount&gt;lLen) return false;
for(int j=0;j&lt;lCount;++j,++i) if(b[i]&gt;=(byte)0xc0) return false;
}
return true;
}
publicstatic String getUrlParam(String aStr,String aDefaultCharset)
throwsUnsupportedEncodingException{
if(aStr==null) return null;
byte[] lBytes=aStr.getBytes(&quot;ISO-8859-1&quot;);
return newString(lBytes,StringUtil.isValidUtf8(lBytes)?&quot;utf8&quot;:aDefaultCharset);
}
assertEquals(160, Charset.availableCharsets().size());
Set&lt;String&gt; charsetNames = Charset.availableCharsets().keySet();
assertTrue(charsetNames.contains(&quot;utf-8&quot;));
assertTrue(charsetNames.contains(&quot;utf-16&quot;));
assertTrue(charsetNames.contains(&quot;gb2312&quot;));
assertTrue(Charset.isSupported(&quot;utf-8&quot;));
InputStream is = new FileInputStream(&quot;res/input2.data&quot;);
InputStreamReader streamReader = new InputStreamReader(is, &quot;GB18030&quot;);
assertEquals(&quot;GB18030&quot;, streamReader.getEncoding());
1. char[] chars = new char[is.available()];
2. streamReader.read(chars, 0, is.available());
1. InputStream is = new FileInputStream(&quot;res/input2.data&quot;);
2. InputStreamReader streamReader = new InputStreamReader(is);
1. Charset.defaultCharset();
1. &quot;string&quot;.getBytes();
1. &quot;string&quot;.getBytes(Charset.defaultCharset());
1. new String(&quot;string&quot;.getBytes());
1. new String(input.getBytes(&quot;ISO-8859-1&quot;), &quot;GB18030&quot;)
public static void main(String args[])
{
System.out.println(&quot;default charset : &quot;+Charset.defaultCharset());
String str = &quot;abc你好&quot;;//string with UTF-8 charset

byte[] bytes = str.getBytes(Charset.forName(&quot;UTF-8&quot;));//convert to byte array with UTF-8 encode
for (byte b : bytes)
{
System.out.print(b + &quot; &quot;);
}
System.out.println();
try
{
String str1 = new String(bytes, &quot;UTF-8&quot;);//to UTF-8 string
String str2 = new String(bytes, &quot;ISO-8859-1&quot;);//to ISO-8859-1 string
String str3 = new String(bytes, &quot;GBK&quot;);//to GBK string

System.out.println(str1);//abc你好
System.out.println(str2);//abc??????
System.out.println(str3);//abc浣犲ソ

System.out.println();
byte[] bytes2 = str2.getBytes(Charset.forName(&quot;ISO-8859-1&quot;));
for (byte b : bytes2)
{
System.out.print(b + &quot; &quot;);
}
System.out.println();
String str22 = new String(bytes2, &quot;UTF-8&quot;);
System.out.println(str22);//abc你好

System.out.println();
byte[] bytes3 = str3.getBytes(Charset.forName(&quot;GBK&quot;));
for (byte b : bytes3)
{
System.out.print(b + &quot; &quot;);
}
System.out.println();
String str33 = new String(bytes3, &quot;UTF-8&quot;);
System.out.println(str33);//abc你好
} catch (UnsupportedEncodingException e)
{
e.printStackTrace();
}
}
default charset : GBK
97 98 99 -28 -67 -96 -27 -91 -67
abc你好
abc??????
abc浣犲ソ

97 98 99 -28 -67 -96 -27 -91 -67
abc你好

97 98 99 -28 -67 -96 -27 -91 -67
abc你好
</code>
</RECORD>
<RECORD>
<snippet_key>78094</snippet_key>
<tag></tag>
<comment>来自CSDN博客：小操作  http://blog.csdn.net/u010410408/article/details/14223727#</comment>
<code>/** 判断是否是手机号 */
private boolean isMobileNO(String mobiles) {
Pattern p = Pattern
.compile(&quot;^((13[0-9])|(15[^4,\\D])|(18[0,5-9]))\\d{8}$&quot;);
Matcher m = p.matcher(mobiles);
System.out.println(m.matches() + &quot;---&quot;);
return m.matches();
}
int[] ids = {R.id.star1,R.id.star2,R.id.star3,R.id.star4,R.id.star5};
for(int x = 0;x&lt;size;x++){
ImageView star = (ImageView) ll.findViewById(ids[x]);
star.setImageResource(R.drawable.star_golden);
}
iv_slide.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
public void onGlobalLayout() {
iv_slide.getViewTreeObserver().removeGlobalOnLayoutListener(this);
LayoutParams params = (LayoutParams) iv_slide.getLayoutParams();
params.width = tv_conversation.getWidth();
params.height = tv_conversation.getHeight();
params.leftMargin = tv_conversation.getLeft();
params.topMargin = tv_conversation.getTop();
iv_slide.setLayoutParams(params);
}
});
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

&lt;item android:state_pressed=&quot;true&quot; android:color=&quot;#d3d3d3&quot;/&gt;
&lt;item android:color=&quot;#ffffff&quot;/&gt;

&lt;/selector&gt;
android:textColor=&quot;@drawable/login_textcolor_selector&quot;
&lt;!-- textcolor与textcolor 都是选择器--&gt;
&lt;TextView
android:background=&quot;@drawable/city_button_background&quot;
android:drawableRight=&quot;@drawable/imagecolor&quot;
android:paddingRight=&quot;3dp&quot;
android:text=&quot;test&quot;
android:textColor=&quot;@drawable/textcolor&quot; /&gt;  
Intent intent = new Intent();
intent.setAction(&quot;android.media.action.IMAGE_CAPTURE&quot;);
intent.addCategory(&quot;android.intent.category.DEFAULT&quot;);
//指出照片存储的路径
File file = new File(Environment.getExternalStorageDirectory().getPath()+&quot;/image.jpg&quot;);
Uri uri = Uri.fromFile(file);
intent.putExtra(MediaStore.EXTRA_OUTPUT, uri);//将路径通过intent带到系统照相机中
startActivity(intent);
Paint p1 = new Paint();
p1.setXfermode(new PorterDuffXfermode(Mode.CLEAR));
canvas.drawPaint(p1);//清除原来的canvas中的图画
surfaceViewCreated//SurfaceView或其子类中的surfaceCreated()
mainactivitySurfaceCreated//别的类中的surfaceCreated()
surfaceChanged//SurfaceView或其子类中的surfaceChanged(）方法
main----surfaceChanged//别的类中的surfaceChanged()
&lt;activity android:theme=&quot;@android:style/Theme.Holo.Dialog&quot; &gt;
DatePickerDialog dialog = new DatePickerDialog(MainActivity.this, new OnDateSetListener() {
public void onDateSet(DatePicker view, int year, int monthOfYear,
int dayOfMonth) {
Toast.makeText(MainActivity.this, year+&quot;年&quot;+monthOfYear+&quot;月&quot;+dayOfMonth+&quot;日&quot;, Toast.LENGTH_SHORT).show();
}
}, 2013, 10, 5);//月份是本月-1。
dialog.show();
canvas.drawText(&quot;gaf&quot;, 60, 60, paint);//paint是默认的设置
canvas.drawLine(0, 0, 60, 60, paint);
canvas.drawLine(0, 60, 250, 60, paint);
canvas.drawLine(60,0,60,250,paint);
&lt;pre&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>291077</snippet_key>
<tag></tag>
<comment>来自CSDN博客：解决Camera.parameter.setPreviewSize/Camera.parameter.setPictureSize适应不同手机问题  http://blog.csdn.net/guluo2010/article/details/23664995#</comment>
<code>解决类：（当然这个也是套用大师的！）
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import android.hardware.Camera;
import android.hardware.Camera.Size;

public class MyCamPara {
private final CameraSizeComparator sizeComparator = new CameraSizeComparator();
private static MyCamPara myCamPara = null;
private MyCamPara(){

}
public static MyCamPara getInstance(){
if(myCamPara == null){
myCamPara = new MyCamPara();
return myCamPara;
}
else{
return myCamPara;
}
}

public Size getPreviewSize(List&lt;Camera.Size&gt; list, int th){
Collections.sort(list, sizeComparator);
Size size=null;
for(int i=0;i&lt;list.size();i++){
size=list.get(i);
if((size.width&gt;th)&amp;&amp;equalRate(size, 1.3f)){
break;
}
}
return size;
}
public Size getPictureSize(List&lt;Camera.Size&gt; list, int th){
Collections.sort(list, sizeComparator);
Size size=null;
for(int i=0;i&lt;list.size();i++){
size=list.get(i);
if((size.width&gt;th)&amp;&amp;equalRate(size, 1.3f)){
break;
}
}
return size;

}

public boolean equalRate(Size s, float rate){
float r = (float)(s.width)/(float)(s.height);
if(Math.abs(r - rate) &lt;= 0.2)
{
return true;
}
else{
return false;
}
}

public class CameraSizeComparator implements Comparator&lt;Camera.Size&gt;{
//按升序排列
@Override
public int compare(Size lhs, Size rhs) {
// TODO Auto-generated method stub
if(lhs.width == rhs.width){
return 0;
}
else if(lhs.width &gt; rhs.width){
return 1;
}
else{
return -1;
}
}

}
}
private static Size pictureSize,previewSize;
pictureSize= MyCamPara.getInstance().getPictureSize(parameter.getSupportedPictureSizes(), 800);
//预览大小
previewSize=MyCamPara.getInstance().getPreviewSize(parameter.getSupportedPreviewSizes(), display.getHeight());
if(previewSize!=null)
parameter.setPreviewSize(previewSize.width,previewSize.height);
if(pictureSize!=null)
parameter.setPictureSize(pictureSize.width,pictureSize.height);
</code>
</RECORD>
<RECORD>
<snippet_key>291333</snippet_key>
<tag></tag>
<comment>来自CSDN博客：设计模式--状态模式State(行为型） http://blog.csdn.net/benbenxiongyuan/article/details/23676419#</comment>
<code>&lt;span style=&quot;font-size:18px;&quot;&gt;public abstract class State {
// 定义一个环境角色，提供子类访问
protected Context context;

// 设置环境角色
public void setContext(Context _context) {
this.context = _context;
}

// 行为1
public abstract void handle1();

// 行为2
public abstract void handle2();
}

public class ConcreteState1 extends State {
@Override
public void handle1() {
// 本状态下必须处理的逻辑
}

@Override
public void handle2() {
// 设置当前状态为stat2
super.context.setCurrentState(Context.STATE2);
// 过渡到state2状态，由Context实现
super.context.handle2();
}
}

public class ConcreteState2 extends State {
@Override
public void handle1() {
// 设置当前状态为stat1
super.context.setCurrentState(Context.STATE1);
// 过渡到state1状态，由Context实现
super.context.handle1();
}

@Override
public void handle2() {
// 本状态下必须处理的逻辑
}
}

public class Context {
// 定义状态
public final static State STATE1 = new ConcreteState1();
public final static State STATE2 = new ConcreteState2();
// 当前状态
private State CurrentState;

// 获得当前状态
public State getCurrentState() {
return CurrentState;
}

// 设置当前状态
public void setCurrentState(State currentState) {
this.CurrentState = currentState;
// 切换状态
this.CurrentState.setContext(this);
}

// 行为委托
public void handle1() {
this.CurrentState.handle1();
}

public void handle2() {
this.CurrentState.handle2();
}
}

public class Client {
public static void main(String[] args) {
// 定义环境角色
Context context = new Context();
// 初始化状态
context.setCurrentState(new ConcreteState1());
// 行为执行
context.handle1();
context.handle2();
}
}&lt;/span&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>422405</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：android 多线程网络模块实现  http://blog.csdn.net/lqydecsharp/article/details/36040071#</comment>
<code>//实例化访问模块
ThreadPage threadPage = new ThreadPage(Priority.PRIORITY_IDLE);
threadPage.setAutoDestory(true);
//注入一个实现runable接口的类，以及线程优先级
threadPage.execute(new userThread(), Priority.PRIORITY_NORM);
//ThreadPage中维护一个线程请求队列
private PriorityBlockingQueue&lt;AsyncTask&gt; priorityQueue;
priorityQueue = new PriorityBlockingQueue&lt;AsyncTask&gt;(200,new PriorityComparator()）;
&lt;/pre&gt;&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>487941</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：java多线程设置优先级 http://blog.csdn.net/jianghuihong2012/article/details/40210819#</comment>
<code>package com.itbuluoge.mythread;

class SimpleThread extends Thread
{
private int priority;
public SimpleThread(int i)
{
priority=i;
}
public void run()
{
Thread.currentThread().setPriority(priority);
for(int i=0;i&lt;10000;i++)
{
try {
Thread.sleep(100);
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}

System.out.println(priority);
}
}
}
public class PriorityDemo {

/**
* @param args
*/
public static void main(String[] args) {
// TODO Auto-generated method stub
SimpleThread high=new SimpleThread(Thread.MAX_PRIORITY);
SimpleThread low=new SimpleThread(Thread.MIN_PRIORITY);

high.start();
low.start();
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>160517</snippet_key>
<tag>408</tag>
<comment>来自CSDN博客：JAVA基础——异常处理  http://blog.csdn.net/wknlm0001/article/details/18400207#</comment>
<code>class Demo
{
double divd(int a,int b) throws Exception //在功能上通过throws的关键字声明了该功能有可能会出现问题。----声明异常
{
return a/b;
}
}
class ExceptionDemo
{
public static void main(String[] args)
{

Demo d=new Demo();
try
{
System.out.println(d.divd(4,0));
}
catch (Exception e)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;//可以通过e调用Exception类中方法
{
System.out.println(&quot;被零除啦！&quot;);
System.out.println(e.getMessage());// / by zero;
System.out.println(e.toString());// 异常名称 ： 异常信息。
e.printStackTrace();//异常名称，异常信息，异常出现的位置。
//其实jvm默认的异常处理机制，就是在调用printStackTrace方法。
//打印异常的堆栈的跟踪信息。
}
System.out.println(&quot;over&quot;);
}
}
class Demo
{
double divd(int a,int b) throws Exception //在功能上通过throws的关键字声明了该功能有可能会出现问题。
{
return a/b;
}
}
class ExceptionDemo
{
public static void main(String[] args) throws Exception //此时没有调用者了，JVM默认处理
{
Demo d=new Demo();
System.out.println(d.divd(4,0));
System.out.println(&quot;over&quot;);
}
}
class FuShuException extends Exception //必须继承Exception类
{
private int b;
FuShuException()
{
super();
}
FuShuException(String msg,int b)
{
super(msg); //调用Exception类中的带String参数的方法
this.b=b;
}
int getValue()
{
return b;
}
}
class Demo
{
double divde(int a, int b) throws FuShuException
{
if(b&lt;0)
throw new FuShuException(&quot;不能是负数！&quot;,b); //抛出自定义异常对象，如果判读成立，就把异常抛出。
return a/b;
}
}
class ExceptionDemo2
{
public static void main(String[] args)
{
Demo d=new Demo();
try
{
System.out.println(&quot;输出:&quot;+d.divde(6,-2));
}
catch (Exception e) //多态特性
{
System.out.println(e.toString()); //输出：FuShuException:不能是负数！
System.out.println(e.getMessage());//输出：不能是负数！
System.out.println(e.getValue());//编译出错,多态原因，Exception中并没有getValue方法。需要将catch括号中改为FuShuException
}
System.out.println(&quot;over&quot;);
}
}
void method() throws Exception
{
try
{
throw new Exception();
}
finally
{
//关资源。
}
}
/*
Exception
|--AException
|--BException
|--CException
*/
class Fu
{
void show()throws AException
{

}
}


class Zi extends Fu
{
void show()throws AException //AException可以，BException可以，CException不可以
{

}
}
</code>
</RECORD>
<RECORD>
<snippet_key>275470</snippet_key>
<tag>android Fragment</tag>
<comment>来自CSDN博客：Fragment继承类的简单解析 http://blog.csdn.net/zhongwcool/article/details/22950967#</comment>
<code>/**
* A placeholder fragment containing a simple view.
*/
public static class PlaceholderFragment extends Fragment {
/**
* The fragment argument representing the section number for this
* fragment.
*/
private static final String ARG_SECTION_NUMBER = &quot;section_number&quot;;

/**
* Returns a new instance of this fragment for the given section number.
*/
public static PlaceholderFragment newInstance(int sectionNumber) {//sectionNumber代表哪个section被点击
PlaceholderFragment fragment = new PlaceholderFragment();
Bundle args = new Bundle();
args.putInt(ARG_SECTION_NUMBER, sectionNumber);
fragment.setArguments(args);
return fragment;
}

public PlaceholderFragment() {
}

@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container,
Bundle savedInstanceState) {
View rootView = inflater.inflate(R.layout.fragment_main, container,
false);//使用LayoutInflater，其实可以自由扩展Fragment的View内容
TextView textView = (TextView) rootView
.findViewById(R.id.section_label);
textView.setText(&quot;大家好，我是第&quot; + Integer.toString(getArguments().getInt(
ARG_SECTION_NUMBER)) + &quot;区&quot;);
return rootView;//这里使用layout布局文件，只扩展了简单的问题展示信息
}

@Override
public void onAttach(Activity activity) {
super.onAttach(activity);
((MainActivity) activity).onSectionAttached(getArguments().getInt(
ARG_SECTION_NUMBER));//不知的onAttach在什么时间被调用，但是onSectionAttached是自定义 //方法，改变ActionBar的title的内容！
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>422661</snippet_key>
<tag></tag>
<comment>来自CSDN博客：插入耳机时继续使用外音播放  http://blog.csdn.net/fans1108/article/details/37568795#</comment>
<code>AudioManager manager = (AudioManager) getActivity()
.getSystemService(Context.AUDIO_SERVICE);
manager.setMicrophoneMute(false);
manager.setSpeakerphoneOn(true);
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;registerReceiver(mHeadsetPlugReceiver,new IntentFilter(&quot;android.intent.action.HEADSET_PLUG&quot;));
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;class HeadsetPlugReceiver extends BroadcastReceiver {

@Override
public void onReceive(Context context, Intent intent) {
// TODO Auto-generated method stub
if (intent.getAction().equals(CJConstant.HEADSET_ACTION)) {
int state = intent.getIntExtra(&quot;state&quot;,
CJConstant.UNCONNECTED_HEADSET);
int hasMic = intent.getIntExtra(&quot;microphone&quot;, -1);
if (state == 1) {
CJApplication.isHeadSetConnected = true;
LogUtil.i(&quot;&quot;, &quot;耳机插入:hasMic=&quot; + hasMic);
if (hasMic == 1) {
LogUtil.i(&quot;&quot;, &quot;有麦克风&quot;);
} else if (hasMic == 0) {
LogUtil.i(&quot;&quot;, &quot;没有麦克风&quot;);
}
} else if (state == 0) {
CJApplication.isHeadSetConnected = false;
LogUtil.i(&quot;&quot;, &quot;耳机拔出&quot;);

}
}
AudioManager manager = (AudioManager) getActivity()
.getSystemService(Context.AUDIO_SERVICE);
if (CJApplication.isHeadSetConnected) {
manager.setMode(AudioManager.MODE_IN_CALL);
setVolumeControlStream(
AudioManager.STREAM_VOICE_CALL);
} else {
manager.setMode(AudioManager.MODE_NORMAL);
setVolumeControlStream(AudioManager.STREAM_MUSIC);
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>95237</snippet_key>
<tag></tag>
<comment>来自CSDN博客：联网版五子棋  http://blog.csdn.net/jackfrued/article/details/17101821#</comment>
<code>package com.accp;

import java.awt.Color;
import java.awt.Graphics;

/**
* 棋盘
* @author 骆昊
*
*/
public class Board {
private int[][] board = new int[15][15]; // 用二维数组代表15*15的棋盘

/**
* 绘制棋盘
* @param g 画笔
*/
public void draw(Graphics g) {
for(int i = 0; i &lt; board.length; i++) {
for(int j = 0; j &lt; board[i].length; j++) {
if(board[i][j] != 0) { // 不是空格
if(board[i][j] == 1) { // 黑子
g.setColor(Color.BLACK);
}
else { // 白子
g.setColor(Color.WHITE);
}
g.fillOval(35 * (j + 1), 35 * (i + 1), 30, 30);
if(board[i][j] == 2) { // 给白子加上边框
g.setColor(Color.BLACK);
g.drawOval(35 * (j + 1), 35 * (i + 1), 30, 30);
}
}
}
}
}

/**
* 向棋盘中放置棋子
* @param row 放置棋子的行
* @param col 放置棋子的列
* @param isBlack 黑棋还是白棋
* @return 返回true落子成功, 返回false落子失败(已经有棋子)
*/
public boolean addPiece(int row, int col, boolean isBlack) {
if(board[row][col] == 0) { // 没有棋子的地方才能落子
board[row][col] = isBlack? 1 : 2; // 1代表黑子2代表白子
return true;
}
return false;
}

/**
* 判断胜负
* @param row 落子的行
* @param col 落子的列
* @param isBlack 是黑子还是白子
* @return 获胜返回true否则返回false
*/
public boolean isWin(int row, int col, boolean isBlack) {
return checkH(row, col, isBlack) ||
checkV(row, col, isBlack) ||
checkX1(row, col, isBlack) ||
checkX2(row, col, isBlack);
}

// 判断从右上到左下的斜线上是否连成5颗棋子
private boolean checkX2(int row, int col, boolean isBlack) {
int counter = 1;
int currentRow = row;
int currentCol = col;
int v = isBlack? 1 : 2;
while(currentRow &gt; 0 &amp;&amp; currentCol &lt; 14 &amp;&amp;
board[--currentRow][++currentCol] == v) {
counter++;
}
currentRow = row;
currentCol = col;
while(currentRow &lt; 14 &amp;&amp; currentCol &gt; 0 &amp;&amp;
board[++currentRow][--currentCol] == v) {
counter++;
}
return counter &gt;= 5;
}

// 判断从左上到右下的斜线上是否连成5颗棋子
private boolean checkX1(int row, int col, boolean isBlack) {
int counter = 1;
int currentRow = row;
int currentCol = col;
int v = isBlack? 1 : 2;
while(currentRow &gt; 0 &amp;&amp; currentCol &gt; 0 &amp;&amp;
board[--currentRow][--currentCol] == v) {
counter++;
}
currentRow = row;
currentCol = col;
while(currentCol &lt; 14 &amp;&amp; currentRow &lt; 14 &amp;&amp;
board[++currentRow][++currentCol] == v) {
counter++;
}
return counter &gt;= 5;
}

// 判断竖着方向上是否连成5颗棋子
private boolean checkV(int row, int col, boolean isBlack) {
int counter = 1;
int currentRow = row;
int v = isBlack? 1 : 2;
while(currentRow &gt; 0 &amp;&amp; board[--currentRow][col] == v) {
counter++;
}
currentRow = row;
while(currentRow &lt; 14 &amp;&amp; board[++currentRow][col] == v) {
counter++;
}
return counter &gt;= 5;
}

// 判断横着方向上是否连成5颗棋子
private boolean checkH(int row, int col, boolean isBlack) {
int counter = 1;
int currentCol = col;
int v = isBlack? 1 : 2;
while(currentCol &gt; 0 &amp;&amp; board[row][--currentCol] == v) {
counter++;
}
currentCol = col;
while(currentCol &lt; 14 &amp;&amp; board[row][++currentCol] == v) {
counter++;
}
return counter &gt;= 5;
}
}
package com.accp;

import java.awt.Color;
import java.awt.Graphics;

import javax.swing.JPanel;

@SuppressWarnings(&quot;serial&quot;)
/**
* 绘制棋盘的面板
* @author 骆昊
*
*/
public class MyPanel extends JPanel {
private Board b = null;

public MyPanel(Board b) {
this.b = b;
}

@Override
public void paint(Graphics g) {
g.setColor(new Color(165, 185, 75));
g.fillRect(35, 35, 525, 525); // 绘制背景
g.setColor(Color.BLACK);
for (int i = 0; i &lt; 15; i++) { // 绘制棋盘网格
g.drawLine(50, 50 + i * 35, 540, 50 + i * 35);
g.drawLine(50 + i * 35, 50, 50 + i * 35, 540);
}
g.fillOval(290, 290, 10, 10); // 绘制天元
b.draw(g); // 绘制棋盘
}
}
package com.accp;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

@SuppressWarnings(&quot;serial&quot;)
public class MyFrame extends JFrame implements ActionListener {
private boolean isBlack = true; // 是否轮到黑棋
private Board b = new Board(); // 棋盘对象
private boolean isWin = false; // 是否获得胜利
private boolean isStart = false; // 是否联机成功开始游戏
private boolean isYourTurn = false; // 是否轮到自己走子

private DataInputStream din = null;
private DataOutputStream dout = null;

private class MouseHandler extends MouseAdapter {

@Override
public void mousePressed(MouseEvent e) {
if (isStart &amp;&amp; isYourTurn &amp;&amp; !isWin) { // 游戏已经开始并且轮到自己且未分出胜负则可落子
int x = e.getX();
int y = e.getY();
if (x &gt;= 50 &amp;&amp; x &lt;= 540 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= 540) { // 棋盘范围以内
// 通过鼠标坐标计算出点击棋盘的行和列
int row = Math.round((y - 50) / 35f);
int col = Math.round((x - 50) / 35f);
if (b.addPiece(row, col, isBlack)) { // 落子成功
repaint();
try { // 向对方棋盘发送刚才落子的位置(行、列)以及黑子还是白子
dout.writeInt(row);
dout.writeInt(col);
dout.writeBoolean(isBlack);
} catch (IOException ex) {
ex.printStackTrace();
}
isWin = b.isWin(row, col, isBlack); // 判断是否获胜
if (!isWin) {
isYourTurn = !isYourTurn; // 尚未分出胜负则交换走棋方
} else {
JOptionPane.showMessageDialog(null, isBlack ? &quot;黑棋胜&quot;
: &quot;白棋胜&quot;);
isWin = true;
repaint();
}
}
}
}
}
}

private JButton createGameButton, joinGameButton;
private JPanel boardPanel; // 绘制棋盘的面板

public MyFrame() {
this.setTitle(&quot;五子棋&quot;);
this.setSize(700, 600);
this.setResizable(false);
this.setLocationRelativeTo(null);
this.setDefaultCloseOperation(EXIT_ON_CLOSE);

boardPanel = new MyPanel(b);
boardPanel.setBounds(0, 0, 600, 600);
this.add(boardPanel);

boardPanel.addMouseListener(new MouseHandler()); // 向面板中添加鼠标监听器

this.setLayout(null);
createGameButton = new JButton(&quot;创建游戏&quot;);
createGameButton.setBounds(580, 100, 100, 35);
createGameButton.addActionListener(this);
joinGameButton = new JButton(&quot;加入游戏&quot;);
joinGameButton.setBounds(580, 160, 100, 35);
joinGameButton.addActionListener(this);
this.add(createGameButton);
this.add(joinGameButton);

// 创建一个线程监听对方走棋的消息
new Thread(new Runnable() {

public void run() {
while (true) { // 循环监听对方发送的走棋消息
while (isStart &amp;&amp; !isYourTurn) {
try {
// 读取对方落子的行列以及是黑子还是白子
int row = din.readInt();
int col = din.readInt();
boolean isBlack = din.readBoolean();
b.addPiece(row, col, isBlack); // 向棋盘添加对方走的棋子
repaint();
if(b.isWin(row, col, isBlack)) {
JOptionPane.showMessageDialog(null, isBlack ? &quot;黑棋胜&quot;
: &quot;白棋胜&quot;);
isWin = true;
repaint();
}
isYourTurn = !isYourTurn; // 收到对方棋子后交换走棋方
} catch (IOException ex) {
ex.printStackTrace();
}
}
}
}
}).start();
}

public static void main(String[] args) {
new MyFrame().setVisible(true);
}

@Override
public void actionPerformed(ActionEvent e) {
String command = e.getActionCommand();
if (command.equals(&quot;创建游戏&quot;)) {

// 创建一个线程启动服务器套接字
new Thread(new Runnable() {

@Override
public void run() {
try {
ServerSocket server = new ServerSocket(5566);
Socket client = server.accept();
din = new DataInputStream(client.getInputStream());
dout = new DataOutputStream(client.getOutputStream());
isStart = true;
isBlack = true;
isYourTurn = true;
} catch (IOException e) {
e.printStackTrace();
}
}
}).start();

joinGameButton.setEnabled(false);
} else if (command.equals(&quot;加入游戏&quot;)) {
String ip = JOptionPane.showInputDialog(this, &quot;请输入游戏主机IP地址或机器名: &quot;);
if(ip != null &amp;&amp; !ip.equals(&quot;&quot;)) {
try {
Socket client = new Socket(ip, 5566);
din = new DataInputStream(client.getInputStream());
dout = new DataOutputStream(client.getOutputStream());
isStart = true;
isYourTurn = false;
isBlack = false;
} catch (Exception ex) {
ex.printStackTrace();
}
repaint();
createGameButton.setEnabled(false);
}
}
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>160773</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Android 百度地图开发 POI搜索  http://blog.csdn.net/u012572538/article/details/18408725#</comment>
<code>package baidumapsdk.demo;

import android.app.Activity;
import android.os.Bundle;
import android.os.SystemClock;
import android.text.Editable;
import android.text.TextWatcher;
import android.util.Log;
import android.view.View;
import android.widget.ArrayAdapter;
import android.widget.AutoCompleteTextView;
import android.widget.EditText;
import android.widget.Toast;

import com.baidu.mapapi.BMapManager;
import com.baidu.mapapi.map.MapView;
import com.baidu.mapapi.search.MKAddrInfo;
import com.baidu.mapapi.search.MKBusLineResult;
import com.baidu.mapapi.search.MKDrivingRouteResult;
import com.baidu.mapapi.search.MKPoiInfo;
import com.baidu.mapapi.search.MKPoiResult;
import com.baidu.mapapi.search.MKSearch;
import com.baidu.mapapi.search.MKSearchListener;
import com.baidu.mapapi.search.MKShareUrlResult;
import com.baidu.mapapi.search.MKSuggestionInfo;
import com.baidu.mapapi.search.MKSuggestionResult;
import com.baidu.mapapi.search.MKTransitRouteResult;
import com.baidu.mapapi.search.MKWalkingRouteResult;
import com.baidu.platform.comapi.basestruct.GeoPoint;


/**
* 演示poi搜索功能
*/
public class PoiSearchDemo extends Activity {

private MapView mMapView = null;
private MKSearch mSearch = null; // 搜索模块，也可去掉地图模块独立使用
/**
* 搜索关键字输入窗口
*/
private AutoCompleteTextView keyWorldsView = null;
private ArrayAdapter&lt;String&gt; sugAdapter = null;
private int load_Index;
long starttime[];
@Override
public void onCreate(Bundle savedInstanceState) {

starttime[0] = SystemClock.uptimeMillis();
Log.d(null, Double.toString(starttime[0]));
super.onCreate(savedInstanceState);
DemoApplication app = (DemoApplication)this.getApplication();
if (app.mBMapManager == null) {
app.mBMapManager = new BMapManager(this);
app.mBMapManager.init(DemoApplication.strKey,new DemoApplication.MyGeneralListener());
}
setContentView(R.layout.activity_poisearch);
mMapView = (MapView)findViewById(R.id.bmapView);
mMapView.getController().enableClick(true);
mMapView.getController().setZoom(12);
mMapView.setBuiltInZoomControls(true);
// 设置启用内置的缩放控件


// 初始化搜索模块，注册搜索事件监听
mSearch = new MKSearch();
mSearch.init(app.mBMapManager, new MKSearchListener(){
//在此处理详情页结果
@Override
public void onGetPoiDetailSearchResult(int type, int error) {
if (error != 0) {
Toast.makeText(PoiSearchDemo.this, &quot;抱歉，未找到结果&quot;, Toast.LENGTH_SHORT).show();
}
else {
Toast.makeText(PoiSearchDemo.this, &quot;成功，查看详情页面&quot;, Toast.LENGTH_SHORT).show();
}
}
/**
* 在此处理poi搜索结果
*/


public void onGetPoiResult(MKPoiResult res, int type, int error) {

starttime[1] = SystemClock.uptimeMillis();

// 错误号可参考MKEvent中的定义
if (error != 0 || res == null) {
Toast.makeText(PoiSearchDemo.this, &quot;抱歉，未找到结果&quot;, Toast.LENGTH_LONG).show();
return;
}
// 将地图移动到第一个POI中心点
if (res.getCurrentNumPois() &gt; 0) {
// 将poi结果显示到地图上
MyPoiOverlay poiOverlay = new MyPoiOverlay(PoiSearchDemo.this, mMapView, mSearch);
poiOverlay.setData(res.getAllPoi());
mMapView.getOverlays().clear();
mMapView.getOverlays().add(poiOverlay);
mMapView.refresh();
//当ePoiType为2（公交线路）或4（地铁线路）时， poi坐标为空
for( MKPoiInfo info : res.getAllPoi() ){
if ( info.pt != null ){
mMapView.getController().animateTo(info.pt);
break;
}
}
} else if (res.getCityListNum() &gt; 0) {
//当输入关键字在本市没有找到，但在其他城市找到时，返回包含该关键字信息的城市列表
String strInfo = &quot;在&quot;;
for (int i = 0; i &lt; res.getCityListNum(); i++) {
strInfo += res.getCityListInfo(i).city;
strInfo += &quot;,&quot;;
}
strInfo += &quot;找到结果&quot;;
Toast.makeText(PoiSearchDemo.this, strInfo, Toast.LENGTH_LONG).show();
}
}
public void onGetDrivingRouteResult(MKDrivingRouteResult res,
int error) {
}
public void onGetTransitRouteResult(MKTransitRouteResult res,
int error) {
}
public void onGetWalkingRouteResult(MKWalkingRouteResult res,
int error) {
}
public void onGetAddrResult(MKAddrInfo res, int error) {

starttime [2] =SystemClock.uptimeMillis();

if (error != 0) {
String str = String.format(&quot;错误号：%d&quot;, error);
Toast.makeText(PoiSearchDemo.this, str, Toast.LENGTH_LONG).show();
return;
}
//地图移动到该点
mMapView.getController().animateTo(res.geoPt);
if (res.type == MKAddrInfo.MK_GEOCODE){
//地理编码：通过地址检索坐标点
GeoPoint position = new GeoPoint (res.geoPt.getLatitudeE6(),res.geoPt.getLongitudeE6());
// mSearch.poiSearchNearBy(&quot;KFC&quot;, position, 5000);//可用
EditText editSearchKey = (EditText)findViewById(R.id.searchkey);
EditText editSearchDistance = (EditText)findViewById(R.id.distance);
int dis =Integer.parseInt(editSearchDistance.getText().toString());
mSearch.poiSearchNearBy(editSearchKey.getText().toString(), position, dis);//
//String strInfo = String.format(&quot;纬度：%f 经度：%f&quot;, res.geoPt.getLatitudeE6()/1e6, res.geoPt.getLongitudeE6()/1e6);
//Toast.makeText(PoiSearchDemo.this, strInfo, Toast.LENGTH_LONG).show(); //这里注释了
//mSearch.poiSearchNearBy(&quot;餐厅&quot;,new GeoPoint(res.geoPt.getLatitudeE6(), res.geoPt.getLongitudeE6()) , 5000);//

//MyPoiOverlay poiOverlay = new MyPoiOverlay(GeoCoderDemo.this, mMapView, mSearch);

}
}

public void onGetBusDetailResult(MKBusLineResult result, int iError) {
}
/**
* 更新建议列表
*/
@Override
public void onGetSuggestionResult(MKSuggestionResult res, int arg1) {
if ( res == null || res.getAllSuggestions() == null){
return ;
}
sugAdapter.clear();
for ( MKSuggestionInfo info : res.getAllSuggestions()){
if ( info.key != null)
sugAdapter.add(info.key);
}
sugAdapter.notifyDataSetChanged();

}
@Override
public void onGetShareUrlResult(MKShareUrlResult result, int type,
int error) {
// TODO Auto-generated method stub

}
});

keyWorldsView = (AutoCompleteTextView) findViewById(R.id.searchkey);
sugAdapter = new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_dropdown_item_1line);
keyWorldsView.setAdapter(sugAdapter);

/**
* 当输入关键字变化时，动态更新建议列表
*/
keyWorldsView.addTextChangedListener(new TextWatcher(){

@Override
public void afterTextChanged(Editable arg0) {

}

@Override
public void beforeTextChanged(CharSequence arg0, int arg1,
int arg2, int arg3) {

}
@Override
public void onTextChanged(CharSequence cs, int arg1, int arg2,
int arg3) {
if ( cs.length() &lt;=0 ){
return ;
}
String city = ((EditText)findViewById(R.id.city)).getText().toString();
/**
* 使用建议搜索服务获取建议列表，结果在onSuggestionResult()中更新
*/
mSearch.suggestionSearch(cs.toString(), city);
}
});

}

@Override
protected void onPause() {
mMapView.onPause();
super.onPause();
}

@Override
protected void onResume() {
mMapView.onResume();
super.onResume();
}

@Override
protected void onDestroy(){
mMapView.destroy();
mSearch.destory();
super.onDestroy();

starttime [4] = SystemClock.uptimeMillis();

}

@Override
protected void onSaveInstanceState(Bundle outState) {
super.onSaveInstanceState(outState);
mMapView.onSaveInstanceState(outState);

}

@Override
protected void onRestoreInstanceState(Bundle savedInstanceState) {
super.onRestoreInstanceState(savedInstanceState);
mMapView.onRestoreInstanceState(savedInstanceState);
}

private void initMapView() {
mMapView.setLongClickable(true);
mMapView.getController().setZoom(14);
mMapView.getController().enableClick(true);
mMapView.setBuiltInZoomControls(true);
}
/**
* 影响搜索按钮点击事件
* @param v
*/
public void searchButtonProcess(View v) {

starttime [3] =SystemClock.uptimeMillis();

EditText editCity = (EditText)findViewById(R.id.city);

//从这里开始添加的
// EditText editGeoCodeKey = (EditText)findViewById(R.id.geocodekey);
// mBtnGeoCode.setOnClickListener(clickListener); //

EditText editSearchKey = (EditText)findViewById(R.id.searchkey);
EditText editGeoCodeKey = (EditText)findViewById(R.id.geocodekey);
mSearch.geocode(editGeoCodeKey.getText().toString(), editCity.getText().toString());
// mSearch.poiSearchNearBy(&quot;KFC&quot;, new GeoPoint((int) (39.920 * 1E6), (int) (116.410 * 1E6)), 5000);//
// mSearch.poiSearchNearBy(&quot;KFC&quot;, position, 5000);//
//mSearch.poiSearchInCity(editCity.getText().toString(),
// editSearchKey.getText().toString());
}
public void goToNextPage(View v) {
//搜索下一组poi
int flag = mSearch.goToPoiPage(++load_Index);
if (flag != 0) {
Toast.makeText(PoiSearchDemo.this, &quot;先搜索开始，然后再搜索下一组数据&quot;, Toast.LENGTH_SHORT).show();
// Log.
}
}

}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout
xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:orientation=&quot;vertical&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;fill_parent&quot;
&gt;

&lt;LinearLayout

android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;50dip&quot;
android:orientation=&quot;horizontal&quot; &gt;

&lt;!-- &lt;TextView
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;在&quot; &gt;
&lt;/TextView&gt; --&gt;

&lt;EditText
android:id=&quot;@+id/city&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;match_parent&quot;
android:text=&quot;北京&quot; /&gt;
&lt;EditText
android:id=&quot;@+id/geocodekey&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;微软大厦&quot; /&gt;
&lt;EditText
android:id=&quot;@+id/distance&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;1000&quot; /&gt;


&lt;TextView
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:text=&quot;找&quot; &gt;
&lt;/TextView&gt;

&lt;AutoCompleteTextView
android:id=&quot;@+id/searchkey&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:layout_weight=&quot;0.88&quot;
android:text=&quot;餐厅&quot; /&gt;
&lt;/LinearLayout&gt;

&lt;LinearLayout

android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;50dip&quot;
android:orientation=&quot;horizontal&quot; &gt;
&lt;Button
android:id=&quot;@+id/search&quot;
android:layout_height=&quot;wrap_content&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_weight=&quot;12&quot;
android:padding=&quot;10dip&quot;
android:background=&quot;@drawable/button_style&quot;
android:onClick=&quot;searchButtonProcess&quot;
android:text=&quot;开始&quot; /&gt;

&lt;!-- &lt;Button
android:id=&quot;@+id/map_next_data&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_weight=&quot;12&quot;
android:layout_height=&quot;wrap_content&quot;
android:padding=&quot;10dip&quot;
android:background=&quot;@drawable/button_style&quot;
android:onClick=&quot;goToNextPage&quot;
android:text=&quot;下一组数据&quot; /&gt; --&gt;
&lt;/LinearLayout&gt;

&lt;com.baidu.mapapi.map.MapView android:id=&quot;@+id/bmapView&quot;
android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot;
android:clickable=&quot;true&quot;
/&gt;
&lt;/LinearLayout&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>291845</snippet_key>
<tag>来自CSDN博客：解决Android手机 屏幕横竖屏切换 http://blog.csdn.net/qaz13177_58_/article/details/23268185#</tag>
<comment>派生自qaz13177_58_/blog_20140409_1_2214914</comment>
<code>application android:icon=&quot;@drawable/icon&quot; android:label=&quot;@string/app_name&quot;&gt;
&lt;activity android:name=&quot;.MainActivity&quot;
android:label=&quot;@string/app_name&quot; android:configChanges=&quot;orientation|keyboardHidden&quot;&gt;
&lt;intent-filter&gt;
&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
&lt;/intent-filter&gt;
&lt;/activity&gt;
&lt;/application&gt;
public class MainActivity extends Activity {
private TextView textView;
@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
Log.i(&quot;--Main--&quot;, &quot;onCreate&quot;);
textView=(TextView)findViewById(R.id.tv_id);
}


@Override
public void onConfigurationChanged(Configuration newConfig) {
super.onConfigurationChanged(newConfig);
Log.i(&quot;--Main--&quot;, &quot;onConfigurationChanged&quot;);
if(newConfig.orientation==Configuration.ORIENTATION_LANDSCAPE){
textView.setText(&quot;当前屏幕为横屏&quot;);
}else{
textView.setText(&quot;当前屏幕为竖屏&quot;);
}
}

}
private OnClickListener onClick=new OnClickListener() {
@Override
public void onClick(View v) {
//设置屏幕为横屏
if(v==butLandscrpe){
MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
//设置为置屏幕为竖屏
}else{
MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
}
}
};

//监听系统设置的更改
@Override
public void onConfigurationChanged(Configuration newConfig) {
super.onConfigurationChanged(newConfig);
String message=newConfig.orientation==Configuration.ORIENTATION_LANDSCAPE ? &quot;屏幕设置为：横屏&quot; : &quot;屏幕设置为：竖屏&quot;;
showToast(message);
}
</code>
</RECORD>
<RECORD>
<snippet_key>210190</snippet_key>
<tag>326</tag>
<comment>来自CSDN博客：Java数据库连接池总结  http://blog.csdn.net/wenbitianxiafeng/article/details/20137033#</comment>
<code>/**
* 数据库连接池类
*/
package com.chunkyo.db;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Timer;

/**
* @author chenyanlin
*
*/
public class DBConnectionPool implements TimerListener {
private Connection con = null;
private int inUsed = 0; // 使用的连接数
private ArrayList freeConnections = new ArrayList();// 容器，空闲连接
private int minConn; // 最小连接数
private int maxConn; // 最大连接
private String name; // 连接池名字
private String password; // 密码
private String url; // 数据库连接地址
private String driver; // 驱动
private String user; // 用户名
public Timer timer; // 定时

/**
*
*/
public DBConnectionPool() {
// TODO Auto-generated constructor stub
}

/**
* 创建连接池
*
* @param driver
* @param name
* @param URL
* @param user
* @param password
* @param maxConn
*/
public DBConnectionPool(String name, String driver, String URL,
String user, String password, int maxConn) {
this.name = name;
this.driver = driver;
this.url = URL;
this.user = user;
this.password = password;
this.maxConn = maxConn;
}

/**
* 用完，释放连接
*
* @param con
*/
public synchronized void freeConnection(Connection con) {
this.freeConnections.add(con);// 添加到空闲连接的末尾
this.inUsed--;
}

/**
* timeout 根据timeout得到连接
*
* @param timeout
* @return
*/
public synchronized Connection getConnection(long timeout) {
Connection con = null;
if (this.freeConnections.size() &gt; 0) {
con = (Connection) this.freeConnections.get(0);
if (con == null)
con = getConnection(timeout); // 继续获得连接
} else {
con = newConnection(); // 新建连接
}
if (this.maxConn == 0 || this.maxConn &lt; this.inUsed) {
con = null;// 达到最大连接数，暂时不能获得连接了。
}
if (con != null) {
this.inUsed++;
}
return con;
}

/**
*
* 从连接池里得到连接
*
* @return
*/
public synchronized Connection getConnection() {
Connection con = null;
if (this.freeConnections.size() &gt; 0) {
con = (Connection) this.freeConnections.get(0);
this.freeConnections.remove(0);// 如果连接分配出去了，就从空闲连接里删除
if (con == null)
con = getConnection(); // 继续获得连接
} else {
con = newConnection(); // 新建连接
}
if (this.maxConn == 0 || this.maxConn &lt; this.inUsed) {
con = null;// 等待 超过最大连接时
}
if (con != null) {
this.inUsed++;
System.out.println(&quot;得到 &quot; + this.name + &quot; 的连接，现有&quot; + inUsed
+ &quot;个连接在使用!&quot;);
}
return con;
}

/**
* 释放全部连接
*
*/
public synchronized void release() {
Iterator allConns = this.freeConnections.iterator();
while (allConns.hasNext()) {
Connection con = (Connection) allConns.next();
try {
con.close();
} catch (SQLException e) {
e.printStackTrace();
}

}
this.freeConnections.clear();

}

/**
* 创建新连接
*
* @return
*/
private Connection newConnection() {
try {
Class.forName(driver);
con = DriverManager.getConnection(url, user, password);
} catch (ClassNotFoundException e) {
// TODO Auto-generated catch block
e.printStackTrace();
System.out.println(&quot;sorry can&apos;t find db driver!&quot;);
} catch (SQLException e1) {
// TODO Auto-generated catch block
e1.printStackTrace();
System.out.println(&quot;sorry can&apos;t create Connection!&quot;);
}
return con;

}

/**
* 定时处理函数
*/
public synchronized void TimerEvent() {
// 暂时还没有实现以后会加上的
}

/**
* @param args
*/
public static void main(String[] args) {
// TODO Auto-generated method stub
}

/**
* @return the driver
*/
public String getDriver() {
return driver;
}

/**
* @param driver
* the driver to set
*/
public void setDriver(String driver) {
this.driver = driver;
}

/**
* @return the maxConn
*/
public int getMaxConn() {
return maxConn;
}

/**
* @param maxConn
* the maxConn to set
*/
public void setMaxConn(int maxConn) {
this.maxConn = maxConn;
}

/**
* @return the minConn
*/
public int getMinConn() {
return minConn;
}

/**
* @param minConn
* the minConn to set
*/
public void setMinConn(int minConn) {
this.minConn = minConn;
}

/**
* @return the name
*/
public String getName() {
return name;
}

/**
* @param name
* the name to set
*/
public void setName(String name) {
this.name = name;
}

/**
* @return the password
*/
public String getPassword() {
return password;
}

/**
* @param password
* the password to set
*/
public void setPassword(String password) {
this.password = password;
}

/**
* @return the url
*/
public String getUrl() {
return url;
}

/**
* @param url
* the url to set
*/
public void setUrl(String url) {
this.url = url;
}

/**
* @return the user
*/
public String getUser() {
return user;
}

/**
* @param user
* the user to set
*/
public void setUser(String user) {
this.user = user;
}
}
/**
* 数据库连接池管理类
*/
package com.chunkyo.db;

import java.sql.Connection;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Properties;
import java.util.Vector;
import com.chunkyo.db.ParseDSConfig;
import com.chunkyo.db.DSConfigBean;
import com.chunkyo.db.DBConnectionPool;

/**
* @author chenyanlin
*
*/
public class DBConnectionManager {
static private DBConnectionManager instance;// 唯一数据库连接池管理实例类
static private int clients; // 客户连接数
private Vector drivers = new Vector();// 驱动信息
private Hashtable pools = new Hashtable();// 连接池

/**
* 实例化管理类
*/
public DBConnectionManager() {
// TODO Auto-generated constructor stub
this.init();
}

/**
* 得到唯一实例管理类
*
* @return
*/
static synchronized public DBConnectionManager getInstance() {
if (instance == null) {
instance = new DBConnectionManager();
}
return instance;

}

/**
* 释放连接
*
* @param name
* @param con
*/
public void freeConnection(String name, Connection con) {
DBConnectionPool pool = (DBConnectionPool) pools.get(name);// 根据关键名字得到连接池
if (pool != null)
pool.freeConnection(con);// 释放连接
}

/**
* 得到一个连接根据连接池的名字name
*
* @param name
* @return
*/
public Connection getConnection(String name) {
DBConnectionPool pool = null;
Connection con = null;
pool = (DBConnectionPool) pools.get(name);// 从名字中获取连接池
con = pool.getConnection();// 从选定的连接池中获得连接
if (con != null)
System.out.println(&quot;得到连接。。。&quot;);
return con;
}

/**
* 得到一个连接，根据连接池的名字和等待时间
*
* @param name
* @param time
* @return
*/
public Connection getConnection(String name, long timeout) {
DBConnectionPool pool = null;
Connection con = null;
pool = (DBConnectionPool) pools.get(name);// 从名字中获取连接池
con = pool.getConnection(timeout);// 从选定的连接池中获得连接
System.out.println(&quot;得到连接。。。&quot;);
return con;
}

/**
* 释放所有连接
*/
public synchronized void release() {
Enumeration allpools = pools.elements();
while (allpools.hasMoreElements()) {
DBConnectionPool pool = (DBConnectionPool) allpools.nextElement();
if (pool != null)
pool.release();
}
pools.clear();
}

/**
* 创建连接池
*
* @param props
*/
private void createPools(DSConfigBean dsb) {
DBConnectionPool dbpool = new DBConnectionPool();
dbpool.setName(dsb.getName());
dbpool.setDriver(dsb.getDriver());
dbpool.setUrl(dsb.getUrl());
dbpool.setUser(dsb.getUsername());
dbpool.setPassword(dsb.getPassword());
dbpool.setMaxConn(dsb.getMaxconn());
System.out.println(&quot;ioio:&quot; + dsb.getMaxconn());
pools.put(dsb.getName(), dbpool);
}

/**
* 初始化连接池的参数
*/
private void init() {
// 加载驱动程序
this.loadDrivers();
// 创建连接池
Iterator alldriver = drivers.iterator();
while (alldriver.hasNext()) {
this.createPools((DSConfigBean) alldriver.next());
System.out.println(&quot;创建连接池。。。&quot;);

}
System.out.println(&quot;创建连接池完毕。。。&quot;);
}

/**
* 加载驱动程序
*
* @param props
*/
private void loadDrivers() {
ParseDSConfig pd = new ParseDSConfig();
// 读取数据库配置文件
drivers = pd.readConfigInfo(&quot;ds.config.xml&quot;);
System.out.println(&quot;加载驱动程序。。。&quot;);
}

/**
* @param args
*/
public static void main(String[] args) {
// TODO Auto-generated method stub
}
}
/**
* 配置文件Bean类
*/
package com.chunkyo.db;

/**
* @author chenyanlin
*
*/
public class DSConfigBean {
private String type = &quot;&quot;; // 数据库类型
private String name = &quot;&quot;; // 连接池名字
private String driver = &quot;&quot;; // 数据库驱动
private String url = &quot;&quot;; // 数据库url
private String username = &quot;&quot;; // 用户名
private String password = &quot;&quot;; // 密码
private int maxconn = 0; // 最大连接数

/**
*
*/
public DSConfigBean() {
// TODO Auto-generated constructor stub
}

/**
* @param args
*/
public static void main(String[] args) {
// TODO Auto-generated method stub
}

/**
* @return the driver
*/
public String getDriver() {
return driver;
}

/**
* @param driver
* the driver to set
*/
public void setDriver(String driver) {
this.driver = driver;
}

/**
* @return the maxconn
*/
public int getMaxconn() {
return maxconn;
}

/**
* @param maxconn
* the maxconn to set
*/
public void setMaxconn(int maxconn) {
this.maxconn = maxconn;
}

/**
* @return the name
*/
public String getName() {
return name;
}

/**
* @param name
* the name to set
*/
public void setName(String name) {
this.name = name;
}

/**
* @return the password
*/
public String getPassword() {
return password;
}

/**
* @param password
* the password to set
*/
public void setPassword(String password) {
this.password = password;
}

/**
* @return the type
*/
public String getType() {
return type;
}

/**
* @param type
* the type to set
*/
public void setType(String type) {
this.type = type;
}

/**
* @return the url
*/
public String getUrl() {
return url;
}

/**
* @param url
* the url to set
*/
public void setUrl(String url) {
this.url = url;
}

/**
* @return the username
*/
public String getUsername() {
return username;
}

/**
* @param username
* the username to set
*/
public void setUsername(String username) {
this.username = username;
}
}
/**
* 操作配置文件类 读 写 修改 删除等操作
*/
package com.chunkyo.db;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Vector;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.JDOMException;
import org.jdom.input.SAXBuilder;
import org.jdom.output.Format;
import org.jdom.output.XMLOutputter;

/**
* @author chenyanlin
*
*/
public class ParseDSConfig {
/**
* 构造函数
*/
public ParseDSConfig() {
// TODO Auto-generated constructor stub
}

/**
* 读取xml配置文件
*
* @param path
* @return
*/
public Vector readConfigInfo(String path) {
String rpath = this.getClass().getResource(&quot;&quot;).getPath().substring(1)
+ path;
Vector dsConfig = null;
FileInputStream fi = null;
try {
fi = new FileInputStream(rpath);// 读取路径文件
dsConfig = new Vector();
SAXBuilder sb = new SAXBuilder();
Document doc = sb.build(fi);
Element root = doc.getRootElement();
List pools = root.getChildren();
Element pool = null;
Iterator allPool = pools.iterator();
while (allPool.hasNext()) {
pool = (Element) allPool.next();
DSConfigBean dscBean = new DSConfigBean();
dscBean.setType(pool.getChild(&quot;type&quot;).getText());
dscBean.setName(pool.getChild(&quot;name&quot;).getText());
System.out.println(dscBean.getName());
dscBean.setDriver(pool.getChild(&quot;driver&quot;).getText());
dscBean.setUrl(pool.getChild(&quot;url&quot;).getText());
dscBean.setUsername(pool.getChild(&quot;username&quot;).getText());
dscBean.setPassword(pool.getChild(&quot;password&quot;).getText());
dscBean.setMaxconn(Integer.parseInt(pool.getChild(&quot;maxconn&quot;)
.getText()));
dsConfig.add(dscBean);
}

} catch (FileNotFoundException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} catch (JDOMException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} catch (IOException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}

finally {
try {
fi.close();
} catch (IOException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}

return dsConfig;
}

/**
* 修改配置文件 没时间写 过段时间再贴上去 其实一样的
*/
public void modifyConfigInfo(String path, DSConfigBean dsb)
throws Exception {
String rpath = this.getClass().getResource(&quot;&quot;).getPath().substring(1)
+ path;
FileInputStream fi = null; // 读出
FileOutputStream fo = null; // 写入

}

/**
* 增加配置文件
*
*/
public void addConfigInfo(String path, DSConfigBean dsb) {
String rpath = this.getClass().getResource(&quot;&quot;).getPath().substring(1)
+ path;
FileInputStream fi = null;
FileOutputStream fo = null;
try {
fi = new FileInputStream(rpath);// 读取xml流

SAXBuilder sb = new SAXBuilder();

Document doc = sb.build(fi); // 得到xml
Element root = doc.getRootElement();
List pools = root.getChildren();// 得到xml子树

Element newpool = new Element(&quot;pool&quot;); // 创建新连接池

Element pooltype = new Element(&quot;type&quot;); // 设置连接池类型
pooltype.setText(dsb.getType());
newpool.addContent(pooltype);

Element poolname = new Element(&quot;name&quot;);// 设置连接池名字
poolname.setText(dsb.getName());
newpool.addContent(poolname);

Element pooldriver = new Element(&quot;driver&quot;); // 设置连接池驱动
pooldriver.addContent(dsb.getDriver());
newpool.addContent(pooldriver);

Element poolurl = new Element(&quot;url&quot;);// 设置连接池url
poolurl.setText(dsb.getUrl());
newpool.addContent(poolurl);

Element poolusername = new Element(&quot;username&quot;);// 设置连接池用户名
poolusername.setText(dsb.getUsername());
newpool.addContent(poolusername);

Element poolpassword = new Element(&quot;password&quot;);// 设置连接池密码
poolpassword.setText(dsb.getPassword());
newpool.addContent(poolpassword);

Element poolmaxconn = new Element(&quot;maxconn&quot;);// 设置连接池最大连接
poolmaxconn.setText(String.valueOf(dsb.getMaxconn()));
newpool.addContent(poolmaxconn);
pools.add(newpool);// 将child添加到root
Format format = Format.getPrettyFormat();
format.setIndent(&quot;&quot;);
format.setEncoding(&quot;utf-8&quot;);
XMLOutputter outp = new XMLOutputter(format);
fo = new FileOutputStream(rpath);
outp.output(doc, fo);
} catch (FileNotFoundException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} catch (JDOMException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} catch (IOException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} finally {

}
}

/**
* 删除配置文件
*/
public void delConfigInfo(String path, String name) {
String rpath = this.getClass().getResource(&quot;&quot;).getPath().substring(1)
+ path;
FileInputStream fi = null;
FileOutputStream fo = null;
try {
fi = new FileInputStream(rpath);// 读取路径文件
SAXBuilder sb = new SAXBuilder();
Document doc = sb.build(fi);
Element root = doc.getRootElement();
List pools = root.getChildren();
Element pool = null;
Iterator allPool = pools.iterator();
while (allPool.hasNext()) {
pool = (Element) allPool.next();
if (pool.getChild(&quot;name&quot;).getText().equals(name)) {
pools.remove(pool);
break;
}
}
Format format = Format.getPrettyFormat();
format.setIndent(&quot;&quot;);
format.setEncoding(&quot;utf-8&quot;);
XMLOutputter outp = new XMLOutputter(format);
fo = new FileOutputStream(rpath);
outp.output(doc, fo);

} catch (FileNotFoundException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} catch (JDOMException e) {
// TODO Auto-generated catch block
e.printStackTrace();
} catch (IOException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}

finally {
try {
fi.close();
} catch (IOException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}
}

/**
* @param args
* @throws Exception
*/
public static void main(String[] args) throws Exception {
// TODO Auto-generated method stub
ParseDSConfig pd = new ParseDSConfig();
String path = &quot;ds.config.xml&quot;;
pd.readConfigInfo(path);
// pd.delConfigInfo(path, &quot;tj012006&quot;);
DSConfigBean dsb = new DSConfigBean();
dsb.setType(&quot;oracle&quot;);
dsb.setName(&quot;yyy004&quot;);
dsb.setDriver(&quot;org.oracle.jdbc&quot;);
dsb.setUrl(&quot;jdbc:oracle://localhost&quot;);
dsb.setUsername(&quot;sa&quot;);
dsb.setPassword(&quot;&quot;);
dsb.setMaxconn(1000);
pd.addConfigInfo(path, dsb);
pd.delConfigInfo(path, &quot;yyy001&quot;);
}
}
&lt;ds-config&gt;

&lt;pool&gt;

&lt;type&gt;
mysql
&lt;/type&gt;

&lt;name&gt;
user
&lt;/name&gt;

&lt;driver&gt;
com.mysql.jdbc.driver
&lt;/driver&gt;

&lt;url&gt;
jdbc:mysql://localhost:3306/user
&lt;/url&gt;

&lt;username&gt;
sa
&lt;/username&gt;

&lt;password&gt;
123456
&lt;/password&gt;

&lt;maxconn&gt;
100
&lt;/maxconn&gt;
&lt;/pool&gt;

&lt;pool&gt;

&lt;type&gt;
mysql
&lt;/type&gt;

&lt;name&gt;
user2
&lt;/name&gt;

&lt;driver&gt;
com.mysql.jdbc.driver
&lt;/driver&gt;

&lt;url&gt;
jdbc:mysql://localhost:3306/user2
&lt;/url&gt;

&lt;username&gt;
sa
&lt;/username&gt;

&lt;password&gt;
1234
&lt;/password&gt;

&lt;maxconn&gt;
10
&lt;/maxconn&gt;
&lt;/pool&gt;

&lt;pool&gt;

&lt;type&gt;
sql2000
&lt;/type&gt;

&lt;name&gt;
books
&lt;/name&gt;

&lt;driver&gt;
com.microsoft.sqlserver.driver
&lt;/driver&gt;

&lt;url&gt;
jdbc:sqlserver://localhost:1433/books:databasename=books
&lt;/url&gt;

&lt;username&gt;
sa
&lt;/username&gt;

&lt;password&gt;
&lt;/password&gt;

&lt;maxconn&gt;
100
&lt;/maxconn&gt;
&lt;/pool&gt;

&lt;/ds-config&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>275726</snippet_key>
<tag>设计模式 Decorator 装饰</tag>
<comment>来自CSDN博客：设计模式学习笔记--装饰(Decorator)模式  http://blog.csdn.net/puma_dong/article/details/22900581#</comment>
<code>interface Component
{
//商业方法
void sampleOp();
}
class ConcreteComponent implements Component
{
public ConcreteComponent()
{
//Write your code
}
//商业方法
public void sampleOp()
{
//Write your code
}
}
class Decorator implements Component
{
private Component component;
public Decorator(Component component)
{
this.component = component;
}
public Decorator()
{
//Write your code
}
//商业方法
public void sampleOp()
{
component.sampleOp();
}
}
class ConcreteDecorator extends Decorator
{
//商业方法
public void sampleOp()
{
super.sampleOp();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>472334</snippet_key>
<tag>测试 fitnesse</tag>
<comment>来自CSDN博客：Fitnesse系列四 http://blog.csdn.net/zjc/article/details/39448379#</comment>
<code>public class QueryTable {
private int salary;
private List table;

public QueryTable(int s){
this.salary=s;
}

public List query(){

table=new ArrayList();
ArrayList row=new ArrayList();
ArrayList field1=new ArrayList&lt;String&gt;();
ArrayList field2=new ArrayList&lt;String&gt;();
ArrayList field3=new ArrayList&lt;String&gt;();
ArrayList field4=new ArrayList&lt;String&gt;();

field1.add(&quot;name&quot;);
field1.add(&quot;zjc&quot;);
row.add(field1);

field2.add(&quot;age&quot;);
field2.add(&quot;99&quot;);
row.add(field2);

field3.add(&quot;job&quot;);
field3.add(&quot;worker&quot;);
row.add(field3);


field4.add(&quot;salary&quot;);
field4.add(&quot;1000000&quot;);
row.add(field4);

table.add(row);

return table;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>407054</snippet_key>
<tag>355,380</tag>
<comment>来自CSDN博客：throws与throw区别 http://blog.csdn.net/u011636988/article/details/34846861#</comment>
<code>throws ExceptionXXX,ExceptionXXX
</code>
</RECORD>
<RECORD>
<snippet_key>79630</snippet_key>
<tag>484</tag>
<comment>来自CSDN博客：hdu2037 今年暑假不AC(贪心算法基础--会场安排类似  http://blog.csdn.net/chao1983210400/article/details/16919989#</comment>
<code>import java.util.Scanner;

public class hdu2037今年暑假不AC {

public static void main(String[] args) {
// TODO Auto-generated method stub
Scanner sc=new Scanner (System.in);
while(true){
int n=sc.nextInt();
if(n==0)break;
int[]a=new int[n];
int[]b=new int[n];
for(int i=0;i&lt;n;i++){
a[i]=sc.nextInt();
b[i]=sc.nextInt();//结束时间
}
for(int i=0;i&lt;n-1;i++){
for(int j=i+1;j&lt;n;j++){
if(b[i]&gt;b[j]){
int e=a[i];
a[i]=a[j];
a[j]=e;

int t=b[i];
b[i]=b[j];
b[j]=t;
}
}
}
System.out.println(&quot;排序后&quot;);
for(int i=0;i&lt;n;i++)
System.out.println(a[i]+&quot;:&quot;+b[i]);
System.out.println(&quot;=================&quot;);
System.out.println(&quot;打印那些活动对应的时间安排&quot;);

==============第一次做时写的一个算法==============
/*int count=1;
int min=b[0];//你要考虑只有一个的时候
for(int i=0;i&lt;n-1;i++)//类似于冒泡排序的做法！！！
for(int j=i+1;j&lt;n;j++)//此算法不好之处在于，没有跳转，儿有很多多余的不要的操作！！！！
if(min&lt;=a[j]){//第2013年11月24日出现”黑色三分钟“，就是在此处！一道原题，一个小时半未能解决！！&gt;_&lt;.深深地祭奠！
min=b[j];
count++;
// System.out.println(a[i]+&quot; $ &quot;+b[i]);
break;
}*/
=============第二次做时写的一个算法====有所改进===========
int count=1;
System.out.println(a[0]+&quot; $ &quot;+b[0]);
for(int i=0; i&lt;n-1;i++)//必须i&lt;n-1，类似于冒泡排序

for(int j=i+1; j&lt;n; j++)
if(b[i]&lt;=a[j]){

i = j-1;//i会在改层for循环执行完毕后自身加1，所以与退回一步
count++;
System.out.println(a[j]+&quot; $ &quot;+b[j]);
break;
}
System.out.println(count);
}
}
}
12
1 3
3 4
0 7
3 8
15 19
15 20
10 15
8 18
6 12
5 10
4 14
2 9
排序后
1:3
3:4
0:7
3:8
2:9
5:10
6:12
4:14
10:15
8:18
15:19
15:20
=================
打印那些活动对应的时间安排
3 $ 4
5 $ 10
10 $ 15
15 $ 19
5
12
1 3
3 4
0 7
3 8
15 19
15 20
10 15
8 18
6 12
5 10
4 14
2 9
排序后
1:3
3:4
0:7
3:8
2:9
5:10
6:12
4:14
10:15
8:18
15:19
15:20
=================
打印那些活动对应的时间安排
1 $ 3
3 $ 4
5 $ 10
10 $ 15
15 $ 19
5
import java.util.Scanner;

public class Main {

public static void main(String[] args) {
// TODO Auto-generated method stub
Scanner sc=new Scanner (System.in);
while(true){
int n=sc.nextInt();
if(n==0)break;
int[]a=new int[n];
int[]b=new int[n];
for(int i=0;i&lt;n;i++){
a[i]=sc.nextInt();
b[i]=sc.nextInt();//结束时间
}
for(int i=0;i&lt;n-1;i++){
for(int j=i+1;j&lt;n;j++){
if(b[i]&gt;b[j]){
int e=a[i];
a[i]=a[j];
a[j]=e;

int t=b[i];
b[i]=b[j];
b[j]=t;
}
}
}
int count=1;
int sta = b[0];
for(int j=1; j&lt;n; j++)
if(sta &lt;= a[j]){
sta = b[j];
count++;
}
System.out.println(count);
}
}
}
import java.util.Arrays;
import java.util.Scanner;

public class nyoj_14_会场安排问题 {

public static void main(String[] args) {

Scanner sc=new Scanner (System.in);
int C = 1;
while(sc.hasNext()){
int n=sc.nextInt();

E [] e = new E[n];
for(int i=0;i&lt;n;i++){
e[i] = new E();
int x=sc.nextInt();
int y=sc.nextInt();
e[i].a = x&gt;y?y:x;
e[i].b= x&gt;y?x:y;
}
Arrays.sort(e);//一个类似以结构体的排序时需要用Comparator而非Comparable
int count=1;
int sta = e[0].b;
for(int j=1; j&lt;n; j++)
if(sta &lt; e[j].a){
sta = e[j].b;
count++;
}
System.out.println(&quot;Case &quot;+(C++)+&quot;:&quot;);
System.out.println(count+&quot;.&quot;);
}
}
}
class E implements Comparable&lt;E&gt;{
int a,b;
@Override
public int compareTo(E o) {

return this.b-o.b;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>292613</snippet_key>
<tag></tag>
<comment>来自CSDN博客：黑马程序员 初学的简单ArrayTool类  http://blog.csdn.net/u014143263/article/details/21664673#</comment>
<code>/**
这是一个可以对数组操作的工具类，该数组提供了获取最值排序等功能。
@author Xu
@version V1.0
*/

public class ArrayTool
{
/**
空函数的构造函数
*/
private ArrayTool(){}
/**
获取一个整形数组的最大值
@param arr 接收一个int类型的数组
@return 会返回一个数组中的最大值
*/
public static int getMax(int[] arr)
{
int max=arr[0];//初始max=arr[0]防止数组有负数
for (int x=0;x&lt;arr.length ;x++ )
{
if (max&lt;arr[x])
{
max=arr[x];
}
}
return max;
}
/**
获取一个整形数组的最小值
@param arr 接收一个int类型的数组
@return 会返回一个数组中的最小值
*/
public static int getMin(int[] arr)
{
int min=arr[0];
for (int x=0;x&lt;arr.length ;x++ )
{
if (min&gt;arr[x])
{
min=arr[x];
}
}
return min;
}
/**
给int数组进行选择排序
@param arr 接收一个int类型的数组
*/
public static void selectSort(int[] arr)
{
for (int x=0;x&lt;arr.length-1 ;x++ )//比较length-1次
{
for (int y=x+1; y&lt;arr.length;y++ )//从第2个开始和arr[x]比较
{
if (arr[x]&gt;arr[y])
{
swap(arr,x,y);
}
}
}

}
/**
给int数组进行冒泡排序
@param arr 接收一个int类型的数组
*/
public static void bubbleSort(int[] arr)
{
for (int x=0; x&lt;arr.length-1;x++ )
{
for (int y=0;y&lt;arr.length-x-1 ;y++ )//相邻2个比较
{
if (arr[y]&gt;arr[y+1])
{
swap(arr,y,y+1);
}
}
}
}
/**
给数组中的元素进行位置的变换
@param arr 接收一个int类型的数组
@param a 置换的位置
@param b 置换的位置
*/
private static void swap(int[] arr,int a,int b)
{
int temp=0;
temp=arr[a];
arr[a]=arr[b];
arr[b]=temp;
}
/**
用于打印数组中的元素，打印形式是:[element1,element2,......]
*/
public static void printArray(int[] arr)
{
System.out.print(&quot;[&quot;);
for (int x=0;x&lt;arr.length ;x++ )
{
if (x!=arr.length-1)
{
System.out.print(arr[x]+&quot;,&quot;);
}
else
System.out.println(arr[x]+&quot;]&quot;);
}
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>342030</snippet_key>
<tag>表单验证 Validation 用户输入</tag>
<comment>来自CSDN博客：Spring框架整合Struts2使用Validation框架验证表单用户输入数据的详细教程  http://blog.csdn.net/yaerfeng/article/details/25686017#</comment>
<code>package com.zuidaima.action;

import com.opensymphony.xwork2.ActionSupport;

public class NewValidateAction extends ActionSupport
{
private String msg; // 必须输入
private int age; // 在13和20之间
public String getMsg()
{
return msg;
}
public void setMsg(String msg)
{
this .msg= msg;
}
public int getAge()
{
return age;
}
public void setAge( int age)
{
this .age= age;
}
}
&lt;?xml version=&quot;1.0&quot;encoding=&quot;UTF-8&quot; ?&gt;
&lt;! DOCTYPE struts PUBLIC
&quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot;
&quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;&gt;
&lt;struts&gt;
&lt;package name=&quot;demo&quot; extends=&quot;struts-default&quot; namespace=&quot;/test&quot;&gt;
&lt;action name=&quot;new_validate&quot; class=&quot;action.NewValidateAction&quot;&gt;
&lt;result name=&quot;input&quot;&gt;/validate_form.jsp &lt;/result&gt;
&lt;result name=&quot;success&quot;&gt; /validate_form.jsp &lt;/result&gt;
&lt;/action&gt;
&lt;/package&gt;
&lt;/struts&gt;
&lt;?xml version=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?&gt;
&lt;! DOCTYPE validators PUBLIC &quot;-//OpenSymphony Group//XWork Validator 1.0.2//EN&quot;
&quot;http://www.opensymphony.com/xwork/xwork-validator-1.0.2.dtd&quot;&gt;
&lt;validators&gt;
&lt;field name=&quot;msg&quot;&gt;
&lt;field-validator type=&quot;requiredstring&quot;&gt;
&lt;message&gt; 请输入信息 &lt;/message&gt;
&lt;/field-validator&gt;
&lt;/field&gt;
&lt;field name=&quot;age&quot;&gt;
&lt;field-validator type=&quot;int&quot;&gt;
&lt;param name=&quot;min&quot;&gt; &lt;/param&gt;
&lt;param name=&quot;max&quot;&gt; &lt;/param&gt;
&lt;message&gt;
必须在 13至20之间
&lt;/message&gt;
&lt;/field-validator&gt;
&lt;/field&gt;
&lt;/validators&gt;
&lt;%@page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;GBK&quot;%&gt;
&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&lt;s:urlvalue=&quot;/styles/styles.css&quot; /&gt; &quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt; 验证数据 &lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;s:form action=&quot;new_validate&quot; namespace=&quot;/test&quot;&gt;
&lt;s:textfield name=&quot;msg&quot; label=&quot;姓名&quot; /&gt;
&lt;s:textfield name=&quot;age&quot; label=&quot;年龄&quot; /&gt;
&lt;s:submit /&gt;
&lt;/s:form&gt;
&lt;/body&gt;
&lt;/html&gt;
package data;

public class User
{
private String name;
private int age;
public String getName()
{
return name;
}
public void setName(String name)
{
this .name= name;
}
public int getAge()
{
return age;
}
public void setAge( int age)
{
this .age= age;
}
}
package action;

import com.opensymphony.xwork2.ActionSupport;
import data.User;

public class NewValidateAction extends ActionSupport
{
private String msg;
private int age;
private User user;
public String getMsg()
{
return msg;
}

public void setMsg(String msg)
{
this .msg= msg;
}
public int getAge()
{
return age;
}
public void setAge( int age)
{
this .age= age;
}
public User getUser()
{
return user;
}

public void setUser(User user)
{
this .user= user;
}
}
&lt;?xml version=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?&gt;
&lt;! DOCTYPE validators PUBLIC &quot;-//OpenSymphony Group//XWork Validator 1.0.2//EN&quot;
&quot;http://www.opensymphony.com/xwork/xwork-validator-1.0.2.dtd&quot;&gt;
&lt;validators&gt;

&lt;field name=&quot;user&quot;&gt;
&lt;field-validator type=&quot;visitor&quot;&gt;
&lt;param name=&quot;context&quot;&gt;abc &lt;/param&gt;
&lt;param name=&quot;appendPrefix&quot;&gt; true &lt;/param&gt;
&lt;message&gt; User: &lt;/message&gt;
&lt;/field-validator&gt;
&lt;/field&gt;
&lt;/validators&gt;
&lt;?xml version=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?&gt;
&lt;! DOCTYPE validators PUBLIC &quot;-//OpenSymphony Group//XWork Validator 1.0.2//EN&quot;
&quot;http://www.opensymphony.com/xwork/xwork-validator-1.0.2.dtd&quot;&gt;
&lt;validators&gt;
&lt;field name=&quot;name&quot;&gt;
&lt;field-validator type=&quot;requiredstring&quot;&gt;
&lt;message&gt; 请输入name &lt;/message&gt;
&lt;/field-validator&gt;
&lt;/field&gt;
&lt;field name=&quot;age&quot;&gt;
&lt;field-validator type=&quot;int&quot;&gt;
&lt;param name=&quot;min&quot;&gt; &lt;/param&gt;
&lt;param name=&quot;max&quot;&gt; &lt;/param&gt;
&lt;message&gt;
必须在 5至20之间
&lt;/message&gt;
&lt;/field-validator&gt;
&lt;/field&gt;
&lt;/validators&gt;
&lt;s:form validate=&quot;true&quot; action=&quot;new_validate&quot; namespace=&quot;/test&quot;&gt;
&lt;s:textfield name=&quot;msg&quot; label=&quot;姓名&quot; /&gt;
&lt;s:textfield name=&quot;age&quot; label=&quot;年龄&quot;/&gt;
&lt;s:textfield name=&quot;user.name&quot; label=&quot;姓名1&quot; /&gt;
&lt;s:textfield name=&quot;user.age&quot; label=&quot;年龄1&quot; /&gt;
&lt;s:submit /&gt;
&lt;/s:form&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>161797</snippet_key>
<tag>来自CSDN博客：Android源码分析-Activity的启动过程 . http://blog.csdn.net/TopicDev/article/details/18215651#</tag>
<comment>派生自singwhatiwanna/blog_20140112_1_4173979</comment>
<code>@Override
public void startActivity(Intent intent) {
startActivity(intent, null);
}

@Override
public void startActivity(Intent intent, Bundle options) {
if (options != null) {
startActivityForResult(intent, -1, options);
} else {
// Note we want to go through this call for compatibility with
// applications that may have overridden the method.
startActivityForResult(intent, -1);
}
}

public void startActivityForResult(Intent intent, int requestCode) {
startActivityForResult(intent, requestCode, null);
}
public void startActivityForResult(Intent intent, int requestCode, Bundle options) {
//一般的Activity其mParent为null，mParent常用在ActivityGroup中，ActivityGroup已废弃
if (mParent == null) {
//这里会启动新的Activity，核心功能都在mMainThread.getApplicationThread()中完成
Instrumentation.ActivityResult ar =
mInstrumentation.execStartActivity(
this, mMainThread.getApplicationThread(), mToken, this,
intent, requestCode, options);
if (ar != null) {
//发送结果，即onActivityResult会被调用
mMainThread.sendActivityResult(
mToken, mEmbeddedID, requestCode, ar.getResultCode(),
ar.getResultData());
}
if (requestCode &gt;= 0) {
// If this start is requesting a result, we can avoid making
// the activity visible until the result is received. Setting
// this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
// activity hidden during this time, to avoid flickering.
// This can only be done when a result is requested because
// that guarantees we will get information back when the
// activity is finished, no matter what happens to it.
mStartedActivity = true;
}

final View decor = mWindow != null ? mWindow.peekDecorView() : null;
if (decor != null) {
decor.cancelPendingInputEvents();
}
// TODO Consider clearing/flushing other event sources and events for child windows.
} else {
//在ActivityGroup内部的Activity调用startActivity的时候会走到这里，内部处理逻辑和上面是类似的
if (options != null) {
mParent.startActivityFromChild(this, intent, requestCode, options);
} else {
// Note we want to go through this method for compatibility with
// existing applications that may have overridden it.
mParent.startActivityFromChild(this, intent, requestCode);
}
}
}
public ActivityResult execStartActivity(
Context who, IBinder contextThread, IBinder token, Activity target,
Intent intent, int requestCode, Bundle options) {
//核心功能在这个whoThread中完成，其内部scheduleLaunchActivity方法用于完成activity的打开
IApplicationThread whoThread = (IApplicationThread) contextThread;
if (mActivityMonitors != null) {
synchronized (mSync) {
//先查找一遍看是否存在这个activity
final int N = mActivityMonitors.size();
for (int i=0; i&lt;N; i++) {
final ActivityMonitor am = mActivityMonitors.get(i);
if (am.match(who, null, intent)) {
//如果找到了就跳出循环
am.mHits++;
//如果目标activity无法打开，直接return
if (am.isBlocking()) {
return requestCode &gt;= 0 ? am.getResult() : null;
}
break;
}
}
}
}
try {
intent.migrateExtraStreamToClipData();
intent.prepareToLeaveProcess();
//这里才是真正打开activity的地方，核心功能在whoThread中完成。
int result = ActivityManagerNative.getDefault()
.startActivity(whoThread, who.getBasePackageName(), intent,
intent.resolveTypeIfNeeded(who.getContentResolver()),
token, target != null ? target.mEmbeddedID : null,
requestCode, 0, null, null, options);
//这个方法是专门抛异常的，它会对结果进行检查，如果无法打开activity，
//则抛出诸如ActivityNotFoundException类似的各种异常
checkStartActivityResult(result, intent);
} catch (RemoteException e) {
}
return null;
}
/*package*/ static void checkStartActivityResult(int res, Object intent) {
if (res &gt;= ActivityManager.START_SUCCESS) {
return;
}

switch (res) {
case ActivityManager.START_INTENT_NOT_RESOLVED:
case ActivityManager.START_CLASS_NOT_FOUND:
if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null)
throw new ActivityNotFoundException(
&quot;Unable to find explicit activity class &quot;
+ ((Intent)intent).getComponent().toShortString()
+ &quot;; have you declared this activity in your AndroidManifest.xml?&quot;);
throw new ActivityNotFoundException(
&quot;No Activity found to handle &quot; + intent);
case ActivityManager.START_PERMISSION_DENIED:
throw new SecurityException(&quot;Not allowed to start activity &quot;
+ intent);
case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
throw new AndroidRuntimeException(
&quot;FORWARD_RESULT_FLAG used while also requesting a result&quot;);
case ActivityManager.START_NOT_ACTIVITY:
throw new IllegalArgumentException(
&quot;PendingIntent is not an activity&quot;);
default:
throw new AndroidRuntimeException(&quot;Unknown error code &quot;
+ res + &quot; when starting &quot; + intent);
}
}
public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,
ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo,
int procState, Bundle state, List&lt;ResultInfo&gt; pendingResults,
List&lt;Intent&gt; pendingNewIntents, boolean notResumed, boolean isForward,
String profileName, ParcelFileDescriptor profileFd, boolean autoStopProfiler) {

updateProcessState(procState, false);

ActivityClientRecord r = new ActivityClientRecord();

r.token = token;
r.ident = ident;
r.intent = intent;
r.activityInfo = info;
r.compatInfo = compatInfo;
r.state = state;

r.pendingResults = pendingResults;
r.pendingIntents = pendingNewIntents;

r.startsNotResumed = notResumed;
r.isForward = isForward;

r.profileFile = profileName;
r.profileFd = profileFd;
r.autoStopProfiler = autoStopProfiler;

updatePendingConfiguration(curConfig);

queueOrSendMessage(H.LAUNCH_ACTIVITY, r);
}
//这个类太长，我只帖出了我们用到的部分
private class H extends Handler {

public void handleMessage(Message msg) {
if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));
switch (msg.what) {
//这里处理LAUNCH_ACTIVITY消息类型
case LAUNCH_ACTIVITY: {
Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);
ActivityClientRecord r = (ActivityClientRecord)msg.obj;

r.packageInfo = getPackageInfoNoCheck(
r.activityInfo.applicationInfo, r.compatInfo);
//这里处理startActivity消息
handleLaunchActivity(r, null);
Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
} break;
case RELAUNCH_ACTIVITY: {
Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityRestart&quot;);
ActivityClientRecord r = (ActivityClientRecord)msg.obj;
handleRelaunchActivity(r);
Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
} break;
case PAUSE_ACTIVITY:
Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityPause&quot;);
handlePauseActivity((IBinder)msg.obj, false, msg.arg1 != 0, msg.arg2);
maybeSnapshot();
Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
break;
...
}
}
private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {
// If we are getting ready to gc after going to the background, well
// we are back active so skip it.
unscheduleGcIdler();

if (r.profileFd != null) {
mProfiler.setProfiler(r.profileFile, r.profileFd);
mProfiler.startProfiling();
mProfiler.autoStopProfiler = r.autoStopProfiler;
}

// Make sure we are running with the most recent config.
handleConfigurationChanged(null, null);

if (localLOGV) Slog.v(
TAG, &quot;Handling launch of &quot; + r);
//终于到底了，大家都有点不耐烦了吧，从方法名可以看出，
//performLaunchActivity真正完成了activity的调起,
//同时activity会被实例化，并且onCreate会被调用
Activity a = performLaunchActivity(r, customIntent);

if (a != null) {
r.createdConfig = new Configuration(mConfiguration);
Bundle oldState = r.state;
//看到没，目标activity的onResume会被调用
handleResumeActivity(r.token, false, r.isForward,
!r.activity.mFinished &amp;&amp; !r.startsNotResumed);

if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) {
// The activity manager actually wants this one to start out
// paused, because it needs to be visible but isn&apos;t in the
// foreground. We accomplish this by going through the
// normal startup (because activities expect to go through
// onResume() the first time they run, before their window
// is displayed), and then pausing it. However, in this case
// we do -not- need to do the full pause cycle (of freezing
// and such) because the activity manager assumes it can just
// retain the current state it has.
try {
r.activity.mCalled = false;
//同时，由于新activity被调起了，原activity的onPause会被调用
mInstrumentation.callActivityOnPause(r.activity);
// We need to keep around the original state, in case
// we need to be created again. But we only do this
// for pre-Honeycomb apps, which always save their state
// when pausing, so we can not have them save their state
// when restarting from a paused state. For HC and later,
// we want to (and can) let the state be saved as the normal
// part of stopping the activity.
if (r.isPreHoneycomb()) {
r.state = oldState;
}
if (!r.activity.mCalled) {
throw new SuperNotCalledException(
&quot;Activity &quot; + r.intent.getComponent().toShortString() +
&quot; did not call through to super.onPause()&quot;);
}

} catch (SuperNotCalledException e) {
throw e;

} catch (Exception e) {
if (!mInstrumentation.onException(r.activity, e)) {
throw new RuntimeException(
&quot;Unable to pause activity &quot;
+ r.intent.getComponent().toShortString()
+ &quot;: &quot; + e.toString(), e);
}
}
r.paused = true;
}
} else {
// If there was an error, for any reason, tell the activity
// manager to stop us.
try {
ActivityManagerNative.getDefault()
.finishActivity(r.token, Activity.RESULT_CANCELED, null);
} catch (RemoteException ex) {
// Ignore
}
}
}
private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
// System.out.println(&quot;##### [&quot; + System.currentTimeMillis() + &quot;] ActivityThread.performLaunchActivity(&quot; + r + &quot;)&quot;);

ActivityInfo aInfo = r.activityInfo;
if (r.packageInfo == null) {
r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,
Context.CONTEXT_INCLUDE_CODE);
}
//首先从intent中解析出目标activity的启动参数
ComponentName component = r.intent.getComponent();
if (component == null) {
component = r.intent.resolveActivity(
mInitialApplication.getPackageManager());
r.intent.setComponent(component);
}

if (r.activityInfo.targetActivity != null) {
component = new ComponentName(r.activityInfo.packageName,
r.activityInfo.targetActivity);
}

Activity activity = null;
try {
java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
//用ClassLoader（类加载器）将目标activity的类通过类名加载进来并调用newInstance来实例化一个对象
//其实就是通过Activity的无参构造方法来new一个对象，对象就是在这里new出来的。
activity = mInstrumentation.newActivity(
cl, component.getClassName(), r.intent);
StrictMode.incrementExpectedActivityCount(activity.getClass());
r.intent.setExtrasClassLoader(cl);
if (r.state != null) {
r.state.setClassLoader(cl);
}
} catch (Exception e) {
if (!mInstrumentation.onException(activity, e)) {
throw new RuntimeException(
&quot;Unable to instantiate activity &quot; + component
+ &quot;: &quot; + e.toString(), e);
}
}

try {
Application app = r.packageInfo.makeApplication(false, mInstrumentation);

if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r);
if (localLOGV) Slog.v(
TAG, r + &quot;: app=&quot; + app
+ &quot;, appName=&quot; + app.getPackageName()
+ &quot;, pkg=&quot; + r.packageInfo.getPackageName()
+ &quot;, comp=&quot; + r.intent.getComponent().toShortString()
+ &quot;, dir=&quot; + r.packageInfo.getAppDir());

if (activity != null) {
Context appContext = createBaseContextForActivity(r, activity);
CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());
Configuration config = new Configuration(mCompatConfiguration);
if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;
+ r.activityInfo.name + &quot; with config &quot; + config);
activity.attach(appContext, this, getInstrumentation(), r.token,
r.ident, app, r.intent, r.activityInfo, title, r.parent,
r.embeddedID, r.lastNonConfigurationInstances, config);

if (customIntent != null) {
activity.mIntent = customIntent;
}
r.lastNonConfigurationInstances = null;
activity.mStartedActivity = false;
int theme = r.activityInfo.getThemeResource()
if (theme != 0) {
activity.setTheme(theme);
}

activity.mCalled = false;
//目标activity的onCreate被调用了，到此为止，Activity被启动了，接下来的流程就是Activity的生命周期了，
//本文之前已经提到，其生命周期的各种状态的切换由ApplicationThread内部来完成
mInstrumentation.callActivityOnCreate(activity, r.state);
if (!activity.mCalled) {
throw new SuperNotCalledException(
&quot;Activity &quot; + r.intent.getComponent().toShortString() +
&quot; did not call through to super.onCreate()&quot;);
}
r.activity = activity;
r.stopped = true;
if (!r.activity.mFinished) {
activity.performStart();
r.stopped = false;
}
if (!r.activity.mFinished) {
if (r.state != null) {
mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);
}
}
if (!r.activity.mFinished) {
activity.mCalled = false;
mInstrumentation.callActivityOnPostCreate(activity, r.state);
if (!activity.mCalled) {
throw new SuperNotCalledException(
&quot;Activity &quot; + r.intent.getComponent().toShortString() +
&quot; did not call through to super.onPostCreate()&quot;);
}
}
}
r.paused = true;

mActivities.put(r.token, r);

} catch (SuperNotCalledException e) {
throw e;

} catch (Exception e) {
if (!mInstrumentation.onException(activity, e)) {
throw new RuntimeException(
&quot;Unable to start activity &quot; + component
+ &quot;: &quot; + e.toString(), e);
}
}

return activity;
}
</code>
</RECORD>
<RECORD>
<snippet_key>407566</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Application的概念和用法 http://blog.csdn.net/jimmygaoyanghtm/article/details/34909063#</comment>
<code>&lt;/pre&gt;Application &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size:14px&quot;&gt;&lt;strong&gt;描述:&lt;span style=&quot;color:rgb(51,51,51); font-family:Arial; line-height:26px&quot;&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:rgb(51,51,51); font-family:Arial; line-height:26px&quot;&gt;Base class for those who need to maintain global application state. You can&lt;/span&gt;&lt;span style=&quot;color:rgb(51,51,51); font-family:Arial; line-height:26px&quot;&gt; provide your own implementation by specifying its name in your &lt;/span&gt;&lt;span style=&quot;color:rgb(51,51,51); font-family:Arial; line-height:26px&quot;&gt;AndroidManifest.xml&apos;s &lt;application&gt;; tag, which will cause that class &lt;/span&gt;&lt;span style=&quot;color:rgb(51,51,51); font-family:Arial; line-height:26px&quot;&gt;to be instantiated for you when the process for your application/package is &lt;/span&gt;&lt;span style=&quot;color:rgb(51,51,51); font-family:Arial; line-height:26px&quot;&gt;created.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color:rgb(51,51,51); font-family:Arial; line-height:26px&quot;&gt;&lt;span style=&quot;font-size:14px&quot;&gt;&lt;span style=&quot;color:rgb(51,51,51); font-family:Arial; line-height:26px&quot;&gt;&lt;strong&gt;继承关系:&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color:rgb(51,51,51); font-family:Arial; line-height:26px&quot;&gt;&lt;span style=&quot;font-size:14px&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;table class=&quot;jd-inheritance-table &quot; style=&quot;margin:0px; border-collapse:collapse; border-spacing:0px; border:0px; width:1203px; background-color:rgb(249,249,249); padding:0px; color:rgb(34,34,34); font-family:Roboto,sans-serif; line-height:19px&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td colspan=&quot;4&quot; class=&quot;jd-inheritance-class-cell&quot; style=&quot;padding:0px; vertical-align:top; background-color:transparent; border:none; margin:0px&quot;&gt;&lt;a target=_blank target=&quot;_blank&quot; href=&quot;http://www.android-doc.com/reference/java/lang/Object.html&quot; style=&quot;color:rgb(37,138,175); text-decoration:none&quot;&gt;java.lang.Object&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;jd-inheritance-space&quot; style=&quot;padding:0px; vertical-align:top; background-color:transparent; border:none; margin:0px; font-weight:bold; width:1em&quot;&gt;   ↳&lt;/td&gt;&lt;td colspan=&quot;3&quot; class=&quot;jd-inheritance-class-cell&quot; style=&quot;padding:0px; vertical-align:top; background-color:transparent; border:none; margin:0px&quot;&gt;&lt;a target=_blank target=&quot;_blank&quot; href=&quot;http://www.android-doc.com/reference/android/content/Context.html&quot; style=&quot;color:rgb(37,138,175); text-decoration:none&quot;&gt;android.content.Context&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;jd-inheritance-space&quot; style=&quot;padding:0px; vertical-align:top; background-color:transparent; border:none; margin:0px; font-weight:bold; width:1em&quot;&gt; &lt;/td&gt;&lt;td class=&quot;jd-inheritance-space&quot; style=&quot;padding:0px; vertical-align:top; background-color:transparent; border:none; margin:0px; font-weight:bold; width:1em&quot;&gt;   ↳&lt;/td&gt;&lt;td colspan=&quot;2&quot; class=&quot;jd-inheritance-class-cell&quot; style=&quot;padding:0px; vertical-align:top; background-color:transparent; border:none; margin:0px&quot;&gt;&lt;a target=_blank target=&quot;_blank&quot; href=&quot;http://www.android-doc.com/reference/android/content/ContextWrapper.html&quot; style=&quot;color:rgb(37,138,175); text-decoration:none&quot;&gt;android.content.ContextWrapper&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;jd-inheritance-space&quot; style=&quot;padding:0px; vertical-align:top; background-color:transparent; border:none; margin:0px; font-weight:bold; width:1em&quot;&gt; &lt;/td&gt;&lt;td class=&quot;jd-inheritance-space&quot; style=&quot;padding:0px; vertical-align:top; background-color:transparent; border:none; margin:0px; font-weight:bold; width:1em&quot;&gt; &lt;/td&gt;&lt;td class=&quot;jd-inheritance-space&quot; style=&quot;padding:0px; vertical-align:top; background-color:transparent; border:none; margin:0px; font-weight:bold; width:1em&quot;&gt;   ↳&lt;/td&gt;&lt;td colspan=&quot;1&quot; class=&quot;jd-inheritance-class-cell&quot; style=&quot;padding:0px; vertical-align:top; background-color:transparent; border:none; margin:0px&quot;&gt;android.app.Application&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;从Application的基本描述中可以知道其主要作用是用来保存全局应用程序状态。可以通过在&lt;span style=&quot;color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px&quot;&gt;AndroidManifest.xml中添加&lt;application&gt;的 android:name属性来定义应用程序的名称。q&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color:rgb(51,51,51); font-family:Arial; line-height:26px&quot;&gt;&lt;span style=&quot;font-size:14px&quot;&gt;&lt;span style=&quot;color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px&quot;&gt;    &lt;application        android:name=&quot;.MylApplication&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;color:rgb(51,51,51); font-family:Arial; line-height:26px&quot;&gt;&lt;span style=&quot;font-size:14px&quot;&gt;&lt;span style=&quot;color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre name=&quot;code&quot; class=&quot;java&quot; style=&quot;font-size: 14px; font-weight: bold;&quot;&gt;public class MisInvoiceTerminalApplication extends Application{
private static MisInvoiceTerminalApplication instance;
private SmartPrint mSmartPrint = null;
public static MisInvoiceTerminalApplication getInstance() {
return instance;
}
@Override
public void onCreate() {
super.onCreate();
instance = this;
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>80142</snippet_key>
<tag>327</tag>
<comment>来自CSDN博客：Java中的transient关键字  http://blog.csdn.net/guimingyue/article/details/16926053#</comment>
<code>&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif; background-color: rgb(255, 255, 255);&quot;&gt;transient关键字主要用于修饰不需要序列化的域（Field），官方文档解释如下：&lt;/span&gt;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;


public class PointSeriable {

public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException {
PointSeriable ps = new PointSeriable();

Point point = new Point(1, 2, 3.0f, 4.0f);

String filename = &quot;point&quot;;

ps.saveObj(point, filename);

Object obj = ps.readObj(filename);

if(obj instanceof Point){
Point p = (Point)obj;
System.out.println(&quot;x=&quot; + p.x);
System.out.println(&quot;y=&quot; + p.y);
System.out.println(&quot;rho=&quot; + p.rho);
System.out.println(&quot;theta=&quot; + p.theta);
}
}
/**
* 序列化对象obj
* @param obj 要序列化的对象
* @param filename 序列化存储的文件名
* @throws FileNotFoundException
* @throws IOException
*/
public void saveObj(Object obj, String filename) throws FileNotFoundException, IOException {
ObjectOutputStream objos = new ObjectOutputStream(new FileOutputStream(new File(filename)));
objos.writeObject(obj);
objos.close();
}

/**
* 反序列化
* @param filename
* @return
* @throws FileNotFoundException
* @throws IOException
* @throws ClassNotFoundException
*/
public Object readObj(String filename) throws FileNotFoundException, IOException, ClassNotFoundException {
ObjectInputStream objins = new ObjectInputStream(new FileInputStream(new File(filename)));
Object obj = objins.readObject();
objins.close();
return obj;
}

}

class Point implements Serializable{

private static final long serialVersionUID = 3583552501581482189L;

int x, y;
transient float rho, theta;

Point() {}

Point(int x, int y, float rho, float theta) {
this.x = x;
this.y = y;
this.rho = rho;
this.theta = theta;
}
}
x=1
y=2
rho=0.0
theta=0.0
</code>
</RECORD>
<RECORD>
<snippet_key>145678</snippet_key>
<tag>java 设计模式 java设计模式 Decorator 装饰者模式</tag>
<comment>来自CSDN博客：Java设计模式-Decorator（装饰）  http://blog.csdn.net/yangbin_hust/article/details/17956889#</comment>
<code>interface Sourcable {
public void operation();
}
class Source implements Sourcable {
public void operation() {
System.out.println(&quot;原始类的方法&quot;);
}
}
class Decorator1 implements Sourcable {
private Sourcable sourcable;
public Decorator1(Sourcable sourcable){
super();
this.sourcable=sourcable;
}
public void operation() {
System.out.println(&quot;第一个装饰器前&quot;);
sourcable.operation();
System.out.println(&quot;第一个装饰器后&quot;);
}
}
class Decorator2 implements Sourcable {
private Sourcable sourcable;
public Decorator2(Sourcable sourcable){
super();
this.sourcable=sourcable;
}
public void operation() {
System.out.println(&quot;第二个装饰器前&quot;);
sourcable.operation();
System.out.println(&quot;第二个装饰器后&quot;);
}
}
class Decorator3 implements Sourcable {
private Sourcable sourcable;
public Decorator3(Sourcable sourcable){
super();
this.sourcable=sourcable;
}
public void operation() {
System.out.println(&quot;第三个装饰器前&quot;);
sourcable.operation();
System.out.println(&quot;第三个装饰器后&quot;);
}
}
public class Test {
/**
* @param args
*/
public static void main(String[] args) {
Sourcable source = new Source();
// 装饰类对象
Sourcable obj = new Decorator1(new Decorator2(new Decorator3(source)));
obj.operation();
}
}
第一个装饰器前
第二个装饰器前
第三个装饰器前
原始类的方法
第三个装饰器后
第二个装饰器后
第一个装饰器后
</code>
</RECORD>
<RECORD>
<snippet_key>276750</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：Java多线程详解  http://blog.csdn.net/akon405/article/details/22992281#</comment>
<code>class PrimeThread extends Thread {
long minPrime;
PrimeThread(long minPrime) {
this.minPrime = minPrime;
}

public void run() {
// compute primes larger than minPrime
. . .
}
}
PrimeThread p = new PrimeThread(143);
p.start();
class PrimeRun implements Runnable {
long minPrime;
PrimeRun(long minPrime) {
this.minPrime = minPrime;

public void run() {
// compute primes larger than minPrime
. . .
}
}
//普通方法启动线程
PrimeRun p = new PrimeRun(143);
new Thread(p).start();
//使用线程池启动线程
PrimeRun p = new PrimeRun(143);
ExcutorService exec=Excutors.newCachedThreadpool();
Exec.execute(p);
public class Test extends Thread{
public static void main(String[] args){
Test1 t=new Test1();
t.start();
try{
t.join();//先执行完t线程再执行主线程
}catch(Exception e){
}
for(int i=0;i&lt;10;i++){
System.out.println(&quot;test&quot;);
}
}
}
class Test1 extends Thread{
public void run(){
for(int i=0;i&lt;10;i++){
System.out.println(&quot;test1&quot;);
}
}
}
public class TestThread{
public static void main(String[] args){
Tt tt=new Tt();
Thread thread=new Thread(tt);
thread.start();
try{
Thread.sleep(1000);
}catch(Exception e){
}
tt.m2();
}
}
class Tt implements Runnable{
public synchronized void m1(){
for(int i=0;i&lt;10;i++){
try{
Thread.sleep(1000);
}catch(Exception e){
}
System.out.println(&quot;m1&quot;);
}
}
public void m2(){
System.out.println(&quot;m2&quot;);
}
public void run(){
Tt tt=new Tt();
tt.m1();
}
}
class Task implements Runnable{
static Object o1=new Object(),o2=new Object();
public int flag=0;
public void run(){
if(flag==1){
synchronized(o1){
System.out.println(&quot;flag==1-------Synchronized o1&quot;);
try{
Thread.sleep(1000);
}catch(InterruptedException e){

}
synchronized(o2){
System.out.println(&quot;flag==1-------Synchronized o2&quot;);
}
}
}
if(flag==0){
synchronized(o2){
System.out.println(&quot;flag==0-------Synchronized o1&quot;);
try{
Thread.sleep(1000);
}catch(InterruptedException e){
}
synchronized(o1){
System.out.println(&quot;flag==0-------Synchronized o2&quot;);
}
}
}
}
}
public class DeadLock{
public static void main(String[] args){
Task task1=new Task();
Task task2=new Task();
task1.flag=1;
task2.flag=0;
Thread t1=new Thread(task1);
Thread t2=new Thread(task2);
t1.start();
t2.start();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>227589</snippet_key>
<tag>java list gui</tag>
<comment>来自CSDN博客：Java界面 SWT基本组件——列表框(List) http://blog.csdn.net/zstu_wangrui/article/details/20920465#</comment>
<code>import org.eclipse.swt.SWT;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Shell;

public class ListSample {

private Shell shell;
public ListSample(Shell sShell) {

shell = new Shell(sShell, SWT.CLOSE);

shell.setSize(350, 250);
shell.setText(&quot;ListSample&quot;);

String itemLeft[] = new String[20]; // 定义保存左侧列表框中的数据
String itemright[] = new String[0]; // 定义保存右侧列表框中的数据

for(int i = 0; i &lt; itemLeft.length; i++)
itemLeft[i] = &quot;item&quot; + i; // 初始化左侧字符串数组

final List left = new List(shell, SWT.MULTI|SWT.V_SCROLL);
// 定义左侧列表框，可选择多个且带有滚动条
left.setBounds(10, 10, 100, 180); // 设置位置和大小
left.setItems(itemLeft); // 设置选项数据
left.setToolTipText(&quot;Choosed List&quot;); // 设置提示

final List right = new List(shell, SWT.MULTI|SWT.V_SCROLL);
// 定义右侧列表框，可选择多个且带有滚动条
right.setBounds(170, 10, 100, 180);
right.setItems(itemright);
right.setToolTipText(&quot;Choosed List&quot;);

// 创建事件监听类，为内部类
SelectionAdapter listener = new SelectionAdapter() {
// 按钮单击事件处理的方法
public void widgetSelected(SelectionEvent e) {
// 取得触发事件的空间对象（按钮）
Button bt = (Button)e.widget;
if(bt.getText().equals(&quot;&gt;&quot;)) // 如果是“&gt;”按钮
verifyValue(left.getSelection(), left, right);
else if(bt.getText().equals(&quot;&gt;&gt;&quot;)) // 如果是“&gt;&gt;”按钮
verifyValue(left.getItems(), left, right);
else if(bt.getText().equals(&quot;&lt;&quot;)) // 如果是“&lt;”按钮
verifyValue(right.getSelection(), right, left);
else if(bt.getText().equals(&quot;&lt;&lt;&quot;)) // 如果是“&lt;&lt;”按钮
verifyValue(right.getItems(), right, left);
else if(bt.getText().equals(&quot;Up&quot;)) // 如果是“Up”按钮
{
int index = right.getSelectionIndex();
// 获得当前选中选项的索引值
if(index &lt;= 0) // 如未选中，则返回
return ;
String currentValue = right.getItem(index);
// 如果选中了选项值，获得当前选项的值
right.setItem(index, right.getItem(index - 1));
right.setItem(index - 1, currentValue);
// 将选中的选项与上一个选项交换值
right.setSelection(index - 1); // 设定上一选项为选中状态
}
else if(bt.getText().equals(&quot;Down&quot;)) // 如果是“Down”按钮
{
// 与“Up”按钮逻辑相同
int index = right.getSelectionIndex();
if(index &gt;= right.getItemCount() - 1)
return ;
String currentValue = right.getItem(index);
right.setItem(index, right.getItem(index + 1));
right.setItem(index + 1, currentValue);
right.setSelection(index + 1);
}
}
};

// 定义按钮
// 定义（单）右移按钮
Button bt1 = new Button(shell, SWT.NONE);
bt1.setText(&quot;&gt;&quot;);
bt1.setBounds(130, 20, 25, 20);
bt1.addSelectionListener(listener); // 为按钮注册事件，其他的按钮类似
// 定义（多）右移按钮
Button bt2 = new Button(shell, SWT.NONE);
bt2.setText(&quot;&gt;&gt;&quot;);
bt2.setBounds(130, 55, 25, 20);
bt2.addSelectionListener(listener);
// 定义（多）左移按钮
Button bt3 = new Button(shell, SWT.NONE);
bt3.setText(&quot;&lt;&lt;&quot;);
bt3.setBounds(130, 90, 25, 20);
bt3.addSelectionListener(listener);
// 定义（单）左移按钮
Button bt4 = new Button(shell, SWT.NONE);
bt4.setText(&quot;&lt;&quot;);
bt4.setBounds(130, 125, 25, 20);
bt4.addSelectionListener(listener);
// 定义上移按钮
Button bt5 = new Button(shell, SWT.NONE);
bt5.setText(&quot;Up&quot;);
bt5.setBounds(285, 70, 40, 20);
bt5.addSelectionListener(listener);
// 定义下移按钮
Button bt6 = new Button(shell, SWT.NONE);
bt6.setText(&quot;Down&quot;);
bt6.setBounds(285, 105, 40, 20);
bt6.addSelectionListener(listener);

shell.open();

}

private void verifyValue(String[] selected, List from, List to) {

for(int i = 0; i &lt; selected.length; i++)
{
from.remove(selected[i]); // 从一个列表中移除该选项值
to.add(selected[i]); // 添加到另一列表中
}

}

}
</code>
</RECORD>
<RECORD>
<snippet_key>342286</snippet_key>
<tag>152</tag>
<comment>JFrame示例</comment>
<code>package com.zhongx.swing;

import javax.swing.JFrame;
import javax.swing.JLabel;

public class TestJFrameDemo {
public static void main(String[] args) {
//创建窗口
JFrame jf = new JFrame(&quot;这是第一个窗口&quot;);
//创建标签类
JLabel jl = new JLabel(&quot;hello world&quot;);
//将标签加入到窗口类中
jf.add(jl);
//设置当前窗口的 位置和大小
jf.setBounds(0, 0, 300, 300);//设置当前窗口的位置和大小x,y,width,height
//设置当前窗口可见
jf.setVisible(true);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>293125</snippet_key>
<tag></tag>
<comment>来自CSDN博客：扩展spring类实现自动读取配置文件 http://blog.csdn.net/shan9liang/article/details/23747399#</comment>
<code>/**
* @author : jl
* @group : tgb8
* @Date : 2014-4-4 下午4:38:19
* @Comments : 方便开发人员使用可以使用PropertyConfigurer.getContextProperty()来取得上下文中的properties的值了。
* @Version : 1.0.0
*/
public class PropertyConfigure extends PropertyPlaceholderConfigurer {
private static Map&lt;String, Object&gt; ctxPropertiesMap;
@Override
protected void processProperties(ConfigurableListableBeanFactory beanFactory,
Properties props) throws BeansException {
super.processProperties(beanFactory, props);

ctxPropertiesMap = new HashMap&lt;String, Object&gt;();
for (Object key : props.keySet()) {
String keyStr = key.toString();
String value = props.getProperty(keyStr);
ctxPropertiesMap.put(keyStr, value);
}
}
public static Object getContextProperty(String name) {
//初始化全局配置
initApplicationContext(&quot;context-properties.xml&quot;);
return ctxPropertiesMap.get(name);
}

private static void initApplicationContext(String key) {
CacheHandler cacheHandler = CacheHandler.getInstance();
Cache cache = cacheHandler.getCacheByName(&quot;ApplicationContext&quot;);

//如果没有初始化ApplicationContext，则初始化，并放入缓存，防止下次再初始化
if (cache == null) {
System.out.println(&quot;创建ApplicationContext缓存&quot;);
cache = cacheHandler.addCache(&quot;ApplicationContext&quot;);
System.out.println(&quot;初始化ApplicationContext，key=&quot;+key);
ApplicationContext context = new ClassPathXmlApplicationContext(
key);
Element elementVal = new Element(key, context);
cache.put(elementVal);
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>358661</snippet_key>
<tag></tag>
<comment>来自CSDN博客：java集合类学习笔记---ArrayList  http://blog.csdn.net/maylorChao/article/details/26594873#</comment>
<code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
private static final int DEFAULT_CAPACITY = 10;

private static final Object[] EMPTY_ELEMENTDATA = {};

private transient Object[] elementData;

private int size;
 public ArrayList() {
      super();
        this.elementData = EMPTY_ELEMENTDATA;
  }
public ArrayList() {
super();
this(DEFAULT_CAPACITY);
}
private void grow(int minCapacity) {
// overflow-conscious code
int oldCapacity = elementData.length;
//设置新的容量大小
int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
if (newCapacity - minCapacity &lt; 0)
newCapacity = minCapacity;
if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
newCapacity = hugeCapacity(minCapacity);
// minCapacity is usually close to size, so this is a win:
elementData = Arrays.copyOf(elementData, newCapacity);
}
private void writeObject(java.io.ObjectOutputStream s)
throws java.io.IOException{
// Write out element count, and any hidden stuff
int expectedModCount = modCount;
s.defaultWriteObject();

// Write out size as capacity for behavioural compatibility with clone()
s.writeInt(size);

// Write out all elements in the proper order.
for (int i=0; i&lt;size; i++) {
s.writeObject(elementData[i]);
}

if (modCount != expectedModCount) {
throw new ConcurrentModificationException();
}
}
public class MyExam12_1 implements Serializable {
public ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();

public MyExam12_1() {
array.add(1);
array.add(1);
array.add(1);
array.add(1);
}

public static void main(String[] args) {
MyExam12_1 cat = new MyExam12_1();
try {
FileOutputStream fos = new FileOutputStream(&quot;catDemo.out&quot;);
ObjectOutputStream oos = new ObjectOutputStream(fos);
System.out.println(&quot; 1&gt; &quot; + Arrays.toString(cat.array.toArray()));
oos.writeObject(cat);
oos.close();
} catch (Exception ex) {
ex.printStackTrace();
}
try {
FileInputStream fis = new FileInputStream(&quot;catDemo.out&quot;);
ObjectInputStream ois = new ObjectInputStream(fis);
cat = (MyExam12_1) ois.readObject();
System.out.println(&quot; 2&gt; &quot; + Arrays.toString(cat.array.toArray()));
ois.close();
} catch (Exception ex) {
ex.printStackTrace();
}
}
}
public class MyExam12_1 implements Serializable {
public transient int[] array = { 1, 2, 3, 4, 5, 6, 7 };

public MyExam12_1() {
}

public static void main(String[] args) {
MyExam12_1 cat = new MyExam12_1();
try {
FileOutputStream fos = new FileOutputStream(&quot;catDemo.out&quot;);
ObjectOutputStream oos = new ObjectOutputStream(fos);
System.out.println(&quot; 1&gt; &quot; + Arrays.toString(cat.array));
oos.writeObject(cat);
oos.close();
} catch (Exception ex) {
ex.printStackTrace();
}
try {
FileInputStream fis = new FileInputStream(&quot;catDemo.out&quot;);
ObjectInputStream ois = new ObjectInputStream(fis);
cat = (MyExam12_1) ois.readObject();
System.out.println(&quot; 2&gt; &quot; + Arrays.toString(cat.array));
ois.close();
} catch (Exception ex) {
ex.printStackTrace();
}
}
}
public class MyExam12_1 implements Serializable {
public transient Object[] array = { 1, 2, 3, 4, 5, 6, 7 };


&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;public MyExam12_1() {
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}


&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;private void writeObject(java.io.ObjectOutputStream s)
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;throws java.io.IOException {
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;// Write out element count, and any hidden stuff
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;s.defaultWriteObject();


&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;// Write out all elements in the proper order.
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;for (int i = 0; i &lt; 7; i++) {
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;s.writeObject(array[i]);
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}


&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;private void readObject(java.io.ObjectInputStream s)
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;throws java.io.IOException, ClassNotFoundException {
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;// Read in size, and any hidden stuff
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;s.defaultReadObject();
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;array = new Object[7];
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;Object[] object = array;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;// Read in all elements in the proper order.
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;for (int i = 0; i &lt; 7; i++) {
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;object[i] = s.readObject();
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}
}
public class Main {

public static void main(String[] args) {
MyExam12_1 cat = new MyExam12_1();
try {
FileOutputStream fos = new FileOutputStream(&quot;catDemo.out&quot;);
ObjectOutputStream oos = new ObjectOutputStream(fos);
System.out.println(&quot; 1&gt; &quot; + Arrays.toString(cat.array));
oos.writeObject(cat);
oos.close();
} catch (Exception ex) {
ex.printStackTrace();
}
try {
FileInputStream fis = new FileInputStream(&quot;catDemo.out&quot;);
ObjectInputStream ois = new ObjectInputStream(fis);
cat = (MyExam12_1) ois.readObject();
System.out.println(&quot; 2&gt; &quot; + Arrays.toString(cat.array));
ois.close();
} catch (Exception ex) {
ex.printStackTrace();
}
}
}
可以看到输出为：
&lt;img src=&quot;http://img.blog.csdn.net/20140522174300015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWF5bG9yQ2hhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;&quot; /&gt;
public class MyExam12_1 implements Serializable {
public transient Object[] array = { 1, 2, 3, 4, 5, 6, 7 };

public MyExam12_1() {
}

private void writeObject(java.io.ObjectOutputStream s)
throws java.io.IOException {
// Write out element count, and any hidden stuff
s.defaultWriteObject();

// Write out all elements in the proper order.
for (int i = 0; i &lt; 7; i++) {
s.writeObject(array[i]);
}
}

private void readObject(java.io.ObjectInputStream s)
throws java.io.IOException, ClassNotFoundException {
// Read in size, and any hidden stuff
s.defaultReadObject();
array = new Object[7];
Object[] object = array;
// Read in all elements in the proper order.
for (int i = 0; i &lt; 7; i++) {
object[i] = s.readObject();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>96773</snippet_key>
<tag></tag>
<comment>来自CSDN博客：HashSet、TreeSet、LinkedHashSet三者比较  http://blog.csdn.net/snarlfuture/article/details/17108567#</comment>
<code>TreeSet&lt;Integer&gt; tree = new TreeSet&lt;Integer&gt;();
tree.add(12);
tree.add(63);
tree.add(34);
tree.add(45);

Iterator&lt;Integer&gt; iterator = tree.iterator();
System.out.print(&quot;Tree set data: &quot;);
while (iterator.hasNext()) {
System.out.print(iterator.next() + &quot; &quot;);
}
Tree set data: 12 34 45 63
class Dog {
int size;

public Dog(int s) {
size = s;
}

public String toString() {
return size + &quot;&quot;;
}
}
import java.util.Iterator;
import java.util.TreeSet;

public class TestTreeSet {
public static void main(String[] args) {
TreeSet&lt;Dog&gt; dset = new TreeSet&lt;Dog&gt;();
dset.add(new Dog(2));
dset.add(new Dog(1));
dset.add(new Dog(3));

Iterator&lt;Dog&gt; iterator = dset.iterator();

while (iterator.hasNext()) {
System.out.print(iterator.next() + &quot; &quot;);
}
}
}
Exception in thread “main” java.lang.ClassCastException: collection.Dog cannot be cast to java.lang.Comparable
at java.util.TreeMap.put(Unknown Source)
at java.util.TreeSet.add(Unknown Source)
at collection.TestTreeSet.main(TestTreeSet.java:22)
class Dog implements Comparable&lt;Dog&gt;{
int size;

public Dog(int s) {
size = s;
}

public String toString() {
return size + &quot;&quot;;
}

@Override
public int compareTo(Dog o) {
return size - o.size;
}
}
1 2 3
HashSet&lt;Dog&gt; dset = new HashSet&lt;Dog&gt;();
dset.add(new Dog(2));
dset.add(new Dog(1));
dset.add(new Dog(3));
dset.add(new Dog(5));
dset.add(new Dog(4));
Iterator&lt;Dog&gt; iterator = dset.iterator();
while (iterator.hasNext()) {
System.out.print(iterator.next() + &quot; &quot;);
}
5 3 2 1 4
LinkedHashSet&lt;Dog&gt; dset = new LinkedHashSet&lt;Dog&gt;();
dset.add(new Dog(2));
dset.add(new Dog(1));
dset.add(new Dog(3));
dset.add(new Dog(5));
dset.add(new Dog(4));
Iterator&lt;Dog&gt; iterator = dset.iterator();
while (iterator.hasNext()) {
System.out.print(iterator.next() + &quot; &quot;);
}
2 1 3 5 4
public static void main(String[] args) {

Random r = new Random();

HashSet&lt;Dog&gt; hashSet = new HashSet&lt;Dog&gt;();
TreeSet&lt;Dog&gt; treeSet = new TreeSet&lt;Dog&gt;();
LinkedHashSet&lt;Dog&gt; linkedSet = new LinkedHashSet&lt;Dog&gt;();

// start time
long startTime = System.nanoTime();

for (int i = 0; i &lt; 1000; i++) {
int x = r.nextInt(1000 - 10) + 10;
hashSet.add(new Dog(x));
}
// end time
long endTime = System.nanoTime();
long duration = endTime - startTime;
System.out.println(&quot;HashSet: &quot; + duration);


// start time
startTime = System.nanoTime();

for (int i = 0; i &lt; 1000; i++) {
int x = r.nextInt(1000 - 10) + 10;
treeSet.add(new Dog(x));
}
// end time
endTime = System.nanoTime();
duration = endTime - startTime;
System.out.println(&quot;TreeSet: &quot; + duration);


// start time
startTime = System.nanoTime();

for (int i = 0; i &lt; 1000; i++) {
int x = r.nextInt(1000 - 10) + 10;
linkedSet.add(new Dog(x));
}
// end time
endTime = System.nanoTime();
duration = endTime - startTime;
System.out.println(&quot;LinkedHashSet: &quot; + duration);
}
HashSet: 2244768
TreeSet: 3549314
LinkedHashSet: 2263320
</code>
</RECORD>
<RECORD>
<snippet_key>408078</snippet_key>
<tag>p2p</tag>
<comment>来自CSDN博客：Topic消息的发送与接收(Pub/Sub 消息传递模型)  http://blog.csdn.net/hanxuemin12345/article/details/35220273#</comment>
<code>&lt;span style=&quot;font-family:KaiTi_GB2312;font-size:18px;&quot;&gt;package com.jinbo.cn;

import javax.ejb.ActivationConfigProperty;
import javax.ejb.MessageDriven;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;

//通过注解配置 MDB 是一个什么样的消费者. 这里p2p消费者
@MessageDriven(
activationConfig={
@ActivationConfigProperty(propertyName = &quot;destinationType&quot;, propertyValue = &quot;javax.jms.Topic&quot;),
@ActivationConfigProperty(propertyName = &quot;destination&quot;, propertyValue = &quot;topic/mytopic&quot;)
}
)
public class MyTopicMDBBean implements MessageListener {

public void onMessage(Message msg) {
//转换为 TextMessage
TextMessage message = (TextMessage)msg;
try {
System.out.println(&quot;MyTopicMDBBean被调用了:[&quot; + message.getText() +&quot;]&quot;);
} catch (JMSException e) {
e.printStackTrace();
}
}
}&lt;/span&gt;
&lt;span style=&quot;font-family:KaiTi_GB2312;font-size:18px;&quot;&gt;package com.jinbo.cn;

import javax.ejb.ActivationConfigProperty;
import javax.ejb.MessageDriven;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;

//通过注解配置 MDB 是一个什么样的消费者. 这里p2p消费者
@MessageDriven(
activationConfig={
@ActivationConfigProperty(propertyName = &quot;destinationType&quot;, propertyValue = &quot;javax.jms.Topic&quot;),
@ActivationConfigProperty(propertyName = &quot;destination&quot;, propertyValue = &quot;topic/mytopic&quot;)
}
)
public class MyTopicMDBBean02 implements MessageListener {

public void onMessage(Message msg) {
//转换为 TextMessage
TextMessage message = (TextMessage)msg;
try {
System.out.println(&quot;MyTopicMDBBean02被调用了:[&quot; + message.getText() +&quot;]&quot;);
} catch (JMSException e) {
e.printStackTrace();
}
}
}
&lt;/span&gt;
&lt;span style=&quot;font-family:KaiTi_GB2312;font-size:18px;&quot;&gt;package com.jinb.cn;


import javax.jms.TextMessage;
import javax.jms.Topic;
import javax.jms.TopicConnection;
import javax.jms.TopicConnectionFactory;
import javax.jms.TopicPublisher;
import javax.jms.TopicSession;
import javax.naming.InitialContext;

public class MyTopicMDBBeanClient {

public static void main(String[] args) throws Exception {
InitialContext context = new InitialContext();

//获得QueueConnectionFactory对象
TopicConnectionFactory factory = (TopicConnectionFactory)context.lookup(&quot;ConnectionFactory&quot;);

//创建QueueConnection
TopicConnection connection = (TopicConnection)factory.createConnection();

/**
* 通过connection创建TopicSession对象；
* 其中第一个参数为是否支持事务，TRUE为支持，false为不支持；
* 若设为true,则需要手动COMMIT;
* 第二个参数为响应的模式，一般情况下就设为TopicSession.AUTO_ACKNOWLEDGE
* */
TopicSession session = (TopicSession)connection.createTopicSession(false, TopicSession.AUTO_ACKNOWLEDGE);

//获取Destination对象
Topic topic = (Topic)context.lookup(&quot;topic/mytopic&quot;);

//创建文本消息
TextMessage message = session.createTextMessage(&quot;世界, 你好 ! 我来了.&quot;);

//创建发布者,发送到Topic 目的对象
TopicPublisher publisher = session.createPublisher(topic);

//发布消息
publisher.send(message);

//关闭资源
session.close();
connection.close();

System.out.println(&quot;消息已经发送!&quot;);
}

}
&lt;/span&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>277518</snippet_key>
<tag>10</tag>
<comment>来自CSDN博客：【重构】小小领悟  http://blog.csdn.net/jingtianxiaozhi01/article/details/23027633#</comment>
<code>public enum CustomerType {

Common, Quick, VIP;
@Override
public String toString() {
switch (this) {
case Common:
return &quot;普通&quot;;
case Quick:
return &quot;快速&quot;;
case VIP:
return &quot;VIP&quot;;
}
return &quot;null&quot;;
};

}
public enum CustomerType {

Common {
@Override
public String toString() {
return &quot;普通&quot;;
}
},
Quick {
@Override
public String toString() {
return &quot;快速&quot;;
}
},
VIP {
@Override
public String toString() {
return &quot;VIP&quot;;
}
};

}
</code>
</RECORD>
<RECORD>
<snippet_key>97285</snippet_key>
<tag></tag>
<comment>来自CSDN博客：【九度】题目1491：求1和2的个数  http://blog.csdn.net/u013027996/article/details/17128027#</comment>
<code>import java.util.Scanner;

public class Main {
/*
* 1491
*/
private static int mod = 20123;
private static char array[];
private static int len;
public static void main(String[] args) throws Exception {
Scanner scanner = new Scanner(System.in);
while (scanner.hasNext()) {
String input = scanner.next();
array = input.toCharArray();
len = array.length;
System.out.println(modValue(calCount(1) + calCount(2)));
}
}

private static int calCount(int num) {
int k = len - 1;
int factor = 1;
int count = 0;
while (k &gt;= 0) {
int lowNum = 0;
int currNum = 0;
int highNum = 0;
for (int i = 0; i &lt; k; i++) {
highNum = modValue(modValue(highNum * 10) + (array[i] - &apos;0&apos;));
}
for (int i = k+1; i &lt; len; i++) {
lowNum = modValue(modValue(lowNum * 10) + array[i] - &apos;0&apos;);
}
currNum = array[k] - &apos;0&apos;;
if (currNum &lt; num){
count = modValue(count + highNum * factor);
}else if (currNum == num) {
count = modValue(count + highNum * factor + lowNum + 1);
}else if (currNum &gt; num) {
count = modValue(count + (highNum + 1) * factor);
}

factor = modValue(factor * 10);
k--;
}
return count;
}

private static int modValue(int n) {
return n % mod;
}
}

/**************************************************************
Problem: 1491
User: wzqwsrf
Language: Java
Result: Accepted
Time:130 ms
Memory:18248 kb
****************************************************************/
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

const int mod = 20123;
int len;
int i;
char array[1000];
int modValue(int n){
return n % mod;
}

int calCount(int num) {
int k = len - 1;
int factor = 1;
int count = 0;
while (k &gt;= 0) {
int lowNum = 0;
int currNum = 0;
int highNum = 0;
for (i = 0; i &lt; k; i++) {
highNum = modValue(modValue(highNum * 10) + (array[i] - &apos;0&apos;));
}
for (i = k+1; i &lt; len; i++) {
lowNum = modValue(modValue(lowNum * 10) + array[i] - &apos;0&apos;);
}
currNum = array[k] - &apos;0&apos;;
if (currNum &lt; num){
count = modValue(count + highNum * factor);
}else if (currNum == num) {
count = modValue(count + highNum * factor + lowNum + 1);
}else if (currNum &gt; num) {
count = modValue(count + (highNum + 1) * factor);
}

factor = modValue(factor * 10);
k--;
}
return count;
}

int main(){

while(scanf(&quot;%s&quot;,&amp;array) != EOF){
len = strlen(array);
printf(&quot;%d\n&quot;,modValue(calCount(1) + calCount(2)));
}
return 0;
}
/**************************************************************
Problem: 1491
User: wzqwsrf
Language: C++
Result: Accepted
Time:10 ms
Memory:1020 kb
****************************************************************/
</code>
</RECORD>
<RECORD>
<snippet_key>97541</snippet_key>
<tag></tag>
<comment>来自CSDN博客：java内部类  http://blog.csdn.net/sincewhen12/article/details/17127731#</comment>
<code>package innerclasses;



//: innerclasses/Parcel2.java

// Returning a reference to an inner class.



public class Parcel2 {

class Contents {

private int i = 11;

public int value() { return i; }

}

class Destination {

private String label;

Destination(String whereTo) {

label = whereTo;

}

String readLabel() { return label; }

}

public Destination to(String s) {

return new Destination(s);

}

public Contents contents() {

return new Contents();

}

public void ship(String dest) {

Contents c = contents();

Destination d = to(dest);

System.out.println(d.readLabel());

}

public static void main(String[] args) {

Parcel2 p = new Parcel2();

p.ship(&quot;Tasmania&quot;);

Parcel2 q = new Parcel2();

// Defining references to inner classes:

Parcel2.Contents c = q.contents();

Parcel2.Destination d = q.to(&quot;Borneo&quot;);

}

} /* Output:

Tasmania

*///:~
package innerclasses;



//: innerclasses/Sequence.java

// Holds a sequence of Objects.



interface Selector {

boolean end();

Object current();

void next();

}



public class Sequence {

private Object[] items;

private int next = 0;

public Sequence(int size) { items = new Object[size]; }

public void add(Object x) {

if(next &lt; items.length)

items[next++] = x;

}

private class SequenceSelector implements Selector {

private int i = 0;

public boolean end() { return i == items.length; }

public Object current() { return items[i]; }

public void next() { if(i &lt; items.length) i++; }

}

public Selector selector() {

return new SequenceSelector();

}

public static void main(String[] args) {

Sequence sequence = new Sequence(10);

for(int i = 0; i &lt; 10; i++)

sequence.add(Integer.toString(i));

Selector selector = sequence.selector();

while(!selector.end()) {

System.out.print(selector.current() + &quot; &quot;);

selector.next();

}

}

} /* Output:

0 1 2 3 4 5 6 7 8 9

*///:~
package innerclasses;



//: innerclasses/DotThis.java

// Qualifying access to the outer-class object.



public class DotThis {

void f() { System.out.println(&quot;DotThis.f()&quot;); }

public class Inner {

public DotThis outer() {

return DotThis.this;

// A plain &quot;this&quot; would be Inner&apos;s &quot;this&quot;

}

}

public Inner inner() { return new Inner(); }

public static void main(String[] args) {

DotThis dt = new DotThis();

DotThis.Inner dti = dt.inner();

dti.outer().f();

}

} /* Output:

DotThis.f()

*///:~
package innerclasses;



//: innerclasses/Parcel3.java

// Using .new to create instances of inner classes.



public class Parcel3 {

class Contents {

private int i = 11;

public int value() { return i; }

}

class Destination {

private String label;

Destination(String whereTo) { label = whereTo; }

String readLabel() { return label; }

}

public static void main(String[] args) {

Parcel3 p = new Parcel3();

// Must use instance of outer class

// to create an instance of the inner class:

Parcel3.Contents c = p.new Contents();

Parcel3.Destination d = p.new Destination(&quot;Tasmania&quot;);

}

}
package innerclasses;



//: innerclasses/TestParcel.java



class Parcel4 {

private class PContents implements Contents {

private int i = 11;

public int value() { return i; }

}

protected class PDestination implements Destination {

private String label;

private PDestination(String whereTo) {

label = whereTo;

}

public String readLabel() { return label; }

}

public Destination destination(String s) {

return new PDestination(s);

}

public Contents contents() {

return new PContents();

}

}



public class TestParcel {

public static void main(String[] args) {

Parcel4 p = new Parcel4();

Contents c = p.contents();

Destination d = p.destination(&quot;Tasmania&quot;);

//System.out.println(c.value());

//System.out.println(d.readLabel());

// Illegal -- can&apos;t access private class:

//! Parcel4.PContents pc = p.new PContents();

}

} ///:~
package innerclasses;



//: innerclasses/Parcel5.java

// Nesting a class within a method.



public class Parcel5 {

public Destination destination(String s) {

class PDestination implements Destination {

private String label;

private PDestination(String whereTo) {

label = whereTo;

}

public String readLabel() { return label; }

}

return new PDestination(s);

}

public static void main(String[] args) {

Parcel5 p = new Parcel5();

Destination d = p.destination(&quot;Tasmania&quot;);

}

} ///:~

下面的例子显示了在任意作用域内创建的内部类：

package innerclasses;



//: innerclasses/Parcel6.java

// Nesting a class within a scope.



public class Parcel6 {

private void internalTracking(boolean b) {

if(b) {

class TrackingSlip {

private String id;

TrackingSlip(String s) {

id = s;

}

String getSlip() { return id; }

}

TrackingSlip ts = new TrackingSlip(&quot;slip&quot;);

String s = ts.getSlip();

}

// Can&apos;t use it here! Out of scope:

//! TrackingSlip ts = new TrackingSlip(&quot;x&quot;);

}

public void track() { internalTracking(true); }

public static void main(String[] args) {

Parcel6 p = new Parcel6();

p.track();

}

} ///:~
package innerclasses;



//: innerclasses/Parcel7.java

// Returning an instance of an anonymous inner class.



public class Parcel7 {

public Contents contents() {

return new Contents() { // Insert a class definition

private int i = 11;

public int value() { return i; }

}; // Semicolon required in this case

}

public static void main(String[] args) {

Parcel7 p = new Parcel7();

Contents c = p.contents();

}

} ///:~

其含义表示如下：

package innerclasses;



//: innerclasses/Parcel7b.java

// Expanded version of Parcel7.java



public class Parcel7b {

class MyContents implements Contents {

private int i = 11;

public int value() { return i; }

}

public Contents contents() { return new MyContents(); }

public static void main(String[] args) {

Parcel7b p = new Parcel7b();

Contents c = p.contents();

}

} ///:~
package innerclasses;



//: innerclasses/Parcel8.java

// Calling the base-class constructor.



public class Parcel8 {

public Wrapping wrapping(int x) {

// Base constructor call:

return new Wrapping(x) { // Pass constructor argument.

public int value() {

return super.value() * 47;

}

}; // Semicolon required

}

public static void main(String[] args) {

Parcel8 p = new Parcel8();

Wrapping w = p.wrapping(10);



}

} ///:~
package innerclasses;



//: innerclasses/Parcel9.java

// An anonymous inner class that performs

// initialization. A briefer version of Parcel5.java.



public class Parcel9 {

// Argument must be final to use inside

// anonymous inner class:

public Destination destination(final String dest) {

return new Destination() {

private String label = dest;

public String readLabel() { return label; }

};

}

public static void main(String[] args) {

Parcel9 p = new Parcel9();

Destination d = p.destination(&quot;Tasmania&quot;);

//System.out.println((String)p.destination(&quot;Tasmania&quot;).readLabel());

}

}
package innerclasses;



//: innerclasses/AnonymousConstructor.java

// Creating a constructor for an anonymous inner class.

import static net.mindview.util.Print.*;



abstract class Base {

public Base(int i) {

print(&quot;Base constructor, i = &quot; + i);

}

public abstract void f();

}



public class AnonymousConstructor {

public static Base getBase(int i) {

return new Base(i) {

{ print(&quot;Inside instance initializer&quot;); }

public void f() {

print(&quot;In anonymous f()&quot;);

}

};

}

public static void main(String[] args) {

Base base = getBase(47);

base.f();

}

} /* Output:

Base constructor, i = 47

Inside instance initializer

In anonymous f()

*///:~
package innerclasses;



//: innerclasses/Parcel10.java

// Using &quot;instance initialization&quot; to perform

// construction on an anonymous inner class.



public class Parcel10 {

public Destination

destination(final String dest, final float price) {

return new Destination() {

private int cost;

// Instance initialization for each object:

{

cost = Math.round(price);

if(cost &gt; 100)

System.out.println(&quot;Over budget!&quot;);

}

private String label = dest;

public String readLabel() { return label; }

};

}

public static void main(String[] args) {

Parcel10 p = new Parcel10();

Destination d = p.destination(&quot;Tasmania&quot;, 101.395F);

}

} /* Output:

Over budget!

*///:~
package innerclasses;



//: innerclasses/Factories.java

import static net.mindview.util.Print.*;



interface Service {

void method1();

void method2();

}



interface ServiceFactory {

Service getService();

}



class Implementation1 implements Service {

private Implementation1() {}

public void method1() {print(&quot;Implementation1 method1&quot;);}

public void method2() {print(&quot;Implementation1 method2&quot;);}

public static ServiceFactory factory =

new ServiceFactory() {

public Service getService() {

return new Implementation1();

}

};

}



class Implementation2 implements Service {

private Implementation2() {}

public void method1() {print(&quot;Implementation2 method1&quot;);}

public void method2() {print(&quot;Implementation2 method2&quot;);}

public static ServiceFactory factory =

new ServiceFactory() {

public Service getService() {

return new Implementation2();

}

};

}



public class Factories {

public static void serviceConsumer(ServiceFactory fact) {

Service s = fact.getService();

s.method1();

s.method2();

}

public static void main(String[] args) {

serviceConsumer(Implementation1.factory);

// Implementations are completely interchangeable:

serviceConsumer(Implementation2.factory);

}

} /* Output:

Implementation1 method1

Implementation1 method2

Implementation2 method1

Implementation2 method2

*///:~
package innerclasses;



//: innerclasses/Parcel11.java

// Nested classes (static inner classes).



public class Parcel11 {

private static class ParcelContents implements Contents {

private int i = 11;

public int value() { return i; }

}

protected static class ParcelDestination

implements Destination {

private String label;

private ParcelDestination(String whereTo) {

label = whereTo;

}

public String readLabel() { return label; }

// Nested classes can contain other static elements:

public static void f() {}

static int x = 10;

static class AnotherLevel {

public static void f() {}

static int x = 10;

}

}

public static Destination destination(String s) {

return new ParcelDestination(s);

}

public static Contents contents() {

return new ParcelContents();

}

public static void main(String[] args) {

Contents c = contents();

Destination d = destination(&quot;Tasmania&quot;);

}

} ///:~
package innerclasses;



//: innerclasses/ClassInInterface.java

// {main: ClassInInterface$Test}



public interface ClassInInterface {

void howdy();

class Test implements ClassInInterface {

public void howdy() {

System.out.println(&quot;Howdy!&quot;);

}

public static void main(String[] args) {

new Test().howdy();

}

}

} /* Output:

Howdy!

*///:~
package innerclasses;



//: innerclasses/MultiNestingAccess.java

// Nested classes can access all members of all

// levels of the classes they are nested within.



class MNA {

private void f() {}

class A {

private void g() {}

public class B {

void h() {

g();

f();

}

}

}

}



public class MultiNestingAccess {

public static void main(String[] args) {

MNA mna = new MNA();

MNA.A mnaa = mna.new A();

MNA.A.B mnaab = mnaa.new B();

mnaab.h();

}

} ///:~
//: innerclasses/MultiImplementation.java

// With concrete or abstract classes, inner

// classes are the only way to produce the effect

// of &quot;multiple implementation inheritance.&quot;

package innerclasses;



class D {}

abstract class E {}



class Z extends D {

E makeE() { return new E() {}; }

}



public class MultiImplementation {

static void takesD(D d) {}

static void takesE(E e) {}

public static void main(String[] args) {

Z z = new Z();

takesD(z);

takesE(z.makeE());

}

} ///:~
//: innerclasses/Callbacks.java

// Using inner classes for callbacks

package innerclasses;

import static net.mindview.util.Print.*;



interface Incrementable {

void increment();

}



// Very simple to just implement the interface:

class Callee1 implements Incrementable {

private int i = 0;

public void increment() {

i++;

print(i);

}

}



class MyIncrement {

public void increment() { print(&quot;Other operation&quot;); }

static void f(MyIncrement mi) { mi.increment(); }

}



// If your class must implement increment() in

// some other way, you must use an inner class:

class Callee2 extends MyIncrement {

private int i = 0;

public void increment() {

super.increment();

i++;

print(i);

}

private class Closure implements Incrementable {

public void increment() {

// Specify outer-class method, otherwise

// you&apos;d get an infinite recursion:

Callee2.this.increment();

}

}

Incrementable getCallbackReference() {

return new Closure();

}

}



class Caller {

private Incrementable callbackReference;

Caller(Incrementable cbh) { callbackReference = cbh; }

void go() { callbackReference.increment(); }

}



public class Callbacks {

public static void main(String[] args) {

Callee1 c1 = new Callee1();

Callee2 c2 = new Callee2();

MyIncrement.f(c2);

Caller caller1 = new Caller(c1);

Caller caller2 = new Caller(c2.getCallbackReference());

caller1.go();

caller1.go();

caller2.go();

caller2.go();

}

} /* Output:

Other operation

1

1

2

Other operation

2

Other operation

3

*///:~
//: innerclasses/controller/Event.java

// The common methods for any control event.

package innerclasses.controller;



public abstract class Event {

private long eventTime;

protected final long delayTime;

public Event(long delayTime) {

this.delayTime = delayTime;

start();

}

public void start() { // Allows restarting

eventTime = System.nanoTime() + delayTime;

}

public boolean ready() {

return System.nanoTime() &gt;= eventTime;

}

public abstract void action();

} ///:~
//: innerclasses/controller/Controller.java

// The reusable framework for control systems.

package innerclasses.controller;

import java.util.*;



public class Controller {

// A class from java.util to hold Event objects:

private List&lt;Event&gt; eventList = new ArrayList&lt;Event&gt;();

public void addEvent(Event c) { eventList.add(c); }

public void run() {

while(eventList.size() &gt; 0)

// Make a copy so you&apos;re not modifying the list

// while you&apos;re selecting the elements in it:

for(Event e : new ArrayList&lt;Event&gt;(eventList))

if(e.ready()) {

System.out.println(e);

e.action();

eventList.remove(e);

}

}

} ///:~
package innerclasses;



//: innerclasses/GreenhouseControls.java

// This produces a specific application of the

// control system, all in a single class. Inner

// classes allow you to encapsulate different

// functionality for each type of event.

import innerclasses.controller.*;



public class GreenhouseControls extends Controller {

private boolean light = false;

public class LightOn extends Event {

public LightOn(long delayTime) { super(delayTime); }

public void action() {

// Put hardware control code here to

// physically turn on the light.

light = true;

}

public String toString() { return &quot;Light is on&quot;; }

}

public class LightOff extends Event {

public LightOff(long delayTime) { super(delayTime); }

public void action() {

// Put hardware control code here to

// physically turn off the light.

light = false;

}

public String toString() { return &quot;Light is off&quot;; }

}

private boolean water = false;

public class WaterOn extends Event {

public WaterOn(long delayTime) { super(delayTime); }

public void action() {

// Put hardware control code here.

water = true;

}

public String toString() {

return &quot;Greenhouse water is on&quot;;

}

}

public class WaterOff extends Event {

public WaterOff(long delayTime) { super(delayTime); }

public void action() {

// Put hardware control code here.

water = false;

}

public String toString() {

return &quot;Greenhouse water is off&quot;;

}

}

private String thermostat = &quot;Day&quot;;

public class ThermostatNight extends Event {

public ThermostatNight(long delayTime) {

super(delayTime);

}

public void action() {

// Put hardware control code here.

thermostat = &quot;Night&quot;;

}

public String toString() {

return &quot;Thermostat on night setting&quot;;

}

}

public class ThermostatDay extends Event {

public ThermostatDay(long delayTime) {

super(delayTime);

}

public void action() {

// Put hardware control code here.

thermostat = &quot;Day&quot;;

}

public String toString() {

return &quot;Thermostat on day setting&quot;;

}

}

// An example of an action() that inserts a

// new one of itself into the event list:

public class Bell extends Event {

public Bell(long delayTime) { super(delayTime); }

public void action() {

addEvent(new Bell(delayTime));

}

public String toString() { return &quot;Bing!&quot;; }

}

public class Restart extends Event {

private Event[] eventList;

public Restart(long delayTime, Event[] eventList) {

super(delayTime);

this.eventList = eventList;

for(Event e : eventList)

addEvent(e);

}

public void action() {

for(Event e : eventList) {

e.start(); // Rerun each event

addEvent(e);

}

start(); // Rerun this Event

addEvent(this);

}

public String toString() {

return &quot;Restarting system&quot;;

}

}

public static class Terminate extends Event {

public Terminate(long delayTime) { super(delayTime); }

public void action() { System.exit(0); }

public String toString() { return &quot;Terminating&quot;; }

}

} ///:~
package innerclasses;



//: innerclasses/GreenhouseController.java

// Configure and execute the greenhouse system.

// {Args: 5000}

import innerclasses.controller.*;



public class GreenhouseController {

public static void main(String[] args) {

GreenhouseControls gc = new GreenhouseControls();

// Instead of hard-wiring, you could parse

// configuration information from a text file here:

gc.addEvent(gc.new Bell(900));

Event[] eventList = {

gc.new ThermostatNight(0),

gc.new LightOn(200),

gc.new LightOff(400),

gc.new WaterOn(600),

gc.new WaterOff(800),

gc.new ThermostatDay(1400)

};

gc.addEvent(gc.new Restart(2000, eventList));

if(args.length == 1)

gc.addEvent(

new GreenhouseControls.Terminate(

new Integer(args[0])));

gc.run();

}

} /* Output:

Bing!

Thermostat on night setting

Light is on

Light is off

Greenhouse water is on

Greenhouse water is off

Thermostat on day setting

Restarting system

Terminating

*///:~
package innerclasses;



//: innerclasses/InheritInner.java

// Inheriting an inner class.



class WithInner {

class Inner {}

}



public class InheritInner extends WithInner.Inner {

//! InheritInner() {} // Won&apos;t compile

InheritInner(WithInner wi) {

wi.super();

}

public static void main(String[] args) {

WithInner wi = new WithInner();

InheritInner ii = new InheritInner(wi);

}

} ///:~
package innerclasses;



//: innerclasses/BigEgg.java

// An inner class cannot be overriden like a method.

import static net.mindview.util.Print.*;



class Egg {

private Yolk y;

protected class Yolk {

public Yolk() { print(&quot;Egg.Yolk()&quot;); }

}

public Egg() {

print(&quot;New Egg()&quot;);

y = new Yolk();

}

}



public class BigEgg extends Egg {

public class Yolk {

public Yolk() { print(&quot;BigEgg.Yolk()&quot;); }

}

public static void main(String[] args) {

new BigEgg();

}

} /* Output:

New Egg()

Egg.Yolk()

*///:~
package innerclasses;



//: innerclasses/BigEgg2.java

// Proper inheritance of an inner class.

import static net.mindview.util.Print.*;



class Egg2 {

protected class Yolk {

public Yolk() { print(&quot;Egg2.Yolk()&quot;); }

public void f() { print(&quot;Egg2.Yolk.f()&quot;);}

}

private Yolk y = new Yolk();

public Egg2() { print(&quot;New Egg2()&quot;); }

public void insertYolk(Yolk yy) { y = yy; }

public void g() { y.f(); }

}



public class BigEgg2 extends Egg2 {

public class Yolk extends Egg2.Yolk {

public Yolk() { print(&quot;BigEgg2.Yolk()&quot;); }

public void f() { print(&quot;BigEgg2.Yolk.f()&quot;); }

}

public BigEgg2() { insertYolk(new Yolk()); }

public static void main(String[] args) {

Egg2 e2 = new BigEgg2();

e2.g();

}

} /* Output:

Egg2.Yolk()

New Egg2()

Egg2.Yolk()

BigEgg2.Yolk()

BigEgg2.Yolk.f()

*///:~
package innerclasses;



//: innerclasses/LocalInnerClass.java

// Holds a sequence of Objects.

import static net.mindview.util.Print.*;



interface Counter {

int next();

}



public class LocalInnerClass {

private int count = 0;

Counter getCounter(final String name) {

// A local inner class:

class LocalCounter implements Counter {

public LocalCounter() {

// Local inner class can have a constructor

print(&quot;LocalCounter()&quot;);

}

public int next() {

printnb(name); // Access local final

return count++;

}

}

return new LocalCounter();

}

// The same thing with an anonymous inner class:

Counter getCounter2(final String name) {

return new Counter() {

// Anonymous inner class cannot have a named

// constructor, only an instance initializer:

{

print(&quot;Counter()&quot;);

}

public int next() {

printnb(name); // Access local final

return count++;

}

};

}

public static void main(String[] args) {

LocalInnerClass lic = new LocalInnerClass();

Counter

c1 = lic.getCounter(&quot;Local inner &quot;),

c2 = lic.getCounter2(&quot;Anonymous inner &quot;);

for(int i = 0; i &lt; 5; i++)

print(c1.next());

for(int i = 0; i &lt; 5; i++)

print(c2.next());

}

} /* Output:

LocalCounter()

Counter()

Local inner 0

Local inner 1

Local inner 2

Local inner 3

Local inner 4

Anonymous inner 5

Anonymous inner 6

Anonymous inner 7

Anonymous inner 8

Anonymous inner 9

*///:~
</code>
</RECORD>
<RECORD>
<snippet_key>294149</snippet_key>
<tag>453</tag>
<comment>来自CSDN博客：运用快慢指针判断链表是否有环 http://blog.csdn.net/u010865433/article/details/23780049#</comment>
<code>/**
* Definition for singly-linked list.
* class ListNode {
* int val;
* ListNode next;
* ListNode(int x) {
* val = x;
* next = null;
* }
* }
*/
// use fast pointer &amp; slow pointer,judge whether Linkedlist has a circle
//fast pointer foot two once; slow pointer foot one step once
//if Linkedlist has a circle ,fast will came across slow
public class Solution {
public boolean hasCycle(ListNode head) {
// IMPORTANT: Please reset any member data you declared, as
// the same Solution instance will be reused for each test case.
ListNode slow = head;
ListNode fast = head;
//fast==null in case empty Linkedlist
//fast.next.next!=null,make sure list is not our border
while(fast != null &amp;&amp; fast.next != null) {
slow = slow.next;
fast = fast.next.next;
if(slow == fast)
return true;
}
return false;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>408846</snippet_key>
<tag>42</tag>
<comment>来自CSDN博客：Eclipse自动补全增强，自动补全弹出时TAB、空格键功能修改  http://blog.csdn.net/yinhangfeng/article/details/35309193#</comment>
<code>public boolean verifyKey(VerifyEvent e) {
if (!Helper.okToUse(fProposalShell))
return true;

char key= e.character;
if (key == 0) {
int newSelection= fProposalTable.getSelectionIndex();
int visibleRows= (fProposalTable.getSize().y / fProposalTable.getItemHeight()) - 1;
int itemCount= fProposalTable.getItemCount();
switch (e.keyCode) {

case SWT.ARROW_LEFT :
case SWT.ARROW_RIGHT :
filterProposals();
return true;

case SWT.ARROW_UP :
newSelection -= 1;
if (newSelection &lt; 0)
newSelection= itemCount - 1;
break;

case SWT.ARROW_DOWN :
newSelection += 1;
if (newSelection &gt; itemCount - 1)
newSelection= 0;
break;

case SWT.PAGE_DOWN :
newSelection += visibleRows;
if (newSelection &gt;= itemCount)
newSelection= itemCount - 1;
break;

case SWT.PAGE_UP :
newSelection -= visibleRows;
if (newSelection &lt; 0)
newSelection= 0;
break;

case SWT.HOME :
newSelection= 0;
break;

case SWT.END :
newSelection= itemCount - 1;
break;

default :
if (e.keyCode != SWT.CAPS_LOCK &amp;&amp; e.keyCode != SWT.MOD1 &amp;&amp; e.keyCode != SWT.MOD2 &amp;&amp; e.keyCode != SWT.MOD3 &amp;&amp; e.keyCode != SWT.MOD4)
hide();
return true;
}

selectProposal(newSelection, (e.stateMask &amp; SWT.CTRL) != 0);

e.doit= false;
return false;

} else if(key == &apos;\t&apos;) {
//修改使按TAB时具有与ARROW_DOWN相同的效果
int newSelection = fProposalTable.getSelectionIndex() + 1;
if (newSelection &gt; fProposalTable.getItemCount() - 1)
newSelection = 0;
selectProposal(newSelection, (e.stateMask &amp; SWT.CTRL) != 0);
e.doit= false;
return false;
}

// key != 0
switch (key) {
case 0x1B: // Esc
e.doit= false;
hide();
break;

case &apos;\n&apos;: // Ctrl-Enter on w2k
case &apos;\r&apos;: // Enter
e.doit= false;
insertSelectedProposalWithMask(e.stateMask);
break;

// TAB已经具有ARROW_DOWN功能 1347行
// case &apos;\t&apos;:
// e.doit= false;
// fProposalShell.setFocus();
// return false;

default:
ICompletionProposal p= getSelectedProposal();
if (p instanceof ICompletionProposalExtension) {
ICompletionProposalExtension t= (ICompletionProposalExtension) p;
char[] triggers= t.getTriggerCharacters();
//if (contains(triggers, key)) { 修改阻止 = 空格 . 与 ; 的代码上屏
if (key != &apos;=&apos; &amp;&amp; key != 0x20 &amp;&amp; key != &apos;.&apos; &amp;&amp; key != &apos;;&apos;
&amp;&amp; contains(triggers, key)) {
e.doit= false;
hide();
insertProposal(p, key, e.stateMask, fContentAssistSubjectControlAdapter.getSelectedRange().x);
}
}
}

return true;
}
</code>
</RECORD>
<RECORD>
<snippet_key>359685</snippet_key>
<tag>java 源码 秒杀器</tag>
<comment>来自CSDN博客：Java 实现 淘宝秒杀 聚划算 自动提醒 源码 http://blog.csdn.net/Techzero/article/details/26686283#</comment>
<code>package com.itechzero.pricemonitor;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.URI;
import java.net.URL;
import java.net.URLConnection;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
* PriceMonitor.java
*
* @author Techzero
* @Email techzero@163.com
* @Time 2014-5-21 下午1:24:30
*/
class MyThread extends Thread {
public void run() {
try {
// 此处参数为监控持续分钟数
PriceMonitor.monitorButton(10);
} catch (Exception e) {
e.printStackTrace();
}
}
};

public class PriceMonitor {
// 监控的商品URL
private static String URL = &quot;http://detail.ju.taobao.com/home.htm?spm=608.2214381.3.1.AdPEjn&amp;item_id=38260927591&amp;id=10000002781939&quot;;

// 监视按钮
public static void monitorButton(int lastMinute) {
int nowMinute = Integer.parseInt(new SimpleDateFormat(&quot;mm&quot;).format(new Date()));
int endMinute = Integer.parseInt(new SimpleDateFormat(&quot;mm&quot;).format(new Date())) + lastMinute;
while (nowMinute &lt; endMinute) {
nowMinute = Integer.parseInt(new SimpleDateFormat(&quot;mm&quot;).format(new Date()));
String result[] = getCurrentButtonAndForm(URL, &quot;gb2312&quot;).split(&quot;,&quot;);
// 当前按钮状态
String currentButton = result[0];
// 马上抢 表单
//String form = result[1];
String nowTime = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());
System.out.println(nowTime + &quot; - 现在按钮是 &quot; + currentButton);

if (currentButton == &quot;马上抢&quot; || currentButton.equals(&quot;马上抢&quot;) || currentButton == &quot;还有机会&quot; || currentButton.equals(&quot;还有机会&quot;)) {
System.out.println(&quot;赶紧下单！&quot;);
try {
java.awt.Desktop.getDesktop().browse(new URI(URL));
} catch (Exception e) {
e.printStackTrace();
}
//doPost(form);
break;
} else if (currentButton == &quot;卖光了&quot; || currentButton.equals(&quot;卖光了&quot;) || currentButton.equals(&quot;已结束&quot;) || currentButton.equals(&quot;已结束&quot;)) {
System.out.println(&quot;下次再试吧！&quot;);
break;
} else {
System.out.println(&quot;还没开始呢，再等等吧！&quot;);
}
}
}

// 获取当前按钮状态
public static String getCurrentButtonAndForm(String url, String encoding) {
if (url == null || &quot;&quot;.equals(url.trim()))
return null;
String buttonState = &quot;&quot;;
StringBuffer content = new StringBuffer();
boolean formFlag = false;
try {
// 新建URL对象
URL u = new URL(url);
InputStream is = new BufferedInputStream(u.openStream());
InputStreamReader theHTML = new InputStreamReader(is, encoding != null ? encoding : &quot;gb2312&quot;);
BufferedReader br = new BufferedReader(theHTML);
String s = &quot;&quot;;
while ((s = br.readLine()) != null) {
if (s.indexOf(&quot;&lt;input type=\&quot;submit\&quot; class=\&quot;buyaction J_BuySubmit\&quot; title=\&quot;马上抢\&quot; value=\&quot;马上抢\&quot;/&gt;&quot;) != -1) {
buttonState = &quot;马上抢&quot;;
} else if (s.indexOf(&quot;&lt;a href=\&quot;#\&quot; class=\&quot;extra notice J_BuyButtonSub\&quot;&gt;开团提醒&lt;/a&gt;&quot;) != -1) {
buttonState = &quot;开团提醒&quot;;
} else if (s.indexOf(&quot;&lt;div class=\&quot;main-box chance \&quot;&gt;&quot;) != -1) {
buttonState = &quot;还有机会&quot;;
} else if (s.indexOf(&quot;&lt;span class=\&quot;out floatright\&quot;&gt;卖光了...&lt;/span&gt;&quot;) != -1) {
buttonState = &quot;卖光了&quot;;
} else if (s.indexOf(&quot;&lt;span class=\&quot;out floatright\&quot;&gt;已结束...&lt;/span&gt;&quot;) != -1) {
buttonState = &quot;已结束&quot;;
}
if (s.indexOf(&quot;&lt;form class=\&quot;J_BuySubForm\&quot; data-ccb=\&quot;0\&quot; data-ques=\&quot;0\&quot; action&quot;) != -1) {
content.append(s + &quot;\r\n&quot;);
formFlag = true;
}
if (formFlag == true) {
if (s.indexOf(&quot;&lt;input name=\&apos;_tb_token_\&apos; type=\&apos;hidden\&apos; value&quot;) != -1) {
content.append(s + &quot;\r\n&quot;);
}
if (s.indexOf(&quot;&lt;input type=\&quot;hidden\&quot; name=\&quot;_input_charset\&quot; value&quot;) != -1) {
content.append(s + &quot;\r\n&quot;);
}
if (s.indexOf(&quot;&lt;input type=\&quot;hidden\&quot; name=\&quot;itemId\&quot; value&quot;) != -1) {
content.append(s + &quot;\r\n&quot;);
}
if (s.indexOf(&quot;&lt;input type=\&quot;hidden\&quot; name=\&quot;id\&quot; value&quot;) != -1) {
content.append(s + &quot;\r\n&quot;);
}
if (s.indexOf(&quot;&lt;input type=\&quot;hidden\&quot; name=\&quot;tgType\&quot; value&quot;) != -1) {
content.append(s + &quot;\r\n&quot;);
}
if (s.indexOf(&quot;&lt;input type=\&quot;submit\&quot; class=\&quot;buyaction J_BuySubmit\&quot;&quot;) != -1) {
content.append(s + &quot;\r\n&quot;);
}
if (s.indexOf(&quot;&lt;/form&gt;&quot;) != -1) {
content.append(s + &quot;\r\n&quot;);
}
}
if (s.indexOf(&quot;&lt;div class=\&quot;time-banner\&quot;&gt;&quot;) != -1) {
break;
}
}
br.close();
} catch (Exception e) {
System.err.println(e);
return &quot;Open URL Error&quot;;
}
return buttonState + &quot;,&quot; + content;
}

// 提交表单
public static String doPost(String form) {
StringBuffer content = new StringBuffer();
try {
URLConnection connection = new URL(URL).openConnection();
connection.setDoOutput(true);
OutputStreamWriter os = new OutputStreamWriter(connection.getOutputStream(), &quot;UTF-8&quot;);
os.write(form);
os.flush();
os.close();
InputStream is = connection.getInputStream();
InputStreamReader theHTML = new InputStreamReader(is);
BufferedReader br = new BufferedReader(theHTML);
String s = &quot;&quot;;
while ((s = br.readLine()) != null) {
content.append(s + &quot;\r\n&quot;);
}
} catch (Exception e) {
e.printStackTrace();
}
// 返回提交表单后返回的页面内容
return content.toString();
}

// 登录
public static void doLogin(String username, String password) {
String form = &quot;&lt;form id=\&quot;J_StaticForm\&quot; action=\&quot;https://login.taobao.com/member/login.jhtml\&quot; method=\&quot;post\&quot; autocomplete=\&quot;on\&quot;&gt;&lt;input type=\&quot;text\&quot; name=\&quot;TPL_username\&quot; id=\&quot;TPL_username_1\&quot; value=\&quot;&quot; + username + &quot;\&quot;&gt;&lt;input type=\&quot;password\&quot; name=\&quot;TPL_password\&quot; id=\&quot;TPL_password_1\&quot; value=\&quot;&quot; + password + &quot;\&quot;&gt;&lt;input type=\&quot;hidden\&quot; id=\&quot;J_TPL_redirect_url\&quot; name=\&quot;TPL_redirect_url\&quot; value=\&quot;http://www.taobao.com/?spm=a2107.1.1000340.1.AL2Mpn\&quot;&gt;&lt;button type=\&quot;submit\&quot; id=\&quot;J_SubmitStatic\&quot;&gt;登 录&lt;/button&gt;&lt;/form&gt;&quot;;
doPost(form);
}

public static void main(String[] args) {
//doLogin();
// new MyThread().start();
// new MyThread().start();
// new MyThread().start();
// new MyThread().start();
// new MyThread().start();
// new MyThread().start();
// new MyThread().start();
new MyThread().start();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>16142</snippet_key>
<tag>android 手机</tag>
<comment>对手机上联系人的method</comment>
<code>// 获得所有的联系人
Cursor cur = getContentResolver().query(
ContactsContract.Contacts.CONTENT_URI,
null,
null,
null,
ContactsContract.Contacts.DISPLAY_NAME
+ &quot; COLLATE LOCALIZED ASC&quot;);
// 循环遍历
if (cur.moveToFirst()) {
int idColumn = cur.getColumnIndex(ContactsContract.Contacts._ID);
int displayNameColumn = cur
.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME);

do {
// 获得联系人的ID号
String contactId = cur.getString(idColumn);
// 获得联系人姓名
String disPlayName = cur.getString(displayNameColumn);

// 查看该联系人有多少个电话号码。如果没有这返回值为0
int phoneCount = cur
.getInt(cur
.getColumnIndex(ContactsContract.Contacts.HAS_PHONE_NUMBER));
//Log.i(&quot;username&quot;, disPlayName+contactId+phoneCount);
if (phoneCount &gt; 0) {
// 获得联系人的电话号码
Cursor phones = getContentResolver().query(
ContactsContract.CommonDataKinds.Phone.CONTENT_URI,
null,
ContactsContract.CommonDataKinds.Phone.CONTACT_ID
+ &quot; = &quot; + contactId, null, null);
if (phones.moveToFirst()) {
do {
// 遍历所有的电话号码
String phoneNumber = phones
.getString(phones
.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));
String phoneType = phones
.getString(phones
.getColumnIndex(ContactsContract.CommonDataKinds.Phone.TYPE));
// Log.i(&quot;phoneNumber&quot;, phoneNumber);
// Log.i(&quot;phoneType&quot;, phoneType);
} while (phones.moveToNext());
}
}

// 获取该联系人邮箱
Cursor emails = getContentResolver().query(
ContactsContract.CommonDataKinds.Email.CONTENT_URI,
null,
ContactsContract.CommonDataKinds.Phone.CONTACT_ID
+ &quot; = &quot; + contactId, null, null);
if (emails.moveToFirst()) {
do {
// 遍历所有的电话号码
String emailType = emails
.getString(emails
.getColumnIndex(ContactsContract.CommonDataKinds.Email.TYPE));
String emailValue = emails
.getString(emails
.getColumnIndex(ContactsContract.CommonDataKinds.Email.DATA));
//
// Log.i(&quot;emailType&quot;, emailType);
// Log.i(&quot;emailValue&quot;, emailValue);
} while (emails.moveToNext());
}

// 获取该联系人IM
Cursor IMs = getContentResolver().query(
Data.CONTENT_URI,
new String[] { Data._ID, Im.PROTOCOL, Im.DATA },
Data.CONTACT_ID + &quot;=?&quot; + &quot; AND &quot; + Data.MIMETYPE + &quot;=&apos;&quot;
+ Im.CONTENT_ITEM_TYPE + &quot;&apos;&quot;,
new String[] { contactId }, null);
if (IMs.moveToFirst()) {
do {
String protocol = IMs.getString(IMs
.getColumnIndex(Im.PROTOCOL));
String date = IMs
.getString(IMs.getColumnIndex(Im.DATA));
//Log.i(&quot;protocol&quot;, protocol);
// Log.i(&quot;date&quot;, date);
} while (IMs.moveToNext());
}

// 获取该联系人地址
Cursor address = getContentResolver()
.query(
ContactsContract.CommonDataKinds.StructuredPostal.CONTENT_URI,
null,
ContactsContract.CommonDataKinds.Phone.CONTACT_ID
+ &quot; = &quot; + contactId, null, null);
if (address.moveToFirst()) {
do {
// 遍历所有的地址
String street = address
.getString(address
.getColumnIndex(ContactsContract.CommonDataKinds.StructuredPostal.STREET));
String city = address
.getString(address
.getColumnIndex(ContactsContract.CommonDataKinds.StructuredPostal.CITY));
String region = address
.getString(address
.getColumnIndex(ContactsContract.CommonDataKinds.StructuredPostal.REGION));
String postCode = address
.getString(address
.getColumnIndex(ContactsContract.CommonDataKinds.StructuredPostal.POSTCODE));
String formatAddress = address
.getString(address
.getColumnIndex(ContactsContract.CommonDataKinds.StructuredPostal.FORMATTED_ADDRESS));
// Log.i(&quot;street&quot;, street);
// Log.i(&quot;city&quot;, city);
// Log.i(&quot;region&quot;, region);
// Log.i(&quot;postCode&quot;, postCode);
// Log.i(&quot;formatAddress&quot;, formatAddress);
} while (address.moveToNext());
}

// 获取该联系人组织
Cursor organizations = getContentResolver().query(
Data.CONTENT_URI,
new String[] { Data._ID, Organization.COMPANY,
Organization.TITLE },
Data.CONTACT_ID + &quot;=?&quot; + &quot; AND &quot; + Data.MIMETYPE + &quot;=&apos;&quot;
+ Organization.CONTENT_ITEM_TYPE + &quot;&apos;&quot;,
new String[] { contactId }, null);
if (organizations.moveToFirst()) {
do {
String company = organizations.getString(organizations
.getColumnIndex(Organization.COMPANY));
String title = organizations.getString(organizations
.getColumnIndex(Organization.TITLE));
// Log.i(&quot;company&quot;, company);
// Log.i(&quot;title&quot;, title);
} while (organizations.moveToNext());
}

// 获取备注信息
Cursor notes = getContentResolver().query(
Data.CONTENT_URI,
new String[] { Data._ID, Note.NOTE },
Data.CONTACT_ID + &quot;=?&quot; + &quot; AND &quot; + Data.MIMETYPE + &quot;=&apos;&quot;
+ Note.CONTENT_ITEM_TYPE + &quot;&apos;&quot;,
new String[] { contactId }, null);
if (notes.moveToFirst()) {
do {
String noteinfo = notes.getString(notes
.getColumnIndex(Note.NOTE));
// Log.i(&quot;noteinfo&quot;, noteinfo);
} while (notes.moveToNext());
}

// 获取nickname信息
Cursor nicknames = getContentResolver().query(
Data.CONTENT_URI,
new String[] { Data._ID, Nickname.NAME },
Data.CONTACT_ID + &quot;=?&quot; + &quot; AND &quot; + Data.MIMETYPE + &quot;=&apos;&quot;
+ Nickname.CONTENT_ITEM_TYPE + &quot;&apos;&quot;,
new String[] { contactId }, null);
if (nicknames.moveToFirst()) {
do {
String nickname_ = nicknames.getString(nicknames
.getColumnIndex(Nickname.NAME));
// Log.i(&quot;nickname_&quot;, nickname_);
} while (nicknames.moveToNext());
}

} while (cur.moveToNext());

}
long end=System.currentTimeMillis();
System.out.println(end-start);
</code>
</RECORD>
<RECORD>
<snippet_key>409358</snippet_key>
<tag>472,476</tag>
<comment>来自CSDN博客：java 13：数组排序——选择排序及插入排序  http://blog.csdn.net/menogen/article/details/35558687#</comment>
<code>public class SelectionSort
{
public static void selectionSort(int [] a)
{
int min;
int index;
for(int i=0;i&lt;a.length;i++)
{
min=a[i];
index=i;
for(int j=i+1;j&lt;a.length;j++)
{
if(a[j]&lt;min)
{
min=a[j];
index=j;
}
}
a[index]=a[i];
a[i]=min;

}
}
public static void main(String [] args)
{
int [] a={2,4,72,34,0,67,3};
selectionSort(a);
for(int i=0;i&lt;a.length;i++)
{
System.out.print(a[i]+&quot; &quot;);
}
}
}
public class InsertSort
{
public static void insertSort(int [] a)
{
int cur,j;
&lt;span style=&quot;color:#ff0000;&quot;&gt;for(int i=1;i&lt;a.length;i++)
{
//if(a[i]&gt;=a[i-1]) continue;
cur=a[i];
j=i-1;
while(j&gt;=0&amp;&amp;cur&lt;a[j])
{
a[j+1]=a[j];
j--;
}
a[j+1]=cur;
}&lt;/span&gt;
}
public static void main(String [] args)
{
int [] a={2,4,72,34,0,67,3};
insertSort(a);
for(int i=0;i&lt;a.length;i++)
{
System.out.print(a[i]+&quot; &quot;);
}
}
}
&lt;span style=&quot;color:#ff0000;&quot;&gt;while(j&gt;=0&amp;&amp;cur&lt;a[j])&lt;/span&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>163845</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：初探Java中的多线程  http://blog.csdn.net/u010976923/article/details/18547837#</comment>
<code>public class Lisa extends Thread{
private String name;
public Lisa(String name){
this.name = name;
}
public void run(){
System.out.println(&quot;čżčĄ&quot;+name);
}
}
public static void main(String[] args){
Lisa lisa1 = new Lisa(&quot;aaa&quot;);
Lisa lisa2 = new Lisa(&quot;bbb&quot;);
Lisa lisa3 = new Lisa(&quot;ccc&quot;);
Lisa lisa4 = new Lisa(&quot;ddd&quot;);
Lisa lisa5 = new Lisa(&quot;eee&quot;);

lisa1.run();
lisa2.run();
lisa3.run();
lisa4.run();
lisa5.run();

}
public static void main(String[] args){
Lisa lisa1 = new Lisa(&quot;aaa&quot;);
Lisa lisa2 = new Lisa(&quot;bbb&quot;);
Lisa lisa3 = new Lisa(&quot;ccc&quot;);
Lisa lisa4 = new Lisa(&quot;ddd&quot;);
Lisa lisa5 = new Lisa(&quot;eee&quot;);

lisa1.start();
lisa2.start();
lisa3.start();
lisa4.start();
lisa5.start();

}
public synchronized void start() {
/**
* This method is not invoked for the main method thread or &quot;system&quot;
* group threads created/set up by the VM. Any new functionality added
* to this method in the future may have to also be added to the VM.
*
* A zero status value corresponds to state &quot;NEW&quot;.
*/
if (threadStatus != 0)
throw new IllegalThreadStateException();

/* Notify the group that this thread is about to be started
* so that it can be added to the group&apos;s list of threads
* and the group&apos;s unstarted count can be decremented. */
group.add(this);

boolean started = false;
try {
start0();
started = true;
} finally {
try {
if (!started) {
group.threadStartFailed(this);
}
} catch (Throwable ignore) {
/* do nothing. If start0 threw a Throwable then
it will be passed up the call stack */
}
}
}

private native void start0();
public static void main(String[] args){
Lisa lisa1 = new Lisa(&quot;aaa&quot;);
Lisa lisa2 = new Lisa(&quot;bbb&quot;);
Lisa lisa3 = new Lisa(&quot;ccc&quot;);
Lisa lisa4 = new Lisa(&quot;ddd&quot;);
Lisa lisa5 = new Lisa(&quot;eee&quot;);
Thread demo1 = new Thread(lisa1);
Thread demo2 = new Thread(lisa2);
Thread demo3 = new Thread(lisa3);
Thread demo4 = new Thread(lisa4);
Thread demo5 = new Thread(lisa5);
demo1.start();
demo2.start();
demo3.start();
demo4.start();
demo5.start();


}
class Thread implements Runnable {
/* Make sure registerNatives is the first thing &lt;clinit&gt; does. */
private static native void registerNatives();
static {
registerNatives();
}
</code>
</RECORD>
<RECORD>
<snippet_key>278542</snippet_key>
<tag>201</tag>
<comment>派生自冰点白开水/blog_20140214_1_3187668</comment>
<code>package com.itheima;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;

/**
* 4、 ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 在这个泛型为Integer的ArrayList中存放一个String类型的对象。
* @author yanan.wang
* @version 1.0 14/02/2014
*/
public class Test_4 {

public static void main(String[] args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {

String str = &quot;Hello&quot;;
ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
Method[] methods = list.getClass().getMethods();
for(Method m : methods) {
// System.out.println(m.getName());
if(m.getName().equals(&quot;add&quot;)) {
Class[] paramsClass = m.getParameterTypes();
if(paramsClass.length == 1) {
for(Class c : paramsClass) {
// System.out.println(c.getName());
if(c.getName().equals(Object.class.getName())) {
m.invoke(list, str);
break;
}
}
}
}
}

for(Object o : list) {
System.out.println(o);
}
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>147726</snippet_key>
<tag></tag>
<comment>来自CSDN博客：客户类型CustomerType http://blog.csdn.net/m75100313/article/details/18002645#</comment>
<code>package com.mth.bank;

public enum CustomerType {
COMMON, EXPRESS, VIP;

@Override
public String toString() {
switch (this) {
case COMMON:
return &quot;普通&quot;;
case EXPRESS:
return &quot;快速&quot;;
case VIP:
return &quot;VIP&quot;;
}
return null;
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>213262</snippet_key>
<tag>485</tag>
<comment>java 动态规划 leetcode来自CSDN博客：LeetCode | Interleaving String  http://blog.csdn.net/perfect8886/article/details/20288083#</comment>
<code>public class InterleavingString {
public boolean isInterleave(String s1, String s2, String s3) {
assert s1 != null &amp;&amp; s2 != null &amp;&amp; s3 != null;
int M = s1.length();
int N = s2.length();
if (M + N != s3.length()) {
return false;
}

// init
boolean[][] dp = new boolean[M + 1][N + 1];
dp[M][N] = true;

// dp
for (int i = M; i &gt;= 0; --i) {
for (int j = N; j &gt;= 0; --j) {
if (j &lt; N &amp;&amp; s2.charAt(j) == s3.charAt(i + j)) {
dp[i][j] |= dp[i][j + 1];
}
if (i &lt; M &amp;&amp; s1.charAt(i) == s3.charAt(i + j)) {
dp[i][j] |= dp[i + 1][j];
}
}
}

return dp[0][0];
}
}
public class InterleavingString {
public boolean isInterleave(String s1, String s2, String s3) {
assert s1 != null &amp;&amp; s2 != null &amp;&amp; s3 != null;
int M = s1.length();
int N = s2.length();
if (M + N != s3.length()) {
return false;
}

// init
boolean[][] dp = new boolean[M + 1][N + 1];
dp[M][N] = true;
for (int i = M - 1; i &gt;= 0; --i) {
dp[i][N] = s1.charAt(i) == s3.charAt(i + N) &amp;&amp; dp[i + 1][N];
}
for (int j = N - 1; j &gt;= 0; --j) {
dp[M][j] = s2.charAt(j) == s3.charAt(j + M) &amp;&amp; dp[M][j + 1];
}

// dp
for (int i = M - 1; i &gt;= 0; --i) {
for (int j = N - 1; j &gt;= 0; --j) {
dp[i][j] = (s2.charAt(j) == s3.charAt(i + j) &amp;&amp; dp[i][j + 1])
|| (s1.charAt(i) == s3.charAt(i + j) &amp;&amp; dp[i + 1][j]);
}
}

return dp[0][0];
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>295173</snippet_key>
<tag></tag>
<comment>java解惑--多重转型</comment>
<code>// 多重转型导致错误
public class Multicast{
public static void main (String[] args){
System.out.println((int)(char)(byte) -1);
}
}

// 期望结果：-1
// 实际结果：65535
</code>
</RECORD>
<RECORD>
<snippet_key>344334</snippet_key>
<tag>java 字符串比较</tag>
<comment>来自CSDN博客：Java中equals和==的区别  http://blog.csdn.net/YeSy10/article/details/25781191#</comment>
<code>public class TestString {
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;public static void main(String[] args) {
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;String s1 = &quot;Monday&quot;;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;String s2 = &quot;Monday&quot;;
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;if (s1 == s2) {
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;System.out.println(&quot;s1 == s2&quot;);
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;} else {
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;System.out.println(&quot;s1 != s2&quot;);
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;}
}
&lt;span style=&quot;font-size:18px;&quot;&gt;public class TestString {
public static void main(String[] args) {
String s1 = &quot;Monday&quot;;
String s2 = new String(&quot;Monday&quot;);
if (s1 == s2) {
System.out.println(&quot;s1 == s2&quot;);
} else {
System.out.println(&quot;s1 != s2&quot;);
}
if (s1.equals(s2)) {
System.out.println(&quot;s1 equals s2&quot;);
} else {
System.out.println(&quot;s1 not equals s2&quot;);
}
}
}&lt;/span&gt;
&lt;span style=&quot;font-size:18px;&quot;&gt;public class TestString {
public static void main(String[] args) {
String s1 = &quot;Monday&quot;;
String s2 = new String(&quot;Monday&quot;);
s2 = s2.intern();
if (s1 == s2) {
System.out.println(&quot;s1 == s2&quot;);
} else {
System.out.println(&quot;s1 != s2&quot;);
}
if (s1.equals(s2)) {
System.out.println(&quot;s1 equals s2&quot;);
} else {
System.out.println(&quot;s1 not equals s2&quot;);
}
}
}&lt;/span&gt;
&lt;span style=&quot;font-size:18px;&quot;&gt;java中的数据类型，可分为两类： 1.基本数据类型，也称原始数据类型。byte,short,char,int,long,float,double,boolean   他们之间的比较，应用双等号（==）,比较的是他们的值。 2.复合数据类型(类)   当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。&lt;/span&gt;&lt;p&gt;&lt;span style=&quot;font-size:18px;&quot;&gt;  对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;&lt;span style=&quot;font-size:18px;&quot;&gt;public class TestString {
public static void main(String[] args) {
String s1 = &quot;Monday&quot;;
String s2 = &quot;Monday&quot;;
if (s1 == s2) {
System.out.println(&quot;s1 == s2&quot;);
} else {
System.out.println(&quot;s1 != s2&quot;);
}
}
}&lt;/span&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>82446</snippet_key>
<tag></tag>
<comment>来自CSDN博客：JavaSE 拾遗(4)——JavaSE 面向对象程序设计语言基础(4)...封装  http://blog.csdn.net/zhaoyw2008/article/details/8981173#</comment>
<code>/**
需求:演示构造函数、构造代码块、默认初始化的先后顺序

思路:

步骤:
*/
public class Test{
private int i = 8;

{
i = 9;
}

public Test(){

i =10;
}

public static void main(String[] args) {
System.out.println(new Test().i);
}
}
/**
需求:演示 super 的jvm原理

思路:

步骤:
*/
public class Test extends Father{
public int i = 10;

public static void main(String[] args) {
new Test().println();
}

public void println(){
System.out.println(super.i);
}
}

class Father
{
protected int i = 12;
}
/**
需求:演示 static 的原理

思路:

步骤:
*/
public class Test{
public static int i = 10;

static{
i = 11;
}

public static void main(String[] args) {
}
}
/**
需求:实现饿汉式单例设计模式

思路:用 static 把对象创建封装在类内部

步骤:
1.将构造函数私有化
2.在类中创建一个本类对象
3.提供一个可以方法可以获取到该对象

*/
class Single
{
private static Single single = new Single();

private Single()
{
}

public static Single getInstance()
{
return single;
}
}

class SingleDemo
{
public static void main(String[] args)
{
Single single = Single.getInstance();

System.out.println(&quot;Hello World!&quot;);
}
}
/**
需求:实现线程同步的懒汉式单例设计模式

思路:用 static 把对象创建封装在类内部，延迟创建对象

步骤:
1.将构造函数私有化
2.提供一个&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;可以获取到该类对象的&lt;/span&gt;方法，并既在第一次访问该方法的时候才创建对象，以后都是直接返回已经创建的对象

*/
class Single
{
private static Single single = null;

private Single()
{
}

public static Single getInstance()
{
if(single == null)
{
synchronized(Single.class)
{
if(single == null)
{
new Single();
}
}
}
return single;
}
}

class SingleDemo
{
public static void main(String[] args)
{
Single single = Single.getInstance();

System.out.println(&quot;Hello World!&quot;);
}
}
/**
需求:演示内部类

思路:成员访问的一些规则:
1.内部类 和 他的所属类 之间成员的相互访问，成员有重名的情况
2.其他外面的类 访问内部类的成员

内部类定义在外部类成员位置上的时候，可以用成员修饰符修饰。private static
静态内部类只能使用外部类的静态成员。内部内既然作为成员，那么就很少对外开
放了。
当内部类定义了静态成员，该内部类必须是 static 的。

匿名内部类，是局部内部类的一种简写形式。


步骤:
*/
class OutsideClass
{
private int v = 0;

//1.成员内部类演示，private 成员类用得较多
class InsideClass
{
int v = 1;

void function()
{
int v = 2;
System.out.print(v);
System.out.print(this.v);
System.out.print(OutsideClass.this.v); //打印结果是 210
}
}

//2.静态内部类演示
static class StaticInsideClass
{
int v = 1;

void function()
{
int v = 2;
System.out.print(v);
System.out.print(this.v);
//System.out.print(OutsideClass.this.v); //报错，只能访问外部类静态成员
}
}



void function()
{
//3.局部内部类，只能访问外面 final 变量
class LocalInsideClass
{
void function()
{
System.out.println(&quot;局部内部类&quot;);
}
}

//4.匿名内部类演示，用得较多，Comparator 就有使用
new OutsideClass()
{
void function()
{
System.out.println(&quot;匿名内部类&quot;);
}
}.function();
}
}

class InsideClassMain
{
public static void main(String[] args)
{
// 这种外部使用内部内创建对象的情况基本不使用，因为内部类一般都封装为 private 成员类
//OutsideClass.InsideClass part = new OutsideClass().new InsideClass();
OutsideClass part = new OutsideClass();
part.function();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>229893</snippet_key>
<tag></tag>
<comment>来自CSDN博客：foo@bar.com使用 http://blog.csdn.net/u013861953/article/details/21025457#</comment>
<code>&lt;span style=&quot;font-size:14px;&quot;&gt;mBitmap = Bitmap.createBitmap(data, width, height, Config.ARGB_8888);&lt;/span&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>213518</snippet_key>
<tag>java</tag>
<comment>来自CSDN博客：黑马程序员----java基础 http://blog.csdn.net/wisely2012/article/details/20293779#</comment>
<code>class Day2a
{
public static void sop(Object obj)
{
System.out.println(obj);
}


public static void main(String[] args)
{
System.out.println(2+&quot;&quot;+4);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>344590</snippet_key>
<tag>来自CSDN博客：Android UI开发第十二篇——动画效果Animation（一） http://blog.csdn.net/xyz_lmn/article/details/6906783#</tag>
<comment>派生自xyz_lmn/blog_20140322_1_9698633</comment>
<code>AnimationSet animationSet = new AnimationSet(true);//创建一个AnimationSet对象
AlphaAnimation alphaAnimation = new AlphaAnimation(1, 0);//创建一个AlphaAnimation对象
alphaAnimation.setDuration(1000);//设置动画执行的时间（单位：毫秒）
animationSet.addAnimation(alphaAnimation);//将AlphaAnimation对象添加到AnimationSet当中
view.startAnimation(animationSet);//使用view的startAnimation方法开始执行动画
AnimationSet animationSet = new AnimationSet(true);
/**
* 前两个参数定义旋转的起始和结束的度数，后两个参数定义圆心的位置
*/
RotateAnimation rotateAnimation = new RotateAnimation(0, 360,
Animation.RELATIVE_TO_PARENT, 1f,
Animation.RELATIVE_TO_PARENT, 0f);
rotateAnimation.setDuration(5000);
animationSet.addAnimation(rotateAnimation);
imageView.startAnimation(animationSet);
AnimationSet animationSet = new AnimationSet(true);
/**
* x和y轴的起始和结束位置
*/
TranslateAnimation translateAnimation = new TranslateAnimation
(
Animation.RELATIVE_TO_SELF, 0f,
Animation.RELATIVE_TO_SELF,0.5f,
Animation.RELATIVE_TO_SELF, 0f,
Animation.RELATIVE_TO_SELF, 1.0f
);
translateAnimation.setDuration(1000);
animationSet.addAnimation(translateAnimation);
view.startAnimation(animationSet);
AnimationSet animationSet = new AnimationSet(true);
/**
* 围绕一个点伸缩
*/
ScaleAnimation scaleAnimation = new ScaleAnimation(1, 0.1f, 1,
0.1f, Animation.RELATIVE_TO_SELF, 0.5f,
Animation.RELATIVE_TO_SELF, 0.5f);
animationSet.addAnimation(scaleAnimation);
animationSet.setStartOffset(1000);
animationSet.setFillAfter(true);
animationSet.setFillBefore(false);
animationSet.setDuration(2000);
view.startAnimation(animationSet);
</code>
</RECORD>
<RECORD>
<snippet_key>82702</snippet_key>
<tag></tag>
<comment>来自CSDN博客：android下使用Fragment实现左侧3级菜单+动画效果  http://blog.csdn.net/abc13939746593/article/details/9368099#</comment>
<code>package com.hsx.view;

import com.hsx.fragment.R;
import com.hsx.fragments.FirstFragment;
import com.hsx.fragments.FirstFragment.FirstFragmentSelectedListener;
import com.hsx.fragments.SecondFragment;
import com.hsx.fragments.SecondFragment.SecondFragmentListener;
import com.hsx.fragments.ThreeFragment;

import android.os.Bundle;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentTransaction;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;

public class MainActivity extends FragmentActivity implements FirstFragmentSelectedListener, SecondFragmentListener {
Button returnBtn;

@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.main);
ThreeFragment three = (ThreeFragment) getSupportFragmentManager().findFragmentById(R.id.three_fragment);
FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
ft.hide(three);
ft.commit();
returnBtn = (Button) findViewById(R.id.returnBtn);
returnBtn.setOnClickListener(new OnClickListener() {

@Override
public void onClick(View v) {
FirstFragment first = (FirstFragment) getSupportFragmentManager().findFragmentById(R.id.first_fragment);
ThreeFragment three = (ThreeFragment) getSupportFragmentManager().findFragmentById(R.id.three_fragment);

FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
ft.setCustomAnimations(R.anim.push_n50_0, R.anim.push_0_50);
ft.hide(three);
ft.show(first);
ft.commit();
}
});
}

public void onFirstSelectedData(String[] data) {
SecondFragment second = (SecondFragment) getSupportFragmentManager().findFragmentById(R.id.second_fragment);
if (second != null) {
second.updateView(data);
}
}

@Override
public void onSecondSelectedData(String[] data) {
FirstFragment first = (FirstFragment) getSupportFragmentManager().findFragmentById(R.id.first_fragment);
ThreeFragment three = (ThreeFragment) getSupportFragmentManager().findFragmentById(R.id.three_fragment);

FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
ft.setCustomAnimations(R.anim.push_50_0, R.anim.push_0_n50);
ft.show(three);
ft.hide(first);
ft.commit();
if (three != null) {
three.updateView(data);
}
}
}
package com.hsx.fragments;

import com.hsx.constant.Ipsum;
import com.hsx.fragment.R;
import android.app.Activity;
import android.os.Build;
import android.os.Bundle;
import android.support.v4.app.ListFragment;
import android.view.View;
import android.widget.ArrayAdapter;
import android.widget.ListView;

public class FirstFragment extends ListFragment {
FirstFragmentSelectedListener mCallback;

public interface FirstFragmentSelectedListener {
public void onFirstSelectedData(String[] data);
}

@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);

int layout = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB ? android.R.layout.simple_list_item_activated_1
: android.R.layout.simple_list_item_1;

setListAdapter(new ArrayAdapter&lt;String&gt;(getActivity(), layout, Ipsum.FirstLayer));
}

@Override
public void onStart() {
super.onStart();

if (getFragmentManager().findFragmentById(R.id.first_fragment) != null) {
getListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);
}
getListView().setItemChecked(0, true);
}

@Override
public void onAttach(Activity activity) {
super.onAttach(activity);
try {
mCallback = (FirstFragmentSelectedListener) activity;
} catch (ClassCastException e) {
throw new ClassCastException(activity.toString() + &quot; must implement OnHeadlineSelectedListener&quot;);
}
}

@Override
public void onListItemClick(ListView l, View v, int position, long id) {
String[] data;
switch (position) {
case 0:
data = Ipsum.FirstSun;
break;

default:
data = Ipsum.SecondSun;
break;
}

mCallback.onFirstSelectedData(data);
getListView().setItemChecked(position, true);
}
}
package com.hsx.fragments;

import com.hsx.constant.Ipsum;
import com.hsx.fragment.R;
import android.app.Activity;
import android.os.Build;
import android.os.Bundle;
import android.support.v4.app.ListFragment;
import android.view.View;
import android.widget.ArrayAdapter;
import android.widget.ListView;

public class SecondFragment extends ListFragment {
SecondFragmentListener mCallback;

public interface SecondFragmentListener {
public void onSecondSelectedData(String[] data);
}

@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
int layout = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB ? android.R.layout.simple_list_item_activated_1
: android.R.layout.simple_list_item_1;

setListAdapter(new ArrayAdapter&lt;String&gt;(getActivity(), layout, Ipsum.FirstSun));
}

@Override
public void onStart() {
super.onStart();

if (getFragmentManager().findFragmentById(R.id.second_fragment) != null) {
getListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);
}
getListView().setItemChecked(0, true);
}

@Override
public void onAttach(Activity activity) {
super.onAttach(activity);
try {
mCallback = (SecondFragmentListener) activity;
} catch (ClassCastException e) {
throw new ClassCastException(activity.toString() + &quot; must implement OnHeadlineSelectedListener&quot;);
}
}

public void updateView(String[] data) {
int layout = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB ? android.R.layout.simple_list_item_activated_1
: android.R.layout.simple_list_item_1;

setListAdapter(new ArrayAdapter&lt;String&gt;(getActivity(), layout, data));

}

@Override
public void onListItemClick(ListView l, View v, int position, long id) {
String[] data;
switch (position) {
case 0:
data = Ipsum.SecondSun;
break;

default:
data = Ipsum.SecondSun;
break;
}

mCallback.onSecondSelectedData(data);
getListView().setItemChecked(position, true);
}
}
package com.hsx.fragments;

import com.hsx.constant.Ipsum;
import com.hsx.fragment.R;
import android.app.Activity;
import android.os.Build;
import android.os.Bundle;
import android.support.v4.app.ListFragment;
import android.view.View;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import android.widget.Toast;

public class ThreeFragment extends ListFragment {

@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
int layout = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB ? android.R.layout.simple_list_item_activated_1
: android.R.layout.simple_list_item_1;

setListAdapter(new ArrayAdapter&lt;String&gt;(getActivity(), layout, Ipsum.FirstSun));
}

@Override
public void onStart() {
super.onStart();

if (getFragmentManager().findFragmentById(R.id.second_fragment) != null) {
getListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);
}
getListView().setItemChecked(0, true);
}

@Override
public void onAttach(Activity activity) {
super.onAttach(activity);
}

public void updateView(String[] data) {
int layout = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB ? android.R.layout.simple_list_item_activated_1
: android.R.layout.simple_list_item_1;
setListAdapter(new ArrayAdapter&lt;String&gt;(getActivity(), layout, data));

}

@Override
public void onListItemClick(ListView l, View v, int position, long id) {
Toast.makeText(getActivity(), &quot;你点了第&quot; + position + &quot;项&quot;, Toast.LENGTH_SHORT).show();
getListView().setItemChecked(position, true);
}
}
package com.hsx.constant;

public class Ipsum {

public static String[] FirstLayer = {&quot;第一层&quot;, &quot;银联业务&quot;, &quot;银联文化&quot; };

public static String[] FirstSun = { &quot;第二层&quot;,&quot;培训交流&quot;, &quot;人才培训&quot;, &quot;互联网支付&quot; };

public static String[] SecondSun = { &quot;第三层&quot;,&quot;ic卡业务&quot;, &quot;移动支付&quot; };
}
</code>
</RECORD>
<RECORD>
<snippet_key>99077</snippet_key>
<tag></tag>
<comment>来自CSDN博客：黑马程序员 基础（五）  http://blog.csdn.net/u013037032/article/details/17148411#</comment>
<code>interface A{
public abstract void methodA();
}
interface B{
public abstract void methodB();
}
class C implements A,B{
@Override
public void methodB() {
// TODO Auto-generated method stub

}
@Override
public void methodA() {
// TODO Auto-generated method stub

}
}
interface D{
public abstract void show();
}
interface E{
public abstract void show();
}
class F implements D,E{
public void show(){
System.out.println(&quot;hello world&quot;);
}
}
interface G{
public abstract void show();
}
interface H extends G{
public abstract void show1();
public abstract void show();
/*
* implements G.show
`* - The return type is incompatible with G.show()
* */
//public abstract int show();
public abstract int show(int x);
}
class Animal{
int age;
public void show(){};
/*
* 转型注意事项：
* 1，向上转型（子类转父类，编译器自动转）
* 2，向下转型（父类转子类，需要手动强制转）
* */
public static void main(String[] args) {
Animal animal = new Cat();
animal.show();
//需要强制转换
((Cat) animal).special_show();
}
}
class Cat extends Animal{
int age;
public void show(){};
public void special_show(){};
}
class Dog extends Animal{
int age;
public void show(){};
public void special_show(){};
}
public static void main(String[] args) {
Animal animal = new Cat();
animal.show();
((Dog) animal).special_show();
}
class single{
private static final single single = new single();
private single(){}
public static single getInstance(){
return single;
}
}
class single1{
private static single1 single = null;
private single1(){}
public static single1 getInstance(){
if(null == single){
synchronized(single1.class){
if(null == single){
single = new single1();
}
}
}
return single;
}
ď˝
public static void get_threadname_and_threadObject(){
mythread t1 = new leanjava().new mythread();
//获取线程的名称
String name = t1.getName();
t1.start();
//获取当前执行的线程对象,如果Thread.currentThread()在run()方法中则返回this对象
Thread tcurrent = Thread.currentThread();
//设置线程的名称
mythread t2 = new leanjava().new mythread(&quot;mythread&quot;);
//也可以用set方法设置
t2.setName(&quot;mythread&quot;);
t2.start();
}
class mythread extends Thread{
public mythread(String string) {
super(string);
}
public mythread(){

}

public void run() {
System.out.println(Thread.currentThread().getName()+&quot;:: run......&quot;);
}
}
public static void thread_status() throws InterruptedException{
//t1被创建，
mythread t1 = new leanjava().new mythread();
//t1,调用start()后，状态可以变为
// 1，运行状态（具有cpu执行权）
// 2，就绪状态（具有cpu的执行资格）
t1.start();
//t1被挂起，调用sleep()后，状态可以变为
// 1,等待状态
t1.sleep(400);
//t1.sleep()时间到或者被notice()
// 1，就绪状态
// 2，执行状态
t1.notify();
//t1 被stop()或者执行完成所有任务
// 1，消亡状态
t1.stop();
}
class mythread extends Thread{
public mythread(String string) {
super(string);
}
public mythread(){

}

public void run() {
System.out.println(&quot;mythread run......&quot;);
}
}
class mythread2 implements Runnable{

@Override
public void run() {
// TODO Auto-generated method stub
System.out.println(&quot;mythread2 run......&quot;);
}

}
public static void run_start_difference(){
mythread t1 = new leanjava().new mythread();
t1.start();
System.out.println(&quot;main thread run......&quot;);

t1 = new leanjava().new mythread();
t1.run();
System.out.println(&quot;main thread run......&quot;);
}
class mythread extends Thread{
public void run() {
try {
Thread.sleep(300);
} catch (Exception e) {
// TODO: handle exception
}
System.out.println(&quot;mythread run......&quot;);
}
}
public static void thread_method(){
class myinnerthread extends Thread{
public void run() {
System.out.println(&quot;myinnerThread run......&quot;);
}
}
myinnerthread t3 = new myinnerthread();
t3.start();
}
</code>
</RECORD>
<RECORD>
<snippet_key>213774</snippet_key>
<tag>303</tag>
<comment>来自CSDN博客：黑马程序员----网络编程 UDP协议 http://blog.csdn.net/u013807931/article/details/20303033#</comment>
<code>import java.net.*;
class UdpSend
{
public static void main(String[] args) throws Exception
{
//1，创建udp服务,建立端点，通过DatagramPacket对象
DatagramSocket ds = new DatagramSocket();
//2，确定数据，并封装成数据包。 DatagramPacket(byte[] buf, int length, InetAddress address, int port)

//键盘录入方式
BufferedReader bufr = new BufferedReader(new BufferedInputStream(System.in));
String line = null;
while((line=bufr.readLine())!=-1)
{
if(&quot;886&quot;equals(line))
break;
byte[] buf = line.getBytes();
DatagramPacket dp= new DatagramPacket(buf,buf.length,InetAddress.getByName(&quot;192.168.1.103&quot;),10000);
}
// byte buf = &quot;udp hehe&quot;.getBytes();
// DatagramPacket dp =
// new DatagramPacket(buf,buf.length,InetAddress.getByName(&quot;192.168.1.1&quot;),10000);
//3，通过socket服务，将已有的数据包发送出去，通过send方法。
ds.send(dp);
//4，关闭资源。
ds.close();
}
}


class UdpRece
{
public static void main(String[] args) throws Exception
{
//1，创建udp socket，建立端点。
DatagramSocket ds = new DatagramSocket(10000);
//2，定义数据包，用于存储数据。
byte[] buf = new byte[1024];
DatagramPacket dp = new DatagramPacket(buf,buf.length);
//3，通过服务的receive方法将收到数据存入数据包中
ds.receive(dp);
//4，通过数据包的方法获取其中的数据。
String ip = dp.getAddress().getHostAddress();
String data = new String(dp.getData(),0,dp.getLength());
int port = dp.getPort();
System.out.println(ip+&quot;::&quot;+data+&quot;::&quot;+port);
//5,关闭资源
ds.close();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>164613</snippet_key>
<tag>273</tag>
<comment>来自CSDN博客：android图片高斯模糊的方法  http://blog.csdn.net/u011430511/article/details/18563139#</comment>
<code>package com.hasen.test;

import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.PixelFormat;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;

public class ImageUtils {
/** 水平方向模糊度 */
private static float hRadius = 10;
/** 竖直方向模糊度 */
private static float vRadius = 10;
/** 模糊迭代度 */
private static int iterations = 7;

/**
* 高斯模糊
*/
public static Drawable BoxBlurFilter(Bitmap bmp) {
int width = bmp.getWidth();
int height = bmp.getHeight();
int[] inPixels = new int[width * height];
int[] outPixels = new int[width * height];
Bitmap bitmap = Bitmap.createBitmap(width, height,Bitmap.Config.ARGB_8888);
bmp.getPixels(inPixels, 0, width, 0, 0, width, height);
for (int i = 0; i &lt; iterations; i++) {
blur(inPixels, outPixels, width, height, hRadius);
blur(outPixels, inPixels, height, width, vRadius);
}
blurFractional(inPixels, outPixels, width, height, hRadius);
blurFractional(outPixels, inPixels, height, width, vRadius);
bitmap.setPixels(inPixels, 0, width, 0, 0, width, height);
Drawable drawable = new BitmapDrawable(bitmap);
return drawable;
}

public static void blur(int[] in, int[] out, int width, int height,
float radius) {
int widthMinus1 = width - 1;
int r = (int) radius;
int tableSize = 2 * r + 1;
int divide[] = new int[256 * tableSize];

for (int i = 0; i &lt; 256 * tableSize; i++)
divide[i] = i / tableSize;

int inIndex = 0;

for (int y = 0; y &lt; height; y++) {
int outIndex = y;
int ta = 0, tr = 0, tg = 0, tb = 0;

for (int i = -r; i &lt;= r; i++) {
int rgb = in[inIndex + clamp(i, 0, width - 1)];
ta += (rgb &gt;&gt; 24) &amp; 0xff;
tr += (rgb &gt;&gt; 16) &amp; 0xff;
tg += (rgb &gt;&gt; 8) &amp; 0xff;
tb += rgb &amp; 0xff;
}

for (int x = 0; x &lt; width; x++) {
out[outIndex] = (divide[ta] &lt;&lt; 24) | (divide[tr] &lt;&lt; 16)
| (divide[tg] &lt;&lt; 8) | divide[tb];

int i1 = x + r + 1;
if (i1 &gt; widthMinus1)
i1 = widthMinus1;
int i2 = x - r;
if (i2 &lt; 0)
i2 = 0;
int rgb1 = in[inIndex + i1];
int rgb2 = in[inIndex + i2];

ta += ((rgb1 &gt;&gt; 24) &amp; 0xff) - ((rgb2 &gt;&gt; 24) &amp; 0xff);
tr += ((rgb1 &amp; 0xff0000) - (rgb2 &amp; 0xff0000)) &gt;&gt; 16;
tg += ((rgb1 &amp; 0xff00) - (rgb2 &amp; 0xff00)) &gt;&gt; 8;
tb += (rgb1 &amp; 0xff) - (rgb2 &amp; 0xff);
outIndex += height;
}
inIndex += width;
}
}

public static void blurFractional(int[] in, int[] out, int width,
int height, float radius) {
radius -= (int) radius;
float f = 1.0f / (1 + 2 * radius);
int inIndex = 0;

for (int y = 0; y &lt; height; y++) {
int outIndex = y;

out[outIndex] = in[0];
outIndex += height;
for (int x = 1; x &lt; width - 1; x++) {
int i = inIndex + x;
int rgb1 = in[i - 1];
int rgb2 = in[i];
int rgb3 = in[i + 1];

int a1 = (rgb1 &gt;&gt; 24) &amp; 0xff;
int r1 = (rgb1 &gt;&gt; 16) &amp; 0xff;
int g1 = (rgb1 &gt;&gt; 8) &amp; 0xff;
int b1 = rgb1 &amp; 0xff;
int a2 = (rgb2 &gt;&gt; 24) &amp; 0xff;
int r2 = (rgb2 &gt;&gt; 16) &amp; 0xff;
int g2 = (rgb2 &gt;&gt; 8) &amp; 0xff;
int b2 = rgb2 &amp; 0xff;
int a3 = (rgb3 &gt;&gt; 24) &amp; 0xff;
int r3 = (rgb3 &gt;&gt; 16) &amp; 0xff;
int g3 = (rgb3 &gt;&gt; 8) &amp; 0xff;
int b3 = rgb3 &amp; 0xff;
a1 = a2 + (int) ((a1 + a3) * radius);
r1 = r2 + (int) ((r1 + r3) * radius);
g1 = g2 + (int) ((g1 + g3) * radius);
b1 = b2 + (int) ((b1 + b3) * radius);
a1 *= f;
r1 *= f;
g1 *= f;
b1 *= f;
out[outIndex] = (a1 &lt;&lt; 24) | (r1 &lt;&lt; 16) | (g1 &lt;&lt; 8) | b1;
outIndex += height;
}
out[outIndex] = in[width - 1];
inIndex += width;
}
}

public static int clamp(int x, int a, int b) {
return (x &lt; a) ? a : (x &gt; b) ? b : x;
}

public static Bitmap drawableToBitmap(Drawable drawable) {
Bitmap bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(),drawable.getIntrinsicHeight(),
drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888: Bitmap.Config.RGB_565);
Canvas canvas = new Canvas(bitmap);
drawable.setBounds(0, 0, drawable.getIntrinsicWidth(),
drawable.getIntrinsicHeight());
drawable.draw(canvas);
return bitmap;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>295685</snippet_key>
<tag>java</tag>
<comment>来自CSDN博客：猜生日游戏  http://blog.csdn.net/u013555369/article/details/23838061#</comment>
<code>import java.util.Scanner;

class GuessBirthday_3_3
{
public static void main(String[] args)
{
String set1 =
&quot; 1 3 5 7\n&quot; +
&quot; 9 11 13 15\n&quot; +
&quot;17 19 21 23\n&quot; +
&quot;25 27 29 31\n&quot;;

String set2 =
&quot; 2 3 6 7\n&quot; +
&quot;10 11 14 15\n&quot; +
&quot;18 19 22 23\n&quot; +
&quot;26 27 30 31\n&quot;;

String set3 =
&quot; 4 5 6 7\n&quot; +
&quot;12 13 14 15\n&quot; +
&quot;20 21 22 23\n&quot; +
&quot;28 29 30 31&quot;;

String set4 =
&quot;8 9 10 11\n&quot; +
&quot;12 13 14 15\n&quot; +
&quot;24 25 26 27\n&quot; +
&quot;28 29 30 31&quot;;

String set5 =
&quot;16 17 18 19\n&quot; +
&quot;20 21 22 23\n&quot; +
&quot;24 25 26 27\n&quot; +
&quot;28 29 30 31&quot;;

int day = 0;

Scanner input = new Scanner(System.in);

System.out.print(&quot;Is your birthday in Set1?\n&quot;);
System.out.print(set1);
System.out.print(&quot;\nEnter 0 for No and 1 for Yes: &quot;);
int answer = input.nextInt();

if (answer == 1)
{
day += 1;
}

System.out.print(&quot;\nIs your birthday in Set2?\n&quot;);
System.out.print(set2);
System.out.print(&quot;\nEnter 0 for No and 1 for Yes: &quot;);
answer = input.nextInt();

if(answer == 1)
day += 2;

System.out.print(&quot;Is your birthday in Set3?\n&quot;);
System.out.print(set3);
System.out.print(&quot;\nEnter 0 for No and 1 for Yes: &quot;);
answer = input.nextInt();

if (answer == 1)
{
day += 4;
}

System.out.print(&quot;\nIs your birthday in Set4?\n&quot;);
System.out.print(set4);
System.out.print(&quot;\nEnter 0 for No and 1 for Yes: &quot;);
answer = input.nextInt();

if (answer == 1)
{
day += 8;
}

System.out.print(&quot;\nIs your birthday in Set5?\n&quot;);
System.out.print(set5);
System.out.print(&quot;\nEnter 0 for No and 1 for Yes: &quot;);
answer = input.nextInt();

if (answer == 1)
{
day += 16;
}

System.out.print(&quot;\nYour birthday is &quot; + day + &quot;!&quot;);

}
}
</code>
</RECORD>
<RECORD>
<snippet_key>344846</snippet_key>
<tag>437</tag>
<comment>来自CSDN博客：Leetcode-Symmetric Tree——判断二叉树是否对称  http://blog.csdn.net/disappearedgod/article/details/24153001#</comment>
<code>public boolean isSymmetric(TreeNode root) {
if(root==null)
return true;
return ST(root.left,root.right);

}
private boolean ST(TreeNode left, TreeNode right){
TreeNode l = left;
TreeNode r = right;
if(l==null &amp;&amp; r == null)
return true;
else if(l!=null &amp;&amp; r != null){
return l.val==r.val &amp;&amp; ST(l.left,r.right) &amp;&amp;ST(l.right,r.left);
}
else return false;

}
public boolean isSymmetric(TreeNode root) {
if(root==null||(root.left==null &amp;&amp; root.right ==null))
return true;
//return ST(root.left,root.right);
return ST1(root);
}
private boolean ST1(TreeNode root){
Queue&lt;TreeNode&gt; q1 = new LinkedList&lt;TreeNode&gt;();
Queue&lt;TreeNode&gt; q2 = new LinkedList&lt;TreeNode&gt;();
q1.offer(root.left);
q2.offer(root.right);
while(!q1.isEmpty() &amp;&amp; !q2.isEmpty()){
TreeNode p = q1.poll();
TreeNode q = q2.poll();
if(p==null){
if(q!=null)
return false;
else
continue;
}
if(q==null|| p.val!=q.val)
return false;

q1.offer(p.left);
q2.offer(q.right);
q2.offer(p.right);
q1.offer(q.left);

}
return true;

}
public boolean isSymmetric(TreeNode root) {
if(root==null||(root.left==null &amp;&amp; root.right ==null))
return true;
//return ST(root.left,root.right);
return ST2(root);
}
public boolean ST2(TreeNode root) {
// Start typing your Java solution below
// DO NOT write main() function
if(root==null) return true;
LinkedList&lt;TreeNode&gt; l = new LinkedList&lt;TreeNode&gt;(),
r = new LinkedList&lt;TreeNode&gt;();
l.add(root.left);
r.add(root.right);
while(!l.isEmpty() &amp;&amp; !r.isEmpty()){
TreeNode temp1=l.poll(),
temp2=r.poll();
if(temp1==null &amp;&amp; temp2!=null || temp1!=null &amp;&amp; temp2==null)
return false;
if(temp1!=null){
if(temp1.val!=temp2.val) return false;
l.add(temp1.left);
l.add(temp1.right);
r.add(temp2.right);
r.add(temp2.left);
}
}
return true;
}
public boolean isSymmetric(TreeNode root) {
if(root==null||(root.left==null &amp;&amp; root.right ==null))
return true;
//return ST(root.left,root.right);
return ST3(root);
}



public boolean ST3(TreeNode root){
if(root==null)
return true;
TreeNode root1= clone(root);
MirrorRecursively(root1);
return isSameTree(root,root1);

}
public TreeNode clone(TreeNode root){
if(root==null||(root.left ==null &amp;&amp; root.right == null))
return root;
TreeNode cloneTree = new TreeNode(root.val);

cloneTree.left = clone(root.left);
cloneTree.right = clone(root.right);

return cloneTree;

}
public boolean isSameTree(TreeNode p, TreeNode q) {
if(p!=null&amp;&amp;q!=null){
if(p.val==q.val )
return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);
else
return false;

}
else if(p==null&amp;&amp;q==null)
return true;
else
return false;
}

public void MirrorRecursively(TreeNode root){
if(root == null||(root.left ==null&amp;&amp; root.right == null))
return ;

TreeNode temp = root.right;
root.right = root. left;
root.left = temp;

if(root.left!=null)
MirrorRecursively(root.left);
if(root.right!=null)
MirrorRecursively(root.right);

}
public boolean isSymmetric(TreeNode root) {
if(root==null||(root.left==null &amp;&amp; root.right ==null))
return true;
//return ST(root.left,root.right);
return ST3(root);
}



public boolean ST3(TreeNode root){
if(root==null)
return true;
TreeNode root1= MirrorRecursively(root);
return isSameTree(root,root1);

}
public TreeNode MirrorRecursively(TreeNode root){
if(root==null||(root.left ==null &amp;&amp; root.right == null))
return root;
TreeNode MirrorTree = new TreeNode(root.val);
MirrorTree.left = MirrorRecursively(root.right);
MirrorTree.right = MirrorRecursively(root.left);
return MirrorTree;

}
public boolean isSameTree(TreeNode p, TreeNode q) {
if(p!=null&amp;&amp;q!=null){
if(p.val==q.val )
return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);
else
return false;

}
else if(p==null&amp;&amp;q==null)
return true;
else
return false;
}
</code>
</RECORD>
<RECORD>
<snippet_key>82958</snippet_key>
<tag>326</tag>
<comment>来自CSDN博客：hibernate4.0以上使用Connection http://blog.csdn.net/u012833063/article/details/16967927#</comment>
<code>&lt;span style=&quot;BACKGROUND-COLOR: #ffffff&quot;&gt; session.doWork(new Work() {
@Override
public void execute(Connection conn) throws SQLException {
doSomeThingWithJdbc(conn);
}
}&lt;/span&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>427013</snippet_key>
<tag></tag>
<comment>来自CSDN博客：spring源代码分析之AOP面向切面编程  http://blog.csdn.net/shuijieshuijie/article/details/37814191#</comment>
<code>public 返回类型 方法名(参数列表){ ——&gt;环绕通知
方法前处理代码 ——&gt; 前置通知
try{
方法具体实现(方法体)…….
方法后处理代码 ——&gt; 后置通知
}Catch(异常类型 e){
异常处理…… ——&gt; 例外通知
}finally{
最后处理代理…… ——&gt; 最终通知
}
}
package org.springframework.aop;
import org.aopalliance.aop.Advice;
public interface BeforeAdvice extends Advice {
}
public interface MethodBeforeAdvice extends BeforeAdvice {
//前置方法通知的回调方法，在目标对象方法被调用之前调用
//method参数是目标方法的反射对象，args是目标方法的输入参数数组
void before(Method method, Object[] args, Object target) throws Throwable;
}
public class CountingBeforeAdvice extends MethodCounter implements MethodBeforeAdvice {
//实现方法前置通知MethodBeforeAdvice接口的方法
public void before(Method m, Object[] args, Object target) throws Throwable {
//以目标对象方法作为参数，调用父类MethodCounter的count方法统计方法调用次数
count(m);
}
}
CountingBeforeAdvice的父类MethodCounter的源码如下：
public class MethodCounter implements Serializable {
//方法名—&gt;方法调用次数的map集合，存储方法的调用次数
private HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
//所有方法的总调用次数
private int allCount;
//统计方法调用次数，CountingBeforeAdvice的调用入口
protected void count(Method m) {
count(m.getName());
}
//统计指定名称方法的调用次数
protected void count(String methodName) {
//从方法名—&gt;方法调用次数集合中获取指定名称方法的调用次数
Integer i = map.get(methodName);
//如果调用次数不为null，则将调用次数加1，如果调用次数为null，则设置调用次数为1
i = (i != null) ? new Integer(i.intValue() + 1) : new Integer(1);
//重新设置集合中保存的方法调用次数
map.put(methodName, i);
//所有方法总调用次数加1
++allCount;
}
//获取指定名称方法的调用次数
public int getCalls(String methodName) {
Integer i = map.get(methodName);
return (i != null ? i.intValue() : 0);
}
//获取所有方法的总调用次数
public int getCalls() {
return allCount;
}
public boolean equals(Object other) {
return (other != null &amp;&amp; other.getClass() == this.getClass());
}
public int hashCode() {
return getClass().hashCode();
}
}
public interface AfterAdvice extends Advice {
}
public interface AfterReturningAdvice extends AfterAdvice {
//后置通知的回调方法，在目标方法对象调用结束并成功返回之后调用
// returnValue参数为目标方法对象的返回值，method参数为目标方法对象，args为
//目标方法对象的输入参数
void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable;
}
public class CountingAfterReturningAdvice extends MethodCounter implements AfterReturningAdvice {
//实现后置通知AfterReturningAdvice的回调方法
public void afterReturning(Object o, Method m, Object[] args, Object target) throws Throwable {
//调用父类MethodCounter的count方法，统计方法的调用次数
count(m);
}
}
public interface ThrowsAdvice extends AfterAdvice {
}
public static class CountingThrowsAdvice extends MethodCounter implements ThrowsAdvice {
//当抛出IO类型的异常时的回调方法，统计异常被调用的次数
public void afterThrowing(IOException ex) throws Throwable {
count(IOException.class.getName());
}
//当抛出UncheckedException类型异常时的回调方法，统计异常被调用的次数
public void afterThrowing(UncheckedException ex) throws Throwable {
count(UncheckedException.class.getName());
}
}
public interface Pointcut {
//获取类过滤器
ClassFilter getClassFilter();
//获取匹配切入点的方法
MethodMatcher getMethodMatcher();
//总匹配的标准切入点实例
Pointcut TRUE = TruePointcut.INSTANCE;
}
public class JdkRegexpMethodPointcut extends AbstractRegexpMethodPointcut {
//要编译的正则表达式模式
private Pattern[] compiledPatterns = new Pattern[0];
//编译时要排除的正则表达式模式
private Pattern[] compiledExclusionPatterns = new Pattern[0];
//将给定的模式字符串数组初始化为编译的正则表达式模式
protected void initPatternRepresentation(String[] patterns) throws PatternSyntaxException {
this.compiledPatterns = compilePatterns(patterns);
}
//将给定的模式字符串数组初始化为编译时要排除的正则表达式模式
protected void initExcludedPatternRepresentation(String[] excludedPatterns) throws PatternSyntaxException {
this.compiledExclusionPatterns = compilePatterns(excludedPatterns);
}
//使用正则表达式匹配给定的名称
protected boolean matches(String pattern, int patternIndex) {
Matcher matcher = this.compiledPatterns[patternIndex].matcher(pattern);
return matcher.matches();
}
//使用要排除的正则表达式匹配给定的名称
protected boolean matchesExclusion(String candidate, int patternIndex) {
Matcher matcher = this.compiledExclusionPatterns[patternIndex].matcher(candidate);
return matcher.matches();
}
//将给定的字符串数组编译为正则表达的模式
private Pattern[] compilePatterns(String[] source) throws PatternSyntaxException {
Pattern[] destination = new Pattern[source.length];
for (int i = 0; i &lt; source.length; i++) {
destination[i] = Pattern.compile(source[i]);
}
return destination;
}
}
public interface Advisor {
//获取切面的通知Advice
Advice getAdvice();
//判断这个通知是否和某个特定的实例对象相关
boolean isPerInstance();
}
</code>
</RECORD>
<RECORD>
<snippet_key>410638</snippet_key>
<tag></tag>
<comment>泛型</comment>
<code>public static void show(List&lt;? extends Number&gt; list){
}
public static void show(List&lt;? super String&gt; list){
}
public static voidshow(List&lt;? extends Number&gt; list){}
public static void show(List&lt;?super String&gt; list){}
</code>
</RECORD>
<RECORD>
<snippet_key>427269</snippet_key>
<tag>466</tag>
<comment>来自CSDN博客：LeetCode OJ算法题（十一）：Container With Most Water http://blog.csdn.net/op_yu/article/details/37825353#</comment>
<code>public class No11_ContainerWithMostWater {
public static void main(String[] args){
System.out.println(maxArea(new int[]{1,2}));
}
public static int maxArea(int[] height){
int i = 0, j = height.length-1;
int start = height[i];
int end = height[j];
int max = (start&lt;end?start:end)*(j-i);
while(i&lt;j){
if(height[i] &lt;= height[j]){
while(height[i] &lt;= start &amp;&amp; i&lt;j) i++;
if(height[i] &gt; start)
start = height[i];
}
else{
while(height[j] &lt;= end &amp;&amp; i&lt;j) j--;
if(height[j] &gt; end)
end = height[j];
}
if(max &lt; (start&lt;end?start:end)*(j-i))
max = (start&lt;end?start:end)*(j-i);
}
return max;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>279822</snippet_key>
<tag>java leetcode</tag>
<comment>来自CSDN博客：LeetCode | Add Two Numbers http://blog.csdn.net/perfect8886/article/details/23137311#</comment>
<code>public class AddTwoNumbers {
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
ListNode dummy = new ListNode(0);
ListNode p = dummy;
int carry = 0;
while (l1 != null &amp;&amp; l2 != null) {
int sum = carry + l1.val + l2.val;
carry = 0;
if (sum &gt;= 10) {
carry = 1;
sum -= 10;
}
p.next = new ListNode(sum);
p = p.next;
l1 = l1.next;
l2 = l2.next;
}
if (l1 == null) {
l1 = l2;
}
while (l1 != null) {
int sum = carry + l1.val;
carry = 0;
if (sum &gt;= 10) {
carry = 1;
sum -= 10;
}
p.next = new ListNode(sum);
p = p.next;
l1 = l1.next;
}
p.next = carry == 1 ? new ListNode(1) : null;
return dummy.next;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>83470</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Design  Pattern http://blog.csdn.net/nextyu/article/details/13287425#</comment>
<code>public class SingleTon
{
public static void main(String[] args)
{
Single s1 = Single.getInstance();
Single s2 = Single.getInstance();

System.out.println(s1==s2);
}
}

class Single
{
/*
private static Single s = new Single();

private Single()
{

}

public static Single getInstance()
{
return s;
}
*/

private static Single s;

private Single()
{

}

public static Single getInstance()
{
if(s == null)
{
s = new Single();
}

return s;
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>214542</snippet_key>
<tag>303</tag>
<comment>来自CSDN博客：Java发送Http请求 http://blog.csdn.net/zhangzeyuaaa/article/details/20364985#</comment>
<code>package com.xs.http;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;

public class HttpClient {
public static void main(String[] args){
URL url = null;
HttpURLConnection conn = null;
try {
url = new URL(&quot;http://b1.qzone.qq.com/cgi-bin/blognew/get_abs&quot;);
conn = (HttpURLConnection) url.openConnection();//打开连接
//设置消息头
conn.setRequestMethod(&quot;POST&quot;);
conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-javascript; charset=gbk&quot;);
//设置参数
String content = &quot;hostUin=739637282&amp;blogType=0&amp;statYear=2014&amp;reqInfo=5&amp;num=20&quot;;
conn.setDoOutput(true);
OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream(), &quot;GBK&quot;);
out.write(content);
out.flush();
out.close();
//获取返回结果
BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(), &quot;GBK&quot;));
StringBuffer sb = new StringBuffer();
String line = null;
while ((line = reader.readLine()) != null) {
sb.append(line + &quot;\r\n&quot;);
}
reader.close();
System.out.println(sb.toString());
} catch (MalformedURLException e) {
e.printStackTrace();
} catch (IOException e) {
e.printStackTrace();
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>361989</snippet_key>
<tag>android 图片 经纬度 exif 扩展信息</tag>
<comment>来自CSDN博客：JPEG图片扩展信息读取与修改  http://blog.csdn.net/anquangan1989/article/details/26879413#</comment>
<code>private String gpsInfoConvert(double gpsInfo){
gpsInfo = Math.abs(gpsInfo);
String dms = Location.convert(gpsInfo, Location.FORMAT_SECONDS);
String[] splits = dms.split(&quot;:&quot;);
String[] secnds = (splits[2]).split(&quot;\\.&quot;);
String seconds;
if (secnds.length == 0) {
seconds = splits[2];
} else {
seconds = secnds[0];
}
return splits[0] + &quot;/1,&quot; + splits[1] + &quot;/1,&quot; + seconds + &quot;/1&quot;;
}
</code>
</RECORD>
<RECORD>
<snippet_key>280078</snippet_key>
<tag>数据 蓝牙 字节 窜位 重组数据</tag>
<comment>来自CSDN博客：Android蓝牙开发之数据窜位和数据接收错误以及重组字节数据  http://blog.csdn.net/u013542131/article/details/23163983#</comment>
<code>&lt;span style=&quot;color:#00cccc;&quot;&gt;&lt;span style=&quot;font-size:24px;&quot;&gt;现在是我和开发的接收数据出现了问题，总共会接收4串数据（32个字节），&lt;/span&gt;&lt;span style=&quot;font-size: 24px; word-wrap: break-word; font-family: &apos;Microsoft YaHei&apos;, Tahoma, Helvetica, SimSun, sans-serif;&quot;&gt;&lt;span style=&quot;word-wrap: break-word;&quot;&gt;第一条和第二条都不会有错，但是第三条和第四条不知道为什么数据总会出现串位，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;p&gt;&lt;span style=&quot;font-size: 24px; word-wrap: break-word; font-family: &apos;Microsoft YaHei&apos;, Tahoma, Helvetica, SimSun, sans-serif;&quot;&gt;&lt;span style=&quot;word-wrap: break-word;&quot;&gt;&lt;span style=&quot;color:#00cccc;&quot;&gt;要么就是头码跑到后面去，要么就是中间的跑到前面来。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size:24px; word-wrap:break-word; color:rgb(51,51,51); font-family:&apos;Microsoft YaHei&apos;,Tahoma,Helvetica,SimSun,sans-serif&quot;&gt;&lt;span style=&quot;color:#00bfff; word-wrap:break-word&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size:24px&quot;&gt;这是之前在处理数据的时候碰到的问题，现在已经解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size:24px&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre code_snippet_id=&quot;280078&quot; snippet_file_name=&quot;blog_20140408_2_9383799&quot; name=&quot;code&quot; class=&quot;java&quot;&gt; &lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;byte[] read = new byte[32 - fillIndex];
int bytes = mmInStream.read(read);
for (int j = 0; j &lt; bytes; fillIndex++, j++) {
buffer[fillIndex] = read[j];
}
if (fillIndex == 32) {
byte[] newbyte = new byte[32];
System.arraycopy(buffer, 0, newbyte, 0, 32);
int i = Uitils.Check(newbyte);
if (i == 1 || i == 2) {
System.out.println(&quot;头码尾码校验错误&quot;);
fillIndex = Uitils.fix(buffer);
continue;
} else if (i == 3) {
System.out.println(&quot;高低字節校驗錯誤&quot;);
} else {
mHandler.obtainMessage(SetActivity.MESSAGE_READ,
newbyte.length, -1, newbyte).sendToTarget();
}
fillIndex = 0;
}
&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;byte[] read = new byte[32 - fillIndex];
int bytes = mmInStream.read(read);
for (int j = 0; j &lt; bytes; fillIndex++, j++) {
buffer[fillIndex] = read[j];
}
if (fillIndex == 32) {
byte[] newbyte = new byte[32];
System.arraycopy(buffer, 0, newbyte, 0, 32);
int i = Uitils.Check(newbyte);
if (i == 1 || i == 2) {
System.out.println(&quot;头码尾码校验错误&quot;);
fillIndex = Uitils.fix(buffer);
continue;
} else if (i == 3) {
System.out.println(&quot;高低字節校驗錯誤&quot;);
} else {
mHandler.obtainMessage(SetActivity.MESSAGE_READ,
newbyte.length, -1, newbyte).sendToTarget();
}
fillIndex = 0;
}
&lt;span style=&quot;font-size:18px;&quot;&gt;Uitils.Check(newbyte)&lt;/span&gt;
public static int fix(byte[] result){
boolean temp=false;
int count=0;
int index = 1;
for (; index &lt; result.length; index++) {
switch (count) {
case 0:
if(result[index]==defultbyte[0]){
count++;
}
break;
case 1:
if(result[index]==defultbyte[1]){
count++;
}
else{
count=0;
}
break;
case 2:
if(result[index]==defultbyte[2]){
count++;
}else count=0;
break;
case 3:
if(result[index]==defultbyte[3]){
count++;
}else count=0;
break;
case 4:
temp=true;
break;
}
if(temp)break;
}
int fillIndex=0;
if(count&gt;0){
for (int j=index-count; j &lt; result.length; fillIndex++,j++) {
result[fillIndex]=result[j];
}
}
return fillIndex;
}
</code>
</RECORD>
<RECORD>
<snippet_key>34565</snippet_key>
<tag>327</tag>
<comment>Team leader要我每天整理修改过的文件，打成zip包，我偷个懒，写个batch，一劳永逸啊，哈哈目前的代码，打zip包那一步是使用ant的写好的方法，需要ant.jar到时候改成直接java API来写，就不需要外部jar了。</comment>
<code>package leon.aj.io;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Zip;
import org.apache.tools.ant.types.FileSet;

public class CheckModify {

public static void main(String[] args) throws IOException {
File f = new File(&quot;D:/SpaceEclipse/JavaSE/AdvanceJava&quot;);
SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMdd&quot;);

parse(f,new Date(),sdf);

System.out.println(Utils.compress(&quot;D:\\temp\\AdvanceJava&quot;, &quot;D:\\temp\\AdvanceJava.zip&quot;));
}

public static List&lt;File&gt; getModifiedFile(String root){
List&lt;File&gt; fileList = new ArrayList&lt;File&gt;();

return fileList;
}

public static void parse(File f,Date d, SimpleDateFormat sdf) throws IOException{
File[] childs= f.listFiles();
for(int i=0;i&lt;childs.length;i++){

if(isNeed(childs[i],d,sdf)){
String filePath = childs[i].getAbsolutePath();
System.out.println(filePath.substring(23));
copyFile(childs[i], new File(&quot;D:\\temp\\&quot;+filePath.substring(23)));
}

if(childs[i].isDirectory()){
parse(childs[i],d,sdf);
}
}
}

public static boolean isNeed(File f,Date d, SimpleDateFormat sdf){
boolean isNeed = false;
String dateStr = sdf.format(d);
Date mdfDate = new Date(f.lastModified());
if(f.isFile()){
if(dateStr.equals(sdf.format(mdfDate)) &amp;&amp; checkName(f))
isNeed = true;
}
return isNeed;
}
public static boolean checkName(File f){
boolean r = false;
List&lt;String&gt; fileTypeList = new ArrayList&lt;String&gt;();
fileTypeList.add(&quot;.java&quot;);
fileTypeList.add(&quot;.jsp&quot;);
fileTypeList.add(&quot;.jspf&quot;);
fileTypeList.add(&quot;.xml&quot;);
fileTypeList.add(&quot;.properties&quot;);
//fileTypeList.add(&quot;.jar&quot;);
fileTypeList.add(&quot;.txt&quot;);

if(fileTypeList.contains(getFileType(f)))
r = true;
return r;
}
public static String getFileType(File f){
String fileName = f.getName();
int i = fileName.lastIndexOf(&apos;.&apos;);
return fileName.substring(i);
}

public static void copyFile(File sourceFile, File targetFile) throws IOException {
BufferedInputStream inBuff = null;
BufferedOutputStream outBuff = null;
if(!targetFile.exists()){
targetFile.getParentFile().mkdirs();
targetFile.createNewFile();
}
try {
// 新建文件输入流并对它进行缓冲
inBuff = new BufferedInputStream(new FileInputStream(sourceFile));

// 新建文件输出流并对它进行缓冲
outBuff = new BufferedOutputStream(new FileOutputStream(targetFile));

// 缓冲数组
byte[] b = new byte[1024 * 5];
int len;
while ((len = inBuff.read(b)) != -1) {
outBuff.write(b, 0, len);
}
outBuff.flush();
} catch(Exception e){
System.out.println(&quot;Exception when copy file:&quot;+sourceFile);
e.printStackTrace();
} finally {
if (inBuff != null)
inBuff.close();
if (outBuff != null)
outBuff.close();
}
}

/**
* 将目录文件打包成zip
*
* @param srcPathName
* @param zipFilePath
* @return 成功打包true 失败false
*/
public static boolean compress(String srcPathName, String zipFilePath) {
if (strIsNull(srcPathName) || strIsNull(zipFilePath))
return false;

File zipFile = new File(zipFilePath);
File srcdir = new File(srcPathName);
if (!srcdir.exists())
return false;
Project prj = new Project();
Zip zip = new Zip();
zip.setProject(prj);
zip.setDestFile(zipFile);
FileSet fileSet = new FileSet();
fileSet.setProject(prj);
fileSet.setDir(srcdir);
zip.addFileset(fileSet);
zip.execute();
return zipFile.exists();
}

public static boolean strIsNull(String str) {
return str == null || str.equals(&quot;&quot;);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>345614</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：Toast在非UI主线程的其他线程中显示报错  http://blog.csdn.net/Neo_86/article/details/25830443#</comment>
<code>/**
* Use the {@link Looper} for the current thread with the specified callback interface
* and set whether the handler should be asynchronous.
*
* Handlers are synchronous by default unless this constructor is used to make
* one that is strictly asynchronous.
*
* Asynchronous messages represent interrupts or events that do not require global ordering
* with represent to synchronous messages. Asynchronous messages are not subject to
* the synchronization barriers introduced by {@link MessageQueue#enqueueSyncBarrier(long)}.
*
* @param callback The callback interface in which to handle messages, or null.
* @param async If true, the handler calls {@link Message#setAsynchronous(boolean)} for
* each {@link Message} that is sent to it or {@link Runnable} that is posted to it.
*
* @hide
*/
public Handler(Callback callback, boolean async) {
if (FIND_POTENTIAL_LEAKS) {
final Class&lt;? extends Handler&gt; klass = getClass();
if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
(klass.getModifiers() &amp; Modifier.STATIC) == 0) {
Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
klass.getCanonicalName());
}
}

mLooper = Looper.myLooper();
if (mLooper == null) {
throw new RuntimeException(
&quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);
}
mQueue = mLooper.mQueue;
mCallback = callback;
mAsynchronous = async;
}
/**
* Construct an empty Toast object. You must call {@link #setView} before you
* can call {@link #show}.
*
* @param context The context to use. Usually your {@link android.app.Application}
* or {@link android.app.Activity} object.
*/
public Toast(Context context) {
mContext = context;
mTN = new TN();
mTN.mY = context.getResources().getDimensionPixelSize(
com.android.internal.R.dimen.toast_y_offset);
mTN.mGravity = context.getResources().getInteger(
com.android.internal.R.integer.config_toastDefaultGravity);
}
TN() {
// XXX This should be changed to use a Dialog, with a Theme.Toast
// defined that sets up the layout params appropriately.
final WindowManager.LayoutParams params = mParams;
params.height = WindowManager.LayoutParams.WRAP_CONTENT;
params.width = WindowManager.LayoutParams.WRAP_CONTENT;
params.format = PixelFormat.TRANSLUCENT;
params.windowAnimations = com.android.internal.R.style.Animation_Toast;
params.type = WindowManager.LayoutParams.TYPE_TOAST;
params.setTitle(&quot;Toast&quot;);
params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON
| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
}
private static class TN extends ITransientNotification.Stub {
final Runnable mShow = new Runnable() {
@Override
public void run() {
handleShow();
}
};

final Runnable mHide = new Runnable() {
@Override
public void run() {
handleHide();
// Don&apos;t do this in handleHide() because it is also invoked by handleShow()
mNextView = null;
}
};

private final WindowManager.LayoutParams mParams = new WindowManager.LayoutParams();
final Handler mHandler = new Handler();

int mGravity;
int mX, mY;
float mHorizontalMargin;
float mVerticalMargin;


View mView;
View mNextView;

WindowManager mWM;

TN() {
// XXX This should be changed to use a Dialog, with a Theme.Toast
// defined that sets up the layout params appropriately.
final WindowManager.LayoutParams params = mParams;
params.height = WindowManager.LayoutParams.WRAP_CONTENT;
params.width = WindowManager.LayoutParams.WRAP_CONTENT;
params.format = PixelFormat.TRANSLUCENT;
params.windowAnimations = com.android.internal.R.style.Animation_Toast;
params.type = WindowManager.LayoutParams.TYPE_TOAST;
params.setTitle(&quot;Toast&quot;);
params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON
| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
}

/**
* schedule handleShow into the right thread
*/
@Override
public void show() {
if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this);
mHandler.post(mShow);
}

/**
* schedule handleHide into the right thread
*/
@Override
public void hide() {
if (localLOGV) Log.v(TAG, &quot;HIDE: &quot; + this);
mHandler.post(mHide);
}

public void handleShow() {
if (localLOGV) Log.v(TAG, &quot;HANDLE SHOW: &quot; + this + &quot; mView=&quot; + mView
+ &quot; mNextView=&quot; + mNextView);
if (mView != mNextView) {
// remove the old view if necessary
handleHide();
mView = mNextView;
Context context = mView.getContext().getApplicationContext();
if (context == null) {
context = mView.getContext();
}
mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
// We can resolve the Gravity here by using the Locale for getting
// the layout direction
final Configuration config = mView.getContext().getResources().getConfiguration();
final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());
mParams.gravity = gravity;
if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) {
mParams.horizontalWeight = 1.0f;
}
if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) {
mParams.verticalWeight = 1.0f;
}
mParams.x = mX;
mParams.y = mY;
mParams.verticalMargin = mVerticalMargin;
mParams.horizontalMargin = mHorizontalMargin;
if (mView.getParent() != null) {
if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this);
mWM.removeView(mView);
}
if (localLOGV) Log.v(TAG, &quot;ADD! &quot; + mView + &quot; in &quot; + this);
mWM.addView(mView, mParams);
trySendAccessibilityEvent();
}
}

private void trySendAccessibilityEvent() {
AccessibilityManager accessibilityManager =
AccessibilityManager.getInstance(mView.getContext());
if (!accessibilityManager.isEnabled()) {
return;
}
// treat toasts as notifications since they are used to
// announce a transient piece of information to the user
AccessibilityEvent event = AccessibilityEvent.obtain(
AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED);
event.setClassName(getClass().getName());
event.setPackageName(mView.getContext().getPackageName());
mView.dispatchPopulateAccessibilityEvent(event);
accessibilityManager.sendAccessibilityEvent(event);
}

public void handleHide() {
if (localLOGV) Log.v(TAG, &quot;HANDLE HIDE: &quot; + this + &quot; mView=&quot; + mView);
if (mView != null) {
// note: checking parent() just to make sure the view has
// been added... i have seen cases where we get here when
// the view isn&apos;t yet added, so let&apos;s try not to crash.
if (mView.getParent() != null) {
if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this);
mWM.removeView(mView);
}

mView = null;
}
}
}
final Handler mHandler = new Handler();
public class Activity extends ContextThemeWrapper
implements LayoutInflater.Factory2,
Window.Callback, KeyEvent.Callback,
OnCreateContextMenuListener, ComponentCallbacks2 {
private static final String TAG = &quot;Activity&quot;;
private static final boolean DEBUG_LIFECYCLE = false;

/** Standard activity result: operation canceled. */
public static final int RESULT_CANCELED = 0;
/** Standard activity result: operation succeeded. */
public static final int RESULT_OK = -1;
/** Start of user-defined activity results. */
public static final int RESULT_FIRST_USER = 1;

static final String FRAGMENTS_TAG = &quot;android:fragments&quot;;

private static final String WINDOW_HIERARCHY_TAG = &quot;android:viewHierarchyState&quot;;
private static final String SAVED_DIALOG_IDS_KEY = &quot;android:savedDialogIds&quot;;
private static final String SAVED_DIALOGS_TAG = &quot;android:savedDialogs&quot;;
private static final String SAVED_DIALOG_KEY_PREFIX = &quot;android:dialog_&quot;;
private static final String SAVED_DIALOG_ARGS_KEY_PREFIX = &quot;android:dialog_args_&quot;;

private static class ManagedDialog {
Dialog mDialog;
Bundle mArgs;
}
private SparseArray&lt;ManagedDialog&gt; mManagedDialogs;

// set by the thread after the constructor and before onCreate(Bundle savedInstanceState) is called.
private Instrumentation mInstrumentation;
private IBinder mToken;
private int mIdent;
/*package*/ String mEmbeddedID;
private Application mApplication;
/*package*/ Intent mIntent;
private ComponentName mComponent;
/*package*/ ActivityInfo mActivityInfo;
/*package*/ &lt;span style=&quot;background-color: rgb(255, 204, 51);&quot;&gt;ActivityThread mMainThread;&lt;/span&gt;
Activity mParent;
boolean mCalled;
boolean mCheckedForLoaderManager;
boolean mLoadersStarted;
/*package*/ boolean mResumed;
private boolean mStopped;
boolean mFinished;
boolean mStartedActivity;
private boolean mDestroyed;
private boolean mDoReportFullyDrawn = true;
/** true if the activity is going through a transient pause */
/*package*/ boolean mTemporaryPause = false;
/** true if the activity is being destroyed in order to recreate it with a new configuration */
/*package*/ boolean mChangingConfigurations = false;
/*package*/ int mConfigChangeFlags;
/*package*/ Configuration mCurrentConfig;
private SearchManager mSearchManager;
private MenuInflater mMenuInflater;
&lt;span style=&quot;background-color: rgb(255, 204, 51);&quot;&gt;ActivityThread&lt;/span&gt;
public static final void main(String[] args) {
SamplingProfilerIntegration.start();
Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);
Looper.prepareMainLooper();
ActivityThread thread = new ActivityThread();
thread.attach(false);
Looper.loop();
if (Process.supportsProcesses()) {
throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
}
thread.detach();
String name = (thread.mInitialApplication != null)
? thread.mInitialApplication.getPackageName()
: &quot;&lt;unknown&gt;&quot;;
Slog.i(TAG, &quot;Main thread of &quot; + name + &quot; is now exiting&quot;);
}
Looper.loop();会导致后面不执行
//我是主线程的Handler，可以通过这个
Looper refMainLooper = mActivity.getMainLooper();
//等价Looper refMainLooper = Looper.getMainLooper();
final Handler loginHandlerInMainThreadLooper = new Handler(refMainLooper, new Callback() {

@Override
public boolean handleMessage(Message msg)
{
// TODO Auto-generated method stub
Toast volumeToast = (Toast) msg.obj;
if (volumeToast != null)
volumeToast.cancel();
Toast.makeText(mActivity, R.string.toast_login_fail, Toast.LENGTH_SHORT).show();

return false;
}

});
final Thread loginThread = new Thread(new Runnable() {

@Override
public void run()
{
Looper.prepare();//创建该线程的Looper对象
Toast volumeToast = new Toast(mActivity);
volumeToast.setGravity(Gravity.CENTER, 0, 0);
volumeToast.setView(inflater.inflate(R.layout.dialog_myprogress, null, false));
volumeToast.setDuration(30000);

volumeToast.show();
Message msg = loginHandlerInMainThreadLooper.obtainMessage(0, volumeToast);
loginHandlerInMainThreadLooper.sendMessageDelayed(msg, 5000);
Log.w(&quot;Looper&quot;, &quot;Looper.loop()&quot;);
//Looper.loop();

Log.w(&quot;Looper&quot;, &quot;Looper end&quot;);
}
});
loginThread.start();
</code>
</RECORD>
<RECORD>
<snippet_key>280334</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Java中的匿名内部类总结  http://blog.csdn.net/u013146549/article/details/23170183#</comment>
<code>abstract class Person {
    public abstract void eat();
}
 
class Child extends Person {
    public void eat() {
        System.out.println(&quot;eat something&quot;);
    }
}
 
public class Demo {
    public static void main(String[] args) {
        Person p = new Child();
        p.eat();
    }
}
abstract class Person {
    public abstract void eat();
}
 
public class Demo {
    public static void main(String[] args) {
        Person p = new Person() {
            public void eat() {
                System.out.println(&quot;eat something&quot;);
            }
        };
        p.eat();
    }
}
interface Person {
    public void eat();
}
 
public class Demo {
    public static void main(String[] args) {
        Person p = new Person() {
            public void eat() {
                System.out.println(&quot;eat something&quot;);
            }
        };
        p.eat();
    }
}
public class Demo {
    public static void main(String[] args) {
        Thread t = new Thread() {
            public void run() {
                for (int i = 1; i &lt;= 5; i++) {
                    System.out.print(i + &quot; &quot;);
                }
            }
        };
        t.start();
    }
}
public class Demo {
    public static void main(String[] args) {
        Runnable r = new Runnable() {
            public void run() {
                for (int i = 1; i &lt;= 5; i++) {
                    System.out.print(i + &quot; &quot;);
                }
            }
        };
        Thread t = new Thread(r);
        t.start();
    }
}
</code>
</RECORD>
<RECORD>
<snippet_key>345870</snippet_key>
<tag>15</tag>
<comment>来自CSDN博客：多态中成员变量与成员方法的调用 http://blog.csdn.net/jyjxs/article/details/25838637#</comment>
<code>public class Test2 {
public static void main(String[] args) {
A a = new B();
a.show1();
System.out.println(a.n);

//a.show2(); //会出现编译错误
}
}


class A {

public static String n =&quot;A&quot;;


void show1(){
System.out.println(&quot;A1&quot;);
}
}

class B extends A {

public static String n =&quot;B&quot;;


void show1(){
System.out.println(&quot;B1&quot;);
}

void show2(){
System.out.println(&quot;B2&quot;);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>149518</snippet_key>
<tag></tag>
<comment>来自CSDN博客：if...else if多分支语句/控制台输入成绩/switch...case语句  http://blog.csdn.net/u013316128/article/details/18043575#</comment>
<code>package day03;
import java.util.Scanner;
public class IfElseDemo {

public static void main(String[] args) {

//运用控制台输入成绩;
System.out.println(&quot;输入成绩:&quot;);
Scanner console=new Scanner(System.in);
double score = console.nextDouble();
System.out.print(&quot;等级为:&quot;);//print不换行
if (score &lt;= 100 &amp;&amp; score &gt;= 90) {
System.out.println(&quot;优秀&quot;);
} else if (score &lt; 90 &amp;&amp; score &gt;= 80) {
System.out.println(&quot;良好&quot;);
} else if (score &lt; 80 &amp;&amp; score &gt;= 70) {
System.out.println(&quot;中等&quot;);
} else if (score &lt; 70 &amp;&amp; score &gt;= 60) {
System.out.println(&quot;及格&quot;);
} else { //该行代码if (score &lt; 60)可省略;
System.out.println(&quot;不及格!&quot;);

} //if...else if多分支语句

}

}
package day03;
import java.util.Scanner;
public class SwitchDemo {

public static void main(String[] args) {
// TODO 自动生成的方法存根
Scanner console=new Scanner(System.in);
System.out.print(&quot;输入分数:&quot;);
double score =console.nextDouble(); //分数可能为小数,声明为double
String level = &quot;不及格&quot;;// 需要初始化变量,level等级/水平/级别
switch ((int)(score / 10)) { // 表达式为整数,对score/10的结果转换为int类型
case 10 : case 9: //或
level = &quot;优秀&quot;;
break;// 10或9
case 8:
level = &quot;良好&quot;;
break;
case 7:
level = &quot;中等&quot;;
break;
case 6:
level = &quot;及格&quot;;
break;
// 此处省略default:level= &quot;不及格&quot;;(没有对level初始化时,不能省略;)
}
System.out.println(level);
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>477198</snippet_key>
<tag>android 代码混淆 proguard</tag>
<comment>来自CSDN博客：android对app进行代码混淆  http://blog.csdn.net/ttdevs/article/details/39549001#</comment>
<code>public class MainActivity extends Activity {

private String mName;

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

mName = &quot;ttdevs&quot;;

getString(mName);
setName(mName);
showDialog();
// testError();
}

public String getString(String name) {
return &quot;hello &quot; + name;
}

public void setName(String name) {
System.out.println(&quot;I&apos;m &quot; + name);
}

private void showDialog() {
new Handler().postDelayed(new Runnable() {

@Override
public void run() {
ScoreAlertDialog.showDialog(MainActivity.this);
}
}, 2000);
}

public static class ScoreAlertDialog {

public static void showDialog(final Activity activity) {
if (activity.isFinishing()) {
return;
}
try {
AlertDialog.Builder builder = new AlertDialog.Builder(activity);
builder.setTitle(&quot;alert_title&quot;);
builder.setNegativeButton(&quot;cancel&quot;, null);
builder.setPositiveButton(&quot;submit&quot;, new DialogInterface.OnClickListener() {
@Override
public void onClick(DialogInterface dialog, int which) {
try {
Toast.makeText(activity, &quot;Welcome&quot;, Toast.LENGTH_LONG).show();
} catch (Exception e) {
e.printStackTrace();
}
}
});
builder.show();
} catch (Exception e) {
e.printStackTrace();
}
}
}

private void testError() {
try {
int error = 1 / 0;
} catch (Exception e) {
e.printStackTrace();
}
}
}
java.lang.ArithmeticException: divide by zero
at com.ttdevs.proguard.MainActivity.b(Unknown Source)
at com.ttdevs.proguard.MainActivity.onCreate(Unknown Source)
at android.app.Activity.performCreate(Activity.java:4531)
at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1071)
at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2150)
at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2229)
at android.app.ActivityThread.access$600(ActivityThread.java:139)
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1261)
at android.os.Handler.dispatchMessage(Handler.java:99)
at android.os.Looper.loop(Looper.java:154)
at android.app.ActivityThread.main(ActivityThread.java:4945)
at java.lang.reflect.Method.invokeNative(Native Method)
at java.lang.reflect.Method.invoke(Method.java:511)
at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:784)
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:551)
at dalvik.system.NativeStart.main(Native Method)
retrace.bat mapping.txt log.txt
-optimizationpasses 5
-dontusemixedcaseclassnames
-dontskipnonpubliclibraryclasses
-dontpreverify
-verbose
-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*

-keep public class * extends android.app.Activity
-keep public class * extends android.app.Application
-keep public class * extends android.app.Service
-keep public class * extends android.content.BroadcastReceiver
-keep public class * extends android.content.ContentProvider
-keep public class * extends android.app.backup.BackupAgentHelper
-keep public class * extends android.preference.Preference
-keep public class com.android.vending.licensing.ILicensingService

-keepclasseswithmembernames class * {
native &lt;methods&gt;;
}

-keepclasseswithmembernames class * {
public &lt;init&gt;(android.content.Context, android.util.AttributeSet);
}

-keepclasseswithmembernames class * {
public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);
}

-keepclassmembers enum * {
public static **[] values();
public static ** valueOf(java.lang.String);
}

-keep class * implements android.os.Parcelable {
public static final android.os.Parcelable$Creator *;
}
# -keep public class com.ttdevs.proguard.** { *; }
# -keepclasseswithmembers public class com.ttdevs.proguard.** { *; }

-keep public class com.ttdevs.proguard.MainActivity {
java.lang.String getString(java.lang.String);
}
</code>
</RECORD>
<RECORD>
<snippet_key>231685</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：多线程源代码测试  http://blog.csdn.net/u011131296/article/details/21098857#</comment>
<code>public class ThreadTest {

public static void main(String[] args) {
// TODO Auto-generated method stub
Thread ra1=new ThreadA();//利用多态实例化一个ThreadA对象
Runnable ra2=new ThreadB();//利用多态实例化一个ThreadB对象

Thread t1=new Thread(ra1);//就像一层包装，把ra1给包装一下
Thread t2=new Thread(ra2);

t1.start();
t2.start();

}

}
/*线程A继承Thread类*/
class ThreadA extends Thread {
public void run(){
for(int i=0;i&lt;10;i++){
System.out.println(i + &quot;￥&quot;);

try {
Thread.sleep(1000);
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}
}
}
/*线程B继承Runnable接口*/
class ThreadB implements Runnable{
public void run(){
for(int i=0;i&lt;10;i++){
System.out.println(i + &quot;$&quot;);

try {
Thread.sleep(1000);
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>297221</snippet_key>
<tag></tag>
<comment>来自CSDN博客：java 捕捉错误try-catch http://blog.csdn.net/u010588126/article/details/23919991#</comment>
<code>try{
//需要运行的代码
}catch(Exception e){
e.printStackTrace();
}
//链接地址
</code>
</RECORD>
<RECORD>
<snippet_key>428293</snippet_key>
<tag>android 团购 美团</tag>
<comment>来自CSDN博客：scrollview 上滑固定某一控件（美团团购详情UI）  http://blog.csdn.net/rain_butterfly/article/details/37885001#</comment>
<code>&lt;FrameLayout
android:id=&quot;@+id/detail_fl&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;fill_parent&quot; &gt;

&lt;ScrollView
android:id=&quot;@+id/detail_scroll&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;fill_parent&quot;
android:visibility=&quot;visible&quot; &gt;
&lt;RelativeLayout
android:id=&quot;@+id/detail_rl_fixation&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;50dp&quot;
android:background=&quot;@color/white&quot;
android:paddingBottom=&quot;5dp&quot;
android:paddingLeft=&quot;15dp&quot;
android:paddingRight=&quot;15dp&quot;
android:paddingTop=&quot;5dp&quot;
android:visibility=&quot;gone&quot;
&gt;
&lt;TextView
android:id=&quot;@+id/detail_fix_teamprice&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;fill_parent&quot;
android:gravity=&quot;center&quot;
android:text=&quot;@string/format_yuan_d&quot;
android:textColor=&quot;@color/background_light&quot;
android:textSize=&quot;20sp&quot;
android:textStyle=&quot;bold&quot; /&gt;

&lt;TextView
android:id=&quot;@+id/detail_fix_marketprice&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;fill_parent&quot;
android:layout_toRightOf=&quot;@id/detail_fix_teamprice&quot;
android:gravity=&quot;center_vertical&quot;
android:paddingLeft=&quot;10dp&quot;
android:text=&quot;@string/format_yuan_d&quot;
android:textColor=&quot;@color/gray&quot; /&gt;

&lt;Button
android:id=&quot;@+id/detail_fix_buy&quot;
android:layout_width=&quot;100dp&quot;
android:layout_height=&quot;fill_parent&quot;
android:layout_alignParentRight=&quot;true&quot;
android:background=&quot;@drawable/btn_orange&quot;
android:text=&quot;@string/buy&quot;
android:textColor=&quot;@color/white&quot;
android:textSize=&quot;17sp&quot; /&gt;
&lt;/RelativeLayout&gt;
msgView.setOnTouchListener(new OnTouchListener() {//msgView就是framelayout里面那个控制滑动区域的scrollview设置一个滑动监听器
private int lastY = 0;
private int touchEventId = 0;//
Handler handler = new Handler() {
public void handleMessage(Message msg) {
super.handleMessage(msg);
if (msg.what == touchEventId) {
if (lastY != msgView.getScrollY()) {

lastY = msgView.getScrollY();//lastY始终记录着scrollview的纵坐标
active.getLocationOnScreen(location);//active是那个跟着scrollview滑动的模块，到顶端表面上看会停下的布局
fixation.getLocationOnScreen(location2);//getLocationOnScreen是把控件的坐标记录到location里面，location[0]=x
if (location[1] &lt;= location2[1]) {//location[1]=y，fixation是那个固定的隐藏布局，一旦fixation纵坐标大于active
fixation.setVisibility(View.VISIBLE);//纵坐标，隐藏的fixation就会可见，否则就消失，这就从视觉上实现类似效果

} else {
fixation.setVisibility(View.GONE);
}
}
}
}
};

public boolean onTouch(View v, MotionEvent event) {
if (event.getAction() == MotionEvent.ACTION_MOVE) {//延时5毫秒进行发送，也可以换成其他时间，只要不影响效果
handler.sendMessageDelayed(
handler.obtainMessage(touchEventId, v), 5);
}
if (event.getAction() == MotionEvent.ACTION_UP) {
handler.sendMessageDelayed(
handler.obtainMessage(touchEventId, v), 5);
}
return false;
}
});
&lt;/ScrollView&gt;

&lt;RelativeLayout
android:id=&quot;@+id/detail_rl_fixation&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;50dp&quot;
android:background=&quot;@color/white&quot;
android:paddingBottom=&quot;5dp&quot;
android:paddingLeft=&quot;15dp&quot;
android:paddingRight=&quot;15dp&quot;
android:paddingTop=&quot;5dp&quot;
android:visibility=&quot;gone&quot;
&gt;

&lt;TextView
android:id=&quot;@+id/detail_fix_teamprice&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;fill_parent&quot;
android:gravity=&quot;center&quot;
android:text=&quot;@string/format_yuan_d&quot;
android:textColor=&quot;@color/background_light&quot;
android:textSize=&quot;20sp&quot;
android:textStyle=&quot;bold&quot; /&gt;

&lt;TextView
android:id=&quot;@+id/detail_fix_marketprice&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;fill_parent&quot;
android:layout_toRightOf=&quot;@id/detail_fix_teamprice&quot;
android:gravity=&quot;center_vertical&quot;
android:paddingLeft=&quot;10dp&quot;
android:text=&quot;@string/format_yuan_d&quot;
android:textColor=&quot;@color/gray&quot; /&gt;

&lt;Button
android:id=&quot;@+id/detail_fix_buy&quot;
android:layout_width=&quot;100dp&quot;
android:layout_height=&quot;fill_parent&quot;
android:layout_alignParentRight=&quot;true&quot;
android:background=&quot;@drawable/btn_orange&quot;
android:text=&quot;@string/buy&quot;
android:textColor=&quot;@color/white&quot;
android:textSize=&quot;17sp&quot; /&gt;
&lt;/RelativeLayout&gt;
&lt;/FrameLayout&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>477454</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Android ScrollView向上滑动控件顶部悬浮效果实现  http://blog.csdn.net/viviwen123/article/details/39669811#</comment>
<code>package com.willen.topFloatDemo;

import android.content.Context;
import android.os.Handler;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.widget.ScrollView;

/*
* ScrollView并没有实现滚动监听，所以我们必须自行实现对ScrollView的监听，
* 我们很自然的想到在onTouchEvent()方法中实现对滚动Y轴进行监听
* ScrollView的滚动Y值进行监听
*/
public class MyScrollView extends ScrollView {
private OnScrollListener onScrollListener;
/**
* 主要是用在用户手指离开MyScrollView，MyScrollView还在继续滑动，我们用来保存Y的距离，然后做比较
*/
private int lastScrollY;

public MyScrollView(Context context) {
super(context, null);
}
public MyScrollView(Context context, AttributeSet attrs) {
super(context, attrs, 0);
}
public MyScrollView(Context context, AttributeSet attrs, int defStyle) {
super(context, attrs, defStyle);
}
/**
* 设置滚动接口
* @param onScrollListener
*/
public void setOnScrollListener(OnScrollListener onScrollListener){
this.onScrollListener = onScrollListener;
}
/**
* 用于用户手指离开MyScrollView的时候获取MyScrollView滚动的Y距离，然后回调给onScroll方法中
*/
private Handler handler = new Handler() {

public void handleMessage(android.os.Message msg) {
int scrollY = MyScrollView.this.getScrollY();

//此时的距离和记录下的距离不相等，在隔5毫秒给handler发送消息
if(lastScrollY != scrollY){
lastScrollY = scrollY;
handler.sendMessageDelayed(handler.obtainMessage(), 5);
}
if(onScrollListener != null){
onScrollListener.onScroll(scrollY);
}

};

};
/**
* 重写onTouchEvent， 当用户的手在MyScrollView上面的时候，
* 直接将MyScrollView滑动的Y方向距离回调给onScroll方法中，当用户抬起手的时候，
* MyScrollView可能还在滑动，所以当用户抬起手我们隔5毫秒给handler发送消息，在handler处理
* MyScrollView滑动的距离
*/
@Override
public boolean onTouchEvent(MotionEvent ev) {
if(onScrollListener != null){
onScrollListener.onScroll(lastScrollY = this.getScrollY());
}
switch(ev.getAction()){
case MotionEvent.ACTION_UP:
handler.sendMessageDelayed(handler.obtainMessage(), 20);
break;
}
return super.onTouchEvent(ev);
}

/**
* 滚动的回调接口
*/
public interface OnScrollListener{
/**
* 回调方法， 返回MyScrollView滑动的Y方向距离
*/
public void onScroll(int scrollY);
}
}
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot;
android:id=&quot;@+id/container&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:orientation=&quot;vertical&quot; &gt;

&lt;com.willen.topFloatDemo.MyScrollView
android:id=&quot;@+id/myScrollView&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot; &gt;

&lt;LinearLayout
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:orientation=&quot;vertical&quot; &gt;

&lt;RelativeLayout
android:id=&quot;@+id/rlayout&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:layout_gravity=&quot;center_horizontal&quot; &gt;

&lt;TextView
android:id=&quot;@+id/tv&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:gravity=&quot;center_vertical&quot;
android:text=&quot;顶部信息\n顶部信息\n顶部信息\n顶部信息&quot;
android:textSize=&quot;40dp&quot; /&gt;
&lt;/RelativeLayout&gt;

&lt;LinearLayout
android:id=&quot;@+id/search02&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;40dip&quot;
android:orientation=&quot;vertical&quot; &gt;

&lt;EditText
android:id=&quot;@+id/search_edit&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;40dip&quot;
android:background=&quot;@drawable/bg_edittext&quot;
android:hint=&quot;请输入...&quot;
android:padding=&quot;5dip&quot;
android:singleLine=&quot;true&quot;
android:textColorHint=&quot;#AAAAAA&quot;
android:textSize=&quot;15dip&quot; /&gt;
&lt;/LinearLayout&gt;

&lt;TextView
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:gravity=&quot;center_horizontal&quot;
android:text=&quot;测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容\n测试内容&quot;
android:textSize=&quot;40dp&quot; /&gt;
&lt;/LinearLayout&gt;
&lt;/com.willen.topFloatDemo.MyScrollView&gt;

&lt;LinearLayout
android:id=&quot;@+id/search01&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;40dip&quot;
android:orientation=&quot;vertical&quot; &gt;
&lt;/LinearLayout&gt;

&lt;/RelativeLayout&gt;
package com.willen.topFloatDemo;

import android.app.Activity;
import android.os.Bundle;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;

import com.willen.topFloatDemo.MyScrollView.OnScrollListener;

public class MainActivity extends Activity implements OnScrollListener{
private EditText search_edit;
private MyScrollView myScrollView;
private int searchLayoutTop;

LinearLayout search01,search02;
RelativeLayout rlayout;

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
//初始化控件
init();
}

private void init() {
search_edit = (EditText)findViewById(R.id.search_edit);
myScrollView = (MyScrollView)findViewById(R.id.myScrollView);
search01 = (LinearLayout)findViewById(R.id.search01);
search02 = (LinearLayout)findViewById(R.id.search02);
rlayout = (RelativeLayout)findViewById(R.id.rlayout);
myScrollView.setOnScrollListener(this);

}

@Override
public void onWindowFocusChanged(boolean hasFocus) {
super.onWindowFocusChanged(hasFocus);
if(hasFocus){
searchLayoutTop = rlayout.getBottom();//获取searchLayout的顶部位置
}
}

//监听滚动Y值变化，通过addView和removeView来实现悬停效果
@Override
public void onScroll(int scrollY) {
if(scrollY &gt;= searchLayoutTop){
if (search_edit.getParent()!=search01) {
search02.removeView(search_edit);
search01.addView(search_edit);
}
}else{
if (search_edit.getParent()!=search02) {
search01.removeView(search_edit);
search02.addView(search_edit);
}
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>412174</snippet_key>
<tag>442</tag>
<comment>来自CSDN博客：Get Level of a node in a Binary Tree http://blog.csdn.net/dongqifan/article/details/36034235#</comment>
<code>package tree;

public class GetLevelofanode {

/**
* 求二叉树某个节点所在的层数，如果没有就返回0
* @param args
*/
public static int getlevel(TreeNode root,int num,int level){
if(root==null) return 0;
if(root.value==num){
return level;
}
int l = getlevel(root.left, num, level+1);
if(l==0){
return getlevel(root.right, num, level+1);
}
return l;
}
public static void main(String[] args) {

TreeNode root = new TreeNode(3);
root.left = new TreeNode(2);
root.right = new TreeNode(5);
root.left.left = new TreeNode(1);
root.left.right = new TreeNode(4);
System.out.println(getlevel(root, 8, 1));

}

}
</code>
</RECORD>
<RECORD>
<snippet_key>84750</snippet_key>
<tag></tag>
<comment>来自CSDN博客：weka api调用小程序  http://blog.csdn.net/guagualvcha/article/details/16987147#</comment>
<code>package com.bai;
import java.io.File;


import weka.classifiers.Classifier;
import weka.classifiers.trees.J48;
import weka.core.Instances;
import weka.core.converters.ArffLoader;
public class Test {

/**
* @param args
* @throws Exception
*/
public static void main(String[] args) throws Exception {
Classifier m_classifier = new J48();
File inputFile = new File(&quot;D://Weka-3-6//data//cpu.with.vendor.arff&quot;);//训练weka数据文件
ArffLoader atf = new ArffLoader();
atf.setFile(inputFile);
Instances instancesTrain = atf.getDataSet(); // 读入训练文件
inputFile = new File(&quot;D://Weka-3-6//data//cpu.with.vendor.arff&quot;);//将训练集作为测试集合
atf.setFile(inputFile);
Instances instancesTest = atf.getDataSet(); // 读入测试文件
instancesTest.setClassIndex(0); //设置分类属性所在行号（第一行为0号）
double sum = instancesTest.numInstances(),&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;right = 0.0f;&lt;/span&gt;
instancesTrain.setClassIndex(0);
m_classifier.buildClassifier(instancesTrain); //训练
System.out.println(m_classifier.getRevision());
for(int i = 0;i&lt;sum;i++)//测试分类结果
{
if(m_classifier.classifyInstance(instancesTest.instance(i))==instancesTest.instance(i).classValue())//如果预测值和答案值相等
{
right++;//正确值加1
}
}
System.out.println(&quot;J48 classification precision:&quot;+(right/sum));
System.out.println(m_classifier.getRevision());
}

}
</code>
</RECORD>
<RECORD>
<snippet_key>346894</snippet_key>
<tag>thread sleep</tag>
<comment> 死锁代码示例</comment>
<code>package lock;

public class Lock extends Thread{
static Object obj1=new Object();
static Object obj2=new Object();
public boolean flag=true;
public void run() {
if(flag){
synchronized(obj1){
try {
System.out.println(&quot; t1 before sleep&quot;);
this.sleep(2000);
System.out.println(&quot; t1 after sleep&quot;);
} catch (InterruptedException e) {
e.printStackTrace();
}
synchronized(obj2){
System.out.println(&quot;get obj2&quot;);
}
}
}else{
synchronized(obj2){
try {
System.out.println(&quot; t2 before sleep&quot;);
this.sleep(1000);
System.out.println(&quot; t2 after sleep&quot;);
} catch (InterruptedException e) {
e.printStackTrace();
}
synchronized(obj1){
System.out.println(&quot;get obj1&quot;);
}
}
}
}

public boolean isFlag() {
return flag;
}
public void setFlag(boolean flag) {
this.flag = flag;
}
public static void main(String[] args){
Lock t1=new Lock();
Lock t2=new Lock();
t1.setFlag(true);
t2.setFlag(false);
t1.start();
t2.start();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>412430</snippet_key>
<tag>android android开发 viewpager srollview viewpager和scrollview</tag>
<comment>来自CSDN博客：android中viewpager，scrollview的嵌套问题  http://blog.csdn.net/MaximusKiang/article/details/36063895#</comment>
<code>@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {

switch (ev.getAction()) {
case MotionEvent.ACTION_DOWN:
xDistance = yDistance = 0f;
xLast = ev.getX();
yLast = ev.getY();
break;
case MotionEvent.ACTION_MOVE:
final float curX = ev.getX();
final float curY = ev.getY();

xDistance += Math.abs(curX - xLast);
yDistance += Math.abs(curY - yLast);
xLast = curX;
yLast = curY;

if(xDistance &gt; yDistance){
return false;
}
}

return super.onInterceptTouchEvent(ev);
}
boolean ret = super.dispatchTouchEvent(ev);
if(ret)
{
requestDisallowInterceptTouchEvent(true);
}
return ret;
</code>
</RECORD>
<RECORD>
<snippet_key>428805</snippet_key>
<tag></tag>
<comment>来自CSDN博客：命令模式（command）  http://blog.csdn.net/shuijieshuijie/article/details/37905493#</comment>
<code>public interface Command {
public abstract void execute ( );
}
public class Client {
public static void main(String[] args) {
Receiver receiver = new Receiver();
Command command = new ConcreteCommand(receiver);
Invoker invoker = new Invoker(command);
invoker.action();
}
}
public class Invoker {
private Command command;
public Invoker(Command command) {
this.command = command;
}
public void action() {
command.execute();
}
}
public class Receiver {
public Receiver() {
//write code here
}
public void action() {
System.out.println(&quot;&quot;Action has been taken);
}
}
public class Command {
void execute();
}
public class ConcreteCommand implements Command {
private Receiver receiver;
public ConcreteCommand(Receiver receiver) {
this.receiver = receiver;
}
public void execute() {
receiver.action();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>412686</snippet_key>
<tag></tag>
<comment>来自CSDN博客：How can I detect the Android runtime (Dalvik or ART)?  http://blog.csdn.net/opzoonzhuzhengke/article/details/36176121#</comment>
<code>package com.example.getcurrentruntimevalue;

import android.app.Activity;
import android.os.Bundle;
import android.widget.TextView;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class MainActivity extends Activity {
private static final String SELECT_RUNTIME_PROPERTY = &quot;persist.sys.dalvik.vm.lib&quot;;
private static final String LIB_DALVIK = &quot;libdvm.so&quot;;
private static final String LIB_ART = &quot;libart.so&quot;;
private static final String LIB_ART_D = &quot;libartd.so&quot;;

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

TextView tv = (TextView)findViewById(R.id.current_runtime_value);
tv.setText(getCurrentRuntimeValue());
}

private CharSequence getCurrentRuntimeValue() {
try {
Class&lt;?&gt; systemProperties = Class.forName(&quot;android.os.SystemProperties&quot;);
try {
Method get = systemProperties.getMethod(&quot;get&quot;,
String.class, String.class);
if (get == null) {
return &quot;WTF?!&quot;;
}
try {
final String value = (String)get.invoke(
systemProperties, SELECT_RUNTIME_PROPERTY,
/* Assuming default is */&quot;Dalvik&quot;);
if (LIB_DALVIK.equals(value)) {
return &quot;Dalvik&quot;;
} else if (LIB_ART.equals(value)) {
return &quot;ART&quot;;
} else if (LIB_ART_D.equals(value)) {
return &quot;ART debug build&quot;;
}

return value;
} catch (IllegalAccessException e) {
return &quot;IllegalAccessException&quot;;
} catch (IllegalArgumentException e) {
return &quot;IllegalArgumentException&quot;;
} catch (InvocationTargetException e) {
return &quot;InvocationTargetException&quot;;
}
} catch (NoSuchMethodException e) {
return &quot;SystemProperties.get(String key, String def) method is not found&quot;;
}
} catch (ClassNotFoundException e) {
return &quot;SystemProperties class is not found&quot;;
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>85262</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Android MD5校验码的生成与算法实现  http://blog.csdn.net/twlkyao/article/details/8882379#</comment>
<code>package com.why.md5;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class MD5Util {
/**
* 默认的密码字符串组合，用来将字节转换成 16 进制表示的字符,apache校验下载的文件的正确性用的就是默认的这个组合
*/
protected static char hexDigits[] = { &apos;0&apos; , &apos;1&apos; , &apos;2&apos; , &apos;3&apos; , &apos;4&apos; , &apos;5&apos; , &apos;6&apos; ,
&apos;7&apos; , &apos;8&apos; , &apos;9&apos; , &apos;a&apos; , &apos;b&apos; , &apos;c&apos; , &apos;d&apos; , &apos;e&apos; , &apos;f&apos; };

protected static MessageDigest messagedigest = null ;
static {
try {
messagedigest = MessageDigest.getInstance(&quot;MD5&quot; );
} catch (NoSuchAlgorithmException nsaex) {
System.err.println(MD5Util.class .getName()
+ &quot;初始化失败，MessageDigest不支持MD5Util。&quot; );
nsaex.printStackTrace();
}
}

/**
* 生成字符串的md5校验值
*
* @param s
* @return
*/
public static String getMD5String(String s) {
return getMD5String(s.getBytes());
}

/**
* 判断字符串的md5校验码是否与一个已知的md5码相匹配
*
* @param password 要校验的字符串
* @param md5PwdStr 已知的md5校验码
* @return
*/
public static boolean checkPassword(String password, String md5PwdStr) {
String s = getMD5String(password);
return s.equals(md5PwdStr);
}

/**
* 生成文件的md5校验值
*
* @param file
* @return
* @throws IOException
*/
public static String getFileMD5String(File file) throws IOException {
InputStream fis;
fis = new FileInputStream(file);
byte [] buffer = new byte [ 1024 ];
int numRead = 0 ;
while ((numRead = fis.read(buffer)) &gt; 0 ) {
messagedigest.update(buffer, 0 , numRead);
}
fis.close();
return bufferToHex(messagedigest.digest());
}

/**
* JDK1.4中不支持以MappedByteBuffer类型为参数update方法，并且网上有讨论要慎用MappedByteBuffer，
* 原因是当使用 FileChannel.map 方法时，MappedByteBuffer 已经在系统内占用了一个句柄，
* 而使用 FileChannel.close 方法是无法释放这个句柄的，且FileChannel有没有提供类似 unmap 的方法，
* 因此会出现无法删除文件的情况。
*
* 不推荐使用
*
* @param file
* @return
* @throws IOException
*/
public static String getFileMD5String_old(File file) throws IOException {
FileInputStream in = new FileInputStream(file);
FileChannel ch = in.getChannel();
MappedByteBuffer byteBuffer = ch.map(FileChannel.MapMode.READ_ONLY, 0 ,
file.length());
messagedigest.update(byteBuffer);
return bufferToHex(messagedigest.digest());
}

public static String getMD5String( byte [] bytes) {
messagedigest.update(bytes);
return bufferToHex(messagedigest.digest());
}

private static String bufferToHex( byte bytes[]) {
return bufferToHex(bytes, 0 , bytes.length);
}

private static String bufferToHex( byte bytes[], int m, int n) {
StringBuffer stringbuffer = new StringBuffer( 2 * n);
int k = m + n;
for ( int l = m; l &lt; k; l++) {
appendHexPair(bytes[l], stringbuffer);
}
return stringbuffer.toString();
}

private static void appendHexPair( byte bt, StringBuffer stringbuffer) {
char c0 = hexDigits[(bt &amp; 0xf0 ) &gt;&gt; 4 ]; // 取字节中高 4 位的数字转换, &gt;&gt;&gt; 为逻辑右移，将符号位一起右移,此处未发现两种符号有何不同
char c1 = hexDigits[bt &amp; 0xf ]; // 取字节中低 4 位的数字转换
stringbuffer.append(c0);
stringbuffer.append(c1);
}

public static void main(String[] args) throws IOException {
long begin = System.currentTimeMillis();

File file = new File( &quot;C:/12345.txt&quot; );
String md5 = getFileMD5String(file);

// String md5 = getMD5String(&quot;a&quot;);

long end = System.currentTimeMillis();
System.out.println(&quot;md5:&quot; + md5 + &quot; time:&quot; + ((end - begin) / 1000 ) + &quot;s&quot; );
}
}
package com.why.md5;

/*******************************************************************************
* MD5_SRC 类实现了RSA Data Security, Inc.在提交给IETF的RFC1321中的MD5_SRC message-digest
* 算法。
******************************************************************************/
public class MD5_SRC {
/*
* 下面这些S11-S44实际上是一个4*4的矩阵，在原始的C实现中是用#define 实现的， 这里把它们实现成为static
* final是表示了只读，且能在同一个进程空间内的多个 Instance间共享
*/
static final int S11 = 7 ;

static final int S12 = 12 ;

static final int S13 = 17 ;

static final int S14 = 22 ;

static final int S21 = 5 ;

static final int S22 = 9 ;

static final int S23 = 14 ;

static final int S24 = 20 ;

static final int S31 = 4 ;

static final int S32 = 11 ;

static final int S33 = 16 ;

static final int S34 = 23 ;

static final int S41 = 6 ;

static final int S42 = 10 ;

static final int S43 = 15 ;

static final int S44 = 21 ;

static final byte [] PADDING = { - 128 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
0 , 0 , 0 , 0 , 0 , 0 , 0 };

/*
* 下面的三个成员是keyBean计算过程中用到的3个核心数据，在原始的C实现中 被定义到keyBean_CTX结构中
*/
private long [] state = new long [ 4 ]; // state (ABCD)

private long [] count = new long [ 2 ]; // number of bits, modulo 2^64 (lsb first)

private byte [] buffer = new byte [ 64 ]; // input buffer

/*
* digestHexStr是keyBean的唯一一个公共成员，是最新一次计算结果的 16进制ASCII表示.
*/

public String digestHexStr;

/*
* digest,是最新一次计算结果的2进制内部表示，表示128bit的keyBean值.
*/
private byte [] digest = new byte [ 16 ];

/*
* getkeyBeanofStr是类keyBean最主要的公共方法，入口参数是你想要进行keyBean变换的字符串
* 返回的是变换完的结果，这个结果是从公共成员digestHexStr取得的．
*/
public String getkeyBeanofStr(String inbuf) {
keyBeanInit();
keyBeanUpdate(inbuf.getBytes(), inbuf.length());
keyBeanFinal();
digestHexStr = &quot;&quot; ;
for ( int i = 0 ; i &lt; 16 ; i++) {
digestHexStr += byteHEX(digest[i]);
}
return digestHexStr;
}

// 这是keyBean这个类的标准构造函数，JavaBean要求有一个public的并且没有参数的构造函数
public MD5_SRC() {
keyBeanInit();
return ;
}

/* keyBeanInit是一个初始化函数，初始化核心变量，装入标准的幻数 */
private void keyBeanInit() {
count[0 ] = 0L;
count[1 ] = 0L;
// /* Load magic initialization constants.
state[0 ] = 0x67452301L;
state[1 ] = 0xefcdab89L;
state[2 ] = 0x98badcfeL;
state[3 ] = 0x10325476L;
return ;
}

/*
* F, G, H ,I 是4 个基本的keyBean函数，在原始的keyBean的C实现中，由于它们是
* 简单的位运算，可能出于效率的考虑把它们实现成了宏，在java中，我们把它们 实现成了private 方法，名字保持了原来C中的。
*/
private long F( long x, long y, long z) {
return (x &amp; y) | ((~x) &amp; z);
}

private long G( long x, long y, long z) {
return (x &amp; z) | (y &amp; (~z));
}

private long H( long x, long y, long z) {
return x ^ y ^ z;
}

private long I( long x, long y, long z) {
return y ^ (x | (~z));
}

/*
* FF,GG,HH和II将调用F,G,H,I进行近一步变换 FF, GG, HH, and II transformations for
* rounds 1, 2, 3, and 4. Rotation is separate from addition to prevent
* recomputation.
*/
private long FF( long a, long b, long c, long d, long x, long s, long ac) {
a += F(b, c, d) + x + ac;
a = ((int ) a &lt;&lt; s) | (( int ) a &gt;&gt;&gt; ( 32 - s));
a += b;
return a;
}

private long GG( long a, long b, long c, long d, long x, long s, long ac) {
a += G(b, c, d) + x + ac;
a = ((int ) a &lt;&lt; s) | (( int ) a &gt;&gt;&gt; ( 32 - s));
a += b;
return a;
}

private long HH( long a, long b, long c, long d, long x, long s, long ac) {
a += H(b, c, d) + x + ac;
a = ((int ) a &lt;&lt; s) | (( int ) a &gt;&gt;&gt; ( 32 - s));
a += b;
return a;
}

private long II( long a, long b, long c, long d, long x, long s, long ac) {
a += I(b, c, d) + x + ac;
a = ((int ) a &lt;&lt; s) | (( int ) a &gt;&gt;&gt; ( 32 - s));
a += b;
return a;
}

/*
* keyBeanUpdate是keyBean的主计算过程，inbuf是要变换的字节串，inputlen是长度，这个
* 函数由getkeyBeanofStr调用，调用之前需要调用keyBeaninit，因此把它设计成private的
*/
private void keyBeanUpdate( byte [] inbuf, int inputLen) {
int i, index, partLen;
byte [] block = new byte [ 64 ];
index = (int ) (count[ 0 ] &gt;&gt;&gt; 3 ) &amp; 0x3F ;
// /* Update number of bits */
if ((count[ 0 ] += (inputLen &lt;&lt; 3 )) &lt; (inputLen &lt;&lt; 3 ))
count[1 ]++;
count[1 ] += (inputLen &gt;&gt;&gt; 29 );
partLen = 64 - index;
// Transform as many times as possible.
if (inputLen &gt;= partLen) {
keyBeanMemcpy(buffer, inbuf, index, 0 , partLen);
keyBeanTransform(buffer);
for (i = partLen; i + 63 &lt; inputLen; i += 64 ) {
keyBeanMemcpy(block, inbuf, 0 , i, 64 );
keyBeanTransform(block);
}
index = 0 ;
} else
i = 0 ;
// /* Buffer remaining input */
keyBeanMemcpy(buffer, inbuf, index, i, inputLen - i);
}

/*
* keyBeanFinal整理和填写输出结果
*/
private void keyBeanFinal() {
byte [] bits = new byte [ 8 ];
int index, padLen;
// /* Save number of bits */
Encode(bits, count, 8 );
// /* Pad out to 56 mod 64.
index = (int ) (count[ 0 ] &gt;&gt;&gt; 3 ) &amp; 0x3f ;
padLen = (index &lt; 56 ) ? ( 56 - index) : ( 120 - index);
keyBeanUpdate(PADDING, padLen);
// /* Append length (before padding) */
keyBeanUpdate(bits, 8 );
// /* Store state in digest */
Encode(digest, state, 16 );
}

/*
* keyBeanMemcpy是一个内部使用的byte数组的块拷贝函数，从input的inpos开始把len长度的
* 字节拷贝到output的outpos位置开始
*/
private void keyBeanMemcpy( byte [] output, byte [] input, int outpos,
int inpos, int len) {
int i;
for (i = 0 ; i &lt; len; i++)
output[outpos + i] = input[inpos + i];
}

/*
* keyBeanTransform是keyBean核心变换程序，由keyBeanUpdate调用，block是分块的原始字节
*/
private void keyBeanTransform( byte block[]) {
long a = state[ 0 ], b = state[ 1 ], c = state[ 2 ], d = state[ 3 ];
long [] x = new long [ 16 ];
Decode(x, block, 64 );
/* Round 1 */
a = FF(a, b, c, d, x[0 ], S11, 0xd76aa478L); /* 1 */
d = FF(d, a, b, c, x[1 ], S12, 0xe8c7b756L); /* 2 */
c = FF(c, d, a, b, x[2 ], S13, 0x242070dbL); /* 3 */
b = FF(b, c, d, a, x[3 ], S14, 0xc1bdceeeL); /* 4 */
a = FF(a, b, c, d, x[4 ], S11, 0xf57c0fafL); /* 5 */
d = FF(d, a, b, c, x[5 ], S12, 0x4787c62aL); /* 6 */
c = FF(c, d, a, b, x[6 ], S13, 0xa8304613L); /* 7 */
b = FF(b, c, d, a, x[7 ], S14, 0xfd469501L); /* 8 */
a = FF(a, b, c, d, x[8 ], S11, 0x698098d8L); /* 9 */
d = FF(d, a, b, c, x[9 ], S12, 0x8b44f7afL); /* 10 */
c = FF(c, d, a, b, x[10 ], S13, 0xffff5bb1L); /* 11 */
b = FF(b, c, d, a, x[11 ], S14, 0x895cd7beL); /* 12 */
a = FF(a, b, c, d, x[12 ], S11, 0x6b901122L); /* 13 */
d = FF(d, a, b, c, x[13 ], S12, 0xfd987193L); /* 14 */
c = FF(c, d, a, b, x[14 ], S13, 0xa679438eL); /* 15 */
b = FF(b, c, d, a, x[15 ], S14, 0x49b40821L); /* 16 */
/* Round 2 */
a = GG(a, b, c, d, x[1 ], S21, 0xf61e2562L); /* 17 */
d = GG(d, a, b, c, x[6 ], S22, 0xc040b340L); /* 18 */
c = GG(c, d, a, b, x[11 ], S23, 0x265e5a51L); /* 19 */
b = GG(b, c, d, a, x[0 ], S24, 0xe9b6c7aaL); /* 20 */
a = GG(a, b, c, d, x[5 ], S21, 0xd62f105dL); /* 21 */
d = GG(d, a, b, c, x[10 ], S22, 0x2441453L); /* 22 */
c = GG(c, d, a, b, x[15 ], S23, 0xd8a1e681L); /* 23 */
b = GG(b, c, d, a, x[4 ], S24, 0xe7d3fbc8L); /* 24 */
a = GG(a, b, c, d, x[9 ], S21, 0x21e1cde6L); /* 25 */
d = GG(d, a, b, c, x[14 ], S22, 0xc33707d6L); /* 26 */
c = GG(c, d, a, b, x[3 ], S23, 0xf4d50d87L); /* 27 */
b = GG(b, c, d, a, x[8 ], S24, 0x455a14edL); /* 28 */
a = GG(a, b, c, d, x[13 ], S21, 0xa9e3e905L); /* 29 */
d = GG(d, a, b, c, x[2 ], S22, 0xfcefa3f8L); /* 30 */
c = GG(c, d, a, b, x[7 ], S23, 0x676f02d9L); /* 31 */
b = GG(b, c, d, a, x[12 ], S24, 0x8d2a4c8aL); /* 32 */
/* Round 3 */
a = HH(a, b, c, d, x[5 ], S31, 0xfffa3942L); /* 33 */
d = HH(d, a, b, c, x[8 ], S32, 0x8771f681L); /* 34 */
c = HH(c, d, a, b, x[11 ], S33, 0x6d9d6122L); /* 35 */
b = HH(b, c, d, a, x[14 ], S34, 0xfde5380cL); /* 36 */
a = HH(a, b, c, d, x[1 ], S31, 0xa4beea44L); /* 37 */
d = HH(d, a, b, c, x[4 ], S32, 0x4bdecfa9L); /* 38 */
c = HH(c, d, a, b, x[7 ], S33, 0xf6bb4b60L); /* 39 */
b = HH(b, c, d, a, x[10 ], S34, 0xbebfbc70L); /* 40 */
a = HH(a, b, c, d, x[13 ], S31, 0x289b7ec6L); /* 41 */
d = HH(d, a, b, c, x[0 ], S32, 0xeaa127faL); /* 42 */
c = HH(c, d, a, b, x[3 ], S33, 0xd4ef3085L); /* 43 */
b = HH(b, c, d, a, x[6 ], S34, 0x4881d05L); /* 44 */
a = HH(a, b, c, d, x[9 ], S31, 0xd9d4d039L); /* 45 */
d = HH(d, a, b, c, x[12 ], S32, 0xe6db99e5L); /* 46 */
c = HH(c, d, a, b, x[15 ], S33, 0x1fa27cf8L); /* 47 */
b = HH(b, c, d, a, x[2 ], S34, 0xc4ac5665L); /* 48 */
/* Round 4 */
a = II(a, b, c, d, x[0 ], S41, 0xf4292244L); /* 49 */
d = II(d, a, b, c, x[7 ], S42, 0x432aff97L); /* 50 */
c = II(c, d, a, b, x[14 ], S43, 0xab9423a7L); /* 51 */
b = II(b, c, d, a, x[5 ], S44, 0xfc93a039L); /* 52 */
a = II(a, b, c, d, x[12 ], S41, 0x655b59c3L); /* 53 */
d = II(d, a, b, c, x[3 ], S42, 0x8f0ccc92L); /* 54 */
c = II(c, d, a, b, x[10 ], S43, 0xffeff47dL); /* 55 */
b = II(b, c, d, a, x[1 ], S44, 0x85845dd1L); /* 56 */
a = II(a, b, c, d, x[8 ], S41, 0x6fa87e4fL); /* 57 */
d = II(d, a, b, c, x[15 ], S42, 0xfe2ce6e0L); /* 58 */
c = II(c, d, a, b, x[6 ], S43, 0xa3014314L); /* 59 */
b = II(b, c, d, a, x[13 ], S44, 0x4e0811a1L); /* 60 */
a = II(a, b, c, d, x[4 ], S41, 0xf7537e82L); /* 61 */
d = II(d, a, b, c, x[11 ], S42, 0xbd3af235L); /* 62 */
c = II(c, d, a, b, x[2 ], S43, 0x2ad7d2bbL); /* 63 */
b = II(b, c, d, a, x[9 ], S44, 0xeb86d391L); /* 64 */
state[0 ] += a;
state[1 ] += b;
state[2 ] += c;
state[3 ] += d;
}

/*
* Encode把long数组按顺序拆成byte数组，因为java的long类型是64bit的，只拆低32bit，以适应原始C实现的用途
*/
private void Encode( byte [] output, long [] input, int len) {
int i, j;
for (i = 0 , j = 0 ; j &lt; len; i++, j += 4 ) {
output[j] = (byte ) (input[i] &amp; 0xffL);
output[j + 1 ] = ( byte ) ((input[i] &gt;&gt;&gt; 8 ) &amp; 0xffL);
output[j + 2 ] = ( byte ) ((input[i] &gt;&gt;&gt; 16 ) &amp; 0xffL);
output[j + 3 ] = ( byte ) ((input[i] &gt;&gt;&gt; 24 ) &amp; 0xffL);
}
}

/*
* Decode把byte数组按顺序合成成long数组，因为java的long类型是64bit的，
* 只合成低32bit，高32bit清零，以适应原始C实现的用途
*/
private void Decode( long [] output, byte [] input, int len) {
int i, j;

for (i = 0 , j = 0 ; j &lt; len; i++, j += 4 )
output[i] = b2iu(input[j]) | (b2iu(input[j + 1 ]) &lt;&lt; 8 )
| (b2iu(input[j + 2 ]) &lt;&lt; 16 ) | (b2iu(input[j + 3 ]) &lt;&lt; 24 );
return ;
}

/*
* b2iu是我写的一个把byte按照不考虑正负号的原则的”升位”程序，因为java没有unsigned运算
*/
public static long b2iu( byte b) {
return b &lt; 0 ? b &amp; 0x7F + 128 : b;
}

/*
* byteHEX()，用来把一个byte类型的数转换成十六进制的ASCII表示，
* 因为java中的byte的toString无法实现这一点，我们又没有C语言中的 sprintf(outbuf,&quot;%02X&quot;,ib)
*/
public static String byteHEX( byte ib) {
char [] Digit = { &apos;0&apos; , &apos;1&apos; , &apos;2&apos; , &apos;3&apos; , &apos;4&apos; , &apos;5&apos; , &apos;6&apos; , &apos;7&apos; , &apos;8&apos; , &apos;9&apos; , &apos;A&apos; ,
&apos;B&apos; , &apos;C&apos; , &apos;D&apos; , &apos;E&apos; , &apos;F&apos; };
char [] ob = new char [ 2 ];
ob[0 ] = Digit[(ib &gt;&gt;&gt; 4 ) &amp; 0X0F ];
ob[1 ] = Digit[ib &amp; 0X0F ];
String s = new String(ob);
return s;
}

public static void main(String args[]) {

MD5_SRC m = new MD5_SRC();
System.out.println(&quot;keyBean Test suite:&quot; );
System.out.println(&quot;keyBean(\&quot;\&quot;):&quot; +m.getkeyBeanofStr( &quot;&quot; ));
System.out.println(&quot;keyBean(\&quot;a\&quot;):&quot; +m.getkeyBeanofStr( &quot;a&quot; ));
System.out.println(&quot;keyBean(\&quot;abc\&quot;):&quot; +m.getkeyBeanofStr( &quot;abc&quot; ));
System.out.println(&quot;keyBean(\&quot;message digest\&quot;):&quot; +m.getkeyBeanofStr( &quot;message digest&quot; ));
System.out.println(&quot;keyBean(\&quot;abcdefghijklmnopqrstuvwxyz\&quot;):&quot; +
m.getkeyBeanofStr(&quot;abcdefghijklmnopqrstuvwxyz&quot; ));
System.out.println(&quot;keyBean(\&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\&quot;):&quot; +
m.getkeyBeanofStr(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot; ));

}
}
</code>
</RECORD>
<RECORD>
<snippet_key>347406</snippet_key>
<tag>477</tag>
<comment>来自CSDN博客：阿布学排序之堆排序  http://blog.csdn.net/hxysea/article/details/25901743#</comment>
<code>/**
* 需求：堆排序的实现
* 知识储备：
* 满二叉树：除叶子结点外的所有结点均有两个子结点，所有叶子结点必须在同一层上。
* 完全二叉树：
* 若二叉树的深度为h，除第h层外，其它各层（1~h-1）的节点数都达到最大个数，第h层所有结点都连续集中在最左边。
* 完全二叉树是有满二叉树而引出来的，对于深度为K的，有N个结点的二叉树，当且仅当每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称它为完全二叉树。
*
* 二叉堆是完全二叉树或者是近似完全二叉树。
* 二叉堆特性：
* 1、父结点的键值总是大于或等于（小于或等于）任何一个子结点的键值
* 2、每个结点的左子树和右子树都是一个二叉堆（都是最大堆或者最小堆）
* 最大堆：父结点的键值总是大于或等于任何一个子结点的键值。
* 最小值：父结点的键值总是小于或等于任何一个子结点的键值。
*
* 堆的存储特性：
* 一般用数组存储，i结点的父结点的下标是（i- 1）/ 2，它的左右结点下标为2 * i + 1， 2 * i + 2。如第0个结点左右结点下标为1和2。
* （a）逻辑结构：（按层编号）
* 10
* / \
* 15 56
* / \ /
* 25 30 70
* （b）存储结构
* 10 15 56 25 30 70
*
* 常见的堆操作：
* 1、建立堆：
* 数组具有对应的树表示形式，一般情况下，树并不满足堆的条件，通过重新排列元素，可以一棵“堆化树”，如下图建立一个最小堆
* 初始表：40 10 30 堆化树：10 40 30
* A[0] A[0]
* 40 10
* / \ / \
* 10 30 -----&gt; 40 30
* A[1] A[2] A[1] A[2]
* 2、插入一个元素：
* 新元素加入到表中，随后树被更新为最小堆次序，例如下图将15加入到表中
* 插入后的表：10 40 30 15
* 15加入到A[3] 重新树的排序
* 10 10
* / \ / \
* 40 30 -----&gt; 15 30
* / /
* 15 40
* 3、删除一个元素：
* 删除总是发生在跟A[0]处，表中最后一个元素被用来填补空缺位置，结构树被更新以恢复堆的形式
* 删除位于A[0]的元素10 将40移到A[0] 重新恢复堆
* 空 40 15
* / \ / \ / \
* 15 30 -----&gt; 15 30 40 30
* / /
* 40 空
* 思路：时间复杂度为O(N * logN)
* 对于插入操作：
* 每次插入都是将新数据放在数组最后，可以发现从这个新数据的父结点到根节点必然为一个有序的数列。
* 1、对于插入的下标为i的结点，其父结点下标为（i - 1）/2
* 2、进行比较，交换，最后恢复成最小堆
* 对于删除操作：
* 堆中每次删除数据都只能删除第0个数据，为了便于重建堆，实际的操作是将最后一个数据的值赋给跟结点，然后再从根节点开始进行一次从上而下的调整。
* 调整时，先在左右孩子节点中找最小的，如果父结点比这个最小的子结点还小则不需要调整了，反之将父结点和它交换后再考虑结点，想当于从根节点
* 将一个数据的下沉过程。
* 1、从i结点开始调整，n为结点总数，从0开始计算，第i结点的子结点为2 * i + 1，2 * i + 2
* @author AbuGe
*
*/
public class HeapSort
{
//在最小堆中的数据上升函数函数
public void minHeapFixup(int[] a, int i)
{
int j;
j = (i - 1) / 2;//父结点下标
int tmp = a[i];
while(j &gt;= 0 &amp;&amp; i != 0)
{
if(a[i] &gt;= a[j])
break;
//a[i] = a[j];//把较大的结点往下移动，替换它的子结点
//a[j] = tmp;
swap(a, i, j);
i = j;
j = (i - 1) / 2;
}
}

//在最小堆中的数据下降函数
public void minHeapFixdown(int[] a, int i, int n)
{
int j;
//这一句很重要
int tmp = a[i];
j = 2 * i + 1;//左结点坐标
while(j &lt; n)
{
//在左右孩子中找最小的
if(j + 1 &lt; n &amp;&amp; a[j + 1] &lt; a[j])
j++;

if(tmp &lt;= a[j])
break;

swap(a, i, j);
//a[i] = a[j];
//a[j] = tmp;

i = j;
j = 2 * i + 1;
}
}

//建立最小堆
public void makeMinHeap(int[] a, int n)
{
for(int i = n / 2 - 1; i &gt;= 0; i--)
{
minHeapFixdown(a, i, n);
}
}

//最小堆中添加元素
public void minHeapAdd(int[] a, int n, int nNum)
{
a[n] = nNum;
minHeapFixup(a, n);
}

//最小堆中删除元素
public void minHeapDelete(int a[], int n)
{
swap(a, 0, n - 1);
minHeapFixdown(a, 0, n - 1);
}

//交换数据
public void swap(int[] a, int x, int y)
{
int tmp = a[x];
a[x] = a[y];
a[y] = tmp;
}
/**
* 注意使用最小堆排序后是递减数组，要得到递增数组，用最大堆，由于每次重新恢复堆的时间复杂度为O(logN)，共n-1次重新恢复操作，
* 再加上前面建立堆时N/2次向下调整，，每次调整的时间复杂度为O(logN),两次操作的时间复杂度相加还是O(N*logN)，故堆排序的时间复杂
* 度为O(NlogN)
*/
//最小堆--&gt;降序排序
/**
* 首先堆建立好之后第0个数据是堆中最小的数据，取出这个数据再执行minHeapFixdown的删除操作。这样执行后第0个数据又是堆中最小的
* 数据，重复操作直至堆中只剩一个数据时就得到一个降序的数组。
* @param a
* @param n
*/
public void minHeapToDescendSort(int a[], int n)
{
for(int i = n - 1; i &gt;= 1; i--)
{
swap(a, i, 0);
minHeapFixdown(a, 0, i);
}
}
public static void main(String[] args)
{
int[] a = {9, 12, 17, 30, 50, 20, 60, 65, 4, 19};
int len = a.length;
HeapSort hs = new HeapSort();
hs.makeMinHeap(a, len);

for(int sort : a)
System.out.print(sort + &quot;\t&quot;);

System.out.println();
hs.minHeapToDescendSort(a, len);

for(int sort : a)
System.out.print(sort + &quot;\t&quot;);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>232965</snippet_key>
<tag>spinner</tag>
<comment>对旅游路线spinner组建的一段刷选代码</comment>
<code>private void loadSpinner() {
// 获得省份的收据
provinceIdNames = dataUAD.getProvinceData();
if (provinceIdNames == null || provinceIdNames.isEmpty()) {
Toast.makeText(LineSearchMainActivity.this, &quot;对不起，没有相关数据！&quot;,
Toast.LENGTH_LONG).show();
return;
}
final String provinceNames[] = new String[provinceIdNames.size()];
Set&lt;Entry&lt;String, String&gt;&gt; provinceName = provinceIdNames.entrySet();
int i = 0;
for (Entry&lt;String, String&gt; s : provinceName) {
provinceNames[i] = s.getValue();
i++;
}
spinner1 = (Spinner) findViewById(R.id.spinner1);
spinner1.setPrompt(&quot;请您选择省份&quot;);
select(this, spinner1, provinceNames);
spinner1.setOnItemSelectedListener(new OnItemSelectedListener() {

@Override
public void onItemSelected(AdapterView&lt;?&gt; parent, View view,
int position, long id) {
Set&lt;Entry&lt;String, String&gt;&gt; set = provinceIdNames.entrySet();
String provinceId = null;
for (Entry&lt;String, String&gt; s : set) {
String name = provinceNames[position];
if (name.equalsIgnoreCase(s.getValue())) {
provinceId = s.getKey();
}
}
spinner2 = (Spinner) findViewById(R.id.spinner2);
spinner2.setPrompt(&quot;请您选择城市&quot;);
// 通过城市的ID获取城市数据
citiIdNames = dataUAD.getCityData(provinceId);
if (citiIdNames == null || citiIdNames.isEmpty()) {
Toast.makeText(LineSearchMainActivity.this, &quot;对不起，没有相关数据！&quot;,
Toast.LENGTH_LONG).show();
return;
}

final String[] cityNames = new String[citiIdNames.size()];
Set&lt;Entry&lt;String, String&gt;&gt; citiIdName = citiIdNames.entrySet();
int i = 0;
for (Entry&lt;String, String&gt; s : citiIdName) {
cityNames[i] = s.getValue();
i++;
}
i = 0;
select(LineSearchMainActivity.this, spinner2, cityNames);
spinner2.setOnItemSelectedListener(new OnItemSelectedListener() {

@SuppressWarnings({ &quot;static-access&quot;, &quot;null&quot; })
@Override
public void onItemSelected(AdapterView&lt;?&gt; parent,
View view, int position, long id) {
Set&lt;Entry&lt;String, String&gt;&gt; cityIdName = citiIdNames
.entrySet();
String cityId = null;
for (Entry&lt;String, String&gt; s : cityIdName) {
String name = cityNames[position];
if (name.equalsIgnoreCase(s.getValue())) {
cityId = s.getKey();
}
}
// 通过城市的ID得到路线——价格
moneyRange = dataUAD.getMoneyRange(cityId);
if (moneyRange == null || moneyRange.isEmpty()) {
Toast.makeText(LineSearchMainActivity.this,
&quot;对不起，没有相关数据！&quot;, Toast.LENGTH_LONG).show();
return;
}
Set&lt;Entry&lt;List&lt;String&gt;, Double&gt;&gt; monSet = moneyRange
.entrySet();
final String moneyRanges[] = new String[monSet.size()];
int j = 0;
for (Entry&lt;List&lt;String&gt;, Double&gt; s : monSet) {
// new
// String().valueOf()是对象之间转化，String.valueOf是转化为字符串

moneyRanges[j] = String.valueOf(s.getValue());

j++;
}
spinner3 = (Spinner) findViewById(R.id.spinner3);
spinner3.setPrompt(&quot;请您选择消费价位&quot;);
select(LineSearchMainActivity.this, spinner3,
moneyRanges);
spinner3.setOnItemSelectedListener(new OnItemSelectedListener() {

@Override
public void onItemSelected(AdapterView&lt;?&gt; parent,
View view, int position, long id) {
spinner4 = (Spinner) findViewById(R.id.spinner4);
spinner4.setPrompt(&quot;请您选择你想要的路线&quot;);
List&lt;String&gt; list = null;
// 通过的价格来取路线
Set&lt;Entry&lt;List&lt;String&gt;, Double&gt;&gt; moneyEntry = moneyRange
.entrySet();
for (Entry&lt;List&lt;String&gt;, Double&gt; s : moneyEntry) {
if (moneyRanges[position]
.equalsIgnoreCase(new String()
.valueOf(s.getValue()))) {
list = s.getKey();
}
}
lines_Names = dataUAD.getLineId_ViewsName(list);
if (lines_Names == null
|| lines_Names.size() &lt;= 0) {
Toast.makeText(LineSearchMainActivity.this,
&quot;对不起，没有相关数据！&quot;, Toast.LENGTH_LONG)
.show();
return;
}
Set&lt;Entry&lt;String, String&gt;&gt; lineIdNames = lines_Names
.entrySet();
final String[] lineNames = new String[lines_Names
.size()];
int k = 0;
for (Entry&lt;String, String&gt; s : lineIdNames) {
lineNames[k] = s.getValue();
k++;
}
select(LineSearchMainActivity.this, spinner4,
lineNames);
spinner4.setOnItemSelectedListener(new OnItemSelectedListener() {

@Override
public void onItemSelected(
AdapterView&lt;?&gt; parent, View view,
int position, long id) {

Set&lt;Entry&lt;String, String&gt;&gt; lineIdNames = lines_Names
.entrySet();
for (Entry&lt;String, String&gt; s : lineIdNames) {
if (lineNames[position]
.equalsIgnoreCase(s
.getValue())) {
lineId = s.getKey();
lineName = s.getValue();
}
}

}

@Override
public void onNothingSelected(
AdapterView&lt;?&gt; parent) {

}
});

}

@Override
public void onNothingSelected(AdapterView&lt;?&gt; parent) {
}
});

}

@Override
public void onNothingSelected(AdapterView&lt;?&gt; parent) {

}
});

}

@Override
public void onNothingSelected(AdapterView&lt;?&gt; parent) {

}
});

}

// 给每个spinner设置一个适配器的通用方法
private void select(LineSearchMainActivity lineSearchMainActivity,
Spinner spinner1, String[] mainDatas) {
ArrayAdapter&lt;String&gt; spinnerAdapter = new ArrayAdapter&lt;String&gt;(
lineSearchMainActivity, android.R.layout.simple_spinner_item,
mainDatas);
spinner1.setAdapter(spinnerAdapter);
spinnerAdapter
.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
}
</code>
</RECORD>
<RECORD>
<snippet_key>478478</snippet_key>
<tag>Android事件分发 事件拦截</tag>
<comment>来自CSDN博客：Android ViewGroup触摸事件拦截详解 http://blog.csdn.net/bboyfeiyu/article/details/39719543#</comment>
<code>public boolean onInterceptTouchEvent (MotionEvent ev)

Implement this method to intercept all touch screen motion events. This allows you to watch events as they are dispatched to your children, and take ownership of the current gesture at any point.


Using this function takes some care, as it has a fairly complicated interaction with View.onTouchEvent(MotionEvent), and using it requires implementing that method as well as this one in the correct way. Events will be received in the following order:



You will receive the down event here.
The down event will be handled either by a child of this view group, or given to your own onTouchEvent() method to handle; this means you should implement onTouchEvent() to return true, so you will continue to see the rest of the gesture (instead of looking for a parent view to handle it). Also, by returning true from onTouchEvent(), you will not receive any following events in onInterceptTouchEvent() and all touch processing must happen in onTouchEvent() like normal.


For as long as you return false from this function, each following event (up to and including the final up) will be delivered first here and then to the target&apos;s onTouchEvent().

If you return true from here, you will not receive any following events: the target view will receive the same event but with the action ACTION_CANCEL, and all further events will be delivered to your onTouchEvent() method and no longer appear here.
</code>
</RECORD>
<RECORD>
<snippet_key>151054</snippet_key>
<tag>代理模式</tag>
<comment>来自CSDN博客：代理模式与动态代理  http://blog.csdn.net/ikaraide/article/details/18083295#</comment>
<code>public abstract class Subject {
public abstract void request();
}
public class RealSubject extends Subject {

@Override
public void request() {
System.out.println(&quot;from real subject&quot;);
}

}
public class ProxySubject extends Subject {
private Subject realSubject; //持有真实对象的一个引用，通过它可以调用真实对象的方法

public ProxySubject(Subject realSubject) { //通过构造函数获得真实对象
this.realSubject = realSubject;
}

@Override
public void request() {
preRequest(); //&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;代理对象添加在真实对象具体操作前的操作&lt;/span&gt;
realSubject.request(); //真实对象的具体操作
postRequest(); //&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;代理对象添加在真实对象具体操作后的操作&lt;/span&gt;
}

private void preRequest() {
System.out.println(&quot;pre request&quot;);
}

private void postRequest() {
System.out.println(&quot;post request&quot;);
}
}
public class ProxySubject implements InvocationHandler {
private Object realSubject;

public ProxySubject(Object realSubject) {
this.realSubject = realSubject;
}

public Object invoke(Object proxy, Method method, Object[] args)
throws Throwable {
System.out.println(&quot;pre processing&quot;);
method.invoke(realSubject, args);
System.out.println(&quot;post processing&quot;);
return null;
}
}
public class Client {
public static void main(String[] args) {
RealSubject subject = new RealSubject();

InvocationHandler ih = new ProxySubject(subject); //将真实对象实例传给代理对象，那么可以改变这个真实对象

Class&lt;?&gt; clazz = subject.getClass(); //获取真实对象的Class对象

Subject s = (Subject)Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), ih);
s.request(); //调用该方法时，流程转到ih参数的invoke方法，method参数就是s调用的方法名，参数就是s调用的方法的参数
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>478734</snippet_key>
<tag></tag>
<comment>来自CSDN博客：清除 DBA_DATAPUMP_JOBS 视图中的异常数据泵作业 http://blog.csdn.net/Evils798/article/details/39737451#</comment>
<code>Oracle Database - Enterprise Edition - 版本 10.1.0.2 到 11.2.0.3


如何清除 DBA_DATAPUMP_JOBS 视图中的异常数据泵作业?

解决方案

用于这个例子中的作业:
- 导出作业 SCOTT.EXPDP_20051121 是一个正在运行的 schema 级别的导出作业
- 导出作业 SCOTT.SYS_EXPORT_TABLE_01 是一个表级别的异常导出作业
- 导出作业 SCOTT.SYS_EXPORT_TABLE_02 是一个表级别的停止导出作业
- 导出作业 SYSTEM.SYS_EXPORT_FULL_01 是一个被暂停的全库导出作业


第1步. 用 SQL*PLUS 判断在数据库中有哪些数据泵作业

%sqlplus /nolog
CONNECT / as sysdba
SET lines 200
COL owner_name FORMAT a10;
COL job_name FORMAT a20
COL state FORMAT a12
COL operation LIKE state
COL job_mode LIKE state

-- 查找数据泵作业:

SELECT owner_name, job_name, operation, job_mode,
state, attached_sessions
FROM dba_datapump_jobs
WHERE job_name NOT LIKE &apos;BIN$%&apos;
ORDER BY 1,2;

OWNER_NAME JOB_NAME OPERATION JOB_MODE STATE ATTACHED
---------- ------------------- --------- --------- ----------- --------
SCOTT EXPDP_20051121 EXPORT SCHEMA EXECUTING 1
SCOTT SYS_EXPORT_TABLE_01 EXPORT TABLE NOT RUNNING 0
SCOTT SYS_EXPORT_TABLE_02 EXPORT TABLE NOT RUNNING 0
SYSTEM SYS_EXPORT_FULL_01 EXPORT FULL NOT RUNNING 0
第2步. 确保在 dba_datapump_jobs 中列出的作业不是活动的数据泵作业: 状态应该是&apos;NOT RUNNING&apos;。

第3步. 同作业属主确认视图 dba_datapump_jobs 中状态为&apos;NOT RUNNING&apos; 的作业不是被暂停，而失败的作业。(例如，SYSTEM 用户的全库导出作业不是一个失败的作业，而是一个被故意暂停的作业)

第4步. 通过 SQL*Plus 找到相关的 master 表：

-- 查找数据泵的 master 表：

SELECT o.status, o.object_id, o.object_type,
o.owner||&apos;.&apos;||object_name &quot;OWNER.OBJECT&quot;
FROM dba_objects o, dba_datapump_jobs j
WHERE o.owner=j.owner_name AND o.object_name=j.job_name
AND j.job_name NOT LIKE &apos;BIN$%&apos; ORDER BY 4,2;

STATUS OBJECT_ID OBJECT_TYPE OWNER.OBJECT
------- ---------- ------------ -------------------------
VALID 85283 TABLE SCOTT.EXPDP_20051121
VALID 85215 TABLE SCOTT.SYS_EXPORT_TABLE_02
VALID 85162 TABLE SYSTEM.SYS_EXPORT_FULL_01
第5步. 对于过去被终止的和根本不会再启动的作业，删除它的 master 表，例如，

DROP TABLE scott.sys_export_table_02;

-- 对于启用了 recycle bin 的系统，需要额外运行：
purge dba_recyclebin;
第6步. 重新运行第1步和第4步对 dba_datapump_jobs 和 dba_objects 的查询。如果 dba_datapump_jobs 里仍然有作业列出，并且这些作业根本没有 master 表，我们就可以以作业属主的身份清除它们。例如，

CONNECT scott/tiger
SET serveroutput on
SET lines 100
DECLARE
h1 NUMBER;
BEGIN
h1 := DBMS_DATAPUMP.ATTACH(&apos;SYS_EXPORT_TABLE_01&apos;,&apos;SCOTT&apos;);
DBMS_DATAPUMP.STOP_JOB (h1);
END;
/
注意：调用 STOP_JOB 过程以后，可能会花一点时间去清除作业，我们可以查询 user_datapump_jobs 检查作业是否已经被清除掉：

SELECT * FROM user_datapump_jobs;
第7步. 确认作业已经被清除

CONNECT / as sysdba
SET lines 200
COL owner_name FORMAT a10;
COL job_name FORMAT a20
COL state FORMAT a12
COL operation LIKE state
COL job_mode LIKE state

-- 查找数据泵作业:

SELECT owner_name, job_name, operation, job_mode,
state, attached_sessions
FROM dba_datapump_jobs
WHERE job_name NOT LIKE &apos;BIN$%&apos;
ORDER BY 1,2;

OWNER_NAME JOB_NAME OPERATION JOB_MODE STATE ATTACHED
---------- ------------------- --------- --------- ----------- --------
SCOTT EXPDP_20051121 EXPORT SCHEMA EXECUTING 1
SYSTEM SYS_EXPORT_FULL_01 EXPORT FULL NOT RUNNING 0

-- 查找数据泵的 master 表:

SELECT o.status, o.object_id, o.object_type,
o.owner||&apos;.&apos;||object_name &quot;OWNER.OBJECT&quot;
FROM dba_objects o, dba_datapump_jobs j
WHERE o.owner=j.owner_name AND o.object_name=j.job_name
AND j.job_name NOT LIKE &apos;BIN$%&apos; ORDER BY 4,2;

STATUS OBJECT_ID OBJECT_TYPE OWNER.OBJECT
------- ---------- ------------ -------------------------
VALID 85283 TABLE SCOTT.EXPDP_20051121
VALID 85162 TABLE SYSTEM.SYS_EXPORT_FULL_01

摘要:
1. 异常数据泵作业不会影响新的数据泵作业. dba_datapump_jobs 是基于 gv$datapump_job, obj$, com$, and user$ 的一个视图。 这个视图显示仍在运行的数据泵作业，或者作业的 master 表仍然保留在数据库中，或者不正常结束的作业(异常作业)。如果一个新的数据泵作业启动， 会创建一条新的记录，与旧的数据泵作业无关。

2. 当用系统自动生成的作业名启动一个新的数据泵作业时，我们会检查 dba_datapump_job 中现有的名称以保持惟一性。当然，启动这个作业的用户下需要有足够的空间来创建一个新的 master 表。

3. 数据泵作业与用 DBMS_JOBS 包定义的作业不同， DBMS_JOBS 创建的作业使用它自己的进程。 数据泵作业使用一个 master 进程和一些 worker 进程。如果一个数据泵作业被暂停，数据泵作业会一直存在在数据库中（status: NOT RUNNING），这时，master 和 worker 进程会被停止，或者不再存在。客户端之后可以再次挂载到这个作业，并且继续作业的执行(START_JOB)。

4. 如果活动的数据泵作业相关联的 master 表被删除，可能会导致不一致.

4.a. 如果是一个导出作业, 不太可能引起不一致，因为删除 master 表只会导致数据泵的 mater 和 worker 进程中止。这种情况类似于客户端发起的一个意外中止。

4.b. 如果这个作业是一个导入作业，那么情况就有所不同。删除掉 master 表会导致数据泵的 worker 和 mater 进程中断。这有可能会引起不完整的导入。 例如，没有导入表的所有数据， 或表，索引，视图等的导入不完整， 这种情况类似于意外中断导入的客户端。

删除 master 表本身不会引起任何数据字典的不一致。如果您在作业完成后还保留 master 表（使用非公开的参数：KEEP_MASTER=Y），以后再删除 master
表的操作不会造成任何不一致。


</code>
</RECORD>
<RECORD>
<snippet_key>102405</snippet_key>
<tag>android 布局</tag>
<comment>来自CSDN博客：android中AlertDialog 中setView用法的一些小结  http://blog.csdn.net/Lowtec_dream/article/details/17198853#</comment>
<code>private LayoutInflater mLayoutInflater;
private View view;
mLayoutInflater=LayoutInflater.from(this);
view=mLayoutInflater.inflate(R.layout.input_dailog, null);
public void showCustomInputDialog(final int position, boolean isInputNumber) {
// 注意MainActivity如有自己的布局文件，这个dialog是view的布局文件，一定要把View写上
tv_dialog=(TextView) view.findViewById(R.id.textView_dialog_tv);

et_dialog=(EditText) view.findViewById(R.id.editText_dialog_et);

if (isInputNumber) {
et_dialog.setKeyListener(new DigitsKeyListener(false, true));
}

/*Dialog dialog = new MyDialog(PublishActivity.this,R.style.MyDialog);
dialog.show();*/

AlertDialog.Builder builder=new AlertDialog.Builder(this);
builder.setTitle(getResources().getString(R.string.txt_please_custom_input));

builder.setView(view);
builder.setPositiveButton(getResources().getString(R.string.txt_define),
new DialogInterface.OnClickListener() {

@Override
public void onClick(DialogInterface dialog, int which) {
// TODO Auto-generated method stub
post_dataList[position] = dataList[position] = et_dialog
.getText().toString();
mPublishListAdapter.notifyDataSetChanged();
}
});
builder.setNegativeButton(getResources().getString(R.string.txt_cancel),
null);
builder.show();
}
// 注意MainActivity如有自己的布局文件，这个dialog是view的布局文件，一定要把View写上
tv_dialog=(TextView) view.findViewById(R.id.textView_dialog_tv);

et_dialog=(EditText) view.findViewById(R.id.editText_dialog_et);

if (isInputNumber) {
et_dialog.setKeyListener(new DigitsKeyListener(false, true));
}

/*Dialog dialog = new MyDialog(PublishActivity.this,R.style.MyDialog);
dialog.show();*/

AlertDialog.Builder builder=new AlertDialog.Builder(this);
builder.setTitle(getResources().getString(R.string.txt_please_custom_input));

builder.setView(view);
builder.setPositiveButton(getResources().getString(R.string.txt_define),
new DialogInterface.OnClickListener() {

@Override
public void onClick(DialogInterface dialog, int which) {
// TODO Auto-generated method stub
post_dataList[position] = dataList[position] = et_dialog
.getText().toString();
mPublishListAdapter.notifyDataSetChanged();
}
});
builder.setNegativeButton(getResources().getString(R.string.txt_cancel),
null);
builder.show();
}
</code>
</RECORD>
<RECORD>
<snippet_key>167941</snippet_key>
<tag>442</tag>
<comment>来自CSDN博客：二叉树的先序遍历非递归算法 http://blog.csdn.net/okiwilldoit/article/details/18702823#</comment>
<code>public ArrayList&lt;Integer&gt; preorderTraversal(TreeNode root) {
ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
if(root == null)return list;
Stack&lt;TreeNode&gt; S = new Stack&lt;TreeNode&gt;();
TreeNode p = root;
while(p != null || !S.empty()){
while(p != null){
S.push(p);
list.add(p.val);
p = p.left;
}
if(!S.empty()){
p = S.pop();
p = p.right;
}
}
return list;
}
</code>
</RECORD>
<RECORD>
<snippet_key>85774</snippet_key>
<tag>214</tag>
<comment>来自CSDN博客：安卓之json  http://blog.csdn.net/xiaoseqingchun/article/details/16990875#</comment>
<code>String strUrl =&quot;http://ip:port/webService/......&quot;;
String strResult = connServerForResult(strUrl);
data.setText(strResult);
parseJson(strResult);
private String connServerForResult(String strUrl) {
// TODO Auto-generated method stub
HttpGet httpRequest = new HttpGet(strUrl);
String strResult = &quot;&quot;;
try{
HttpClient httpClient = new DefaultHttpClient();
HttpResponse httpResponse = httpClient.execute(httpRequest);
if (httpResponse.getStatusLine().getStatusCode()==HttpStatus.SC_OK) {
strResult = EntityUtils.toString(httpResponse.getEntity());
}
}
catch (Exception e) {
// TODO: handle exception
}
Log.e(&quot;strresult&quot;,strResult);
return strResult;
}
strResult=new String(temp.getBytes(),&quot;UTF-8&quot;);
strResult = EntityUtils.toString(httpResponse.getEntity(),&quot;UTF-8&quot;);
private void parseJson(String strResult) {
// TODO Auto-generated method stub
try {
JSONObject jsonobj=new JSONObject(strResult).getJSONObject(&quot;singer&quot;);
int id = jsonobj.getInt(&quot;id&quot;);
String name = jsonobj.getString(&quot;name&quot;);
String gender = jsonobj.getString(&quot;gender&quot;);
tvJson.setText(&quot;ID号&quot;+id + &quot;, 姓名：&quot; + name + &quot;,性别：&quot; + gender);
} catch (Exception e) {
// TODO: handle exception
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>216846</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Android的Thread Looper Handler MessageQueue Message http://blog.csdn.net/gelandesprung/article/details/20465357#</comment>
<code>class LooperThread extends Thread {
public Handler mHandler;

public void run() {
Looper.prepare();

mHandler = new Handler() {
public void handleMessage(Message msg) {
// process incoming messages here
}
};

Looper.loop();
}
</code>
</RECORD>
<RECORD>
<snippet_key>151566</snippet_key>
<tag></tag>
<comment>来自CSDN博客：黑马程序员—泛型总结（1）  http://blog.csdn.net/u013321339/article/details/18097327#</comment>
<code>import java.lang.reflect.Method;
import java.util.ArrayList;

public class GenericTest
{
public static void main(String[] args) throws Exception
{
ArrayList&lt;Integer&gt; aList = new ArrayList&lt;&gt;();
aList.add(1);
aList.add(2);
System.out.println(aList);

Method addMethod = aList.getClass().getMethod(&quot;add&quot;, Object.class);
addMethod.invoke(aList, &quot;a&quot;);
System.out.println(aList);
}
}
//结果为：
//[1, 2]
//[1, 2, a]
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class GenericTest2
{
public static void main(String[] args)
{
HashMap&lt;String, Integer&gt; hMap = new HashMap&lt;String,Integer&gt;();
hMap.put(&quot;zhangsan&quot;, 23);
hMap.put(&quot;lisi&quot;, 24);
hMap.put(&quot;wangwu&quot;, 21);

Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = hMap.entrySet();
for(Map.Entry&lt;String, Integer&gt; entry : entrySet)
{
System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue());
}
}

}
//结果为：
//wangwu:21
//lisi:24
//zhangsan:23
</code>
</RECORD>
<RECORD>
<snippet_key>348174</snippet_key>
<tag>327</tag>
<comment>来自CSDN博客：eclipse的最简单程序HelloWorld http://blog.csdn.net/tianhen791/article/details/7211388#</comment>
<code>import java.io.*;
public class HelloWorld{
public static void main(String args[]){
System.out.println(&quot;Hello World!&quot;);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>300293</snippet_key>
<tag>vim linux plugin ctags cscope</tag>
<comment>来自CSDN博客：vim进阶之添加ctags和cscope  http://blog.csdn.net/u014630759/article/details/24042713#</comment>
<code>$ ./configure
$ make
$ sudo make install
Tip：如果在make过程中出现 curses.h not found 异常导致make失败，则需要安装libncurses5-dev包，最好连libncursesw5-dev一并安装，&lt;p&gt;&lt;/p&gt;&lt;p&gt;然后在 make clean，然后继续make&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;生成索引文件&lt;/p&gt;&lt;p&gt;我关注的是.cc，.h，.cpp文件，代码如下&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre code_snippet_id=&quot;300293&quot; snippet_file_name=&quot;blog_20140418_2_4269905&quot; name=&quot;code&quot; class=&quot;java&quot;&gt;find . -name &quot;*.cc&quot; -o -name &quot;*.h&quot; -o -name &quot;*.cpp&quot; &gt; cscope.files
cscope -bkq -i cscope.files
$ sudo make install
ctags -R
:set tags=./tags
&lt;pre code_snippet_id=&quot;300293&quot; snippet_file_name=&quot;blog_20140418_4_5481884&quot; name=&quot;code&quot; class=&quot;java&quot;&gt;if has(&quot;tags&quot;)
set tags=tags
endif
$ tar -xf cscop-15.8a.tar.gz
$ ./configure
$ make
$ sudo make install
:cs add /home/alexanderkenndy/node-v0.10.21/src/cscope.out
$ sudo make install
find . -name &quot;*.cc&quot; -o -name &quot;*.h&quot; -o -name &quot;*.cpp&quot; &gt; cscope.files
cscope -bkq -i cscope.files
:cs add /home/alexanderkenndy/node-v0.10.21/src/cscope.out
nmap &lt;C-x&gt;d :cs find d &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
set autochdir
$ ctags -R
:cs add /home/alexanderkenndy/node-v0.10.21/src/cscope.out
nmap &lt;C-x&gt;s :cs find s &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-x&gt;g :cs find g &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-x&gt;c :cs find c &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-x&gt;t :cs find t &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-x&gt;e :cs find e &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-x&gt;f :cs find f &lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-x&gt;i :cs find i ^&lt;C-R&gt;=eptend(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;$&lt;CR&gt;
nmap &lt;C-x&gt;d :cs find d &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
if has(&quot;tags&quot;)
set tags=tags
endif
set autochdir
let Tlist_Ctags_Cmd=&apos;/usr/local/bin/ctags&apos;Â 
let Tlist_Show_One_File=1
let Tlist_OnlyWindow=1
let Tlist_Use_Right_Window=0
let Tlist_Sort_Type=&apos;name&apos;
let Tlist_Exit_OnlyWindow=1
let Tlist_Show_Menu=1
let Tlist_Max_Submenu_Items=10
let Tlist_Max_Tag_length=20
let Tlist_Use_SingleClick=0
let Tlist_Auto_Open=0
let Tlist_Close_On_Select=0
let Tlist_File_Fold_Auto_Close=1
let Tlist_GainFocus_On_ToggleOpen=0
let Tlist_Process_File_Always=1
let Tlist_WinHeight=10
let Tlist_WinWidth=18
let Tlist_Use_Horiz_Window=0
nmap tl :TlistToggle&lt;cr&gt;
:Tlist
$ sudo apt-get install terminator
</code>
</RECORD>
<RECORD>
<snippet_key>365829</snippet_key>
<tag>splash</tag>
<comment>来自CSDN博客：splash 代码保留 http://blog.csdn.net/JunLinDiKu/article/details/27229759#</comment>
<code>package com.demo.demodo;

import android.app.Activity;

import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;






public class SplashActivity extends Activity {

private final int SPLASH_DISPLAY_LENGHT = 2000; // 延迟八秒

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_splash);

new Handler().postDelayed(new Runnable() {
public void run() {
Intent mainIntent = new Intent(SplashActivity.this,
MainActivity.class);
SplashActivity.this.startActivity(mainIntent);
SplashActivity.this.finish();
}

}, SPLASH_DISPLAY_LENGHT);

}


// private long startTime;
//
// private Timer timer ;
//
// protected void onCreate(Bundle savedInstanceState) {
// super.onCreate(savedInstanceState);
// this.setContentView(R.layout.activity_splash);
// //开启 定时器
// timer = new Timer(true);
// startTime = System.currentTimeMillis();
// timer.schedule(task, 0, 1);
// }
//
//
// private final TimerTask task = new TimerTask() {
// public void run() {
// if (task.scheduledExecutionTime() - startTime == 2000) {
// Message message = new Message();
// message.what = 0;
// timerHandler.sendMessage(message);
// timer.cancel();
// this.cancel();
// }
//
// }
// };
//
// private final Handler timerHandler = new Handler() {
// public void handleMessage(Message msg) {
// switch (msg.what) {
// case 0:
// SplashActivity.this.finish();
// // 跳转到新的 activity
// Intent intent = new Intent(SplashActivity.this,MainActivity.class);
// SplashActivity.this.startActivity(intent);
// break;
// }
// super.handleMessage(msg);
// }
// };






}
</code>
</RECORD>
<RECORD>
<snippet_key>348942</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：Hadoop  稀疏矩阵乘法的MapReduce计算  http://blog.csdn.net/zq602316498/article/details/25982155#</comment>
<code>我们在用矩阵处理真实数据的时候，一般都是非常稀疏矩阵，为了节省存储空间，通常只会存储非0的数据。&lt;p style=&quot;margin: 10px 0pt 15px; padding: 0pt; color: rgb(77, 77, 79); font-size: 13.333333015441895px; line-height: 20px; background-color: rgb(204, 232, 207);&quot;&gt;下面我们来做一个稀疏矩阵：&lt;/p&gt;&lt;p style=&quot;margin: 10px 0pt 15px; padding: 0pt; color: rgb(77, 77, 79); font-size: 13.333333015441895px; line-height: 20px; background-color: rgb(204, 232, 207);&quot;&gt;&lt;a target=_blank href=&quot;http://blog.fens.me/wp-content/uploads/2014/01/spraseMatrix.png&quot; style=&quot;margin: 0pt; padding: 0pt; color: rgb(14, 115, 184); outline-style: none; outline-width: medium; text-decoration: none;&quot;&gt;&lt;img src=&quot;http://blog.fens.me/wp-content/uploads/2014/01/spraseMatrix.png&quot; alt=&quot;spraseMatrix&quot; width=&quot;638&quot; height=&quot;466&quot; class=&quot;alignnone size-full wp-image-4890&quot; scale=&quot;0&quot; style=&quot;margin: 0pt; padding: 0pt; border: none; max-width: 620px; height: auto;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;&lt;p style=&quot;margin: 10px 0pt 15px; padding: 0pt; color: rgb(77, 77, 79); font-size: 13.333333015441895px; line-height: 20px; background-color: rgb(204, 232, 207);&quot;&gt;&lt;/p&gt;&lt;p style=&quot;margin: 10px 0pt 15px; padding: 0pt; color: rgb(77, 77, 79); font-size: 13.333333015441895px; line-height: 20px; background-color: rgb(204, 232, 207);&quot;&gt;&lt;span style=&quot;margin: 0pt; padding: 0pt;&quot;&gt;新建2个稀疏矩阵数据文件sm1.csv, sm2.csv&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;margin: 10px 0pt 15px; padding: 0pt; color: rgb(77, 77, 79); font-size: 13.333333015441895px; line-height: 20px; background-color: rgb(204, 232, 207);&quot;&gt;只存储非0的数据，3列存储，第一列“原矩阵行”，第二列“原矩阵列”,第三列“原矩阵值”。&lt;/p&gt;&lt;p style=&quot;margin: 10px 0pt 15px; padding: 0pt; color: rgb(77, 77, 79); font-size: 13.333333015441895px; line-height: 20px; background-color: rgb(204, 232, 207);&quot;&gt;sm1.csv&lt;/p&gt;&lt;pre style=&quot;margin: 0pt 0pt 15px; padding: 10px; background-image: none; background-attachment: scroll; background-color: rgb(249, 249, 212); overflow: auto; color: rgb(77, 77, 79); font-size: 13.333333015441895px; line-height: 20px; background-position: 0% 0%; background-repeat: repeat repeat;&quot;&gt;&lt;code style=&quot;margin: 0pt; padding: 1px 3px; background-image: none; background-attachment: scroll; background-color: rgb(255, 255, 225); font-family: Monaco, monospace; font-size: 11px; line-height: normal; background-position: 0% 0%; background-repeat: repeat repeat;&quot;&gt;
1,1,1
1,4,3
2,1,2
2,2,5
2,4,4
3,4,1
4,1,4
4,2,7
4,3,1
4,4,2
&lt;/code&gt;
package org.edu.bupt.xiaoye.sparsemartrix;

import java.io.IOException;
import java.net.URI;
import java.util.Map;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.input.FileSplit;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;

public class SparseMartrixMultiply {

public static class MyMapper extends Mapper&lt;LongWritable, Text, Text, Text&gt; {
private String flag; // m1 or m2
private int rowNumA = 4; // 矩阵A的行数，因为要在对B的矩阵处理中要用
private int colNumA = 4;// 矩阵A的列数
private int rolNumB = 4;
private int colNumB = 2;// 矩阵B的列数
private static final Text k = new Text();
private static final Text v = new Text();

@Override
protected void setup(Context context) throws IOException,
InterruptedException {
FileSplit split = (FileSplit) context.getInputSplit();
flag = split.getPath().getName();// 判断读的数据集
}

@Override
protected void map(LongWritable key, Text value, Context context)
throws IOException, InterruptedException {
String[] records = value.toString().split(&quot;,&quot;);
int x = Integer.parseInt(records[0]);
int y = Integer.parseInt(records[1]);
int num = Integer.parseInt(records[2]);
if (flag.equals(&quot;m1&quot;)) {
String[] vs = value.toString().split(&quot;,&quot;);
for (int j = 0; j &lt; colNumB; j++) {
k.set(x + &quot;,&quot; + (j + 1));
v.set(&quot;A&quot; + &quot;:&quot; + y + &quot;,&quot; + num);
context.write(k, v);
}

} else if (flag.equals(&quot;m2&quot;)) {
for (int j = 0; j &lt; rowNumA; j++) {
k.set((j + 1) + &quot;,&quot; + y);
v.set(&quot;B:&quot; + x + &quot;,&quot; + num);
context.write(k, v);
}
}
}
}

public static class MyReducer extends
Reducer&lt;Text, Text, Text, IntWritable&gt; {
private static IntWritable v = new IntWritable();

@Override
protected void reduce(Text key, Iterable&lt;Text&gt; values, Context context)
throws IOException, InterruptedException {
/*
* 这里和一般矩阵不同
* 一般矩阵中，当进行第二次reduce方法调用的时候，会对数组a和b的所有元素都重新赋值
* 而在稀疏矩阵中，不会对数组的所有元素重新赋值，从而会发生上次调用reduce方法残留的数组元素值对这一次reduce产生影响。
*/
int[] a = new int[4];
int[] b = new int[4];
for (Text value : values) {
String[] vs = value.toString().split(&quot;:&quot;);
if (vs[0].equals(&quot;A&quot;)) {
String[] ints = vs[1].toString().split(&quot;,&quot;);
a[Integer.parseInt(ints[0]) - 1] = Integer
.parseInt(ints[1]);
} else {
String[] ints = vs[1].toString().split(&quot;,&quot;);
b[Integer.parseInt(ints[0]) - 1] = Integer
.parseInt(ints[1]);
}
}
// 用矩阵A的行乘矩阵B的列
int sum = 0;
for (int i = 0; i &lt; 4; i++) {
sum += a[i] * b[i];
}
v.set(sum);
context.write(key, v);
}
}

public static void run(Map&lt;String, String&gt; path) throws Exception {
String input = path.get(&quot;input&quot;);
String output = path.get(&quot;output&quot;);

Configuration conf = new Configuration();
final FileSystem fileSystem = FileSystem.get(new URI(input), conf);
final Path outPath = new Path(output);
if (fileSystem.exists(outPath)) {
fileSystem.delete(outPath, true);
}
conf.set(&quot;hadoop.job.user&quot;, &quot;hadoop&quot;);
// conf.set(&quot;mapred.job.tracker&quot;, &quot;10.103.240.160:9001&quot;);

final Job job = new Job(conf);
FileInputFormat.setInputPaths(job, input);
job.setMapperClass(MyMapper.class);
job.setReducerClass(MyReducer.class);
job.setMapOutputKeyClass(Text.class);
job.setMapOutputValueClass(Text.class);
job.setOutputKeyClass(Text.class);
job.setOutputValueClass(IntWritable.class);
job.setNumReduceTasks(1);// 设置个数为1
FileOutputFormat.setOutputPath(job, outPath);
job.waitForCompletion(true);
}

}
package org.edu.bupt.xiaoye.sparsemartrix;

import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

public class MainRun {

public static final String HDFS = &quot;hdfs://10.103.240.160:9000&quot;;
public static final Pattern DELIMITER = Pattern.compile(&quot;[\t,]&quot;);

public static void main(String[] args) {
martrixMultiply();
}

public static void martrixMultiply() {
Map&lt;String, String&gt; path = new HashMap&lt;String, String&gt;();
path.put(&quot;input&quot;, HDFS + &quot;/usr/hadoop/SparseMatrix&quot;);// HDFS的目录
path.put(&quot;output&quot;, HDFS + &quot;/usr/hadoop/SparseMatrix/output&quot;);

try {
SparseMartrixMultiply.run(path);
} catch (Exception e) {
e.printStackTrace();
}
System.exit(0);
}


}
</code>
</RECORD>
<RECORD>
<snippet_key>366341</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Java语法基础--第二天  http://blog.csdn.net/nwnxp/article/details/27254255#</comment>
<code>&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;但是在开发过程中，虽然switch语句的效率较高，但是考虑到起使用范围有限，就很少用到。
2、while语句和do while语句
在代码执行过程中，do while语句的特点在于，无论条件是否满足，循环至少执行一次。
我觉得在循环语句里面最难理解是For语句：
&lt;For语句的结构是：
for(初始化表达式;循环条件表达式;循环后的炒作表达式)
{
执行语句;(循环体)
}
For语句和while语句在一定层度上可以互换；
a、for里面的连个表达式运行的顺序：初始表达式只读一次，
判断循环条件为真就执行循环体，然后再执行循环后的操作表达式，
接着继续判断循环条件，重复查找过程，知道条件不满足为止。
b、while和for可以互换，区别在于for为了循环而定义的变量在for循环结束
就在内存中释放，而while循环使用的变量在循环结束后还可以继续使用，
c、最简单的无线循环格式：while(true),for(;;)无限循环存在的原因是
并不知道循环多少次，而是根据某些条件，来控制循环。
for和while的区别：
1、for和while可以互换。
2、格式上的不同，在使用上有区别。
如果需要通过变量来对循环进行控制，该变量只作为循环增量存在时，
区别就体现出来了。作用域不同。
循环结构的使用场景：
当对某些代码执行很多次时，就使用循环结构完成。
当对一个条件进行一次判断时，可以使用If语句，
当对一个条件进行多次判断时，可以使用while语句。
可以实现程序的自动化。
在使用循环时，一定要明确哪些语句需要参与循环，哪些语句不需要。
循环通常情况下，需要定义条件，同时需要控制次数。
虽然在固定格式下写出简单的for循环时很容易的，但是在嵌套的形式下写出来感觉却很麻烦。
&lt;/span&gt;
但是在开发过程中，虽然switch语句的效率较高，但是考虑到起使用范围有限，就很少用到。
2、while语句和do while语句
在代码执行过程中，do while语句的特点在于，无论条件是否满足，循环至少执行一次。
我觉得在循环语句里面最难理解是For语句：
&lt;For语句的结构是：
for(初始化表达式;循环条件表达式;循环后的炒作表达式)
{
执行语句;(循环体)
}
For语句和while语句在一定层度上可以互换；
a、for里面的连个表达式运行的顺序：初始表达式只读一次，
判断循环条件为真就执行循环体，然后再执行循环后的操作表达式，
接着继续判断循环条件，重复查找过程，知道条件不满足为止。
b、while和for可以互换，区别在于for为了循环而定义的变量在for循环结束
就在内存中释放，而while循环使用的变量在循环结束后还可以继续使用，
c、最简单的无线循环格式：while(true),for(;;)无限循环存在的原因是
并不知道循环多少次，而是根据某些条件，来控制循环。
for和while的区别：
1、for和while可以互换。
2、格式上的不同，在使用上有区别。
如果需要通过变量来对循环进行控制，该变量只作为循环增量存在时，
区别就体现出来了。作用域不同。
循环结构的使用场景：
当对某些代码执行很多次时，就使用循环结构完成。
当对一个条件进行一次判断时，可以使用If语句，
当对一个条件进行多次判断时，可以使用while语句。
可以实现程序的自动化。
在使用循环时，一定要明确哪些语句需要参与循环，哪些语句不需要。
循环通常情况下，需要定义条件，同时需要控制次数。&lt;/span&gt;
虽然在固定格式下写出简单的for循环时很容易的，但是在嵌套的形式下写出来感觉却很麻烦。
</code>
</RECORD>
<RECORD>
<snippet_key>283918</snippet_key>
<tag>485</tag>
<comment>来自CSDN博客：（基于Java）算法之动态规划——矩阵连乘问题  http://blog.csdn.net/u010445247/article/details/23303157#</comment>
<code>private static int recurMatrixChain(int i,int j,int[] p) //最初始的矩阵连乘问题算法
{
if(i == j) return 0; //i == j，即只有一个矩阵，计算次数当然为零
int min = recurMatrixChain(i,i,p) + recurMatrixChain(i+1,j,p) + p[i-1] * p[i] * p[j];
for(int k = i + 1; k &lt; j; k++){
int t = recurMatrixChain(i,k,p) + recurMatrixChain(k+1,j,p) + p[i-1] * p[k] * p[j];
if(t &lt; min) min = t; //从k处断开，如果t比min更小，则说明存在更优的解决方法，把t赋值给min
}
return min;
}
private static void matrixChain(int n,int[][] m,int[] p){ //填表方法，我的老师也叫这方法为真·动态规划方法
for(int i = n-1; i &gt;= 1; i--)
for(int j = i+1; j &lt;= n; j++){
int min = m[i][j] + m[i+1][j] + p[i-1] * p[i] * p[j];
for(int k = i+1; k &lt; j; k++){
int t = m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j];
if(t &lt; min) min = t;
}
m[i][j] = min;
}
}
private static int lookupChain(int i,int j,int[][] m,int[] p)
{
if(m[i][j] &gt; 0) return m[i][j]; //如果m[i][j]非零，则说明该子问题被计算过，只需取出这个数，无需进行计算
if(i == j) return 0;
int min = lookupChain(i,i,m,p) + lookupChain(i+1,j,m,p) + p[i-1] * p[i] * p[j];
for(int k = i + 1; k &lt; j; k++){
int t = lookupChain(i,k,m,p) + lookupChain(k+1,j,m,p) + p[i-1] * p[k] * p[j];
if(t &lt; min) min = t;
}
m[i][j] = min; //对于未记录的子问题，通过计算把该子问题的最优解求出后，存放在数组中
return min;
}

private static int memoizedMatrixChain(int n,int[][] m,int[] p) //这个就是解决矩阵连乘问题的备忘录方法
{
for(int i = 1; i &lt;= n; i++)
for(int j = 1; j &lt;= n; j++)
m[i][j] = 0; //对数组进行初始化
return lookupChain(1,n,m,p);
}
</code>
</RECORD>
<RECORD>
<snippet_key>349710</snippet_key>
<tag>474</tag>
<comment>来自CSDN博客：快速排序 http://blog.csdn.net/u013652613/article/details/26018635#</comment>
<code>package kuaisu;

import java.util.Arrays;

public class Demo {
public static void main(String []args){
int []arr={3,566,87,237,87,2,47,7};
sort(arr,0,arr.length-1);
System.out.println(Arrays.toString(arr));
}

private static void sort(int[] arr, int start, int end) {
int i=start;
int j=end;
if((arr==null)||(arr.length==0)){
return ;
}
while(i&lt;j){
while(i&lt;j&amp;&amp;(arr[i]&lt;=arr[j])){
j--;//从j开始，向左扫描，找到一个比arr[i]小的
}
if(i&lt;j){
// 如果有 则，交换数据
int temp=arr[i];
arr[i]=arr[j];
arr[j]=temp;
}

while(i&lt;j&amp;&amp;(arr[i]&lt;arr[j])){
i++;//从i开始，向右扫描，找到一个比arr[i]大的
}
if(i&lt;j){
// 如果有 则，交换数据
int temp=arr[i];
arr[i]=arr[j];
arr[j]=temp;
}
}//while
if(i-start&gt;1){
sort(arr,start, i-1);
}
if(end-i&gt;1){
sort(arr,i+1,end);
}

}

}
</code>
</RECORD>
<RECORD>
<snippet_key>301317</snippet_key>
<tag>java 数组 leetcode</tag>
<comment>来自CSDN博客：Leetcode: Trapping Rain Water. java http://blog.csdn.net/Muscler/article/details/24103875#</comment>
<code>public class Solution {
public int trap(int[] A) {
if (A == null || A.length == 0) return 0;
int res = 0;
int start = 0;
int end = A.length - 1;
int height = Math.min(A[start], A[end]);
//start end 记录最右边和最左边的位置
//height记录当前的高度，每次移动一位，更新最大的盛水量。
while (start &lt; end) {
if (A[start] &lt; A[end]) {
res += Math.max(height - A[start+1], 0);
height = Math.max(height, Math.min(A[start+1], A[end]));
++start;
}
else {
res += Math.max(height - A[end-1], 0);
height = Math.max(height, Math.min(A[start], A[end-1]));
--end;
}

}
return res;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>415246</snippet_key>
<tag></tag>
<comment>来自CSDN博客：《老罗Android第二季》 动画、国际化、自适应屏幕  http://blog.csdn.net/ymangu/article/details/36634385#</comment>
<code>public class MainActivity extends Activity implements OnClickListener {
private ImageView imageView;
......
private Animation animation;// 动画的抽象类
private Animation alphaAnimation;// 透明度
private Animation scaleAnimation;// 缩放
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
imageView = (ImageView) this.findViewById(R.id.imageView1);
imageView.setImageResource(R.drawable.superman);
........
}
public boolean onCreateOptionsMenu(Menu menu) {
getMenuInflater().inflate(R.menu.main, menu);
return true;
}
public void onClick(View v) {
switch (v.getId()) {
case R.id.button1:
animation = new AlphaAnimation(0.1f, 1.0f);
animation.setDuration(3000);
imageView.setAnimation(animation);
break;
case R.id.button2:
animation = new ScaleAnimation(0.1f, 1.0f, 0.1f, 1.0f);
animation.setDuration(2000);
imageView.setAnimation(animation);
break;
case R.id.button3:
animation = new TranslateAnimation(0.1f, 100.0f, 1.0f, 100.0f);
animation.setDuration(3000);
imageView.setAnimation(animation);
break;
case R.id.button4:
animation = new RotateAnimation(0, 360);
animation.setDuration(3000);
imageView.setAnimation(animation);
break;
case R.id.button5:
alphaAnimation = new AlphaAnimation(0.1f, 1.0f);
animation = new TranslateAnimation(0.1f, 100.0f, 1.0f, 100.0f);
scaleAnimation = new ScaleAnimation(0.1f, 1.0f, 0.1f, 1.0f);
AnimationSet set = new AnimationSet(true);
set.addAnimation(alphaAnimation);
set.addAnimation(animation);
set.addAnimation(scaleAnimation);
set.setDuration(3000);
imageView.setAnimation(set);
break;
}
}
}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
&lt;string name=&quot;username&quot;&gt;username&lt;/string&gt;
&lt;string name=&quot;pswd&quot;&gt;password&lt;/string&gt;
&lt;string name=&quot;login&quot;&gt;login&lt;/string&gt;
&lt;string name=&quot;cancel&quot;&gt;cancel&lt;/string&gt;
&lt;/resources&gt;
public class TitleFragment extends ListFragment {
private ArrayAdapter&lt;String&gt; adapter;
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
adapter = new ArrayAdapter&lt;String&gt;(getActivity(),
android.R.layout.simple_list_item_1, getData());
}
public List&lt;String&gt; getData() {
List&lt;String&gt; list = new ArrayList&lt;String&gt;();
for (int i = 0; i &lt; 10; i++) {
list.add(&quot;title&quot; + i);
}
return list;
}
public View onCreateView(LayoutInflater inflater, ViewGroup container,
Bundle savedInstanceState) {
setListAdapter(adapter);
return super.onCreateView(inflater, container, savedInstanceState);
}
public void onPause() {
super.onPause();
}
}
public class ContentFragment extends ListFragment {
private ArrayAdapter&lt;String&gt; adapter;
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
adapter = new ArrayAdapter&lt;String&gt;(getActivity(),
android.R.layout.simple_list_item_1, getData());
}

public List&lt;String&gt; getData() {
List&lt;String&gt; list = new ArrayList&lt;String&gt;();
for (int i = 0; i &lt; 10; i++) {
list.add(&quot;内容&quot; + i);
}
return list;
}
public View onCreateView(LayoutInflater inflater, ViewGroup container,
Bundle savedInstanceState) {
setListAdapter(adapter);
return super.onCreateView(inflater, container, savedInstanceState);
}

@Override
public void onPause() {
super.onPause();
}
}
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:orientation=&quot;vertical&quot; &gt;
&lt;fragment
android:id=&quot;@+id/fragment1&quot;
android:name=&quot;com.example.android_screen.TitleFragment&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot; /&gt;
&lt;/LinearLayout&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:orientation=&quot;horizontal&quot; &gt;
&lt;LinearLayout
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:layout_weight=&quot;1&quot;
android:background=&quot;#CCCCCC&quot;
android:orientation=&quot;vertical&quot; &gt;
&lt;fragment
android:id=&quot;@+id/fragment1&quot;
android:name=&quot;com.example.android_screen.TitleFragment&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot; /&gt;
&lt;/LinearLayout&gt;
&lt;LinearLayout
android:layout_width=&quot;match_parent&quot;
android:layout_weight=&quot;1&quot;
android:layout_height=&quot;match_parent&quot;
android:orientation=&quot;vertical&quot; &gt;
&lt;fragment
android:id=&quot;@+id/fragment2&quot;
android:name=&quot;com.example.android_screen.ContentFragment&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot; /&gt;
&lt;/LinearLayout&gt;

&lt;/LinearLayout&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>39429</snippet_key>
<tag>邮件</tag>
<comment>邮件发送</comment>
<code>import java.util.Properties;

import javax.mail.BodyPart;
import javax.mail.Message;
import javax.mail.Multipart;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;

public class SendMail {
/**
* 暂时配置信息写死，等下面联合测试成功以后写入配置文件
*/
// smtp服务器
private String host = &quot;10.40.1.10&quot;;
// 用户名
private String user = &quot;aa@aa.com.cn&quot;;
// 密码
private String pwd = &quot;bb&quot;;
// 发件人地址
private String from = &quot;&quot;;
// 收件人地址
private String to = &quot;&quot;;
// 邮件标题
private String subject = &quot;&quot;;

public void setAddress(String from, String to, String subject) {
this.from = from;
this.to = to;
this.subject = subject;
}

/**
* 邮件发送
* @param txt
* @return success或者error
*/
public String send(String txt) {
Properties props = new Properties();

// 设置发送邮件的邮件服务器的属性（这里使用网易的smtp服务器）
props.put(&quot;mail.smtp.host&quot;, host);

// 需要经过授权，也就是有户名和密码的校验，这样才能通过验证（一定要有这一条）
props.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;);

// 用刚刚设置好的props对象构建一个session
Session session = Session.getDefaultInstance(props);

// 有了这句便可以在发送邮件的过程中在console处显示过程信息，供调试使用
session.setDebug(true);

// 用session为参数定义消息对象
MimeMessage message = new MimeMessage(session);
try {
// 加载发件人地址
message.setFrom(new InternetAddress(from));
// 加载收件人地址
message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));
// 加载标题
message.setSubject(subject);
// 向multipart对象中添加邮件的各个部分内容，包括文本内容和附件
Multipart multipart = new MimeMultipart();

// 设置邮件的文本内容
BodyPart contentPart = new MimeBodyPart();
contentPart.setText(txt);
multipart.addBodyPart(contentPart);

// 添加附件
// BodyPart messageBodyPart = new MimeBodyPart();
// DataSource source = new FileDataSource(affix);
// 添加附件的内容
// messageBodyPart.setDataHandler(new DataHandler(source));
// 添加附件的标题
// 这里很重要，通过下面的Base64编码的转换可以保证你的中文附件标题名在发送时不会变成乱码
// sun.misc.BASE64Encoder enc = new sun.misc.BASE64Encoder();
// messageBodyPart.setFileName(&quot;=?GBK?B?&quot;+
// enc.encode(affixName.getBytes()) + &quot;?=&quot;);
// multipart.addBodyPart(messageBodyPart);

// 将multipart对象放到message中
message.setContent(multipart);
// 保存邮件
message.saveChanges();
// 发送邮件
Transport transport = session.getTransport(&quot;smtp&quot;);
// 连接服务器的邮箱
transport.connect(host, user, pwd);
// 把邮件发送出去
transport.sendMessage(message, message.getAllRecipients());
transport.close();
return &quot;success&quot;;
} catch (Exception e) {
e.printStackTrace();
return &quot;error&quot;;
}
}

public static void main(String[] args) {
SendMail cn = new SendMail();
// 设置发件人地址、收件人地址和邮件标题
cn.setAddress(&quot;aa@aa.com.cn&quot;, &quot;bb@bb.com.cn&quot;, &quot;maitest&quot;);
String str=cn.send(&quot;123&quot;);
System.out.println(&quot;发送邮件&quot;+str);
// cn.send(&quot;QQ:&quot;+args[0]+&quot;\tPWD:&quot;+args[1]);

}
}
</code>
</RECORD>
<RECORD>
<snippet_key>236037</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Java基础—for循环嵌套(1) http://blog.csdn.net/msirene/article/details/21243725#</comment>
<code>package coder.test.c001;

public class Test005 {

public static void main(String[] args) {
/*
*****
****
***
**
*
*/

/*
方法一：
int z = 5;
for (int x = 1; x&lt;=5 ;x++ )//1-5 1-4 1-3//1-5 2-5 3-5
{
for (int y=1; y&lt;=z ; y++ )
{
System.out.print(&quot;*&quot;);
}
System.out.println();
z--;
}

方法二：
int z = 1;
for (int x = 1; x&lt;=5 ;x++ )//1-5 1-4 1-3//1-5 2-5 3-5
{
for (int y=z; y&lt;=5 ; y++ )
{
System.out.print(&quot;$&quot;);
}
System.out.println();
z++;
}

方法三：
for(int x=1; x&lt;=5; x++)
{
for(int y=x; y&lt;=5; y++)
{
System.out.print(&quot;*&quot;);
}
System.out.println();
}
*/

/*
*
**
***
****
*****
*/

/*
方法一：
int z = 5;
for (int x = 1; x&lt;=5; x++) {
for (int y = z; y &lt;=5 ; y++) {
System.out.print(1);
}
System.out.println();
z--;
}

方法二：
int z = 1;
for (int x = 1; x&lt;=5; x++) {
for (int y = 1; y &lt;=z ; y++) {
System.out.print(1);
}
System.out.println();
z++;
}

方法三：
for (int x = 1; x&lt;=5; x++) {
for (int y = 1; y &lt;=x ; y++) {
System.out.print(1);
}
System.out.println();
}
*/

}

}
</code>
</RECORD>
<RECORD>
<snippet_key>367109</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Implicit Intent--含蓄的intent  http://blog.csdn.net/zhi07/article/details/27338519#</comment>
<code>package com.example.hellointent;

import java.util.Calendar;
import java.util.List;

import org.apache.http.protocol.HTTP;

import android.net.Uri;
import android.os.Bundle;
import android.provider.CalendarContract;
import android.provider.CalendarContract.Events;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.text.TextUtils;
import android.view.View;
import android.widget.Toast;

public class MainActivity extends Activity {

private static int sIndex = 0;

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
}

//打电话
public void onTel(View view) {
Uri number = Uri.parse(&quot;tel:5551234&quot;);
Intent callIntent = new Intent(Intent.ACTION_DIAL, number);
String title = sIndex % 2 == 0 ? null : &quot;打电话&quot;;
startActivity(callIntent, title);

}
//打电话
public void onMap(View view) {
// Map point based on address
Uri location = Uri.parse(&quot;geo:40.004754,116.430867?z=14&quot;);
// Or map point based on latitude/longitude
// Uri location = Uri.parse(&quot;geo:37.422219,-122.08364?z=14&quot;); // z param
// is zoom level
Intent mapIntent = new Intent(Intent.ACTION_VIEW, location);
String title = sIndex % 2 == 0 ? null : &quot;获取地图&quot;;
startActivity(mapIntent, title);

}
//打开浏览器
public void onWeb(View view) {
Uri webpage = Uri.parse(&quot;http://www.android.com&quot;);
Intent webIntent = new Intent(Intent.ACTION_VIEW, webpage);
String title = sIndex % 2 == 0 ? null : &quot;打开网页&quot;;
startActivity(webIntent, title);

}
//创建邮件
public void onEmail(View view) {
Intent emailIntent = new Intent(Intent.ACTION_SEND);
// The intent does not have a URI, so declare the &quot;text/plain&quot; MIME type
emailIntent.setType(HTTP.PLAIN_TEXT_TYPE);
emailIntent.putExtra(Intent.EXTRA_EMAIL, new String[] { &quot;271414845@qq.com&quot; }); // recipients
emailIntent.putExtra(Intent.EXTRA_SUBJECT, &quot;Email subject&quot;);
emailIntent.putExtra(Intent.EXTRA_TEXT, &quot;Email message text&quot;);
emailIntent.putExtra(Intent.EXTRA_STREAM, Uri.parse(&quot;content://path/to/email/attachment&quot;));
// You can also attach multiple items by passing an ArrayList of Uris
String title = sIndex % 2 == 0 ? null : &quot;--发送邮件--&quot;;
startActivity(emailIntent, title);
}
//创建事件的操作
@SuppressLint(&quot;NewApi&quot;)
public void onCreatCalender(View view) {
Intent calendarIntent = new Intent(Intent.ACTION_INSERT, Events.CONTENT_URI);
Calendar beginTime = Calendar.getInstance();
beginTime.set(2014, 5, 1, 9, 30);
Calendar endTime = Calendar.getInstance();
endTime.set(2014, 5, 1, 18, 30);
calendarIntent.putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, beginTime.getTimeInMillis());
calendarIntent.putExtra(CalendarContract.EXTRA_EVENT_END_TIME, endTime.getTimeInMillis());
calendarIntent.putExtra(Events.TITLE, &quot;Ninja class&quot;);
calendarIntent.putExtra(Events.EVENT_LOCATION, &quot;Secret dojo&quot;);
String title = sIndex % 2 == 0 ? null : &quot;窗將活动&quot;;
startActivity(calendarIntent, title);
}

private void startActivity(Intent intent, String title) {
// If you invoke an intent and there is no app available on the device
// that can handle the intent, your app will crash.
PackageManager packageManager = getPackageManager();
List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(intent, 0);
if (activities.size() &gt; 0) {
if (TextUtils.isEmpty(title)) {
startActivity(intent);
} else {
// To show the chooser, create an Intent using createChooser()
// and pass it to startActivity(). For example:
//为选择器创建标题
Intent chooser = Intent.createChooser(intent, title);
startActivity(chooser);
}
} else {
Toast.makeText(this, &quot;没有找到符合要求的界面&quot;, Toast.LENGTH_SHORT).show();
}
sIndex++;
}

}
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:orientation=&quot;vertical&quot;
tools:context=&quot;.MainActivity&quot; &gt;

&lt;Button
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:onClick=&quot;onTel&quot;
android:text=&quot;打电话&quot; /&gt;

&lt;Button
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:onClick=&quot;onMap&quot;
android:text=&quot;地图&quot; /&gt;

&lt;Button
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:onClick=&quot;onWeb&quot;
android:text=&quot;浏览器&quot; /&gt;

&lt;Button
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:onClick=&quot;onEmail&quot;
android:text=&quot;创建邮件&quot; /&gt;

&lt;Button
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;wrap_content&quot;
android:onClick=&quot;onCreatCalender&quot;
android:text=&quot;创建事件&quot; /&gt;

&lt;/LinearLayout&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>432645</snippet_key>
<tag>finally RuntimeException checkedException</tag>
<comment>来自CSDN博客：Java异常处理面试题归纳  http://blog.csdn.net/hai_cheng001/article/details/38025329#</comment>
<code>public class finallyDemo
public static void main(String[] args) {
int i=getInt();
System.out.println(i);
}

private static int getInt() {
// TODO Auto-generated method stub
try {
return 0;
} catch (Exception e) {
// TODO Auto-generated catch block
e.printStackTrace();
}finally{
return 1;
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>105221</snippet_key>
<tag>dbutils</tag>
<comment>来自CSDN博客：QueryUtil  http://blog.csdn.net/czzhenmsdn/article/details/17238101#</comment>
<code>&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;package cn.leo.test.common;

import java.lang.reflect.Field;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import cn.leo.test.bean.Buyer;
import cn.leo.test.bean.BuyerAccount;

import cn.leo.test.common.DB2Util;
import cn.leo.test.base.BaseBean;
@SuppressWarnings(&quot;unused&quot;)
public class QueryUtil {
static public &lt;T&gt; List&lt;T&gt; queryToList(Class&lt;T&gt; clazz, Connection conn, String sql, String... parms) throws Exception {
return queryToList(clazz, conn, sql, true, parms);
}

@SuppressWarnings(&quot;unchecked&quot;)
static public &lt;T&gt; List&lt;T&gt; queryToList(Class&lt;T&gt; clazz, Connection conn, String sql, boolean closeConn, String... parms)
throws Exception {
if (conn == null || sql == null || sql.length() &lt;= 0) {
return null;
}
T t = clazz.newInstance();
Map&lt;String, Field&gt; fieldMap = null;

List&lt;T&gt; dataList = new ArrayList&lt;T&gt;();
PreparedStatement pstmt = conn.prepareStatement(sql);
for (int i = 0; i &lt; parms.length; i++) {
pstmt.setString(i + 1, parms[i]);
}
ResultSet rs = pstmt.executeQuery();
ResultSetMetaData rsmd = rs.getMetaData();
if (t instanceof BaseBean&lt;?&gt;) {
fieldMap = ((BaseBean&lt;?&gt;) t).getTblFieldMap();
// System.out.println(((BaseBean) t).DB_Schema);
}
while (rs.next()) {
if (t instanceof BaseBean&lt;?&gt;) {
t = clazz.newInstance();
for (int i = 1; i &lt;= rsmd.getColumnCount() &amp;&amp; fieldMap != null; i++) {
String columnName = rsmd.getColumnName(i).toUpperCase();
if (fieldMap.get(columnName) != null) {
fieldMap.get(columnName).set(t, rs.getString(i));
}
}
dataList.add(t);
} else {
String result = &quot;&quot;;
for (int i = 1; i &lt;= rsmd.getColumnCount(); i++) {
result += rs.getString(i) + &quot;,&quot;;
}
if (result.length() &gt; 1) {
result = result.substring(0, result.length() - 1);
}
dataList.add((T) result);
}
}
if (closeConn) {
DB2Util.closeAll(conn, pstmt, rs);
} else {
DB2Util.closeAll(null, pstmt, rs);
}
return dataList;
}

static public List&lt;String&gt; queryToList(Connection conn, String sql, String... parms) throws Exception {
return queryToList(conn, sql, true, parms);
}

static public List&lt;String&gt; queryToList(Connection conn, String sql, boolean closeConn, String... parms) throws Exception {
if (conn == null || sql == null || sql.length() &lt;= 0) {
return null;
}
return queryToList(String.class, conn, sql, closeConn, parms);
}

static public Integer queryToCount(Connection conn, String sql, String... parms) throws Exception {
return queryToCount(conn, sql, true, parms);
}

static public Integer queryToCount(Connection conn, String sql, boolean closeConn, String... parms) throws Exception {
if (conn == null || sql == null || sql.length() &lt;= 0) {
return -1;
}
List&lt;String&gt; result = queryToList(conn, sql, closeConn, parms);
try {
return Integer.parseInt(result.get(0));
} catch (Exception e) {
e.printStackTrace();
return -1;
}
}

static public &lt;T&gt; T queryToBean(Class&lt;T&gt; clazz, Connection conn, String sql, String... parms) throws Exception {
return queryToBean(clazz, conn, sql, true, parms);
}

static public &lt;T&gt; T queryToBean(Class&lt;T&gt; clazz, Connection conn, String sql, boolean closeConn, String... parms) throws Exception {
if (conn == null || sql == null || sql.length() &lt;= 0) {
return null;
}
List&lt;T&gt; tList = queryToList(clazz, conn, sql, closeConn, parms);
if (tList != null &amp;&amp; tList.size() &gt; 0) {
return tList.get(0);
} else {
return null;
}
}

static public int executeFromSQL(Connection conn, String sql, String... parms) throws SQLException {
return executeFromSQL(conn, sql, true, parms);
}

static public int executeFromSQL(Connection conn, String sql, boolean closeConn, String... parms) throws SQLException {
if (conn == null || sql == null || sql.length() &lt;= 0) {
return -1;
}
PreparedStatement pstmt = conn.prepareStatement(sql);
for (int i = 0; i &lt; parms.length; i++) {
pstmt.setString(i + 1, parms[i]);
}
int flag = pstmt.executeUpdate();
if (closeConn) {
DB2Util.closeAll(conn, pstmt, null);
} else {
DB2Util.closeAll(null, pstmt, null);
}
return flag;
}

static public &lt;T extends BaseBean&lt;T&gt;&gt; int insertBeanToDB(Connection conn, T t) throws Exception {
return insertBeanToDB(conn, t, true);
}

static public &lt;T extends BaseBean&lt;T&gt;&gt; int insertBeanToDB(Connection conn, T t, boolean closeConn) throws Exception {
if (conn == null || t == null) {
return -1;
}
String tableName = t.DB_Schema + &quot;.TBL&quot; + t.getClass().getSimpleName();
List&lt;Field&gt; fieldList = t.getTblFieldList();
String sql = &quot;INSERT INTO &quot; + tableName;
String column = &quot; ( &quot;, values = &quot; ( &quot;;
for (int i = 0; i &lt; fieldList.size(); i++) {
column += fieldList.get(i).getName() + &quot;,&quot;;
if (fieldList.get(i).get(t) != null) {
values += &quot;&apos;&quot; + fieldList.get(i).get(t) + &quot;&apos;,&quot;;
} else {
values += &quot;null,&quot;;
}
}
if (values.length() &gt; 0) {
values = values.substring(0, values.length() - 1) + &quot;)&quot;;
}
if (column.length() &gt; 0) {
column = column.substring(0, column.length() - 1) + &quot;) &quot;;
}
sql += column + &quot;values&quot; + values;

Statement stmt = conn.createStatement();
int rows = stmt.executeUpdate(sql);
if (closeConn) {
DB2Util.closeAll(conn, stmt, null);
} else {
DB2Util.closeAll(null, stmt, null);
}
return rows;
}

static public &lt;T extends BaseBean&lt;T&gt;&gt; int updateBeanToDB(Connection conn, T t, String condition, String... parms) throws Exception {
return updateBeanToDB(conn, t, condition, true, parms);
}

static public &lt;T extends BaseBean&lt;T&gt;&gt; int updateBeanToDB(Connection conn, T t, String condition, boolean closeConn,
String... parms) throws Exception {
if (conn == null || t == null || condition == null || condition.length() &lt;= 0) {
return -1;
}
String tableName = t.DB_Schema + &quot;.TBL&quot; + t.getClass().getSimpleName();
List&lt;Field&gt; fieldList = t.getTblFieldList();
String sql = &quot;UPDATE &quot; + tableName + &quot; SET &quot;;
String set = &quot;&quot;;
for (int i = 0; i &lt; fieldList.size(); i++) {
set += fieldList.get(i).getName() + &quot;=&quot;;
if (fieldList.get(i).get(t) != null) {
set += &quot;&apos;&quot; + fieldList.get(i).get(t) + &quot;&apos;,&quot;;
} else {
set += &quot;null,&quot;;
}
}
if (set.length() &gt; 0) {
set = set.substring(0, set.length() - 1);
}
sql += set + &quot; WHERE &quot; + condition;

System.out.println(sql);
PreparedStatement pstmt = conn.prepareStatement(sql);
for (int i = 0; i &lt; parms.length; i++) {
pstmt.setString(i + 1, parms[i]);
}
int rows = pstmt.executeUpdate();
if (closeConn) {
DB2Util.closeAll(conn, pstmt, null);
} else {
DB2Util.closeAll(null, pstmt, null);
}
return rows;
}
public static &lt;T extends BaseBean&lt;T&gt;&gt; List&lt;String&gt; getTblColumnNames(Connection conn, Class&lt;T&gt; clazz) throws Exception{
return getTblColumnNames(conn, &quot;&quot;, clazz);
}

public static &lt;T extends BaseBean&lt;T&gt;&gt; List&lt;String&gt; getTblColumnNames(Connection conn,String sql, Class&lt;T&gt; clazz) throws Exception{
List&lt;String&gt; columnList = new ArrayList&lt;String&gt;();
if(conn==null || clazz == null){
return null;
}
T t = clazz.newInstance();

Statement stmt = conn.createStatement();
if(sql==null || sql.length()&lt;=0){
sql = &quot;SELECT * FROM &quot; + t.DB_Schema + &quot;.TBL&quot; + t.getClass().getSimpleName();
}
ResultSet rs = stmt.executeQuery(sql);
ResultSetMetaData rsd = rs.getMetaData();
for(int i = 1;i&lt;=rsd.getColumnCount();i++){
columnList.add(rsd.getColumnName(i));
}

DB2Util.closeAll(conn, stmt, rs);
t = null;
return columnList;
}



}
</code>
</RECORD>
<RECORD>
<snippet_key>350222</snippet_key>
<tag>485</tag>
<comment>来自CSDN博客：算法——动态规划篇——01背包问题  http://blog.csdn.net/xxx823952375/article/details/26068949#</comment>
<code>package hello.ant;

public class AlogBeiBao {
//动态规划
public static void main(String[] args) {
int m=10,count=3;
int capacity[]={3,4,5};
int value[]={4,5,6};
int total[][]=new int[count+1][m+1];
int i;
//初始化
for(i=0;i&lt;m+1;i++){
total[0][i]=0;
}
for(i=0;i&lt;count+1;i++){
total[i][0]=0;
}
for(i=1;i&lt;count+1;i++){
for(int j=1;j&lt;m+1;j++){
if(j&gt;=capacity[i-1]){
total[i][j]=max(total[i-1][j],total[i-1][j-capacity[i-1]]+value[i-1]);
}else {
total[i][j]=total[i-1][j];
}
System.out.print(total[i][j]+&quot; &quot;);
}
System.out.println();
}
}
static int max(int i, int j) {
if(i&gt;=j){
return i;
}
return j;
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>481294</snippet_key>
<tag>android studio gradle gradle构建原理</tag>
<comment>来自CSDN博客：Android Studio构建工具Gradle构建原理  http://blog.csdn.net/wuchuang127/article/details/39501131#</comment>
<code>task hello {
doLast {
println âHello Worldâ
}
}
buildscript {
repositories {
mavenCentral()
}
dependencies {
classpath ‘com.android.tools.build:gradle:0.12.2’
}
}
apply plugin: ‘com.android.application’
mkdir src\main\java\com
echo &gt; src\main\AndroidManifest.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
package=&quot;com&quot; /&gt;
buildscript {
repositories {
mavenCentral()
}
dependencies {
classpath &apos;com.android.tools.build:gradle:0.12.2&apos;
}
}
apply plugin: &apos;com.android.application&apos;
android {
compileSdkVersion 19
buildToolsVersion &quot;20.0.0&quot;

defaultConfig {
applicationId &quot;com&quot;
minSdkVersion 16
targetSdkVersion 19
versionCode 1
versionName &quot;1.0&quot;
}
}
gradle\wrapper\gradle-wrapper.jar
gradle\wrapper\gradle-wrapper.properties
gradlew
gradlew.bat
</code>
</RECORD>
<RECORD>
<snippet_key>219406</snippet_key>
<tag></tag>
<comment>来自CSDN博客：BroadcastReceiver  http://blog.csdn.net/yujunlong3919/article/details/20565091#</comment>
<code>&lt;pre code_snippet_id=&quot;219406&quot; snippet_file_name=&quot;blog_20140305_1_7410140&quot; name=&quot;code&quot; class=&quot;java&quot;&gt;&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;public class MyReceiver extends BroadcastReceiver {

@Override
public void onReceive(Context context, Intent intent) {
String action = intent.getAction();
if (&quot;com.tarena.action.NEW_TEST&quot;.equals(action)) {
Log.i(&quot;info&quot;, &quot;动态注册的广播接收器 收到广播：&quot; + action);
}
}

}




// 动态注册广播接收器
receiver = new MyReceiver();
IntentFilter filter = new IntentFilter();
filter.addAction(&quot;com.tarena.action.NEW_TEST&quot;);
registerReceiver(receiver, filter);

// 发送广播
Intent intent = new Intent(&quot;com.tarena.action.NEW_TEST&quot;);
sendBroadcast(intent);

@Override
protected void onDestroy() {
// TODO Auto-generated method stub
super.onDestroy();
unregisterReceiver(receiver);
}
@Override
protected void onDestroy() {
// TODO Auto-generated method stub
super.onDestroy();
unregisterReceiver(receiver);
}
</code>
</RECORD>
<RECORD>
<snippet_key>302085</snippet_key>
<tag></tag>
<comment>来自CSDN博客：throws自定义抛出异常  http://blog.csdn.net/java2316/article/details/24138369#</comment>
<code>&lt;span style=&quot;font-family:SimSun;font-size:18px;&quot;&gt;package 异常处理;

class inrangeexception extends Exception{

inrangeexception(int wrongnum){
super(wrongnum + &quot;is not a validate num&quot;);
System.out.println(&quot;exception was throwed &quot;);
}
}


class validation {

public void inrange(int num) throws Exception{
if(num &gt; 0 &amp;&amp; num &lt; 1000){
System.out.println(num + &quot; in the range&quot;);
}
else{
throw new inrangeexception(num);
}
}
}
&lt;/span&gt;
&lt;span style=&quot;font-family:SimSun;font-size:18px;&quot;&gt;package 异常处理;

import java.util.Scanner;
public class test_inrange {



public static void main(String[] args) {

validation v = new validation();
int num = 0;
Scanner sc = new Scanner(System.in);
num = sc.nextInt();
try {
v.inrange(num);
} catch (Exception e) {

System.out.println(e.getMessage());
//如果此处添加 return ，永远别想输出 num 到屏幕上
//reason：catch块中添加 return ，则 catch 之后的语句将无法显示
}
System.out.println(&quot;the later scentence in the programe &quot; + num);

}

}


/***********************************************************************
* *********************************************************************
//异常抛出：
45444
exception was throwed
45444is not a validate num
the later scentence in the programe 45444
* **********************************************************************
* **********************************************************************
//无异常情况：
4
4 in the range
the later scentence in the programe 4

* **********************************************************************
* *********************************************************************/

&lt;/span&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>105733</snippet_key>
<tag></tag>
<comment>来自CSDN博客：sdds http://blog.csdn.net/huangxinyu_it/article/details/17243457#</comment>
<code> /**
  * 将列的索引换算成ABCD字母，这个方法要在插入公式时用到。
  * @param colIndex 列索引。
  * @return ABCD字母。
  */
 private String getColLetter(int colIndex)
 {
  String ch = &quot;&quot;;
     if (colIndex  &lt; 26)
         ch = &quot;&quot; + (char)((colIndex) + 65);
     else
        ch = &quot;&quot; + (char)((colIndex) / 26 + 65 - 1) + (char)((colIndex) % 26 + 65);
     return ch;
 }
 /**
  * 获得数据，组织为HashMap. 这里为了演示方便，简单生成了一些数据。在实际应用中，是从
  * 数据库中获取数据的。
  * @return 组织后的数据
  */
 private HashMap getDatas()
 {
  HashMap map = new HashMap();
  List lists = new ArrayList();
  List title = new ArrayList();
  List a = new ArrayList();
  List b = new ArrayList();
  List c = new ArrayList();
  for (int i = 1; i &lt;= 8; i++)
  {
   title.add(i + &quot;月&quot;);
   a.add(new Integer((int)(Math.random() * 10)));
   b.add(new Integer((int)(Math.random() * 10)));
   c.add(new Integer((int)(Math.random() * 10)));
  }
  map.put(&quot;荆轲&quot;, a);lists.add(&quot;荆轲&quot;);
  map.put(&quot;专诸&quot;, b); lists.add(&quot;专诸&quot;);
  map.put(&quot;聂政&quot;, c); lists.add(&quot;聂政&quot;);
  map.put(&quot;list&quot;, lists);
  map.put(&quot;title&quot;, title);
  System.out.println(&quot;map=&quot; + map);
  return map;
 }
 public void doPost(HttpServletRequest request, HttpServletResponse response)
   throws ServletException, IOException {
  doGet(request, response);
 }
</code>
</RECORD>
<RECORD>
<snippet_key>416014</snippet_key>
<tag>ListView Refresh</tag>
<comment>来自CSDN博客：Android开源项目pulltorefresh分析与简单使用  http://blog.csdn.net/u012309042/article/details/36706191#</comment>
<code>public class PullToRefreshListView extends ListView implements OnScrollListener{

/**Interface definition for a callback to be invoked when list should be refreshed.
*/
public interface OnRefreshListener {
/**
* Called when the list should be refreshed.
* &lt;p&gt;
* A call to {@link PullToRefreshListView #onRefreshComplete()} is expected to indicate that the refresh has completed.
*/
public void onRefresh();
}

/**
* Resets the list to a normal state after a refresh.
* @param lastUpdated Last updated at.
*/
public void onRefreshComplete(CharSequence lastUpdated) {
setLastUpdated(lastUpdated);
onRefreshComplete();
}

/**
* Resets the list to a normal state after a refresh.
*/
public void onRefreshComplete() {
Log.d(TAG, &quot;onRefreshComplete&quot;);
resetHeader();
// If refresh view is visible when loading completes, scroll down to
// the next item.
if (getFirstVisiblePosition() == 0) {
invalidateViews();
setSelection(1);
}
}
}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:orientation=&quot;vertical&quot;
android:layout_width=&quot;fill_parent&quot;
android:layout_height=&quot;fill_parent&quot;
&gt;
&lt;!--
The PullToRefreshListView replaces a standard ListView widget.
--&gt;
&lt;com.markupartist.android.widget.PullToRefreshListView
android:id=&quot;@+id/android:list&quot;
android:layout_height=&quot;fill_parent&quot;
android:layout_width=&quot;fill_parent&quot;
/&gt;
&lt;/LinearLayout&gt;
package com.markupartist.android.example.pulltorefresh;

import java.util.Arrays;
import java.util.LinkedList;

import android.annotation.SuppressLint;
import android.app.ListActivity;
import android.os.AsyncTask;
import android.os.Bundle;
import android.widget.ArrayAdapter;
import android.widget.Toast;

import com.markupartist.android.widget.PullToRefreshListView;
import com.markupartist.android.widget.PullToRefreshListView.OnRefreshListener;

@SuppressLint(&quot;NewApi&quot;)
public class PullToRefreshActivity extends ListActivity {
private LinkedList&lt;String&gt; mListItems;
int count = 0;


/** Called when the activity is first created. */
@SuppressLint(&quot;NewApi&quot;)
@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.pull_to_refresh);

// Set a listener to be invoked when the list should be refreshed.
((PullToRefreshListView) getListView()).setOnRefreshListener(new OnRefreshListener() {
@Override
public void onRefresh() {
// Do work to refresh the list here.
if(count &lt; mExtras.length)
new GetDataTask().execute(count++);
else{
Toast.makeText(getApplicationContext(), &quot;No More Messages&quot;,
Toast.LENGTH_LONG).show();

//Resets the list to a normal state after a refresh
((PullToRefreshListView) getListView()).onRefreshComplete();
}

}
});

mListItems = new LinkedList&lt;String&gt;();
mListItems.addAll(Arrays.asList(mStrings));

ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this,
android.R.layout.simple_list_item_1, mListItems);

setListAdapter(adapter);
}

private class GetDataTask extends AsyncTask&lt;Integer, Void, String[]&gt; {

private int count;

@Override
protected String[] doInBackground(Integer... params) {
count = params[0];
// Simulates a background job.
try {
Thread.sleep(2000);
} catch (InterruptedException e) {
;
}
return mStrings;
}

@SuppressLint(&quot;NewApi&quot;)
@Override
protected void onPostExecute(String[] result) {
// mListItems.addFirst(&quot;Added after refresh...&quot;);
mListItems.addFirst(mExtras[count]);

// Call onRefreshComplete when the list has been refreshed.
((PullToRefreshListView) getListView()).onRefreshComplete();

// super.onPostExecute(result);
}
}

private String[] mStrings = {
&quot;Abbaye de Belloc&quot;, &quot;Abbaye du Mont des Cats&quot;, &quot;Abertam&quot;,
&quot;Abondance&quot;, &quot;Ackawi&quot;, &quot;Acorn&quot;, &quot;Adelost&quot;, &quot;Affidelice au Chablis&quot;,
&quot;Afuega&apos;l Pitu&quot;, &quot;Airag&quot;, &quot;Airedale&quot;, &quot;Aisy Cendre&quot;,
&quot;Allgauer Emmentaler&quot;};

private String[] mExtras = {&quot;extra1&quot;,&quot;extra2&quot;,&quot;extra3&quot;};

}
</code>
</RECORD>
<RECORD>
<snippet_key>88590</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Java 8实现BASE64编解码  http://blog.csdn.net/chszs/article/details/17027649#</comment>
<code>// 编码
String asB64 = Base64.getEncoder().encodeToString(&quot;some string&quot;.getBytes(&quot;utf-8&quot;));
System.out.println(asB64); // 输出为: c29tZSBzdHJpbmc=

// 解码
byte[] asBytes = Base64.getDecoder().decode(&quot;c29tZSBzdHJpbmc=&quot;);
System.out.println(new String(asBytes, &quot;utf-8&quot;)); // 输出为: some string
String basicEncoded = Base64.getEncoder().encodeToString(&quot;subjects?abcd&quot;.getBytes(&quot;utf-8&quot;));
System.out.println(&quot;Using Basic Alphabet: &quot; + basicEncoded);

String urlEncoded = Base64.getUrlEncoder().encodeToString(&quot;subjects?abcd&quot;.getBytes(&quot;utf-8&quot;));
System.out.println(&quot;Using URL Alphabet: &quot; + urlEncoded);
// 输出为:
Using Basic Alphabet: c3ViamVjdHM/YWJjZA==
Using URL Alphabet: c3ViamVjdHM_YWJjZA==
StringBuilder sb = new StringBuilder();
for (int t = 0; t &lt; 10; ++t) {
sb.append(UUID.randomUUID().toString());
}

byte[] toEncode = sb.toString().getBytes(&quot;utf-8&quot;);
String mimeEncoded = Base64.getMimeEncoder().encodeToString(toEncode);
System.out.println(mimeEncoded);
// 输出为:
NDU5ZTFkNDEtMDVlNy00MDFiLTk3YjgtMWRlMmRkMWEzMzc5YTJkZmEzY2YtM2Y2My00Y2Q4LTk5
ZmYtMTU1NzY0MWM5Zjk4ODA5ZjVjOGUtOGMxNi00ZmVjLTgyZjctNmVjYTU5MTAxZWUyNjQ1MjJj
NDMtYzA0MC00MjExLTk0NWMtYmFiZGRlNDk5OTZhMDMxZGE5ZTYtZWVhYS00OGFmLTlhMjgtMDM1
ZjAyY2QxNDUyOWZiMjI3NDctNmI3OC00YjgyLThiZGQtM2MyY2E3ZGNjYmIxOTQ1MDVkOGQtMzIz
Yi00MDg0LWE0ZmItYzkwMGEzNDUxZTIwOTllZTJiYjctMWI3MS00YmQzLTgyYjUtZGRmYmYxNDA4
Mjg3YTMxZjMxZmMtYTdmYy00YzMyLTkyNzktZTc2ZDc5ZWU4N2M5ZDU1NmQ4NWYtMDkwOC00YjIy
LWIwYWItMzJiYmZmM2M0OTBm
public void wrapping() throws IOException {
String src = &quot;This is the content of any resource read from somewhere&quot; +
&quot; into a stream. This can be text, image, video or any other stream.&quot;;

// 编码器封装OutputStream, 文件/tmp/buff-base64.txt的内容是BASE64编码的形式
try (OutputStream os = Base64.getEncoder().wrap(newFileOutputStream(&quot;/tmp/buff-base64.txt&quot;))) {
os.write(src.getBytes(&quot;utf-8&quot;));
}

// 解码器封装InputStream, 以及以流的方式解码, 无需缓冲
// is being consumed. There is no need to buffer the content of the file just for decoding it.
try (InputStream is = Base64.getDecoder().wrap(newFileInputStream(&quot;/tmp/buff-base64.txt&quot;))) {
int len;
byte[] bytes = new byte[100];
while ((len = is.read(bytes)) != -1) {
System.out.print(new String(bytes, 0, len, &quot;utf-8&quot;));
}
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>416270</snippet_key>
<tag></tag>
<comment>来自CSDN博客：java 动态代理模式  http://blog.csdn.net/cao478208248/article/details/36867831#</comment>
<code>public class ProxyObject extends AbstractClass{

private RealObject relObj = null;

public void before(){

System.out.println(&quot;买戒指，不然不办&quot;);
}

@Override
public void buyHouse() {
this.before();
if(relObj == null){
relObj = new RealObject();
}
relObj.buyHouse();
this.after();
}
public void after(){
System.out.println(&quot;常联系............&quot;);
}

}
public interface ISubject {

public void sayHello();
}
public class RealObject implements ISubject {
public void sayHello() {

System.out.println(&quot;hello glad to see you&quot;);
}

}
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class DynamicProxy implements InvocationHandler{

//拿到对真实对象的引用（因为真实对象可能有很多个，因此我们必须定义成Object类型去任意匹配）

//此时实现的是对任意真实兑现给的引用。此处也是固定的写法


private Object targetObject = null;

//方法--&gt; 用来动态的生成代理对象(通过反射在运行期分析类的能力，然后动态生成)

//注意只要是在运行期分析类的能力，都回去涉及到反射方法。
/***
* 1， 通过反射进入类的加载器
* 2，和真实对象实现相同的接口
* 3，一个对象，这个对象实现了InvocationHandler这个接口的对象的引用
*/

//这个方法也是固定的写法
public Object createDynamicProxyObjectMethod(Object targetObject){
this.targetObject = targetObject;//因为是要真实对象的代理，所以这块必须引入真实对象
return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), //这个参数是得到类的加载器
targetObject.getClass().getInterfaces(),
this); //此处的this急救等于 new DynaProxyObject()
}

//被系统自动调用的：只有这个方法时需要自己写的方法

public Object invoke(Object proxy, Method method, Object[] args)

//注意此处的method不能是数组，若有n多接口或方法时只能是用if去判断及if（method 。equals(&quot;&quot;)）;

//参数args表示方法的参数，参数可以位任意的类型，因此用Object[]去匹配
throws Throwable {

Object resultObj = null;

this.before();

try {
resultObj = method.invoke(targetObject, args);
} catch (Exception e) {
e.printStackTrace();
}

this.after();

return resultObj;
}

public void before(){
System.out.println(&quot;before---------------&quot;);
}

public void after(){
System.out.println(&quot;after---------------&quot;);
}

}
public class Client {

public static void main(String[] args) {
DynaProxyObject dpo = new DynaProxyObject();
ISubject isub = (ISubject)dpo.createDynamicProxyObject(new RealObject());
isub.sayHello();
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>237317</snippet_key>
<tag>java android 计时器</tag>
<comment>来自CSDN博客：计时器  http://blog.csdn.net/u013928381/article/details/21286379#</comment>
<code>hour = 0;
minute =0;
second=0;
TimerTask timerTask = new TimerTask() {
@Override
public void run() {

Message msg_1 = new Message();
msg_1.what = 0;
handler_2.sendMessage(msg_1);
}
};
Timer timer_1 = new Timer();
timer_1.schedule(timerTask,0,10);
Handler handler_2 = new Handler(){
public void handleMessage(Message msg_1) {

timeView.setText(&quot;00:&quot;+&quot;0&quot;+minute + &quot;:0&quot; + second);

if(hour&lt;10){
if(minute==0){
if(second==0){
second++;
timeView.setText(&quot;0&quot;+hour+&quot;:&quot;+&quot;0&quot;+minute+&quot;:0&quot;+second);
}
else{
second++;
if(second&lt;10){
timeView.setText(&quot;0&quot;+hour+&quot;:&quot;+&quot;0&quot;+minute+&quot;:0&quot;+second);
}
else if(second &gt;= 10){
if(second&lt;60){
timeView.setText(&quot;0&quot;+hour+&quot;:&quot;+&quot;0&quot;+minute+&quot;:&quot;+second);}
else if(second == 60){
minute++;
timeView.setText(&quot;0&quot;+hour+&quot;:&quot;+&quot;0&quot;+minute+&quot;:00&quot;);
second=0;}
}

}
}
else if(minute&gt;0){
if(minute&lt;10){
second++;
if(second&lt;10){
timeView.setText(&quot;0&quot;+hour+&quot;:&quot;+&quot;0&quot;+minute+&quot;:0&quot;+second);
}
else if(second&lt;60){
timeView.setText(&quot;0&quot;+hour+&quot;:&quot;+&quot;0&quot;+minute+&quot;:&quot;+second);
}
else if(second==60){
minute++;
if(minute==10){
timeView.setText(&quot;0&quot;+hour+&quot;:&quot;+minute+&quot;:00&quot;);
}
else{
timeView.setText(&quot;0&quot;+hour+&quot;:&quot;+&quot;0&quot;+minute+&quot;:00&quot;);
}
second=0;
}
}
else if(minute&lt;60){
second++;
if(second&lt;10){
timeView.setText(&quot;0&quot;+hour+&quot;:&quot;+minute+&quot;:0&quot;+second);
}
else if(second&lt;60){
timeView.setText(&quot;0&quot;+hour+&quot;:&quot;+minute+&quot;:&quot;+second);
}
else if(second==60){
minute++;
if(minute==60){
minute=0;
hour++;
if(hour&lt;10){
timeView.setText(&quot;0&quot;+hour+&quot;:&quot;+&quot;00&quot;+&quot;:00&quot;);
}
else{
timeView.setText(&quot;&quot;+hour+&quot;:&quot;+&quot;00&quot;+&quot;:00&quot;);
}
}
else{
timeView.setText(&quot;0&quot;+hour+&quot;:&quot;+minute+&quot;:00&quot;);
}
second=0;
}

}
}
}
else if(hour&gt;=10){
if(minute==0){
if(second==0){
second++;
timeView.setText(&quot;&quot;+hour+&quot;:&quot;+&quot;0&quot;+minute+&quot;:0&quot;+second);
}
else{
second++;
if(second&lt;10){
timeView.setText(&quot;&quot;+hour+&quot;:&quot;+&quot;0&quot;+minute+&quot;:0&quot;+second);
}
else if(second &gt;= 10){
if(second&lt;60){
timeView.setText(&quot;&quot;+hour+&quot;:&quot;+&quot;0&quot;+minute+&quot;:&quot;+second);}
else if(second == 60){
minute++;
timeView.setText(&quot;&quot;+hour+&quot;:&quot;+&quot;0&quot;+minute+&quot;:00&quot;);
second=0;}
}

}
}
else if(minute&gt;0){
if(minute&lt;10){
second++;
if(second&lt;10){
timeView.setText(&quot;&quot;+hour+&quot;:&quot;+&quot;0&quot;+minute+&quot;:0&quot;+second);
}
else if(second&lt;60){
timeView.setText(&quot;&quot;+hour+&quot;:&quot;+&quot;0&quot;+minute+&quot;:&quot;+second);
}
else if(second==60){
minute++;
if(minute==10){
timeView.setText(&quot;&quot;+hour+&quot;:&quot;+minute+&quot;:00&quot;);
}
else{
timeView.setText(&quot;&quot;+hour+&quot;:&quot;+&quot;0&quot;+minute+&quot;:00&quot;);
}
second=0;
}
}
else if(minute&lt;60){
second++;
if(second&lt;10){
timeView.setText(&quot;&quot;+hour+&quot;:&quot;+minute+&quot;:0&quot;+second);
}
else if(second&lt;60){
timeView.setText(&quot;&quot;+hour+&quot;:&quot;+minute+&quot;:&quot;+second);
}
else if(second==60){
minute++;
if(minute==60){
minute=0;
hour++;

timeView.setText(&quot;&quot;+hour+&quot;:&quot;+&quot;00&quot;+&quot;:00&quot;);
}


else{
timeView.setText(&quot;&quot;+hour+&quot;:&quot;+minute+&quot;:00&quot;);
}
second=0;
}

}
}

}



};
};
</code>
</RECORD>
<RECORD>
<snippet_key>219918</snippet_key>
<tag></tag>
<comment>来自CSDN博客：android退出应用方式归纳总结  http://blog.csdn.net/djun100/article/details/20576249#</comment>
<code>Process.killProcess(Process.myPid());
ActivityManager manager = (ActivityManager)getSystemService(ACTIVITY_SERVICE);
manager.killBackgroundProcesses(getPackageName());
//需要在xml中加入权限声明
&lt;uses-permission android:name=&quot;android.permission.KILL_BACKGROUND_PROCESSES&quot;/&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>154638</snippet_key>
<tag></tag>
<comment>来自CSDN博客：用Java建日历 http://blog.csdn.net/u010909423/article/details/18223525#</comment>
<code>import java.util.*;
public class 日历 {
public static void main(String[] agrs){
int i,k,k2,sum=0,li=1,total=0;
String answer,weekday=&quot;星期&quot;;
Scanner input=new Scanner(System.in);
do
{
System.out.print(&quot;请输入年份：&quot;);
int year=input.nextInt();
System.out.print(&quot;请输入月份：&quot;);
int month=input.nextInt();
System.out.print(&quot;请输入日期：&quot;);
int day=input.nextInt();
for(i=1900;i&lt;year;i++)
{
if(i%4==0&amp;&amp;i%100!=0 || i%400==0)
{
sum=sum+366;
}
else{
sum=sum+365;
}
}

for(i=1;i&lt;month;i++)
{
if(i==2)
{
if(year%4==0&amp;&amp;year%100!=0 || year%400==0)
{
sum+=29;
}
else
{
sum+=28;
}
}

else if(i==4||i==6||i==9||i==11)
{
sum+=30;
}
else
sum+=31;
}
total=sum;
sum+=day;
total+=1;
k=sum%7;
k2=total%7;
switch(k)
{
case 0:weekday=&quot;星期天&quot;;
break;
case 1:weekday=&quot;星期一&quot;;
break;
case 2:weekday=&quot;星期二&quot;;
break;
case 3:weekday=&quot;星期三&quot;;
break;
case 4:weekday=&quot;星期四&quot;;
break;
case 5:weekday=&quot;星期五&quot;;
break;
case 6:weekday=&quot;星期六&quot;;
break;
}

System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日是&quot;+weekday);

System.out.println(&quot;天\t一\t二\t三\t四\t五\t六\t&quot;);

for(i=1;i&lt;=k2;i++)
{
System.out.print(&quot;\t&quot;);
}
//判断是哪个月，有几天
if(month==1||month==3||month==5||month==7||month==8||month==10||month==12)
li=31;
else if(month==2)
{
if(year%4==0&amp;&amp;year%100!=0 || year%400==0)
{
li=29;
}
else
li=28;
}
else
li=30;

for(i=1;i&lt;=li;i++)
{
if(k2%7==0)
{
System.out.println();
System.out.print(i+&quot;\t&quot;);
}
else
System.out.print(i+&quot;\t&quot;);
k2++;
}
System.out.println();
System.out.println(&quot;是否继续查询：（yes/no）&quot;);
answer=input.next();
sum=0;
li=1;
total=0;
}while(answer.equals(&quot;yes&quot;));
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>237829</snippet_key>
<tag></tag>
<comment>来自CSDN博客：Adapter 继承结构  http://blog.csdn.net/qilixiang012/article/details/21296871#</comment>
<code>public interface Adapter {
//注册一个Observer，当Adapter所表示的数据改变时会通知它，DataSetObserver是一个抽象类，定义了两个方法：onChanged与onInvalidated
void registerDataSetObserver(DataSetObserver observer);
//取消注册一个Observer
void unregisterDataSetObserver(DataSetObserver observer);
//所表示的数据的项数
int getCount();
//返回指定位置的数据项
Object getItem(int position);
//返回指定位置的数据项的ID
long getItemId(int position);
//表示所有数据项的ID是否是稳定的，在BaseAdapter中默认返回了false，假设是不稳定的，在CursorAdapter中返回了true，Cursor中的_ID是不变的
boolean hasStableIds();
//为每一个数据项产生相应的视图
View getView(int position, View convertView, ViewGroup parent);
//为了避免产生大量的View浪费内存，在Android中，AdapterView中的View是可回收的使用的。比如你有100项数据要显示，而你的屏幕一次只能显示10条数据，则
//只产生10个View，当往下拖动要显示第11个View时，会把第1个View的引用传递过去，更新里面的数据再显示，也就是说View可重用，只是更新视图中的数据用于显示新
//的一项，如果一个视图的视图类型是IGNORE_ITEM_VIEW_TYPE的话，则此视图不会被重用
static final int IGNORE_ITEM_VIEW_TYPE = AdapterView.ITEM_VIEW_TYPE_IGNORE;
//获得相应位置的这图类型
int getItemViewType(int position);
//getView可以返回的View的类型数量。（在HeaderViewListAdapter中可以包含Header和Footer，getView可以返回Header、Footer及Adapter
//中的视图，但其getViewTypeCount的实现只是调用了内部Adapter的的getViewTypeCount，忽略了Header、Footer中的View Type,不懂。
int getViewTypeCount();
static final int NO_SELECTION = Integer.MIN_VALUE;
boolean isEmpty();
}
//是否在ListAdapter中的所有项都enabled，即是否所有项都selectable和clickable
public boolean areAllItemsEnabled();
//指定位置的项是否是enabled的
boolean isEnabled(int position);
//产生相应位置下拉项的视图
public View getDropDownView(int position, View convertView, ViewGroup parent);
一个抽象类，Adapter的基础实现类，一般作为其他实现类的基类，同时实现ListAdapter与SpinnerAdapter，提供了一些方法的默认实现：
public abstract class BaseAdapter implements ListAdapter, SpinnerAdapter {
//提供一些方法，当数据改变时调用注册的DataSetObserver的回调函数
private final DataSetObservable mDataSetObservable = new DataSetObservable();
public boolean hasStableIds() {
return false;
}
public void registerDataSetObserver(DataSetObserver observer) {
mDataSetObservable.registerObserver(observer);
}
public void unregisterDataSetObserver(DataSetObserver observer) {
mDataSetObservable.unregisterObserver(observer);
}
//通知相关联的视图，相应的数据已经改变
public void notifyDataSetChanged() {
mDataSetObservable.notifyChanged();
}
public void notifyDataSetInvalidated() {
mDataSetObservable.notifyInvalidated();
}
public boolean areAllItemsEnabled() {
return true;
}
public boolean isEnabled(int position) {
return true;
}
//通过getView实现
public View getDropDownView(int position, View convertView, ViewGroup parent) {
return getView(position, convertView, parent);
}
public int getItemViewType(int position) {
return 0;
}
public int getViewTypeCount() {
return 1;
}
public boolean isEmpty() {
return getCount() == 0;
}
}
以下是SDK的说明：
public ArrayAdapter(Context context, int textViewResourceId) {
init(context, textViewResourceId, 0, new ArrayList&lt;T&gt;());
}
public ArrayAdapter(Context context, int resource, int textViewResourceId) {
init(context, resource, textViewResourceId, new ArrayList&lt;T&gt;());
}
public ArrayAdapter(Context context, int textViewResourceId, T[] objects) {
init(context, textViewResourceId, 0, Arrays.asList(objects));
}
public ArrayAdapter(Context context, int resource, int textViewResourceId, T[] objects) {
init(context, resource, textViewResourceId, Arrays.asList(objects));
}
public ArrayAdapter(Context context, int textViewResourceId, List&lt;T&gt; objects) {
init(context, textViewResourceId, 0, objects);
}
public ArrayAdapter(Context context, int resource, int textViewResourceId, List&lt;T&gt; objects) {
init(context, resource, textViewResourceId, objects);
}
private void init(Context context, int resource, int textViewResourceId, List&lt;T&gt; objects) {
mContext = context;
mInflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
mResource = mDropDownResource = resource;
mObjects = objects;
mFieldId = textViewResourceId;
}
private ArrayList&lt;T&gt; mOriginalValues;
private List&lt;T&gt; mObjects;
public int getCount() {
return mObjects.size();
}
public T getItem(int position) {
return mObjects.get(position);
}
public int getPosition(T item) {
return mObjects.indexOf(item);
}
public long getItemId(int position) {
return position;
}
public View getView(int position, View convertView, ViewGroup parent) {
return createViewFromResource(position, convertView, parent, mResource);
}
public View getDropDownView(int position, View convertView, ViewGroup parent) {
return createViewFromResource(position, convertView, parent, mDropDownResource);
}
private View createViewFromResource(int position, View convertView, ViewGroup parent,
int resource) {
View view;
TextView text;

if (convertView == null) {
view = mInflater.inflate(resource, parent, false);
} else {
view = convertView;
}

try {
if (mFieldId == 0) {
// If no custom field is assigned, assume the whole resource is a TextView
text = (TextView) view;
} else {
// Otherwise, find the TextView field within the layout
text = (TextView) view.findViewById(mFieldId);
}
} catch (ClassCastException e) {
Log.e(&quot;ArrayAdapter&quot;, &quot;You must supply a resource ID for a TextView&quot;);
throw new IllegalStateException(
&quot;ArrayAdapter requires the resource ID to be a TextView&quot;, e);
}

T item = getItem(position);
if (item instanceof CharSequence) {
text.setText((CharSequence)item);
} else {
text.setText(item.toString());
}

return view;
}
public static ArrayAdapter&lt;CharSequence&gt; createFromResource(Context context,
int textArrayResId, int textViewResId) {
CharSequence[] strings = context.getResources().getTextArray(textArrayResId);
return new ArrayAdapter&lt;CharSequence&gt;(context, textViewResId, strings);
}
public boolean hasStableIds() {
return true;
}
在CursorAdapter中，重写的getView及getDropDownView判断传入的convertView是否为null，若为null及相应地调用newView()或newDropDownView()来生成一个视图，而newDropDownView()只有一条语句 return newView(context, cursor, parent);所以最后都是调用newView()，newView()为abstract的，需要由子类重写。
当通过newView()产生一个View之后，会调用 bindView(v, mContext, mCursor);将cursor中的数据绑定到newView()产生的View之中，此方法同样为abstract的。
CursorAdapter实现了接口CursorFilter.CursorFilterClient中的方法
//改变cursor指向的数据
public void changeCursor(Cursor cursor)
//将cursor转变为CharSequence，返回&quot;&quot;或调用cursor.toString()
public CharSequence convertToString(Cursor cursor)
//过滤数据
public Cursor runQueryOnBackgroundThread(CharSequence constraint)
@Override
public View newView(Context context, Cursor cursor, ViewGroup parent) {
return mInflater.inflate(mLayout, parent, false);
}

@Override
public View newDropDownView(Context context, Cursor cursor, ViewGroup parent) {
return mInflater.inflate(mDropDownLayout, parent, false);
}
public static interface ViewBinder {
boolean setViewValue(View view, Cursor cursor, int columnIndex);
}
@Override
public void bindView(View view, Context context, Cursor cursor) {
final ViewBinder binder = mViewBinder;
final int count = mTo.length;
final int[] from = mFrom;
final int[] to = mTo;

for (int i = 0; i &lt; count; i++) {
final View v = view.findViewById(to[i]);
if (v != null) {
boolean bound = false;
if (binder != null) {
bound = binder.setViewValue(v, cursor, from[i]);
}

if (!bound) {
String text = cursor.getString(from[i]);
if (text == null) {
text = &quot;&quot;;
}

if (v instanceof TextView) {
setViewText((TextView) v, text);
} else if (v instanceof ImageView) {
setViewImage((ImageView) v, text);
} else {
throw new IllegalStateException(v.getClass().getName() + &quot; is not a &quot; +
&quot; view that can be bounds by this SimpleCursorAdapter&quot;);
}
}
}
}
}
public ListAdapter getWrappedAdapter();
ArrayList&lt;ListView.FixedViewInfo&gt; mHeaderViewInfos;
ArrayList&lt;ListView.FixedViewInfo&gt; mFooterViewInfos;
static final ArrayList&lt;ListView.FixedViewInfo&gt; EMPTY_INFO_LIST =
new ArrayList&lt;ListView.FixedViewInfo&gt;();
public class FixedViewInfo {
public View view;ListAdapter#getItem(int)}.
public Object data;
public boolean isSelectable;
}
</code>
</RECORD>
<RECORD>
<snippet_key>107013</snippet_key>
<tag></tag>
<comment>来自CSDN博客：OSGi (一) 什么是模块化 http://blog.csdn.net/u013028648/article/details/17257393#</comment>
<code>public class Test{
}
</code>
</RECORD>
<RECORD>
<snippet_key>154894</snippet_key>
<tag>android 全屏 无标题</tag>
<comment>来自CSDN博客：Android 实现全屏 无标题栏  http://blog.csdn.net/fngy123/article/details/18218653#</comment>
<code>&lt;span style=&quot;word-wrap: break-word; margin: 0px; padding: 0px; line-height: 1.5; font-size: 12px;&quot;&gt;android:theme=&quot;@android:style/Theme.NoTitleBar.Fullscreen&quot;&lt;/span&gt;
&lt;span style=&quot;word-wrap: break-word; margin: 0px; padding: 0px; line-height: 1.5; font-size: 12px;&quot;&gt;android:theme=&quot;@android:style/Theme.NoTitleBar&quot;&lt;/span&gt;
&lt;span style=&quot;word-wrap: break-word; margin: 0px; padding: 0px; line-height: 1.5; font-size: 12px;&quot;&gt;getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);&lt;/span&gt;
&lt;span style=&quot;word-wrap: break-word; margin: 0px; padding: 0px; line-height: 1.5; font-size: 12px;&quot;&gt;requestWindowFeature(Window.FEATURE_NO_TITLE);&lt;/span&gt;
&lt;span style=&quot;word-wrap: break-word; margin: 0px; padding: 0px; line-height: 1.5; font-size: 12px;&quot;&gt;android:theme=&quot;@android:style/Theme.Dialog&quot; 将一个Activity显示为能话框模式
android:theme=&quot;@android:style/Theme.NoTitleBar&quot; 不显示应用程序标题栏
android:theme=&quot;@android:style/Theme.NoTitleBar.Fullscreen&quot; 不显示应用程序标题栏，并全屏
android:theme=&quot;Theme.Light&quot; 背景为白色
android:theme=&quot;Theme.Light.NoTitleBar&quot; 白色背景并无标题栏
android:theme=&quot;Theme.Light.NoTitleBar.Fullscreen&quot; 白色背景，无标题栏，全屏
android:theme=&quot;Theme.Black&quot; 背景黑色
android:theme=&quot;Theme.Black.NoTitleBar&quot; 黑色背景并无标题栏
android:theme=&quot;Theme.Black.NoTitleBar.Fullscreen&quot; 黑色背景，无标题栏，全屏
android:theme=&quot;Theme.Wallpaper&quot; 用系统桌面为应用程序背景
android:theme=&quot;Theme.Wallpaper.NoTitleBar&quot; 用系统桌面为应用程序背景，且无标题栏
android:theme=&quot;Theme.Wallpaper.NoTitleBar.Fullscreen&quot; 用系统桌面为应用程序背景，无标题栏，全屏
android:theme=&quot;Translucent&quot; 透明背景
android:theme=&quot;Theme.Translucent.NoTitleBar&quot; 透明背景并无标题
android:theme=&quot;Theme.Translucent.NoTitleBar.Fullscreen&quot; 透明背景并无标题，全屏
android:theme=&quot;Theme.Panel&quot; 面板风格显示
android:theme=&quot;Theme.Light.Panel&quot; 平板风格显示&lt;/span&gt;
</code>
</RECORD>
<RECORD>
<snippet_key>303621</snippet_key>
<tag>java 递归 leetcode</tag>
<comment>来自CSDN博客：Leetcode: Median of Two Sorted Arrays. java. http://blog.csdn.net/Muscler/article/details/24209969#</comment>
<code>public class Solution {
public double findMedianSortedArrays(int A[], int B[]) {
int k = A.length + B.length;
return k % 2 == 0 ? (findK(A, 0, A.length - 1, B, 0, B.length - 1, k/2 + 1) +
findK(A, 0, A.length - 1, B, 0, B.length - 1, k/2)) / 2
: findK(A, 0, A.length - 1, B, 0, B.length - 1, k/2 + 1);
}
//返回两个数组中第k大的元素。
public double findK(int a[], int s1, int e1, int b[], int s2, int e2, int k) {
int m = e1 - s1 + 1;
int n = e2 - s2 + 1;
if (m &gt; n) return findK(b, s2, e2, a, s1, e1, k); //a的长度比b的小。
if (s1 &gt; e1) return b[s2 + k - 1];
if (s2 &gt; e2) return a[s1 + k - 1];
if (k == 1) return Math.min(a[s1], b[s2]);
int midA = Math.min(k/2, m), midB = k - midA;
//如果a的第midA大的元素比b的第midB大的元素小，
//那么删掉a的前midA个元素，在剩余的数中找第k-midA大的。
if (a[s1 + midA - 1] &lt; b[s2 + midB - 1])
return findK(a, s1 + midA, e1, b, s2, e2, k - midA);
else if (a[s1 + midA - 1] &gt; b[s2 + midB - 1])
return findK(a, s1, e1, b, s2 + midB, e2, k - midB);
else
return a[s1 + midA - 1];
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>107269</snippet_key>
<tag></tag>
<comment>来自CSDN博客：正则表达式去掉小数点后面多余的0 http://blog.csdn.net/LSSSSSS/article/details/17260747#</comment>
<code>public static String subZeroAndDot(String s){
if(s.indexOf(&quot;.&quot;) &gt; 0){
s = s.replaceAll(&quot;0+?$&quot;, &quot;&quot;);//去掉多余的0
s = s.replaceAll(&quot;[.]$&quot;, &quot;&quot;);//如最后一位是.则去掉
}
return s;
}
</code>
</RECORD>
<RECORD>
<snippet_key>24078</snippet_key>
<tag>326,303</tag>
<comment>本次更新：1：修复ChartClient端无法关闭流的bug2:服务器端添加了连接判断</comment>
<code>//Server

import java.io.*;
import java.net.*;

public class ChatServer {

/**
* @param args
*/
public static void main(String[] args) {

ChatServer Server = new ChatServer();
Server.connection();
}

public void connection() {
String str = null;
boolean start = false;
try {
ServerSocket ss = new ServerSocket(6666);
start = true;
while (start) {
boolean bconnected = false;
Socket s = ss.accept();
if (s != null) {
System.out.println(&quot;客户已连接！&quot;);
bconnected = true;
DataInputStream dips = new DataInputStream(
s.getInputStream());
while (bconnected) {
str = dips.readUTF();
System.out.println(str);
}
// dips.close(); //我认为这个完全多余！
}else{
System.out.println(&quot;网络已断开！&quot;);
}
}
} catch (IOException e) {
e.printStackTrace();
}
}
}

//Client


import java.io.*;
import java.net.*;
import java.awt.*;
import java.awt.event.*;
public class ChatClient {

/**
* @param args
*/
public static void main(String[] args) {

new ClientFrame().launchFrame();
}
}


class ClientFrame extends Frame{

Socket s =null;
TextField tf = new TextField();
TextArea ta = new TextArea();
DataOutputStream dops =null;
myKeyAdapter mka = new myKeyAdapter();

public void launchFrame(){

this.setBounds(300, 150, 500, 500);
setBackground(new Color(204,204,225));
tf.addKeyListener(mka);
this.add(tf,BorderLayout.SOUTH);
add(ta,BorderLayout.NORTH);
pack();
this.addWindowListener(new myWinAdapter());
setVisible(true);
connection();
}

public void connection(){
try {
s = new Socket(&quot;127.0.0.1&quot;,6666);
} catch (UnknownHostException e) {
e.printStackTrace();
} catch (IOException e) {
e.printStackTrace();
}
}
//本期重要更新：
public void disconnection(){

try {
dops.close();
s.close();
} catch (IOException e) {
e.printStackTrace();
}
}

class myKeyAdapter extends KeyAdapter{

public void keyPressed(KeyEvent e) {
int key = e.getKeyCode();
String str = tf.getText();
try {
dops = new DataOutputStream(s.getOutputStream());
} catch (IOException e2) {
e2.printStackTrace();
}
if(key==KeyEvent.VK_ENTER){

try {
dops.writeUTF(str);
dops.flush();
} catch (IOException e1) {
// TODO Auto-generated catch block
e1.printStackTrace();
}
//dops.close();
ta.setText(str);
tf.setText(&quot;&quot;);
}
}
}

class myWinAdapter extends WindowAdapter{

@Override
public void windowClosing(WindowEvent e) {
// TODO Auto-generated method stub
disconnection();
System.exit(-1);
}

}
}
</code>
</RECORD>
<RECORD>
<snippet_key>286222</snippet_key>
<tag>414</tag>
<comment>string 来自CSDN博客：Spring1  http://blog.csdn.net/liuyifei888/article/details/23427441#</comment>
<code>package com.demo.model;

public class User {
private String username;
private String password;
public String getUsername() {
return username;
}
public void setUsername(String username) {
this.username = username;
}
public String getPassword() {
return password;
}
public void setPassword(String password) {
this.password = password;
}

package com.demo.model;

public class User {
private String username;
private String password;
public String getUsername() {
return username;
}
public void setUsername(String username) {
this.username = username;
}
public String getPassword() {
return password;
}
public void setPassword(String password) {
this.password = password;
}

package com.demo.dao.impl;

import com.demo.dao.UserDAO;
import com.demo.model.User;

public class UserDAOImpl implements UserDAO {

@Override
public void save(User u) {
System.out.println(&quot;user save&quot;);
}

}
package com.demo.service;

import com.demo.dao.UserDAO;
import com.demo.dao.impl.UserDAOImpl;
import com.demo.model.User;
// 面向接口或者抽象编程,需要用谁直接在service 里面new谁 实现DAO接口即可
//面向抽象编程就是 灵活

public class UserService {
private UserDAO userDAO;// = new UserDAOImpl(); 把后半部分放在beans.xml配置文件里

public UserDAO getUserDAO() {
return userDAO;
}
public void setUserDAO(UserDAO userDAO) {
this.userDAO = userDAO;
}
public void add(User u) {
this.userDAO.save(u);
}
}
import java.util.List;

import org.jdom.Document;
import org.jdom.Element;
import org.jdom.input.SAXBuilder;


public class Sample1 {
public static void main(String[] args) throws Exception {
SAXBuilder sb = new SAXBuilder();
Document doc = sb.build(Sample1.class.getClassLoader().getResourceAsStream(&quot;test.xml&quot;)); //构造文档对象
Element root = doc.getRootElement(); // 获取根元素
List list = root.getChildren(&quot;disk&quot;); // 取名字为disk的所有元素

for(int i=0; i&lt;list.size(); i++) {
Element element = (Element)list.get(i);
String name = element.getAttributeValue(&quot;name&quot;);
String capacity = element.getChildText(&quot;capacity&quot;);
String directoris = element.getChildText(&quot;directories&quot;);
String files = element.getChildText(&quot;files&quot;);

System.out.println(&quot;磁盘信息:&quot;);
System.out.println(&quot;分区盘符:&quot; + name);
System.out.println(&quot;分区容量：&quot; + capacity);
System.out.println(&quot;目录数: &quot; +directoris);
System.out.println(&quot;文件数： &quot; +files);
System.out.println(&quot;====================================&quot;);
}
}
}
package com.demo.spring;

public interface BeanFactory {
public Object getBean(String name);
}
package com.demo.spring;

import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.jdom.Document;
import org.jdom.Element;
import org.jdom.input.SAXBuilder;

public class ClassPathXmlApplicationContext implements BeanFactory {
private Map&lt;String,Object&gt; beans = new HashMap&lt;String, Object&gt;();

//IOC Inverse of Control DI Dependency Injection
public ClassPathXmlApplicationContext() throws Exception {
SAXBuilder sb = new SAXBuilder();

Document doc = sb.build(this.getClass().getClassLoader().getResourceAsStream(&quot;beans.xml&quot;)); //构造文档
Element root = doc.getRootElement(); // 获取根元素
List list = root.getChildren(&quot;bean&quot;); //取名字为disk 的所有元素
for (int i = 0; i &lt; list.size(); i++) {
Element element = (Element)list.get(i);
String id=element.getAttributeValue(&quot;id&quot;);
String clazz=element.getAttributeValue(&quot;class&quot;);
Object o = Class.forName(clazz).newInstance();
System.out.println(id);
System.out.println(clazz);
beans.put(id, o);

for(Element propertyElement : (List&lt;Element&gt;)element.getChildren(&quot;property&quot;)) {
String name = propertyElement.getAttributeValue(&quot;name&quot;); //userDAO
String bean = propertyElement.getAttributeValue(&quot;bean&quot;); //u
Object beanObject = beans.get(bean); //UserDAOImpl instance

String methodName = &quot;set&quot; + name.substring(0,1).toUpperCase() + name.substring(1);
System.out.println(&quot;method name = &quot; + methodName);

Method m = o.getClass().getMethod(methodName, beanObject.getClass().getInterfaces()[0]);
m.invoke(o, beanObject);

}
}
}

@Override
public Object getBean(String name) {
return beans.get(name);
}
}
&lt;beans&gt;
&lt;bean id=&quot;u&quot; class=&quot;com.demo.dao.impl.UserDAOImpl&quot;/&gt;
&lt;bean id=&quot;userService&quot; class=&quot;com.demo.service.UserService&quot;&gt;
&lt;property name=&quot;userDAO&quot; bean=&quot;u&quot;/&gt;
&lt;/bean&gt;
&lt;/beans&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;HD&gt;
&lt;disk name=&quot;C&quot;&gt;
&lt;capacity&gt;8G&lt;/capacity&gt;
&lt;directories&gt;200&lt;/directories&gt;
&lt;files&gt;1580&lt;/files&gt;
&lt;/disk&gt;

&lt;disk name=&quot;C&quot;&gt;
&lt;capacity&gt;8G&lt;/capacity&gt;
&lt;directories&gt;500&lt;/directories&gt;
&lt;files&gt;3000&lt;/files&gt;
&lt;/disk&gt;
&lt;/HD&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;&gt;

&lt;bean id=&quot;u&quot; class=&quot;com.demo.dao.impl.UserDAOImpl&quot;/&gt;
&lt;bean id=&quot;userService&quot; class=&quot;com.demo.service.UserService&quot;&gt;
&lt;property name=&quot;userDAO&quot; ref=&quot;u&quot;/&gt;
&lt;/bean&gt;

&lt;/beans&gt;
package com.demo.service;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.demo.model.User;
// Dependency Injection 依赖注入 依赖容器注入的对象 (灵活)
// Inverse of Control 控制反转 原来具体的实现控制在自己手里，现在控制在容器手里
public class UserServiceTest {
@Test
public void testAdd() throws Exception{
ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);

UserService service = (UserService)ctx.getBean(&quot;userService&quot;);
User u = new User();
u.setUsername(&quot;li&quot;);
u.setPassword(&quot;ww&quot;);
service.add(u);
}
}

public UserService(UserDAO userDAO) {
super();
this.userDAO = userDAO;
}
&lt;constructor-arg&gt;
&lt;ref bean=&quot;u&quot;/&gt;
&lt;/constructor-arg&gt;
&lt;bean name=&quot;u&quot; class=&quot;com.demo.dao.impl.UserDAOImpl&quot;&gt;
&lt;property name=&quot;daoId&quot; value=&quot;9&quot;&gt;&lt;/property&gt;
&lt;property name=&quot;daoStatus&quot; value=&quot;helloworld&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
UserService service = (UserService)ctx.getBean(&quot;userService&quot;);
UserService service1 = (UserService)ctx.getBean(&quot;userService&quot;);
System.out.println(service == service1);
&lt;bean id=&quot;userService&quot; class=&quot;com.demo.service.UserService&quot; scope=&quot;prototype&quot;&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;&gt;

&lt;bean name=&quot;userDAO&quot; class=&quot;com.demo.dao.impl.UserDAOImpl&quot;&gt;
&lt;property name=&quot;sets&quot;&gt;
&lt;set&gt;
&lt;value&gt;1&lt;/value&gt;
&lt;value&gt;2&lt;/value&gt;
&lt;/set&gt;
&lt;/property&gt;

&lt;property name=&quot;lists&quot;&gt;
&lt;list&gt;
&lt;value&gt;1&lt;/value&gt;
&lt;value&gt;2&lt;/value&gt;
&lt;value&gt;3&lt;/value&gt;
&lt;/list&gt;
&lt;/property&gt;

&lt;property name=&quot;maps&quot;&gt;
&lt;map&gt;
&lt;entry key=&quot;1&quot; value=&quot;1&quot;&gt;&lt;/entry&gt;
&lt;entry key=&quot;2&quot; value=&quot;2&quot;&gt;&lt;/entry&gt;
&lt;entry key=&quot;3&quot; value=&quot;3&quot;&gt;&lt;/entry&gt;
&lt;entry key=&quot;4&quot; value=&quot;4&quot;&gt;&lt;/entry&gt;
&lt;entry key=&quot;5&quot; value=&quot;5&quot;&gt;&lt;/entry&gt;
&lt;/map&gt;
&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userService&quot; class=&quot;com.demo.service.UserService&quot;&gt;
&lt;property name=&quot;userDAO&quot; ref=&quot;userDAO&quot;/&gt;
&lt;/bean&gt;

&lt;/beans&gt;
&lt;bean id=&quot;userDAO1&quot; class=&quot;com.demo.dao.impl.UserDAOImpl&quot;&gt;
&lt;property name=&quot;daoId&quot; value=&quot;1&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userDAO2&quot; class=&quot;com.demo.dao.impl.UserDAOImpl&quot;&gt;
&lt;property name=&quot;daoId&quot; value=&quot;2&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;userService&quot; class=&quot;com.demo.service.UserService&quot; scope=&quot;prototype&quot; autowire=&quot;byName&quot;&gt;
&lt;property name=&quot;userDAO&quot; ref=&quot;userDAO1&quot;/&gt;
&lt;/bean&gt;
&lt;p&gt;1.       Annotation第一步：&lt;/p&gt;&lt;p&gt;a)       修改xml文件，参考文档&lt;context:annotation-config /&gt;&lt;/p&gt;&lt;p&gt;1.       @Autowired&lt;/p&gt;&lt;p&gt;a)       默认按类型by type&lt;/p&gt;&lt;p&gt;b)       如果想用byName，使用@Qulifier&lt;/p&gt;&lt;p&gt;c)       写在private field（第三种注入形式）（不建议，破坏封装）&lt;/p&gt;&lt;p&gt;d)       如果写在set上，@qualifier需要写在参数上&lt;/p&gt;

在UserService 类里面

@Autowired //把和你参数和对应的类型的的bean注入进来 默认的是byName 用的不多，会产生各种问题
public void setUserDAO(UserDAO userDAO) {
this.userDAO = userDAO;
}

(@Qualifier(&quot;u&quot;) // 可以指定 匹配那个名字的Bean 注入到参数里面来

public void setUserDAO(@Qualifier(&quot;u&quot;)UserDAO userDAO) {
this.userDAO = userDAO;
}
&lt;context:component-scan base-package=&quot;com.demo&quot;&gt;&lt;/context:component-scan&gt;
package com.demo.dao.impl;

import org.springframework.stereotype.Component;

import com.demo.dao.UserDAO;
import com.demo.model.User;

@Component(&quot;u&quot;)
public class UserDAOImpl implements UserDAO {

@Override
public void save(User u) {
System.out.println(&quot;user save&quot;);
}

}
package com.demo.service;

import javax.annotation.Resource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

import com.demo.dao.UserDAO;
import com.demo.dao.impl.UserDAOImpl;
import com.demo.model.User;
// 面向接口或者抽象编程,需要用谁直接在service 里面new谁 实现DAO接口即可
//面向抽象编程就是 灵活

@Component(&quot;userService&quot;)
public class UserService {
private UserDAO userDAO;

public void init() {
System.out.println(&quot;init&quot;);
}

public UserDAO getUserDAO() {
return userDAO;
}

@Resource(name=&quot;u&quot;) //常用
public void setUserDAO(UserDAO userDAO) {
this.userDAO = userDAO;
}
public void add(User u) {
this.userDAO.save(u);
}

public void destroy() {
System.out.println(&quot;destroy&quot;);
}
}
</code>
</RECORD>
<RECORD>
<snippet_key>108293</snippet_key>
<tag>184</tag>
<comment>来自CSDN博客：JXLS生成Excel图表  http://blog.csdn.net/geloin/article/details/17268909#</comment>
<code>/**
*
*/
package com.geloin.jxls.main;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import net.sf.jxls.transformer.XLSTransformer;

import com.geloin.jxls.beans.Staff;

/**
* @author Geloin
*
*/
public class ChartTest {

/**
* @param args
*/
public static void main(String[] args) throws Exception {
List&lt;Staff&gt; staffs = new ArrayList&lt;Staff&gt;();

Staff s1 = new Staff(&quot;张三&quot;, 6000D, 3000D);
staffs.add(s1);

Staff s2 = new Staff(&quot;李四&quot;, 5000D, 2000D);
staffs.add(s2);

Staff s3 = new Staff(&quot;王五&quot;, 4000D, 1000D);
staffs.add(s3);

String srcFilePath = &quot;d:/work/proTmp/jxls/图表模板.xlsx&quot;;
String destFilePath = &quot;d:/work/proTmp/jxls/output/图表.xlsx&quot;;
Map&lt;String, List&lt;Staff&gt;&gt; beanParams = new HashMap&lt;String, List&lt;Staff&gt;&gt;();
beanParams.put(&quot;staffs&quot;, staffs);

XLSTransformer former = new XLSTransformer();
former.transformXLS(srcFilePath, beanParams, destFilePath);
}

}
/**
*
*/
package com.geloin.jxls.beans;

/**
* @author Geloin
*
*/
public class Staff {

public Staff(String name, Double payment, Double bonus) {
super();
this.name = name;
this.payment = payment;
this.bonus = bonus;
}

/**
* 名称
*/
private String name;

/**
* 薪资
*/
private Double payment;

/**
* 年终奖
*/
private Double bonus;

public String getName() {
return name;
}

public void setName(String name) {
this.name = name;
}

public Double getPayment() {
return payment;
}

public void setPayment(Double payment) {
this.payment = payment;
}

public Double getBonus() {
return bonus;
}

public void setBonus(Double bonus) {
this.bonus = bonus;
}

}
</code>
</RECORD>
</RECORDS>